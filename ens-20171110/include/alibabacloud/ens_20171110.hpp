// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_ENS20171110_H_
#define ALIBABACLOUD_ENS20171110_H_

#include <alibabacloud/open_api.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Ens20171110 {
class BucketInfo : public Darabonba::Model {
public:
  shared_ptr<string> bucketAcl{};
  shared_ptr<string> bucketName{};
  shared_ptr<string> comment{};
  shared_ptr<string> createTime{};
  shared_ptr<string> dataRedundancyType{};
  shared_ptr<string> dispatcherType{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> storageClass{};

  BucketInfo() {}

  explicit BucketInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketAcl) {
      res["BucketAcl"] = boost::any(*bucketAcl);
    }
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataRedundancyType) {
      res["DataRedundancyType"] = boost::any(*dataRedundancyType);
    }
    if (dispatcherType) {
      res["DispatcherType"] = boost::any(*dispatcherType);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (storageClass) {
      res["StorageClass"] = boost::any(*storageClass);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketAcl") != m.end() && !m["BucketAcl"].empty()) {
      bucketAcl = make_shared<string>(boost::any_cast<string>(m["BucketAcl"]));
    }
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DataRedundancyType") != m.end() && !m["DataRedundancyType"].empty()) {
      dataRedundancyType = make_shared<string>(boost::any_cast<string>(m["DataRedundancyType"]));
    }
    if (m.find("DispatcherType") != m.end() && !m["DispatcherType"].empty()) {
      dispatcherType = make_shared<string>(boost::any_cast<string>(m["DispatcherType"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("StorageClass") != m.end() && !m["StorageClass"].empty()) {
      storageClass = make_shared<string>(boost::any_cast<string>(m["StorageClass"]));
    }
  }


  virtual ~BucketInfo() = default;
};
class DataDisk : public Darabonba::Model {
public:
  shared_ptr<long> size{};

  DataDisk() {}

  explicit DataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DataDisk() = default;
};
class HealthCheck : public Darabonba::Model {
public:
  shared_ptr<string> healthCheck{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<long> healthCheckConnectTimeout{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckMethod{};
  shared_ptr<long> healthCheckTimeout{};
  shared_ptr<string> healthCheckType{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> unhealthyThreshold{};

  HealthCheck() {}

  explicit HealthCheck(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckConnectTimeout) {
      res["HealthCheckConnectTimeout"] = boost::any(*healthCheckConnectTimeout);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckMethod) {
      res["HealthCheckMethod"] = boost::any(*healthCheckMethod);
    }
    if (healthCheckTimeout) {
      res["HealthCheckTimeout"] = boost::any(*healthCheckTimeout);
    }
    if (healthCheckType) {
      res["HealthCheckType"] = boost::any(*healthCheckType);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckConnectTimeout") != m.end() && !m["HealthCheckConnectTimeout"].empty()) {
      healthCheckConnectTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectTimeout"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckMethod") != m.end() && !m["HealthCheckMethod"].empty()) {
      healthCheckMethod = make_shared<string>(boost::any_cast<string>(m["HealthCheckMethod"]));
    }
    if (m.find("HealthCheckTimeout") != m.end() && !m["HealthCheckTimeout"].empty()) {
      healthCheckTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckTimeout"]));
    }
    if (m.find("HealthCheckType") != m.end() && !m["HealthCheckType"].empty()) {
      healthCheckType = make_shared<string>(boost::any_cast<string>(m["HealthCheckType"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~HealthCheck() = default;
};
class HttpConfig : public Darabonba::Model {
public:
  shared_ptr<string> cookie{};
  shared_ptr<long> cookieTimeout{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<long> requestTimeout{};
  shared_ptr<string> scheduler{};
  shared_ptr<string> serverCertificateId{};
  shared_ptr<string> stickySession{};
  shared_ptr<string> stickySessionType{};
  shared_ptr<string> XForwardedFor{};

  HttpConfig() {}

  explicit HttpConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cookie) {
      res["Cookie"] = boost::any(*cookie);
    }
    if (cookieTimeout) {
      res["CookieTimeout"] = boost::any(*cookieTimeout);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (requestTimeout) {
      res["RequestTimeout"] = boost::any(*requestTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (serverCertificateId) {
      res["ServerCertificateId"] = boost::any(*serverCertificateId);
    }
    if (stickySession) {
      res["StickySession"] = boost::any(*stickySession);
    }
    if (stickySessionType) {
      res["StickySessionType"] = boost::any(*stickySessionType);
    }
    if (XForwardedFor) {
      res["XForwardedFor"] = boost::any(*XForwardedFor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cookie") != m.end() && !m["Cookie"].empty()) {
      cookie = make_shared<string>(boost::any_cast<string>(m["Cookie"]));
    }
    if (m.find("CookieTimeout") != m.end() && !m["CookieTimeout"].empty()) {
      cookieTimeout = make_shared<long>(boost::any_cast<long>(m["CookieTimeout"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("RequestTimeout") != m.end() && !m["RequestTimeout"].empty()) {
      requestTimeout = make_shared<long>(boost::any_cast<long>(m["RequestTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("ServerCertificateId") != m.end() && !m["ServerCertificateId"].empty()) {
      serverCertificateId = make_shared<string>(boost::any_cast<string>(m["ServerCertificateId"]));
    }
    if (m.find("StickySession") != m.end() && !m["StickySession"].empty()) {
      stickySession = make_shared<string>(boost::any_cast<string>(m["StickySession"]));
    }
    if (m.find("StickySessionType") != m.end() && !m["StickySessionType"].empty()) {
      stickySessionType = make_shared<string>(boost::any_cast<string>(m["StickySessionType"]));
    }
    if (m.find("XForwardedFor") != m.end() && !m["XForwardedFor"].empty()) {
      XForwardedFor = make_shared<string>(boost::any_cast<string>(m["XForwardedFor"]));
    }
  }


  virtual ~HttpConfig() = default;
};
class InstanceActiveOpsGroup : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};

  InstanceActiveOpsGroup() {}

  explicit InstanceActiveOpsGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~InstanceActiveOpsGroup() = default;
};
class InstanceActiveOpsTask : public Darabonba::Model {
public:
  shared_ptr<string> instanceActiveOpsTaskId{};
  shared_ptr<string> instanceActiveOpsTaskStatus{};

  InstanceActiveOpsTask() {}

  explicit InstanceActiveOpsTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceActiveOpsTaskId) {
      res["InstanceActiveOpsTaskId"] = boost::any(*instanceActiveOpsTaskId);
    }
    if (instanceActiveOpsTaskStatus) {
      res["InstanceActiveOpsTaskStatus"] = boost::any(*instanceActiveOpsTaskStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceActiveOpsTaskId") != m.end() && !m["InstanceActiveOpsTaskId"].empty()) {
      instanceActiveOpsTaskId = make_shared<string>(boost::any_cast<string>(m["InstanceActiveOpsTaskId"]));
    }
    if (m.find("InstanceActiveOpsTaskStatus") != m.end() && !m["InstanceActiveOpsTaskStatus"].empty()) {
      instanceActiveOpsTaskStatus = make_shared<string>(boost::any_cast<string>(m["InstanceActiveOpsTaskStatus"]));
    }
  }


  virtual ~InstanceActiveOpsTask() = default;
};
class InstanceOperateResponse : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> message{};

  InstanceOperateResponse() {}

  explicit InstanceOperateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~InstanceOperateResponse() = default;
};
class SecurityGroupRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> direction{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<long> priority{};

  SecurityGroupRule() {}

  explicit SecurityGroupRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
  }


  virtual ~SecurityGroupRule() = default;
};
class TagsInParamsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagsInParamsTag() {}

  explicit TagsInParamsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagsInParamsTag() = default;
};
class TagsInParams : public Darabonba::Model {
public:
  shared_ptr<vector<TagsInParamsTag>> tag{};

  TagsInParams() {}

  explicit TagsInParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagsInParamsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagsInParamsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagsInParamsTag>>(expect1);
      }
    }
  }


  virtual ~TagsInParams() = default;
};
class TcpConfig : public Darabonba::Model {
public:
  shared_ptr<long> establishedTimeout{};
  shared_ptr<long> persistenceTimeout{};
  shared_ptr<string> scheduler{};

  TcpConfig() {}

  explicit TcpConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (establishedTimeout) {
      res["EstablishedTimeout"] = boost::any(*establishedTimeout);
    }
    if (persistenceTimeout) {
      res["PersistenceTimeout"] = boost::any(*persistenceTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EstablishedTimeout") != m.end() && !m["EstablishedTimeout"].empty()) {
      establishedTimeout = make_shared<long>(boost::any_cast<long>(m["EstablishedTimeout"]));
    }
    if (m.find("PersistenceTimeout") != m.end() && !m["PersistenceTimeout"].empty()) {
      persistenceTimeout = make_shared<long>(boost::any_cast<long>(m["PersistenceTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
  }


  virtual ~TcpConfig() = default;
};
class UdpCheck : public Darabonba::Model {
public:
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<long> healthCheckConnectTimeout{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> unhealthyThreshold{};

  UdpCheck() {}

  explicit UdpCheck(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckConnectTimeout) {
      res["HealthCheckConnectTimeout"] = boost::any(*healthCheckConnectTimeout);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckConnectTimeout") != m.end() && !m["HealthCheckConnectTimeout"].empty()) {
      healthCheckConnectTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectTimeout"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~UdpCheck() = default;
};
class UdpConfig : public Darabonba::Model {
public:
  shared_ptr<string> hashKey{};
  shared_ptr<string> scheduler{};

  UdpConfig() {}

  explicit UdpConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hashKey) {
      res["HashKey"] = boost::any(*hashKey);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HashKey") != m.end() && !m["HashKey"].empty()) {
      hashKey = make_shared<string>(boost::any_cast<string>(m["HashKey"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
  }


  virtual ~UdpConfig() = default;
};
class AccosicateNetworkAclRequestResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  AccosicateNetworkAclRequestResource() {}

  explicit AccosicateNetworkAclRequestResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~AccosicateNetworkAclRequestResource() = default;
};
class AccosicateNetworkAclRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkAclId{};
  shared_ptr<vector<AccosicateNetworkAclRequestResource>> resource{};

  AccosicateNetworkAclRequest() {}

  explicit AccosicateNetworkAclRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<AccosicateNetworkAclRequestResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AccosicateNetworkAclRequestResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<AccosicateNetworkAclRequestResource>>(expect1);
      }
    }
  }


  virtual ~AccosicateNetworkAclRequest() = default;
};
class AccosicateNetworkAclResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AccosicateNetworkAclResponseBody() {}

  explicit AccosicateNetworkAclResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AccosicateNetworkAclResponseBody() = default;
};
class AccosicateNetworkAclResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AccosicateNetworkAclResponseBody> body{};

  AccosicateNetworkAclResponse() {}

  explicit AccosicateNetworkAclResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AccosicateNetworkAclResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AccosicateNetworkAclResponseBody>(model1);
      }
    }
  }


  virtual ~AccosicateNetworkAclResponse() = default;
};
class AddBackendServersRequestBackendServers : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<long> port{};
  shared_ptr<string> serverId{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  AddBackendServersRequestBackendServers() {}

  explicit AddBackendServersRequestBackendServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~AddBackendServersRequestBackendServers() = default;
};
class AddBackendServersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AddBackendServersRequestBackendServers>> backendServers{};
  shared_ptr<string> loadBalancerId{};

  AddBackendServersRequest() {}

  explicit AddBackendServersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServers) {
      vector<boost::any> temp1;
      for(auto item1:*backendServers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendServers"] = boost::any(temp1);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendServers"].type()) {
        vector<AddBackendServersRequestBackendServers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendServers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddBackendServersRequestBackendServers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendServers = make_shared<vector<AddBackendServersRequestBackendServers>>(expect1);
      }
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~AddBackendServersRequest() = default;
};
class AddBackendServersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> backendServersShrink{};
  shared_ptr<string> loadBalancerId{};

  AddBackendServersShrinkRequest() {}

  explicit AddBackendServersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServersShrink) {
      res["BackendServers"] = boost::any(*backendServersShrink);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      backendServersShrink = make_shared<string>(boost::any_cast<string>(m["BackendServers"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~AddBackendServersShrinkRequest() = default;
};
class AddBackendServersResponseBodyBackendServersBackendServer : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<long> port{};
  shared_ptr<string> serverId{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  AddBackendServersResponseBodyBackendServersBackendServer() {}

  explicit AddBackendServersResponseBodyBackendServersBackendServer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~AddBackendServersResponseBodyBackendServersBackendServer() = default;
};
class AddBackendServersResponseBodyBackendServers : public Darabonba::Model {
public:
  shared_ptr<vector<AddBackendServersResponseBodyBackendServersBackendServer>> backendServer{};

  AddBackendServersResponseBodyBackendServers() {}

  explicit AddBackendServersResponseBodyBackendServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServer) {
      vector<boost::any> temp1;
      for(auto item1:*backendServer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendServer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServer") != m.end() && !m["BackendServer"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendServer"].type()) {
        vector<AddBackendServersResponseBodyBackendServersBackendServer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendServer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddBackendServersResponseBodyBackendServersBackendServer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendServer = make_shared<vector<AddBackendServersResponseBodyBackendServersBackendServer>>(expect1);
      }
    }
  }


  virtual ~AddBackendServersResponseBodyBackendServers() = default;
};
class AddBackendServersResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddBackendServersResponseBodyBackendServers> backendServers{};
  shared_ptr<string> requestId{};

  AddBackendServersResponseBody() {}

  explicit AddBackendServersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServers) {
      res["BackendServers"] = backendServers ? boost::any(backendServers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackendServers"].type()) {
        AddBackendServersResponseBodyBackendServers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackendServers"]));
        backendServers = make_shared<AddBackendServersResponseBodyBackendServers>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddBackendServersResponseBody() = default;
};
class AddBackendServersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddBackendServersResponseBody> body{};

  AddBackendServersResponse() {}

  explicit AddBackendServersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddBackendServersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddBackendServersResponseBody>(model1);
      }
    }
  }


  virtual ~AddBackendServersResponse() = default;
};
class AddNetworkInterfaceToInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoStart{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> networks{};

  AddNetworkInterfaceToInstanceRequest() {}

  explicit AddNetworkInterfaceToInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoStart) {
      res["AutoStart"] = boost::any(*autoStart);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networks) {
      res["Networks"] = boost::any(*networks);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoStart") != m.end() && !m["AutoStart"].empty()) {
      autoStart = make_shared<bool>(boost::any_cast<bool>(m["AutoStart"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Networks") != m.end() && !m["Networks"].empty()) {
      networks = make_shared<string>(boost::any_cast<string>(m["Networks"]));
    }
  }


  virtual ~AddNetworkInterfaceToInstanceRequest() = default;
};
class AddNetworkInterfaceToInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddNetworkInterfaceToInstanceResponseBody() {}

  explicit AddNetworkInterfaceToInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddNetworkInterfaceToInstanceResponseBody() = default;
};
class AddNetworkInterfaceToInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddNetworkInterfaceToInstanceResponseBody> body{};

  AddNetworkInterfaceToInstanceResponse() {}

  explicit AddNetworkInterfaceToInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddNetworkInterfaceToInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddNetworkInterfaceToInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~AddNetworkInterfaceToInstanceResponse() = default;
};
class AddSnatIpForSnatEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> snatEntryId{};
  shared_ptr<string> snatIp{};

  AddSnatIpForSnatEntryRequest() {}

  explicit AddSnatIpForSnatEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snatEntryId) {
      res["SnatEntryId"] = boost::any(*snatEntryId);
    }
    if (snatIp) {
      res["SnatIp"] = boost::any(*snatIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnatEntryId") != m.end() && !m["SnatEntryId"].empty()) {
      snatEntryId = make_shared<string>(boost::any_cast<string>(m["SnatEntryId"]));
    }
    if (m.find("SnatIp") != m.end() && !m["SnatIp"].empty()) {
      snatIp = make_shared<string>(boost::any_cast<string>(m["SnatIp"]));
    }
  }


  virtual ~AddSnatIpForSnatEntryRequest() = default;
};
class AddSnatIpForSnatEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddSnatIpForSnatEntryResponseBody() {}

  explicit AddSnatIpForSnatEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddSnatIpForSnatEntryResponseBody() = default;
};
class AddSnatIpForSnatEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddSnatIpForSnatEntryResponseBody> body{};

  AddSnatIpForSnatEntryResponse() {}

  explicit AddSnatIpForSnatEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddSnatIpForSnatEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddSnatIpForSnatEntryResponseBody>(model1);
      }
    }
  }


  virtual ~AddSnatIpForSnatEntryResponse() = default;
};
class AssignPrivateIpAddressesRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> vSwitchId{};

  AssignPrivateIpAddressesRequest() {}

  explicit AssignPrivateIpAddressesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~AssignPrivateIpAddressesRequest() = default;
};
class AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet : public Darabonba::Model {
public:
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<vector<string>> privateIpSet{};

  AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet() {}

  explicit AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (privateIpSet) {
      res["PrivateIpSet"] = boost::any(*privateIpSet);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("PrivateIpSet") != m.end() && !m["PrivateIpSet"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrivateIpSet"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrivateIpSet"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      privateIpSet = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet() = default;
};
class AssignPrivateIpAddressesResponseBody : public Darabonba::Model {
public:
  shared_ptr<AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet> assignedPrivateIpAddressesSet{};
  shared_ptr<string> requestId{};

  AssignPrivateIpAddressesResponseBody() {}

  explicit AssignPrivateIpAddressesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedPrivateIpAddressesSet) {
      res["AssignedPrivateIpAddressesSet"] = assignedPrivateIpAddressesSet ? boost::any(assignedPrivateIpAddressesSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssignedPrivateIpAddressesSet") != m.end() && !m["AssignedPrivateIpAddressesSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssignedPrivateIpAddressesSet"].type()) {
        AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssignedPrivateIpAddressesSet"]));
        assignedPrivateIpAddressesSet = make_shared<AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssignPrivateIpAddressesResponseBody() = default;
};
class AssignPrivateIpAddressesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssignPrivateIpAddressesResponseBody> body{};

  AssignPrivateIpAddressesResponse() {}

  explicit AssignPrivateIpAddressesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssignPrivateIpAddressesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssignPrivateIpAddressesResponseBody>(model1);
      }
    }
  }


  virtual ~AssignPrivateIpAddressesResponse() = default;
};
class AssociateEnsEipAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<bool> standby{};

  AssociateEnsEipAddressRequest() {}

  explicit AssociateEnsEipAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (standby) {
      res["Standby"] = boost::any(*standby);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Standby") != m.end() && !m["Standby"].empty()) {
      standby = make_shared<bool>(boost::any_cast<bool>(m["Standby"]));
    }
  }


  virtual ~AssociateEnsEipAddressRequest() = default;
};
class AssociateEnsEipAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateEnsEipAddressResponseBody() {}

  explicit AssociateEnsEipAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateEnsEipAddressResponseBody() = default;
};
class AssociateEnsEipAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssociateEnsEipAddressResponseBody> body{};

  AssociateEnsEipAddressResponse() {}

  explicit AssociateEnsEipAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateEnsEipAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateEnsEipAddressResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateEnsEipAddressResponse() = default;
};
class AssociateHaVipRequest : public Darabonba::Model {
public:
  shared_ptr<string> haVipId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};

  AssociateHaVipRequest() {}

  explicit AssociateHaVipRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (haVipId) {
      res["HaVipId"] = boost::any(*haVipId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HaVipId") != m.end() && !m["HaVipId"].empty()) {
      haVipId = make_shared<string>(boost::any_cast<string>(m["HaVipId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~AssociateHaVipRequest() = default;
};
class AssociateHaVipResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateHaVipResponseBody() {}

  explicit AssociateHaVipResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateHaVipResponseBody() = default;
};
class AssociateHaVipResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssociateHaVipResponseBody> body{};

  AssociateHaVipResponse() {}

  explicit AssociateHaVipResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateHaVipResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateHaVipResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateHaVipResponse() = default;
};
class AttachDiskRequest : public Darabonba::Model {
public:
  shared_ptr<string> deleteWithInstance{};
  shared_ptr<string> diskId{};
  shared_ptr<string> instanceId{};

  AttachDiskRequest() {}

  explicit AttachDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<string>(boost::any_cast<string>(m["DeleteWithInstance"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~AttachDiskRequest() = default;
};
class AttachDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  AttachDiskResponseBody() {}

  explicit AttachDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachDiskResponseBody() = default;
};
class AttachDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachDiskResponseBody> body{};

  AttachDiskResponse() {}

  explicit AttachDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachDiskResponseBody>(model1);
      }
    }
  }


  virtual ~AttachDiskResponse() = default;
};
class AttachEnsInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scripts{};

  AttachEnsInstancesRequest() {}

  explicit AttachEnsInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scripts) {
      res["Scripts"] = boost::any(*scripts);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Scripts") != m.end() && !m["Scripts"].empty()) {
      scripts = make_shared<string>(boost::any_cast<string>(m["Scripts"]));
    }
  }


  virtual ~AttachEnsInstancesRequest() = default;
};
class AttachEnsInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AttachEnsInstancesResponseBody() {}

  explicit AttachEnsInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachEnsInstancesResponseBody() = default;
};
class AttachEnsInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachEnsInstancesResponseBody> body{};

  AttachEnsInstancesResponse() {}

  explicit AttachEnsInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachEnsInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachEnsInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~AttachEnsInstancesResponse() = default;
};
class AttachInstanceSDGRequestLoadOpt : public Darabonba::Model {
public:
  shared_ptr<bool> blockRwSplit{};
  shared_ptr<long> blockRwSplitSize{};
  shared_ptr<bool> cache{};
  shared_ptr<long> cacheSize{};

  AttachInstanceSDGRequestLoadOpt() {}

  explicit AttachInstanceSDGRequestLoadOpt(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockRwSplit) {
      res["BlockRwSplit"] = boost::any(*blockRwSplit);
    }
    if (blockRwSplitSize) {
      res["BlockRwSplitSize"] = boost::any(*blockRwSplitSize);
    }
    if (cache) {
      res["Cache"] = boost::any(*cache);
    }
    if (cacheSize) {
      res["CacheSize"] = boost::any(*cacheSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockRwSplit") != m.end() && !m["BlockRwSplit"].empty()) {
      blockRwSplit = make_shared<bool>(boost::any_cast<bool>(m["BlockRwSplit"]));
    }
    if (m.find("BlockRwSplitSize") != m.end() && !m["BlockRwSplitSize"].empty()) {
      blockRwSplitSize = make_shared<long>(boost::any_cast<long>(m["BlockRwSplitSize"]));
    }
    if (m.find("Cache") != m.end() && !m["Cache"].empty()) {
      cache = make_shared<bool>(boost::any_cast<bool>(m["Cache"]));
    }
    if (m.find("CacheSize") != m.end() && !m["CacheSize"].empty()) {
      cacheSize = make_shared<long>(boost::any_cast<long>(m["CacheSize"]));
    }
  }


  virtual ~AttachInstanceSDGRequestLoadOpt() = default;
};
class AttachInstanceSDGRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<AttachInstanceSDGRequestLoadOpt> loadOpt{};
  shared_ptr<string> SDGId{};

  AttachInstanceSDGRequest() {}

  explicit AttachInstanceSDGRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (loadOpt) {
      res["LoadOpt"] = loadOpt ? boost::any(loadOpt->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LoadOpt") != m.end() && !m["LoadOpt"].empty()) {
      if (typeid(map<string, boost::any>) == m["LoadOpt"].type()) {
        AttachInstanceSDGRequestLoadOpt model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LoadOpt"]));
        loadOpt = make_shared<AttachInstanceSDGRequestLoadOpt>(model1);
      }
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~AttachInstanceSDGRequest() = default;
};
class AttachInstanceSDGShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIdsShrink{};
  shared_ptr<string> loadOptShrink{};
  shared_ptr<string> SDGId{};

  AttachInstanceSDGShrinkRequest() {}

  explicit AttachInstanceSDGShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIdsShrink) {
      res["InstanceIds"] = boost::any(*instanceIdsShrink);
    }
    if (loadOptShrink) {
      res["LoadOpt"] = boost::any(*loadOptShrink);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("LoadOpt") != m.end() && !m["LoadOpt"].empty()) {
      loadOptShrink = make_shared<string>(boost::any_cast<string>(m["LoadOpt"]));
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~AttachInstanceSDGShrinkRequest() = default;
};
class AttachInstanceSDGResponseBodyDataResultFailedItems : public Darabonba::Model {
public:
  shared_ptr<string> errMessage{};
  shared_ptr<string> instanceId{};

  AttachInstanceSDGResponseBodyDataResultFailedItems() {}

  explicit AttachInstanceSDGResponseBodyDataResultFailedItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~AttachInstanceSDGResponseBodyDataResultFailedItems() = default;
};
class AttachInstanceSDGResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<long> failedCount{};
  shared_ptr<vector<AttachInstanceSDGResponseBodyDataResultFailedItems>> failedItems{};
  shared_ptr<long> successCount{};

  AttachInstanceSDGResponseBodyDataResult() {}

  explicit AttachInstanceSDGResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedCount) {
      res["FailedCount"] = boost::any(*failedCount);
    }
    if (failedItems) {
      vector<boost::any> temp1;
      for(auto item1:*failedItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedItems"] = boost::any(temp1);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedCount") != m.end() && !m["FailedCount"].empty()) {
      failedCount = make_shared<long>(boost::any_cast<long>(m["FailedCount"]));
    }
    if (m.find("FailedItems") != m.end() && !m["FailedItems"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedItems"].type()) {
        vector<AttachInstanceSDGResponseBodyDataResultFailedItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachInstanceSDGResponseBodyDataResultFailedItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedItems = make_shared<vector<AttachInstanceSDGResponseBodyDataResultFailedItems>>(expect1);
      }
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
  }


  virtual ~AttachInstanceSDGResponseBodyDataResult() = default;
};
class AttachInstanceSDGResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<AttachInstanceSDGResponseBodyDataResult> result{};
  shared_ptr<bool> success{};

  AttachInstanceSDGResponseBodyData() {}

  explicit AttachInstanceSDGResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        AttachInstanceSDGResponseBodyDataResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<AttachInstanceSDGResponseBodyDataResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AttachInstanceSDGResponseBodyData() = default;
};
class AttachInstanceSDGResponseBody : public Darabonba::Model {
public:
  shared_ptr<AttachInstanceSDGResponseBodyData> data{};
  shared_ptr<string> requestId{};

  AttachInstanceSDGResponseBody() {}

  explicit AttachInstanceSDGResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AttachInstanceSDGResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AttachInstanceSDGResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachInstanceSDGResponseBody() = default;
};
class AttachInstanceSDGResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachInstanceSDGResponseBody> body{};

  AttachInstanceSDGResponse() {}

  explicit AttachInstanceSDGResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachInstanceSDGResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachInstanceSDGResponseBody>(model1);
      }
    }
  }


  virtual ~AttachInstanceSDGResponse() = default;
};
class AttachNetworkInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkInterfaceId{};

  AttachNetworkInterfaceRequest() {}

  explicit AttachNetworkInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
  }


  virtual ~AttachNetworkInterfaceRequest() = default;
};
class AttachNetworkInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AttachNetworkInterfaceResponseBody() {}

  explicit AttachNetworkInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachNetworkInterfaceResponseBody() = default;
};
class AttachNetworkInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachNetworkInterfaceResponseBody> body{};

  AttachNetworkInterfaceResponse() {}

  explicit AttachNetworkInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachNetworkInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachNetworkInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~AttachNetworkInterfaceResponse() = default;
};
class AuthorizeSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> sourcePortRange{};

  AuthorizeSecurityGroupRequest() {}

  explicit AuthorizeSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
  }


  virtual ~AuthorizeSecurityGroupRequest() = default;
};
class AuthorizeSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AuthorizeSecurityGroupResponseBody() {}

  explicit AuthorizeSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AuthorizeSecurityGroupResponseBody() = default;
};
class AuthorizeSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AuthorizeSecurityGroupResponseBody> body{};

  AuthorizeSecurityGroupResponse() {}

  explicit AuthorizeSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AuthorizeSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AuthorizeSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AuthorizeSecurityGroupResponse() = default;
};
class AuthorizeSecurityGroupEgressRequest : public Darabonba::Model {
public:
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> sourcePortRange{};

  AuthorizeSecurityGroupEgressRequest() {}

  explicit AuthorizeSecurityGroupEgressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
  }


  virtual ~AuthorizeSecurityGroupEgressRequest() = default;
};
class AuthorizeSecurityGroupEgressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AuthorizeSecurityGroupEgressResponseBody() {}

  explicit AuthorizeSecurityGroupEgressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AuthorizeSecurityGroupEgressResponseBody() = default;
};
class AuthorizeSecurityGroupEgressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AuthorizeSecurityGroupEgressResponseBody> body{};

  AuthorizeSecurityGroupEgressResponse() {}

  explicit AuthorizeSecurityGroupEgressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AuthorizeSecurityGroupEgressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AuthorizeSecurityGroupEgressResponseBody>(model1);
      }
    }
  }


  virtual ~AuthorizeSecurityGroupEgressResponse() = default;
};
class CleanDistDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataName{};
  shared_ptr<string> dataVersion{};
  shared_ptr<string> ensRegionId{};

  CleanDistDataRequest() {}

  explicit CleanDistDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataName) {
      res["DataName"] = boost::any(*dataName);
    }
    if (dataVersion) {
      res["DataVersion"] = boost::any(*dataVersion);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataName") != m.end() && !m["DataName"].empty()) {
      dataName = make_shared<string>(boost::any_cast<string>(m["DataName"]));
    }
    if (m.find("DataVersion") != m.end() && !m["DataVersion"].empty()) {
      dataVersion = make_shared<string>(boost::any_cast<string>(m["DataVersion"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
  }


  virtual ~CleanDistDataRequest() = default;
};
class CleanDistDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CleanDistDataResponseBody() {}

  explicit CleanDistDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CleanDistDataResponseBody() = default;
};
class CleanDistDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CleanDistDataResponseBody> body{};

  CleanDistDataResponse() {}

  explicit CleanDistDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CleanDistDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CleanDistDataResponseBody>(model1);
      }
    }
  }


  virtual ~CleanDistDataResponse() = default;
};
class CopySDGRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> destinationRegionIds{};
  shared_ptr<string> SDGId{};

  CopySDGRequest() {}

  explicit CopySDGRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationRegionIds) {
      res["DestinationRegionIds"] = boost::any(*destinationRegionIds);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationRegionIds") != m.end() && !m["DestinationRegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DestinationRegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DestinationRegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      destinationRegionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~CopySDGRequest() = default;
};
class CopySDGShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> destinationRegionIdsShrink{};
  shared_ptr<string> SDGId{};

  CopySDGShrinkRequest() {}

  explicit CopySDGShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationRegionIdsShrink) {
      res["DestinationRegionIds"] = boost::any(*destinationRegionIdsShrink);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationRegionIds") != m.end() && !m["DestinationRegionIds"].empty()) {
      destinationRegionIdsShrink = make_shared<string>(boost::any_cast<string>(m["DestinationRegionIds"]));
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~CopySDGShrinkRequest() = default;
};
class CopySDGResponseBodyDataResultFailedItems : public Darabonba::Model {
public:
  shared_ptr<string> destinationRegionId{};
  shared_ptr<string> errorMessage{};

  CopySDGResponseBodyDataResultFailedItems() {}

  explicit CopySDGResponseBodyDataResultFailedItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationRegionId) {
      res["DestinationRegionId"] = boost::any(*destinationRegionId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationRegionId") != m.end() && !m["DestinationRegionId"].empty()) {
      destinationRegionId = make_shared<string>(boost::any_cast<string>(m["DestinationRegionId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~CopySDGResponseBodyDataResultFailedItems() = default;
};
class CopySDGResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<long> failedCount{};
  shared_ptr<vector<CopySDGResponseBodyDataResultFailedItems>> failedItems{};
  shared_ptr<long> successCount{};

  CopySDGResponseBodyDataResult() {}

  explicit CopySDGResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedCount) {
      res["FailedCount"] = boost::any(*failedCount);
    }
    if (failedItems) {
      vector<boost::any> temp1;
      for(auto item1:*failedItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedItems"] = boost::any(temp1);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedCount") != m.end() && !m["FailedCount"].empty()) {
      failedCount = make_shared<long>(boost::any_cast<long>(m["FailedCount"]));
    }
    if (m.find("FailedItems") != m.end() && !m["FailedItems"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedItems"].type()) {
        vector<CopySDGResponseBodyDataResultFailedItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CopySDGResponseBodyDataResultFailedItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedItems = make_shared<vector<CopySDGResponseBodyDataResultFailedItems>>(expect1);
      }
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
  }


  virtual ~CopySDGResponseBodyDataResult() = default;
};
class CopySDGResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<CopySDGResponseBodyDataResult> result{};
  shared_ptr<bool> success{};

  CopySDGResponseBodyData() {}

  explicit CopySDGResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CopySDGResponseBodyDataResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CopySDGResponseBodyDataResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CopySDGResponseBodyData() = default;
};
class CopySDGResponseBody : public Darabonba::Model {
public:
  shared_ptr<CopySDGResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CopySDGResponseBody() {}

  explicit CopySDGResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CopySDGResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CopySDGResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CopySDGResponseBody() = default;
};
class CopySDGResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CopySDGResponseBody> body{};

  CopySDGResponse() {}

  explicit CopySDGResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopySDGResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopySDGResponseBody>(model1);
      }
    }
  }


  virtual ~CopySDGResponse() = default;
};
class CopySnapshotRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> destinationRegionIds{};
  shared_ptr<string> destinationSnapshotDescription{};
  shared_ptr<string> destinationSnapshotName{};
  shared_ptr<string> instanceBillingCycle{};
  shared_ptr<string> snapshotId{};

  CopySnapshotRequest() {}

  explicit CopySnapshotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationRegionIds) {
      res["DestinationRegionIds"] = boost::any(*destinationRegionIds);
    }
    if (destinationSnapshotDescription) {
      res["DestinationSnapshotDescription"] = boost::any(*destinationSnapshotDescription);
    }
    if (destinationSnapshotName) {
      res["DestinationSnapshotName"] = boost::any(*destinationSnapshotName);
    }
    if (instanceBillingCycle) {
      res["InstanceBillingCycle"] = boost::any(*instanceBillingCycle);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationRegionIds") != m.end() && !m["DestinationRegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DestinationRegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DestinationRegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      destinationRegionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DestinationSnapshotDescription") != m.end() && !m["DestinationSnapshotDescription"].empty()) {
      destinationSnapshotDescription = make_shared<string>(boost::any_cast<string>(m["DestinationSnapshotDescription"]));
    }
    if (m.find("DestinationSnapshotName") != m.end() && !m["DestinationSnapshotName"].empty()) {
      destinationSnapshotName = make_shared<string>(boost::any_cast<string>(m["DestinationSnapshotName"]));
    }
    if (m.find("InstanceBillingCycle") != m.end() && !m["InstanceBillingCycle"].empty()) {
      instanceBillingCycle = make_shared<string>(boost::any_cast<string>(m["InstanceBillingCycle"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
  }


  virtual ~CopySnapshotRequest() = default;
};
class CopySnapshotShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> destinationRegionIdsShrink{};
  shared_ptr<string> destinationSnapshotDescription{};
  shared_ptr<string> destinationSnapshotName{};
  shared_ptr<string> instanceBillingCycle{};
  shared_ptr<string> snapshotId{};

  CopySnapshotShrinkRequest() {}

  explicit CopySnapshotShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationRegionIdsShrink) {
      res["DestinationRegionIds"] = boost::any(*destinationRegionIdsShrink);
    }
    if (destinationSnapshotDescription) {
      res["DestinationSnapshotDescription"] = boost::any(*destinationSnapshotDescription);
    }
    if (destinationSnapshotName) {
      res["DestinationSnapshotName"] = boost::any(*destinationSnapshotName);
    }
    if (instanceBillingCycle) {
      res["InstanceBillingCycle"] = boost::any(*instanceBillingCycle);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationRegionIds") != m.end() && !m["DestinationRegionIds"].empty()) {
      destinationRegionIdsShrink = make_shared<string>(boost::any_cast<string>(m["DestinationRegionIds"]));
    }
    if (m.find("DestinationSnapshotDescription") != m.end() && !m["DestinationSnapshotDescription"].empty()) {
      destinationSnapshotDescription = make_shared<string>(boost::any_cast<string>(m["DestinationSnapshotDescription"]));
    }
    if (m.find("DestinationSnapshotName") != m.end() && !m["DestinationSnapshotName"].empty()) {
      destinationSnapshotName = make_shared<string>(boost::any_cast<string>(m["DestinationSnapshotName"]));
    }
    if (m.find("InstanceBillingCycle") != m.end() && !m["InstanceBillingCycle"].empty()) {
      instanceBillingCycle = make_shared<string>(boost::any_cast<string>(m["InstanceBillingCycle"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
  }


  virtual ~CopySnapshotShrinkRequest() = default;
};
class CopySnapshotResponseBodyAllocationId : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<vector<string>> instanceId{};

  CopySnapshotResponseBodyAllocationId() {}

  explicit CopySnapshotResponseBodyAllocationId(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CopySnapshotResponseBodyAllocationId() = default;
};
class CopySnapshotResponseBodyUnAllocationId : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};

  CopySnapshotResponseBodyUnAllocationId() {}

  explicit CopySnapshotResponseBodyUnAllocationId(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
  }


  virtual ~CopySnapshotResponseBodyUnAllocationId() = default;
};
class CopySnapshotResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<CopySnapshotResponseBodyAllocationId>> allocationId{};
  shared_ptr<string> bizStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<CopySnapshotResponseBodyUnAllocationId>> unAllocationId{};

  CopySnapshotResponseBody() {}

  explicit CopySnapshotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      vector<boost::any> temp1;
      for(auto item1:*allocationId){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AllocationId"] = boost::any(temp1);
    }
    if (bizStatusCode) {
      res["BizStatusCode"] = boost::any(*bizStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (unAllocationId) {
      vector<boost::any> temp1;
      for(auto item1:*unAllocationId){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UnAllocationId"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      if (typeid(vector<boost::any>) == m["AllocationId"].type()) {
        vector<CopySnapshotResponseBodyAllocationId> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AllocationId"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CopySnapshotResponseBodyAllocationId model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        allocationId = make_shared<vector<CopySnapshotResponseBodyAllocationId>>(expect1);
      }
    }
    if (m.find("BizStatusCode") != m.end() && !m["BizStatusCode"].empty()) {
      bizStatusCode = make_shared<string>(boost::any_cast<string>(m["BizStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UnAllocationId") != m.end() && !m["UnAllocationId"].empty()) {
      if (typeid(vector<boost::any>) == m["UnAllocationId"].type()) {
        vector<CopySnapshotResponseBodyUnAllocationId> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UnAllocationId"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CopySnapshotResponseBodyUnAllocationId model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        unAllocationId = make_shared<vector<CopySnapshotResponseBodyUnAllocationId>>(expect1);
      }
    }
  }


  virtual ~CopySnapshotResponseBody() = default;
};
class CopySnapshotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CopySnapshotResponseBody> body{};

  CopySnapshotResponse() {}

  explicit CopySnapshotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopySnapshotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopySnapshotResponseBody>(model1);
      }
    }
  }


  virtual ~CopySnapshotResponse() = default;
};
class CreateARMServerInstancesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateARMServerInstancesRequestTag() {}

  explicit CreateARMServerInstancesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateARMServerInstancesRequestTag() = default;
};
class CreateARMServerInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<bool> autoUseCoupon{};
  shared_ptr<string> cidr{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> environmentVar{};
  shared_ptr<long> frequency{};
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> nameSpace_{};
  shared_ptr<string> payType{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> resolution{};
  shared_ptr<string> serverName{};
  shared_ptr<string> serverType{};
  shared_ptr<vector<CreateARMServerInstancesRequestTag>> tag{};

  CreateARMServerInstancesRequest() {}

  explicit CreateARMServerInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoUseCoupon) {
      res["AutoUseCoupon"] = boost::any(*autoUseCoupon);
    }
    if (cidr) {
      res["Cidr"] = boost::any(*cidr);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (environmentVar) {
      res["EnvironmentVar"] = boost::any(*environmentVar);
    }
    if (frequency) {
      res["Frequency"] = boost::any(*frequency);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (nameSpace_) {
      res["NameSpace"] = boost::any(*nameSpace_);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (resolution) {
      res["Resolution"] = boost::any(*resolution);
    }
    if (serverName) {
      res["ServerName"] = boost::any(*serverName);
    }
    if (serverType) {
      res["ServerType"] = boost::any(*serverType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoUseCoupon") != m.end() && !m["AutoUseCoupon"].empty()) {
      autoUseCoupon = make_shared<bool>(boost::any_cast<bool>(m["AutoUseCoupon"]));
    }
    if (m.find("Cidr") != m.end() && !m["Cidr"].empty()) {
      cidr = make_shared<string>(boost::any_cast<string>(m["Cidr"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnvironmentVar") != m.end() && !m["EnvironmentVar"].empty()) {
      environmentVar = make_shared<string>(boost::any_cast<string>(m["EnvironmentVar"]));
    }
    if (m.find("Frequency") != m.end() && !m["Frequency"].empty()) {
      frequency = make_shared<long>(boost::any_cast<long>(m["Frequency"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("NameSpace") != m.end() && !m["NameSpace"].empty()) {
      nameSpace_ = make_shared<string>(boost::any_cast<string>(m["NameSpace"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("Resolution") != m.end() && !m["Resolution"].empty()) {
      resolution = make_shared<string>(boost::any_cast<string>(m["Resolution"]));
    }
    if (m.find("ServerName") != m.end() && !m["ServerName"].empty()) {
      serverName = make_shared<string>(boost::any_cast<string>(m["ServerName"]));
    }
    if (m.find("ServerType") != m.end() && !m["ServerType"].empty()) {
      serverType = make_shared<string>(boost::any_cast<string>(m["ServerType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateARMServerInstancesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateARMServerInstancesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateARMServerInstancesRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateARMServerInstancesRequest() = default;
};
class CreateARMServerInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  CreateARMServerInstancesResponseBody() {}

  explicit CreateARMServerInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateARMServerInstancesResponseBody() = default;
};
class CreateARMServerInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateARMServerInstancesResponseBody> body{};

  CreateARMServerInstancesResponse() {}

  explicit CreateARMServerInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateARMServerInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateARMServerInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~CreateARMServerInstancesResponse() = default;
};
class CreateApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> template_{};
  shared_ptr<long> timeout{};

  CreateApplicationRequest() {}

  explicit CreateApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~CreateApplicationRequest() = default;
};
class CreateApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> requestId{};

  CreateApplicationResponseBody() {}

  explicit CreateApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateApplicationResponseBody() = default;
};
class CreateApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateApplicationResponseBody> body{};

  CreateApplicationResponse() {}

  explicit CreateApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApplicationResponse() = default;
};
class CreateClassicNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> networkName{};

  CreateClassicNetworkRequest() {}

  explicit CreateClassicNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (networkName) {
      res["NetworkName"] = boost::any(*networkName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("NetworkName") != m.end() && !m["NetworkName"].empty()) {
      networkName = make_shared<string>(boost::any_cast<string>(m["NetworkName"]));
    }
  }


  virtual ~CreateClassicNetworkRequest() = default;
};
class CreateClassicNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> networkId{};
  shared_ptr<string> requestId{};

  CreateClassicNetworkResponseBody() {}

  explicit CreateClassicNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateClassicNetworkResponseBody() = default;
};
class CreateClassicNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateClassicNetworkResponseBody> body{};

  CreateClassicNetworkResponse() {}

  explicit CreateClassicNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateClassicNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateClassicNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~CreateClassicNetworkResponse() = default;
};
class CreateClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterVersion{};
  shared_ptr<string> name{};

  CreateClusterRequest() {}

  explicit CreateClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterVersion) {
      res["ClusterVersion"] = boost::any(*clusterVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterVersion") != m.end() && !m["ClusterVersion"].empty()) {
      clusterVersion = make_shared<string>(boost::any_cast<string>(m["ClusterVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateClusterRequest() = default;
};
class CreateClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> requestId{};

  CreateClusterResponseBody() {}

  explicit CreateClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateClusterResponseBody() = default;
};
class CreateClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateClusterResponseBody> body{};

  CreateClusterResponse() {}

  explicit CreateClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateClusterResponseBody>(model1);
      }
    }
  }


  virtual ~CreateClusterResponse() = default;
};
class CreateDiskRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateDiskRequestTag() {}

  explicit CreateDiskRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDiskRequestTag() = default;
};
class CreateDiskRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> diskName{};
  shared_ptr<bool> encrypted{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceBillingCycle{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<string> size{};
  shared_ptr<string> snapshotId{};
  shared_ptr<vector<CreateDiskRequestTag>> tag{};

  CreateDiskRequest() {}

  explicit CreateDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceBillingCycle) {
      res["InstanceBillingCycle"] = boost::any(*instanceBillingCycle);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["Encrypted"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceBillingCycle") != m.end() && !m["InstanceBillingCycle"].empty()) {
      instanceBillingCycle = make_shared<string>(boost::any_cast<string>(m["InstanceBillingCycle"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateDiskRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDiskRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateDiskRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateDiskRequest() = default;
};
class CreateDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  CreateDiskResponseBody() {}

  explicit CreateDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDiskResponseBody() = default;
};
class CreateDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDiskResponseBody> body{};

  CreateDiskResponse() {}

  explicit CreateDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDiskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDiskResponse() = default;
};
class CreateEipInstanceRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateEipInstanceRequestTag() {}

  explicit CreateEipInstanceRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateEipInstanceRequestTag() = default;
};
class CreateEipInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> isp{};
  shared_ptr<string> name{};
  shared_ptr<vector<CreateEipInstanceRequestTag>> tag{};

  CreateEipInstanceRequest() {}

  explicit CreateEipInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateEipInstanceRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEipInstanceRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateEipInstanceRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateEipInstanceRequest() = default;
};
class CreateEipInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> requestId{};

  CreateEipInstanceResponseBody() {}

  explicit CreateEipInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEipInstanceResponseBody() = default;
};
class CreateEipInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEipInstanceResponseBody> body{};

  CreateEipInstanceResponse() {}

  explicit CreateEipInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEipInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEipInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEipInstanceResponse() = default;
};
class CreateEnsRouteEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> nextHopId{};
  shared_ptr<string> nextHopType{};
  shared_ptr<string> routeEntryName{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> sourceCidrBlock{};

  CreateEnsRouteEntryRequest() {}

  explicit CreateEnsRouteEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (nextHopId) {
      res["NextHopId"] = boost::any(*nextHopId);
    }
    if (nextHopType) {
      res["NextHopType"] = boost::any(*nextHopType);
    }
    if (routeEntryName) {
      res["RouteEntryName"] = boost::any(*routeEntryName);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (sourceCidrBlock) {
      res["SourceCidrBlock"] = boost::any(*sourceCidrBlock);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("NextHopId") != m.end() && !m["NextHopId"].empty()) {
      nextHopId = make_shared<string>(boost::any_cast<string>(m["NextHopId"]));
    }
    if (m.find("NextHopType") != m.end() && !m["NextHopType"].empty()) {
      nextHopType = make_shared<string>(boost::any_cast<string>(m["NextHopType"]));
    }
    if (m.find("RouteEntryName") != m.end() && !m["RouteEntryName"].empty()) {
      routeEntryName = make_shared<string>(boost::any_cast<string>(m["RouteEntryName"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("SourceCidrBlock") != m.end() && !m["SourceCidrBlock"].empty()) {
      sourceCidrBlock = make_shared<string>(boost::any_cast<string>(m["SourceCidrBlock"]));
    }
  }


  virtual ~CreateEnsRouteEntryRequest() = default;
};
class CreateEnsRouteEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> routeEntryId{};

  CreateEnsRouteEntryResponseBody() {}

  explicit CreateEnsRouteEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routeEntryId) {
      res["RouteEntryId"] = boost::any(*routeEntryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouteEntryId") != m.end() && !m["RouteEntryId"].empty()) {
      routeEntryId = make_shared<string>(boost::any_cast<string>(m["RouteEntryId"]));
    }
  }


  virtual ~CreateEnsRouteEntryResponseBody() = default;
};
class CreateEnsRouteEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEnsRouteEntryResponseBody> body{};

  CreateEnsRouteEntryResponse() {}

  explicit CreateEnsRouteEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEnsRouteEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEnsRouteEntryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEnsRouteEntryResponse() = default;
};
class CreateEnsSaleControlRequestSaleControlsConditionControls : public Darabonba::Model {
public:
  shared_ptr<string> conditionControlModuleCode{};
  shared_ptr<string> conditionControlModuleValue{};

  CreateEnsSaleControlRequestSaleControlsConditionControls() {}

  explicit CreateEnsSaleControlRequestSaleControlsConditionControls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionControlModuleCode) {
      res["ConditionControlModuleCode"] = boost::any(*conditionControlModuleCode);
    }
    if (conditionControlModuleValue) {
      res["ConditionControlModuleValue"] = boost::any(*conditionControlModuleValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionControlModuleCode") != m.end() && !m["ConditionControlModuleCode"].empty()) {
      conditionControlModuleCode = make_shared<string>(boost::any_cast<string>(m["ConditionControlModuleCode"]));
    }
    if (m.find("ConditionControlModuleValue") != m.end() && !m["ConditionControlModuleValue"].empty()) {
      conditionControlModuleValue = make_shared<string>(boost::any_cast<string>(m["ConditionControlModuleValue"]));
    }
  }


  virtual ~CreateEnsSaleControlRequestSaleControlsConditionControls() = default;
};
class CreateEnsSaleControlRequestSaleControlsModuleValue : public Darabonba::Model {
public:
  shared_ptr<string> moduleMaxValue{};
  shared_ptr<string> moduleMinValue{};
  shared_ptr<vector<string>> moduleValue{};

  CreateEnsSaleControlRequestSaleControlsModuleValue() {}

  explicit CreateEnsSaleControlRequestSaleControlsModuleValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moduleMaxValue) {
      res["ModuleMaxValue"] = boost::any(*moduleMaxValue);
    }
    if (moduleMinValue) {
      res["ModuleMinValue"] = boost::any(*moduleMinValue);
    }
    if (moduleValue) {
      res["ModuleValue"] = boost::any(*moduleValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModuleMaxValue") != m.end() && !m["ModuleMaxValue"].empty()) {
      moduleMaxValue = make_shared<string>(boost::any_cast<string>(m["ModuleMaxValue"]));
    }
    if (m.find("ModuleMinValue") != m.end() && !m["ModuleMinValue"].empty()) {
      moduleMinValue = make_shared<string>(boost::any_cast<string>(m["ModuleMinValue"]));
    }
    if (m.find("ModuleValue") != m.end() && !m["ModuleValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ModuleValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ModuleValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      moduleValue = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateEnsSaleControlRequestSaleControlsModuleValue() = default;
};
class CreateEnsSaleControlRequestSaleControls : public Darabonba::Model {
public:
  shared_ptr<vector<CreateEnsSaleControlRequestSaleControlsConditionControls>> conditionControls{};
  shared_ptr<string> description{};
  shared_ptr<string> moduleCode{};
  shared_ptr<CreateEnsSaleControlRequestSaleControlsModuleValue> moduleValue{};
  shared_ptr<string> operator_{};
  shared_ptr<string> orderType{};

  CreateEnsSaleControlRequestSaleControls() {}

  explicit CreateEnsSaleControlRequestSaleControls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionControls) {
      vector<boost::any> temp1;
      for(auto item1:*conditionControls){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConditionControls"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (moduleCode) {
      res["ModuleCode"] = boost::any(*moduleCode);
    }
    if (moduleValue) {
      res["ModuleValue"] = moduleValue ? boost::any(moduleValue->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionControls") != m.end() && !m["ConditionControls"].empty()) {
      if (typeid(vector<boost::any>) == m["ConditionControls"].type()) {
        vector<CreateEnsSaleControlRequestSaleControlsConditionControls> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConditionControls"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEnsSaleControlRequestSaleControlsConditionControls model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditionControls = make_shared<vector<CreateEnsSaleControlRequestSaleControlsConditionControls>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModuleCode") != m.end() && !m["ModuleCode"].empty()) {
      moduleCode = make_shared<string>(boost::any_cast<string>(m["ModuleCode"]));
    }
    if (m.find("ModuleValue") != m.end() && !m["ModuleValue"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModuleValue"].type()) {
        CreateEnsSaleControlRequestSaleControlsModuleValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModuleValue"]));
        moduleValue = make_shared<CreateEnsSaleControlRequestSaleControlsModuleValue>(model1);
      }
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
  }


  virtual ~CreateEnsSaleControlRequestSaleControls() = default;
};
class CreateEnsSaleControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliUidAccount{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> customAccount{};
  shared_ptr<vector<CreateEnsSaleControlRequestSaleControls>> saleControls{};

  CreateEnsSaleControlRequest() {}

  explicit CreateEnsSaleControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUidAccount) {
      res["AliUidAccount"] = boost::any(*aliUidAccount);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (customAccount) {
      res["CustomAccount"] = boost::any(*customAccount);
    }
    if (saleControls) {
      vector<boost::any> temp1;
      for(auto item1:*saleControls){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SaleControls"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUidAccount") != m.end() && !m["AliUidAccount"].empty()) {
      aliUidAccount = make_shared<string>(boost::any_cast<string>(m["AliUidAccount"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CustomAccount") != m.end() && !m["CustomAccount"].empty()) {
      customAccount = make_shared<string>(boost::any_cast<string>(m["CustomAccount"]));
    }
    if (m.find("SaleControls") != m.end() && !m["SaleControls"].empty()) {
      if (typeid(vector<boost::any>) == m["SaleControls"].type()) {
        vector<CreateEnsSaleControlRequestSaleControls> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SaleControls"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEnsSaleControlRequestSaleControls model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        saleControls = make_shared<vector<CreateEnsSaleControlRequestSaleControls>>(expect1);
      }
    }
  }


  virtual ~CreateEnsSaleControlRequest() = default;
};
class CreateEnsSaleControlShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliUidAccount{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> customAccount{};
  shared_ptr<string> saleControlsShrink{};

  CreateEnsSaleControlShrinkRequest() {}

  explicit CreateEnsSaleControlShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUidAccount) {
      res["AliUidAccount"] = boost::any(*aliUidAccount);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (customAccount) {
      res["CustomAccount"] = boost::any(*customAccount);
    }
    if (saleControlsShrink) {
      res["SaleControls"] = boost::any(*saleControlsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUidAccount") != m.end() && !m["AliUidAccount"].empty()) {
      aliUidAccount = make_shared<string>(boost::any_cast<string>(m["AliUidAccount"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CustomAccount") != m.end() && !m["CustomAccount"].empty()) {
      customAccount = make_shared<string>(boost::any_cast<string>(m["CustomAccount"]));
    }
    if (m.find("SaleControls") != m.end() && !m["SaleControls"].empty()) {
      saleControlsShrink = make_shared<string>(boost::any_cast<string>(m["SaleControls"]));
    }
  }


  virtual ~CreateEnsSaleControlShrinkRequest() = default;
};
class CreateEnsSaleControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateEnsSaleControlResponseBody() {}

  explicit CreateEnsSaleControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEnsSaleControlResponseBody() = default;
};
class CreateEnsSaleControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEnsSaleControlResponseBody> body{};

  CreateEnsSaleControlResponse() {}

  explicit CreateEnsSaleControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEnsSaleControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEnsSaleControlResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEnsSaleControlResponse() = default;
};
class CreateEnsServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensServiceId{};
  shared_ptr<string> orderType{};

  CreateEnsServiceRequest() {}

  explicit CreateEnsServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensServiceId) {
      res["EnsServiceId"] = boost::any(*ensServiceId);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsServiceId") != m.end() && !m["EnsServiceId"].empty()) {
      ensServiceId = make_shared<string>(boost::any_cast<string>(m["EnsServiceId"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
  }


  virtual ~CreateEnsServiceRequest() = default;
};
class CreateEnsServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  CreateEnsServiceResponseBody() {}

  explicit CreateEnsServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEnsServiceResponseBody() = default;
};
class CreateEnsServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEnsServiceResponseBody> body{};

  CreateEnsServiceResponse() {}

  explicit CreateEnsServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEnsServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEnsServiceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEnsServiceResponse() = default;
};
class CreateEpnInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceName{};
  shared_ptr<string> EPNInstanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> networkingModel{};

  CreateEpnInstanceRequest() {}

  explicit CreateEpnInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceName) {
      res["EPNInstanceName"] = boost::any(*EPNInstanceName);
    }
    if (EPNInstanceType) {
      res["EPNInstanceType"] = boost::any(*EPNInstanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (networkingModel) {
      res["NetworkingModel"] = boost::any(*networkingModel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceName") != m.end() && !m["EPNInstanceName"].empty()) {
      EPNInstanceName = make_shared<string>(boost::any_cast<string>(m["EPNInstanceName"]));
    }
    if (m.find("EPNInstanceType") != m.end() && !m["EPNInstanceType"].empty()) {
      EPNInstanceType = make_shared<string>(boost::any_cast<string>(m["EPNInstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("NetworkingModel") != m.end() && !m["NetworkingModel"].empty()) {
      networkingModel = make_shared<string>(boost::any_cast<string>(m["NetworkingModel"]));
    }
  }


  virtual ~CreateEpnInstanceRequest() = default;
};
class CreateEpnInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> requestId{};

  CreateEpnInstanceResponseBody() {}

  explicit CreateEpnInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEpnInstanceResponseBody() = default;
};
class CreateEpnInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEpnInstanceResponseBody> body{};

  CreateEpnInstanceResponse() {}

  explicit CreateEpnInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEpnInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEpnInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEpnInstanceResponse() = default;
};
class CreateFileSystemRequestOrderDetails : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> fileSystemName{};
  shared_ptr<string> mountTargetDomain{};
  shared_ptr<string> networkId{};
  shared_ptr<string> orderType{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> storgeType{};

  CreateFileSystemRequestOrderDetails() {}

  explicit CreateFileSystemRequestOrderDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (fileSystemName) {
      res["FileSystemName"] = boost::any(*fileSystemName);
    }
    if (mountTargetDomain) {
      res["MountTargetDomain"] = boost::any(*mountTargetDomain);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (storgeType) {
      res["StorgeType"] = boost::any(*storgeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("FileSystemName") != m.end() && !m["FileSystemName"].empty()) {
      fileSystemName = make_shared<string>(boost::any_cast<string>(m["FileSystemName"]));
    }
    if (m.find("MountTargetDomain") != m.end() && !m["MountTargetDomain"].empty()) {
      mountTargetDomain = make_shared<string>(boost::any_cast<string>(m["MountTargetDomain"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("StorgeType") != m.end() && !m["StorgeType"].empty()) {
      storgeType = make_shared<string>(boost::any_cast<string>(m["StorgeType"]));
    }
  }


  virtual ~CreateFileSystemRequestOrderDetails() = default;
};
class CreateFileSystemRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateFileSystemRequestOrderDetails>> orderDetails{};

  CreateFileSystemRequest() {}

  explicit CreateFileSystemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderDetails) {
      vector<boost::any> temp1;
      for(auto item1:*orderDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OrderDetails"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderDetails") != m.end() && !m["OrderDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["OrderDetails"].type()) {
        vector<CreateFileSystemRequestOrderDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OrderDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateFileSystemRequestOrderDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        orderDetails = make_shared<vector<CreateFileSystemRequestOrderDetails>>(expect1);
      }
    }
  }


  virtual ~CreateFileSystemRequest() = default;
};
class CreateFileSystemShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> orderDetailsShrink{};

  CreateFileSystemShrinkRequest() {}

  explicit CreateFileSystemShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderDetailsShrink) {
      res["OrderDetails"] = boost::any(*orderDetailsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderDetails") != m.end() && !m["OrderDetails"].empty()) {
      orderDetailsShrink = make_shared<string>(boost::any_cast<string>(m["OrderDetails"]));
    }
  }


  virtual ~CreateFileSystemShrinkRequest() = default;
};
class CreateFileSystemResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> allocationId{};
  shared_ptr<string> bizStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> unAllocationId{};

  CreateFileSystemResponseBody() {}

  explicit CreateFileSystemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (bizStatusCode) {
      res["BizStatusCode"] = boost::any(*bizStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (unAllocationId) {
      res["UnAllocationId"] = boost::any(*unAllocationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AllocationId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AllocationId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      allocationId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("BizStatusCode") != m.end() && !m["BizStatusCode"].empty()) {
      bizStatusCode = make_shared<string>(boost::any_cast<string>(m["BizStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UnAllocationId") != m.end() && !m["UnAllocationId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UnAllocationId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UnAllocationId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      unAllocationId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateFileSystemResponseBody() = default;
};
class CreateFileSystemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFileSystemResponseBody> body{};

  CreateFileSystemResponse() {}

  explicit CreateFileSystemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFileSystemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFileSystemResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFileSystemResponse() = default;
};
class CreateForwardEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> externalIp{};
  shared_ptr<string> externalPort{};
  shared_ptr<string> forwardEntryName{};
  shared_ptr<long> healthCheckPort{};
  shared_ptr<string> internalIp{};
  shared_ptr<string> internalPort{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> standbyExternalIp{};

  CreateForwardEntryRequest() {}

  explicit CreateForwardEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (externalIp) {
      res["ExternalIp"] = boost::any(*externalIp);
    }
    if (externalPort) {
      res["ExternalPort"] = boost::any(*externalPort);
    }
    if (forwardEntryName) {
      res["ForwardEntryName"] = boost::any(*forwardEntryName);
    }
    if (healthCheckPort) {
      res["HealthCheckPort"] = boost::any(*healthCheckPort);
    }
    if (internalIp) {
      res["InternalIp"] = boost::any(*internalIp);
    }
    if (internalPort) {
      res["InternalPort"] = boost::any(*internalPort);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (standbyExternalIp) {
      res["StandbyExternalIp"] = boost::any(*standbyExternalIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExternalIp") != m.end() && !m["ExternalIp"].empty()) {
      externalIp = make_shared<string>(boost::any_cast<string>(m["ExternalIp"]));
    }
    if (m.find("ExternalPort") != m.end() && !m["ExternalPort"].empty()) {
      externalPort = make_shared<string>(boost::any_cast<string>(m["ExternalPort"]));
    }
    if (m.find("ForwardEntryName") != m.end() && !m["ForwardEntryName"].empty()) {
      forwardEntryName = make_shared<string>(boost::any_cast<string>(m["ForwardEntryName"]));
    }
    if (m.find("HealthCheckPort") != m.end() && !m["HealthCheckPort"].empty()) {
      healthCheckPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckPort"]));
    }
    if (m.find("InternalIp") != m.end() && !m["InternalIp"].empty()) {
      internalIp = make_shared<string>(boost::any_cast<string>(m["InternalIp"]));
    }
    if (m.find("InternalPort") != m.end() && !m["InternalPort"].empty()) {
      internalPort = make_shared<string>(boost::any_cast<string>(m["InternalPort"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("StandbyExternalIp") != m.end() && !m["StandbyExternalIp"].empty()) {
      standbyExternalIp = make_shared<string>(boost::any_cast<string>(m["StandbyExternalIp"]));
    }
  }


  virtual ~CreateForwardEntryRequest() = default;
};
class CreateForwardEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> forwardEntryId{};
  shared_ptr<string> requestId{};

  CreateForwardEntryResponseBody() {}

  explicit CreateForwardEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardEntryId) {
      res["ForwardEntryId"] = boost::any(*forwardEntryId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardEntryId") != m.end() && !m["ForwardEntryId"].empty()) {
      forwardEntryId = make_shared<string>(boost::any_cast<string>(m["ForwardEntryId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateForwardEntryResponseBody() = default;
};
class CreateForwardEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateForwardEntryResponseBody> body{};

  CreateForwardEntryResponse() {}

  explicit CreateForwardEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateForwardEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateForwardEntryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateForwardEntryResponse() = default;
};
class CreateHaVipRequest : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> description{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> name{};
  shared_ptr<string> vSwitchId{};

  CreateHaVipRequest() {}

  explicit CreateHaVipRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateHaVipRequest() = default;
};
class CreateHaVipResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> haVipIds{};
  shared_ptr<string> requestId{};

  CreateHaVipResponseBody() {}

  explicit CreateHaVipResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (haVipIds) {
      res["HaVipIds"] = boost::any(*haVipIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HaVipIds") != m.end() && !m["HaVipIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HaVipIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HaVipIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      haVipIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateHaVipResponseBody() = default;
};
class CreateHaVipResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateHaVipResponseBody> body{};

  CreateHaVipResponse() {}

  explicit CreateHaVipResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHaVipResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHaVipResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHaVipResponse() = default;
};
class CreateImageRequest : public Darabonba::Model {
public:
  shared_ptr<string> deleteAfterImageUpload{};
  shared_ptr<string> imageName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> targetOSSRegionId{};
  shared_ptr<bool> withDataDisks{};

  CreateImageRequest() {}

  explicit CreateImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteAfterImageUpload) {
      res["DeleteAfterImageUpload"] = boost::any(*deleteAfterImageUpload);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (targetOSSRegionId) {
      res["TargetOSSRegionId"] = boost::any(*targetOSSRegionId);
    }
    if (withDataDisks) {
      res["WithDataDisks"] = boost::any(*withDataDisks);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteAfterImageUpload") != m.end() && !m["DeleteAfterImageUpload"].empty()) {
      deleteAfterImageUpload = make_shared<string>(boost::any_cast<string>(m["DeleteAfterImageUpload"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("TargetOSSRegionId") != m.end() && !m["TargetOSSRegionId"].empty()) {
      targetOSSRegionId = make_shared<string>(boost::any_cast<string>(m["TargetOSSRegionId"]));
    }
    if (m.find("WithDataDisks") != m.end() && !m["WithDataDisks"].empty()) {
      withDataDisks = make_shared<bool>(boost::any_cast<bool>(m["WithDataDisks"]));
    }
  }


  virtual ~CreateImageRequest() = default;
};
class CreateImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> imageId{};
  shared_ptr<string> requestId{};

  CreateImageResponseBody() {}

  explicit CreateImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateImageResponseBody() = default;
};
class CreateImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateImageResponseBody> body{};

  CreateImageResponse() {}

  explicit CreateImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateImageResponseBody>(model1);
      }
    }
  }


  virtual ~CreateImageResponse() = default;
};
class CreateInstanceRequestDataDisk : public Darabonba::Model {
public:
  shared_ptr<string> size{};

  CreateInstanceRequestDataDisk() {}

  explicit CreateInstanceRequestDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
  }


  virtual ~CreateInstanceRequestDataDisk() = default;
};
class CreateInstanceRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> size{};

  CreateInstanceRequestSystemDisk() {}

  explicit CreateInstanceRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
  }


  virtual ~CreateInstanceRequestSystemDisk() = default;
};
class CreateInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateInstanceRequestDataDisk>> dataDisk{};
  shared_ptr<CreateInstanceRequestSystemDisk> systemDisk{};
  shared_ptr<string> autoRenew{};
  shared_ptr<string> autoRenewPeriod{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> ipType{};
  shared_ptr<string> keyPairName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> password{};
  shared_ptr<bool> passwordInherit{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> period{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<bool> publicIpIdentification{};
  shared_ptr<string> quantity{};
  shared_ptr<bool> uniqueSuffix{};
  shared_ptr<string> userData{};
  shared_ptr<string> vSwitchId{};

  CreateInstanceRequest() {}

  explicit CreateInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewPeriod) {
      res["AutoRenewPeriod"] = boost::any(*autoRenewPeriod);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (passwordInherit) {
      res["PasswordInherit"] = boost::any(*passwordInherit);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (publicIpIdentification) {
      res["PublicIpIdentification"] = boost::any(*publicIpIdentification);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (uniqueSuffix) {
      res["UniqueSuffix"] = boost::any(*uniqueSuffix);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<CreateInstanceRequestDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateInstanceRequestDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<CreateInstanceRequestDataDisk>>(expect1);
      }
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        CreateInstanceRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<CreateInstanceRequestSystemDisk>(model1);
      }
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<string>(boost::any_cast<string>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewPeriod") != m.end() && !m["AutoRenewPeriod"].empty()) {
      autoRenewPeriod = make_shared<string>(boost::any_cast<string>(m["AutoRenewPeriod"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<string>(boost::any_cast<string>(m["IpType"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PasswordInherit") != m.end() && !m["PasswordInherit"].empty()) {
      passwordInherit = make_shared<bool>(boost::any_cast<bool>(m["PasswordInherit"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("PublicIpIdentification") != m.end() && !m["PublicIpIdentification"].empty()) {
      publicIpIdentification = make_shared<bool>(boost::any_cast<bool>(m["PublicIpIdentification"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<string>(boost::any_cast<string>(m["Quantity"]));
    }
    if (m.find("UniqueSuffix") != m.end() && !m["UniqueSuffix"].empty()) {
      uniqueSuffix = make_shared<bool>(boost::any_cast<bool>(m["UniqueSuffix"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateInstanceRequest() = default;
};
class CreateInstanceResponseBodyInstanceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceId{};

  CreateInstanceResponseBodyInstanceIds() {}

  explicit CreateInstanceResponseBodyInstanceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateInstanceResponseBodyInstanceIds() = default;
};
class CreateInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<CreateInstanceResponseBodyInstanceIds> instanceIds{};
  shared_ptr<string> requestId{};

  CreateInstanceResponseBody() {}

  explicit CreateInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (instanceIds) {
      res["InstanceIds"] = instanceIds ? boost::any(instanceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceIds"].type()) {
        CreateInstanceResponseBodyInstanceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceIds"]));
        instanceIds = make_shared<CreateInstanceResponseBodyInstanceIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateInstanceResponseBody() = default;
};
class CreateInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateInstanceResponseBody> body{};

  CreateInstanceResponse() {}

  explicit CreateInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateInstanceResponse() = default;
};
class CreateInstanceActiveOpsTaskRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};

  CreateInstanceActiveOpsTaskRequest() {}

  explicit CreateInstanceActiveOpsTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateInstanceActiveOpsTaskRequest() = default;
};
class CreateInstanceActiveOpsTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIdsShrink{};

  CreateInstanceActiveOpsTaskShrinkRequest() {}

  explicit CreateInstanceActiveOpsTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIdsShrink) {
      res["InstanceIds"] = boost::any(*instanceIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
  }


  virtual ~CreateInstanceActiveOpsTaskShrinkRequest() = default;
};
class CreateInstanceActiveOpsTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<InstanceActiveOpsTask> instanceActiveOpsTask{};
  shared_ptr<string> requestId{};

  CreateInstanceActiveOpsTaskResponseBody() {}

  explicit CreateInstanceActiveOpsTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceActiveOpsTask) {
      res["InstanceActiveOpsTask"] = instanceActiveOpsTask ? boost::any(instanceActiveOpsTask->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceActiveOpsTask") != m.end() && !m["InstanceActiveOpsTask"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceActiveOpsTask"].type()) {
        InstanceActiveOpsTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceActiveOpsTask"]));
        instanceActiveOpsTask = make_shared<InstanceActiveOpsTask>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateInstanceActiveOpsTaskResponseBody() = default;
};
class CreateInstanceActiveOpsTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateInstanceActiveOpsTaskResponseBody> body{};

  CreateInstanceActiveOpsTaskResponse() {}

  explicit CreateInstanceActiveOpsTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateInstanceActiveOpsTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateInstanceActiveOpsTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateInstanceActiveOpsTaskResponse() = default;
};
class CreateKeyPairRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyPairName{};

  CreateKeyPairRequest() {}

  explicit CreateKeyPairRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
  }


  virtual ~CreateKeyPairRequest() = default;
};
class CreateKeyPairResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> keyPairFingerPrint{};
  shared_ptr<string> keyPairId{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> privateKeyBody{};
  shared_ptr<string> requestId{};

  CreateKeyPairResponseBody() {}

  explicit CreateKeyPairResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPairFingerPrint) {
      res["KeyPairFingerPrint"] = boost::any(*keyPairFingerPrint);
    }
    if (keyPairId) {
      res["KeyPairId"] = boost::any(*keyPairId);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (privateKeyBody) {
      res["PrivateKeyBody"] = boost::any(*privateKeyBody);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPairFingerPrint") != m.end() && !m["KeyPairFingerPrint"].empty()) {
      keyPairFingerPrint = make_shared<string>(boost::any_cast<string>(m["KeyPairFingerPrint"]));
    }
    if (m.find("KeyPairId") != m.end() && !m["KeyPairId"].empty()) {
      keyPairId = make_shared<string>(boost::any_cast<string>(m["KeyPairId"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("PrivateKeyBody") != m.end() && !m["PrivateKeyBody"].empty()) {
      privateKeyBody = make_shared<string>(boost::any_cast<string>(m["PrivateKeyBody"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateKeyPairResponseBody() = default;
};
class CreateKeyPairResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateKeyPairResponseBody> body{};

  CreateKeyPairResponse() {}

  explicit CreateKeyPairResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateKeyPairResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateKeyPairResponseBody>(model1);
      }
    }
  }


  virtual ~CreateKeyPairResponse() = default;
};
class CreateLoadBalancerRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> loadBalancerName{};
  shared_ptr<string> loadBalancerSpec{};
  shared_ptr<string> networkId{};
  shared_ptr<string> payType{};
  shared_ptr<string> vSwitchId{};

  CreateLoadBalancerRequest() {}

  explicit CreateLoadBalancerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (loadBalancerName) {
      res["LoadBalancerName"] = boost::any(*loadBalancerName);
    }
    if (loadBalancerSpec) {
      res["LoadBalancerSpec"] = boost::any(*loadBalancerSpec);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("LoadBalancerName") != m.end() && !m["LoadBalancerName"].empty()) {
      loadBalancerName = make_shared<string>(boost::any_cast<string>(m["LoadBalancerName"]));
    }
    if (m.find("LoadBalancerSpec") != m.end() && !m["LoadBalancerSpec"].empty()) {
      loadBalancerSpec = make_shared<string>(boost::any_cast<string>(m["LoadBalancerSpec"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateLoadBalancerRequest() = default;
};
class CreateLoadBalancerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> loadBalancerName{};
  shared_ptr<string> networkId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vSwitchId{};

  CreateLoadBalancerResponseBody() {}

  explicit CreateLoadBalancerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (loadBalancerName) {
      res["LoadBalancerName"] = boost::any(*loadBalancerName);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("LoadBalancerName") != m.end() && !m["LoadBalancerName"].empty()) {
      loadBalancerName = make_shared<string>(boost::any_cast<string>(m["LoadBalancerName"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateLoadBalancerResponseBody() = default;
};
class CreateLoadBalancerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLoadBalancerResponseBody> body{};

  CreateLoadBalancerResponse() {}

  explicit CreateLoadBalancerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLoadBalancerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLoadBalancerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLoadBalancerResponse() = default;
};
class CreateLoadBalancerHTTPListenerRequest : public Darabonba::Model {
public:
  shared_ptr<long> backendServerPort{};
  shared_ptr<string> description{};
  shared_ptr<long> forwardPort{};
  shared_ptr<string> healthCheck{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckMethod{};
  shared_ptr<long> healthCheckTimeout{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<string> listenerForward{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<long> requestTimeout{};
  shared_ptr<string> scheduler{};
  shared_ptr<long> unhealthyThreshold{};
  shared_ptr<string> XForwardedFor{};

  CreateLoadBalancerHTTPListenerRequest() {}

  explicit CreateLoadBalancerHTTPListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServerPort) {
      res["BackendServerPort"] = boost::any(*backendServerPort);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (forwardPort) {
      res["ForwardPort"] = boost::any(*forwardPort);
    }
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckMethod) {
      res["HealthCheckMethod"] = boost::any(*healthCheckMethod);
    }
    if (healthCheckTimeout) {
      res["HealthCheckTimeout"] = boost::any(*healthCheckTimeout);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (listenerForward) {
      res["ListenerForward"] = boost::any(*listenerForward);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (requestTimeout) {
      res["RequestTimeout"] = boost::any(*requestTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    if (XForwardedFor) {
      res["XForwardedFor"] = boost::any(*XForwardedFor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServerPort") != m.end() && !m["BackendServerPort"].empty()) {
      backendServerPort = make_shared<long>(boost::any_cast<long>(m["BackendServerPort"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ForwardPort") != m.end() && !m["ForwardPort"].empty()) {
      forwardPort = make_shared<long>(boost::any_cast<long>(m["ForwardPort"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckMethod") != m.end() && !m["HealthCheckMethod"].empty()) {
      healthCheckMethod = make_shared<string>(boost::any_cast<string>(m["HealthCheckMethod"]));
    }
    if (m.find("HealthCheckTimeout") != m.end() && !m["HealthCheckTimeout"].empty()) {
      healthCheckTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckTimeout"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("ListenerForward") != m.end() && !m["ListenerForward"].empty()) {
      listenerForward = make_shared<string>(boost::any_cast<string>(m["ListenerForward"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("RequestTimeout") != m.end() && !m["RequestTimeout"].empty()) {
      requestTimeout = make_shared<long>(boost::any_cast<long>(m["RequestTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
    if (m.find("XForwardedFor") != m.end() && !m["XForwardedFor"].empty()) {
      XForwardedFor = make_shared<string>(boost::any_cast<string>(m["XForwardedFor"]));
    }
  }


  virtual ~CreateLoadBalancerHTTPListenerRequest() = default;
};
class CreateLoadBalancerHTTPListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateLoadBalancerHTTPListenerResponseBody() {}

  explicit CreateLoadBalancerHTTPListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLoadBalancerHTTPListenerResponseBody() = default;
};
class CreateLoadBalancerHTTPListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLoadBalancerHTTPListenerResponseBody> body{};

  CreateLoadBalancerHTTPListenerResponse() {}

  explicit CreateLoadBalancerHTTPListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLoadBalancerHTTPListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLoadBalancerHTTPListenerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLoadBalancerHTTPListenerResponse() = default;
};
class CreateLoadBalancerHTTPSListenerRequest : public Darabonba::Model {
public:
  shared_ptr<long> backendServerPort{};
  shared_ptr<string> cookie{};
  shared_ptr<long> cookieTimeout{};
  shared_ptr<string> description{};
  shared_ptr<long> forwardPort{};
  shared_ptr<string> healthCheck{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckMethod{};
  shared_ptr<long> healthCheckTimeout{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<string> listenerForward{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<long> requestTimeout{};
  shared_ptr<string> scheduler{};
  shared_ptr<string> serverCertificateId{};
  shared_ptr<string> stickySessionType{};
  shared_ptr<long> unhealthyThreshold{};

  CreateLoadBalancerHTTPSListenerRequest() {}

  explicit CreateLoadBalancerHTTPSListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServerPort) {
      res["BackendServerPort"] = boost::any(*backendServerPort);
    }
    if (cookie) {
      res["Cookie"] = boost::any(*cookie);
    }
    if (cookieTimeout) {
      res["CookieTimeout"] = boost::any(*cookieTimeout);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (forwardPort) {
      res["ForwardPort"] = boost::any(*forwardPort);
    }
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckMethod) {
      res["HealthCheckMethod"] = boost::any(*healthCheckMethod);
    }
    if (healthCheckTimeout) {
      res["HealthCheckTimeout"] = boost::any(*healthCheckTimeout);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (listenerForward) {
      res["ListenerForward"] = boost::any(*listenerForward);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (requestTimeout) {
      res["RequestTimeout"] = boost::any(*requestTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (serverCertificateId) {
      res["ServerCertificateId"] = boost::any(*serverCertificateId);
    }
    if (stickySessionType) {
      res["StickySessionType"] = boost::any(*stickySessionType);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServerPort") != m.end() && !m["BackendServerPort"].empty()) {
      backendServerPort = make_shared<long>(boost::any_cast<long>(m["BackendServerPort"]));
    }
    if (m.find("Cookie") != m.end() && !m["Cookie"].empty()) {
      cookie = make_shared<string>(boost::any_cast<string>(m["Cookie"]));
    }
    if (m.find("CookieTimeout") != m.end() && !m["CookieTimeout"].empty()) {
      cookieTimeout = make_shared<long>(boost::any_cast<long>(m["CookieTimeout"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ForwardPort") != m.end() && !m["ForwardPort"].empty()) {
      forwardPort = make_shared<long>(boost::any_cast<long>(m["ForwardPort"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckMethod") != m.end() && !m["HealthCheckMethod"].empty()) {
      healthCheckMethod = make_shared<string>(boost::any_cast<string>(m["HealthCheckMethod"]));
    }
    if (m.find("HealthCheckTimeout") != m.end() && !m["HealthCheckTimeout"].empty()) {
      healthCheckTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckTimeout"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("ListenerForward") != m.end() && !m["ListenerForward"].empty()) {
      listenerForward = make_shared<string>(boost::any_cast<string>(m["ListenerForward"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("RequestTimeout") != m.end() && !m["RequestTimeout"].empty()) {
      requestTimeout = make_shared<long>(boost::any_cast<long>(m["RequestTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("ServerCertificateId") != m.end() && !m["ServerCertificateId"].empty()) {
      serverCertificateId = make_shared<string>(boost::any_cast<string>(m["ServerCertificateId"]));
    }
    if (m.find("StickySessionType") != m.end() && !m["StickySessionType"].empty()) {
      stickySessionType = make_shared<string>(boost::any_cast<string>(m["StickySessionType"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~CreateLoadBalancerHTTPSListenerRequest() = default;
};
class CreateLoadBalancerHTTPSListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateLoadBalancerHTTPSListenerResponseBody() {}

  explicit CreateLoadBalancerHTTPSListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLoadBalancerHTTPSListenerResponseBody() = default;
};
class CreateLoadBalancerHTTPSListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLoadBalancerHTTPSListenerResponseBody> body{};

  CreateLoadBalancerHTTPSListenerResponse() {}

  explicit CreateLoadBalancerHTTPSListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLoadBalancerHTTPSListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLoadBalancerHTTPSListenerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLoadBalancerHTTPSListenerResponse() = default;
};
class CreateLoadBalancerTCPListenerRequest : public Darabonba::Model {
public:
  shared_ptr<long> backendServerPort{};
  shared_ptr<string> description{};
  shared_ptr<string> eipTransmit{};
  shared_ptr<long> establishedTimeout{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<long> healthCheckConnectTimeout{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckType{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<long> persistenceTimeout{};
  shared_ptr<string> scheduler{};
  shared_ptr<long> unhealthyThreshold{};

  CreateLoadBalancerTCPListenerRequest() {}

  explicit CreateLoadBalancerTCPListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServerPort) {
      res["BackendServerPort"] = boost::any(*backendServerPort);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eipTransmit) {
      res["EipTransmit"] = boost::any(*eipTransmit);
    }
    if (establishedTimeout) {
      res["EstablishedTimeout"] = boost::any(*establishedTimeout);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckConnectTimeout) {
      res["HealthCheckConnectTimeout"] = boost::any(*healthCheckConnectTimeout);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckType) {
      res["HealthCheckType"] = boost::any(*healthCheckType);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (persistenceTimeout) {
      res["PersistenceTimeout"] = boost::any(*persistenceTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServerPort") != m.end() && !m["BackendServerPort"].empty()) {
      backendServerPort = make_shared<long>(boost::any_cast<long>(m["BackendServerPort"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EipTransmit") != m.end() && !m["EipTransmit"].empty()) {
      eipTransmit = make_shared<string>(boost::any_cast<string>(m["EipTransmit"]));
    }
    if (m.find("EstablishedTimeout") != m.end() && !m["EstablishedTimeout"].empty()) {
      establishedTimeout = make_shared<long>(boost::any_cast<long>(m["EstablishedTimeout"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckConnectTimeout") != m.end() && !m["HealthCheckConnectTimeout"].empty()) {
      healthCheckConnectTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectTimeout"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckType") != m.end() && !m["HealthCheckType"].empty()) {
      healthCheckType = make_shared<string>(boost::any_cast<string>(m["HealthCheckType"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("PersistenceTimeout") != m.end() && !m["PersistenceTimeout"].empty()) {
      persistenceTimeout = make_shared<long>(boost::any_cast<long>(m["PersistenceTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~CreateLoadBalancerTCPListenerRequest() = default;
};
class CreateLoadBalancerTCPListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateLoadBalancerTCPListenerResponseBody() {}

  explicit CreateLoadBalancerTCPListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLoadBalancerTCPListenerResponseBody() = default;
};
class CreateLoadBalancerTCPListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLoadBalancerTCPListenerResponseBody> body{};

  CreateLoadBalancerTCPListenerResponse() {}

  explicit CreateLoadBalancerTCPListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLoadBalancerTCPListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLoadBalancerTCPListenerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLoadBalancerTCPListenerResponse() = default;
};
class CreateLoadBalancerUDPListenerRequest : public Darabonba::Model {
public:
  shared_ptr<long> backendServerPort{};
  shared_ptr<string> description{};
  shared_ptr<string> eipTransmit{};
  shared_ptr<long> establishedTimeout{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<long> healthCheckConnectTimeout{};
  shared_ptr<string> healthCheckExp{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckReq{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> scheduler{};
  shared_ptr<long> unhealthyThreshold{};

  CreateLoadBalancerUDPListenerRequest() {}

  explicit CreateLoadBalancerUDPListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServerPort) {
      res["BackendServerPort"] = boost::any(*backendServerPort);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eipTransmit) {
      res["EipTransmit"] = boost::any(*eipTransmit);
    }
    if (establishedTimeout) {
      res["EstablishedTimeout"] = boost::any(*establishedTimeout);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckConnectTimeout) {
      res["HealthCheckConnectTimeout"] = boost::any(*healthCheckConnectTimeout);
    }
    if (healthCheckExp) {
      res["HealthCheckExp"] = boost::any(*healthCheckExp);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckReq) {
      res["HealthCheckReq"] = boost::any(*healthCheckReq);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServerPort") != m.end() && !m["BackendServerPort"].empty()) {
      backendServerPort = make_shared<long>(boost::any_cast<long>(m["BackendServerPort"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EipTransmit") != m.end() && !m["EipTransmit"].empty()) {
      eipTransmit = make_shared<string>(boost::any_cast<string>(m["EipTransmit"]));
    }
    if (m.find("EstablishedTimeout") != m.end() && !m["EstablishedTimeout"].empty()) {
      establishedTimeout = make_shared<long>(boost::any_cast<long>(m["EstablishedTimeout"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckConnectTimeout") != m.end() && !m["HealthCheckConnectTimeout"].empty()) {
      healthCheckConnectTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectTimeout"]));
    }
    if (m.find("HealthCheckExp") != m.end() && !m["HealthCheckExp"].empty()) {
      healthCheckExp = make_shared<string>(boost::any_cast<string>(m["HealthCheckExp"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckReq") != m.end() && !m["HealthCheckReq"].empty()) {
      healthCheckReq = make_shared<string>(boost::any_cast<string>(m["HealthCheckReq"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~CreateLoadBalancerUDPListenerRequest() = default;
};
class CreateLoadBalancerUDPListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateLoadBalancerUDPListenerResponseBody() {}

  explicit CreateLoadBalancerUDPListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLoadBalancerUDPListenerResponseBody() = default;
};
class CreateLoadBalancerUDPListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLoadBalancerUDPListenerResponseBody> body{};

  CreateLoadBalancerUDPListenerResponse() {}

  explicit CreateLoadBalancerUDPListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLoadBalancerUDPListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLoadBalancerUDPListenerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLoadBalancerUDPListenerResponse() = default;
};
class CreateMountTargetRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> fileSystemId{};
  shared_ptr<string> mountTargetName{};
  shared_ptr<string> netWorkId{};

  CreateMountTargetRequest() {}

  explicit CreateMountTargetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (fileSystemId) {
      res["FileSystemId"] = boost::any(*fileSystemId);
    }
    if (mountTargetName) {
      res["MountTargetName"] = boost::any(*mountTargetName);
    }
    if (netWorkId) {
      res["NetWorkId"] = boost::any(*netWorkId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("FileSystemId") != m.end() && !m["FileSystemId"].empty()) {
      fileSystemId = make_shared<string>(boost::any_cast<string>(m["FileSystemId"]));
    }
    if (m.find("MountTargetName") != m.end() && !m["MountTargetName"].empty()) {
      mountTargetName = make_shared<string>(boost::any_cast<string>(m["MountTargetName"]));
    }
    if (m.find("NetWorkId") != m.end() && !m["NetWorkId"].empty()) {
      netWorkId = make_shared<string>(boost::any_cast<string>(m["NetWorkId"]));
    }
  }


  virtual ~CreateMountTargetRequest() = default;
};
class CreateMountTargetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  CreateMountTargetResponseBody() {}

  explicit CreateMountTargetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~CreateMountTargetResponseBody() = default;
};
class CreateMountTargetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMountTargetResponseBody> body{};

  CreateMountTargetResponse() {}

  explicit CreateMountTargetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMountTargetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMountTargetResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMountTargetResponse() = default;
};
class CreateNatGatewayRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateNatGatewayRequestTag() {}

  explicit CreateNatGatewayRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateNatGatewayRequestTag() = default;
};
class CreateNatGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceBillingCycle{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> name{};
  shared_ptr<string> networkId{};
  shared_ptr<vector<CreateNatGatewayRequestTag>> tag{};
  shared_ptr<string> vSwitchId{};

  CreateNatGatewayRequest() {}

  explicit CreateNatGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceBillingCycle) {
      res["InstanceBillingCycle"] = boost::any(*instanceBillingCycle);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceBillingCycle") != m.end() && !m["InstanceBillingCycle"].empty()) {
      instanceBillingCycle = make_shared<string>(boost::any_cast<string>(m["InstanceBillingCycle"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateNatGatewayRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateNatGatewayRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateNatGatewayRequestTag>>(expect1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateNatGatewayRequest() = default;
};
class CreateNatGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> requestId{};

  CreateNatGatewayResponseBody() {}

  explicit CreateNatGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateNatGatewayResponseBody() = default;
};
class CreateNatGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNatGatewayResponseBody> body{};

  CreateNatGatewayResponse() {}

  explicit CreateNatGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNatGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNatGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNatGatewayResponse() = default;
};
class CreateNetworkRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateNetworkRequestTag() {}

  explicit CreateNetworkRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateNetworkRequestTag() = default;
};
class CreateNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> networkName{};
  shared_ptr<vector<CreateNetworkRequestTag>> tag{};

  CreateNetworkRequest() {}

  explicit CreateNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (networkName) {
      res["NetworkName"] = boost::any(*networkName);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("NetworkName") != m.end() && !m["NetworkName"].empty()) {
      networkName = make_shared<string>(boost::any_cast<string>(m["NetworkName"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateNetworkRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateNetworkRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateNetworkRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateNetworkRequest() = default;
};
class CreateNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> networkId{};
  shared_ptr<string> requestId{};

  CreateNetworkResponseBody() {}

  explicit CreateNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateNetworkResponseBody() = default;
};
class CreateNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNetworkResponseBody> body{};

  CreateNetworkResponse() {}

  explicit CreateNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNetworkResponse() = default;
};
class CreateNetworkAclRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> networkAclName{};

  CreateNetworkAclRequest() {}

  explicit CreateNetworkAclRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (networkAclName) {
      res["NetworkAclName"] = boost::any(*networkAclName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NetworkAclName") != m.end() && !m["NetworkAclName"].empty()) {
      networkAclName = make_shared<string>(boost::any_cast<string>(m["NetworkAclName"]));
    }
  }


  virtual ~CreateNetworkAclRequest() = default;
};
class CreateNetworkAclResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> networkAclId{};
  shared_ptr<string> requestId{};

  CreateNetworkAclResponseBody() {}

  explicit CreateNetworkAclResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateNetworkAclResponseBody() = default;
};
class CreateNetworkAclResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNetworkAclResponseBody> body{};

  CreateNetworkAclResponse() {}

  explicit CreateNetworkAclResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNetworkAclResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNetworkAclResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNetworkAclResponse() = default;
};
class CreateNetworkAclEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> description{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> direction{};
  shared_ptr<string> networkAclEntryName{};
  shared_ptr<string> networkAclId{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> protocol{};

  CreateNetworkAclEntryRequest() {}

  explicit CreateNetworkAclEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (networkAclEntryName) {
      res["NetworkAclEntryName"] = boost::any(*networkAclEntryName);
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("NetworkAclEntryName") != m.end() && !m["NetworkAclEntryName"].empty()) {
      networkAclEntryName = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryName"]));
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~CreateNetworkAclEntryRequest() = default;
};
class CreateNetworkAclEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> networkAclEntryId{};
  shared_ptr<string> requestId{};

  CreateNetworkAclEntryResponseBody() {}

  explicit CreateNetworkAclEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAclEntryId) {
      res["NetworkAclEntryId"] = boost::any(*networkAclEntryId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAclEntryId") != m.end() && !m["NetworkAclEntryId"].empty()) {
      networkAclEntryId = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateNetworkAclEntryResponseBody() = default;
};
class CreateNetworkAclEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNetworkAclEntryResponseBody> body{};

  CreateNetworkAclEntryResponse() {}

  explicit CreateNetworkAclEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNetworkAclEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNetworkAclEntryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNetworkAclEntryResponse() = default;
};
class CreateNetworkInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<string> vSwitchId{};

  CreateNetworkInterfaceRequest() {}

  explicit CreateNetworkInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateNetworkInterfaceRequest() = default;
};
class CreateNetworkInterfaceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> securityGroupIdsShrink{};
  shared_ptr<string> vSwitchId{};

  CreateNetworkInterfaceShrinkRequest() {}

  explicit CreateNetworkInterfaceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (securityGroupIdsShrink) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIdsShrink);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      securityGroupIdsShrink = make_shared<string>(boost::any_cast<string>(m["SecurityGroupIds"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateNetworkInterfaceShrinkRequest() = default;
};
class CreateNetworkInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> networkInterfaceIds{};
  shared_ptr<string> requestId{};

  CreateNetworkInterfaceResponseBody() {}

  explicit CreateNetworkInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceIds) {
      res["NetworkInterfaceIds"] = boost::any(*networkInterfaceIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceIds") != m.end() && !m["NetworkInterfaceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NetworkInterfaceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NetworkInterfaceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      networkInterfaceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateNetworkInterfaceResponseBody() = default;
};
class CreateNetworkInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNetworkInterfaceResponseBody> body{};

  CreateNetworkInterfaceResponse() {}

  explicit CreateNetworkInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNetworkInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNetworkInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNetworkInterfaceResponse() = default;
};
class CreateSDGRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> fromSDGId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> size{};

  CreateSDGRequest() {}

  explicit CreateSDGRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fromSDGId) {
      res["FromSDGId"] = boost::any(*fromSDGId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FromSDGId") != m.end() && !m["FromSDGId"].empty()) {
      fromSDGId = make_shared<string>(boost::any_cast<string>(m["FromSDGId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
  }


  virtual ~CreateSDGRequest() = default;
};
class CreateSDGResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> SDGId{};

  CreateSDGResponseBody() {}

  explicit CreateSDGResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~CreateSDGResponseBody() = default;
};
class CreateSDGResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSDGResponseBody> body{};

  CreateSDGResponse() {}

  explicit CreateSDGResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSDGResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSDGResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSDGResponse() = default;
};
class CreateSecurityGroupRequestPermissions : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> direction{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> sourcePortRange{};

  CreateSecurityGroupRequestPermissions() {}

  explicit CreateSecurityGroupRequestPermissions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
  }


  virtual ~CreateSecurityGroupRequestPermissions() = default;
};
class CreateSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<vector<CreateSecurityGroupRequestPermissions>> permissions{};
  shared_ptr<string> securityGroupName{};

  CreateSecurityGroupRequest() {}

  explicit CreateSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (permissions) {
      vector<boost::any> temp1;
      for(auto item1:*permissions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Permissions"] = boost::any(temp1);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Permissions") != m.end() && !m["Permissions"].empty()) {
      if (typeid(vector<boost::any>) == m["Permissions"].type()) {
        vector<CreateSecurityGroupRequestPermissions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Permissions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSecurityGroupRequestPermissions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        permissions = make_shared<vector<CreateSecurityGroupRequestPermissions>>(expect1);
      }
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
  }


  virtual ~CreateSecurityGroupRequest() = default;
};
class CreateSecurityGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> permissionsShrink{};
  shared_ptr<string> securityGroupName{};

  CreateSecurityGroupShrinkRequest() {}

  explicit CreateSecurityGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (permissionsShrink) {
      res["Permissions"] = boost::any(*permissionsShrink);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Permissions") != m.end() && !m["Permissions"].empty()) {
      permissionsShrink = make_shared<string>(boost::any_cast<string>(m["Permissions"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
  }


  virtual ~CreateSecurityGroupShrinkRequest() = default;
};
class CreateSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> securityGroupId{};

  CreateSecurityGroupResponseBody() {}

  explicit CreateSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~CreateSecurityGroupResponseBody() = default;
};
class CreateSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSecurityGroupResponseBody> body{};

  CreateSecurityGroupResponse() {}

  explicit CreateSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSecurityGroupResponse() = default;
};
class CreateSnapshotRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> diskId{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceBillingCycle{};
  shared_ptr<string> snapshotName{};

  CreateSnapshotRequest() {}

  explicit CreateSnapshotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceBillingCycle) {
      res["InstanceBillingCycle"] = boost::any(*instanceBillingCycle);
    }
    if (snapshotName) {
      res["SnapshotName"] = boost::any(*snapshotName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceBillingCycle") != m.end() && !m["InstanceBillingCycle"].empty()) {
      instanceBillingCycle = make_shared<string>(boost::any_cast<string>(m["InstanceBillingCycle"]));
    }
    if (m.find("SnapshotName") != m.end() && !m["SnapshotName"].empty()) {
      snapshotName = make_shared<string>(boost::any_cast<string>(m["SnapshotName"]));
    }
  }


  virtual ~CreateSnapshotRequest() = default;
};
class CreateSnapshotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> snapShotId{};

  CreateSnapshotResponseBody() {}

  explicit CreateSnapshotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapShotId) {
      res["SnapShotId"] = boost::any(*snapShotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnapShotId") != m.end() && !m["SnapShotId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SnapShotId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SnapShotId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      snapShotId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateSnapshotResponseBody() = default;
};
class CreateSnapshotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSnapshotResponseBody> body{};

  CreateSnapshotResponse() {}

  explicit CreateSnapshotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSnapshotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSnapshotResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSnapshotResponse() = default;
};
class CreateSnatEntryRequest : public Darabonba::Model {
public:
  shared_ptr<bool> eipAffinity{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<bool> ispAffinity{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> snatEntryName{};
  shared_ptr<string> snatIp{};
  shared_ptr<string> sourceCIDR{};
  shared_ptr<string> sourceNetworkId{};
  shared_ptr<string> sourceVSwitchId{};
  shared_ptr<string> standbySnatIp{};

  CreateSnatEntryRequest() {}

  explicit CreateSnatEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipAffinity) {
      res["EipAffinity"] = boost::any(*eipAffinity);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (ispAffinity) {
      res["IspAffinity"] = boost::any(*ispAffinity);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (snatEntryName) {
      res["SnatEntryName"] = boost::any(*snatEntryName);
    }
    if (snatIp) {
      res["SnatIp"] = boost::any(*snatIp);
    }
    if (sourceCIDR) {
      res["SourceCIDR"] = boost::any(*sourceCIDR);
    }
    if (sourceNetworkId) {
      res["SourceNetworkId"] = boost::any(*sourceNetworkId);
    }
    if (sourceVSwitchId) {
      res["SourceVSwitchId"] = boost::any(*sourceVSwitchId);
    }
    if (standbySnatIp) {
      res["StandbySnatIp"] = boost::any(*standbySnatIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipAffinity") != m.end() && !m["EipAffinity"].empty()) {
      eipAffinity = make_shared<bool>(boost::any_cast<bool>(m["EipAffinity"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("IspAffinity") != m.end() && !m["IspAffinity"].empty()) {
      ispAffinity = make_shared<bool>(boost::any_cast<bool>(m["IspAffinity"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("SnatEntryName") != m.end() && !m["SnatEntryName"].empty()) {
      snatEntryName = make_shared<string>(boost::any_cast<string>(m["SnatEntryName"]));
    }
    if (m.find("SnatIp") != m.end() && !m["SnatIp"].empty()) {
      snatIp = make_shared<string>(boost::any_cast<string>(m["SnatIp"]));
    }
    if (m.find("SourceCIDR") != m.end() && !m["SourceCIDR"].empty()) {
      sourceCIDR = make_shared<string>(boost::any_cast<string>(m["SourceCIDR"]));
    }
    if (m.find("SourceNetworkId") != m.end() && !m["SourceNetworkId"].empty()) {
      sourceNetworkId = make_shared<string>(boost::any_cast<string>(m["SourceNetworkId"]));
    }
    if (m.find("SourceVSwitchId") != m.end() && !m["SourceVSwitchId"].empty()) {
      sourceVSwitchId = make_shared<string>(boost::any_cast<string>(m["SourceVSwitchId"]));
    }
    if (m.find("StandbySnatIp") != m.end() && !m["StandbySnatIp"].empty()) {
      standbySnatIp = make_shared<string>(boost::any_cast<string>(m["StandbySnatIp"]));
    }
  }


  virtual ~CreateSnatEntryRequest() = default;
};
class CreateSnatEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> snatEntryId{};

  CreateSnatEntryResponseBody() {}

  explicit CreateSnatEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snatEntryId) {
      res["SnatEntryId"] = boost::any(*snatEntryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnatEntryId") != m.end() && !m["SnatEntryId"].empty()) {
      snatEntryId = make_shared<string>(boost::any_cast<string>(m["SnatEntryId"]));
    }
  }


  virtual ~CreateSnatEntryResponseBody() = default;
};
class CreateSnatEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSnatEntryResponseBody> body{};

  CreateSnatEntryResponse() {}

  explicit CreateSnatEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSnatEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSnatEntryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSnatEntryResponse() = default;
};
class CreateStorageGatewayRequestOrderDetails : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> gatewayName{};
  shared_ptr<string> gatewayType{};
  shared_ptr<string> vpcId{};

  CreateStorageGatewayRequestOrderDetails() {}

  explicit CreateStorageGatewayRequestOrderDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (gatewayName) {
      res["GatewayName"] = boost::any(*gatewayName);
    }
    if (gatewayType) {
      res["GatewayType"] = boost::any(*gatewayType);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("GatewayName") != m.end() && !m["GatewayName"].empty()) {
      gatewayName = make_shared<string>(boost::any_cast<string>(m["GatewayName"]));
    }
    if (m.find("GatewayType") != m.end() && !m["GatewayType"].empty()) {
      gatewayType = make_shared<string>(boost::any_cast<string>(m["GatewayType"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreateStorageGatewayRequestOrderDetails() = default;
};
class CreateStorageGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateStorageGatewayRequestOrderDetails>> orderDetails{};

  CreateStorageGatewayRequest() {}

  explicit CreateStorageGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderDetails) {
      vector<boost::any> temp1;
      for(auto item1:*orderDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OrderDetails"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderDetails") != m.end() && !m["OrderDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["OrderDetails"].type()) {
        vector<CreateStorageGatewayRequestOrderDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OrderDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateStorageGatewayRequestOrderDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        orderDetails = make_shared<vector<CreateStorageGatewayRequestOrderDetails>>(expect1);
      }
    }
  }


  virtual ~CreateStorageGatewayRequest() = default;
};
class CreateStorageGatewayShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> orderDetailsShrink{};

  CreateStorageGatewayShrinkRequest() {}

  explicit CreateStorageGatewayShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderDetailsShrink) {
      res["OrderDetails"] = boost::any(*orderDetailsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderDetails") != m.end() && !m["OrderDetails"].empty()) {
      orderDetailsShrink = make_shared<string>(boost::any_cast<string>(m["OrderDetails"]));
    }
  }


  virtual ~CreateStorageGatewayShrinkRequest() = default;
};
class CreateStorageGatewayResponseBodyAllocationId : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceId{};

  CreateStorageGatewayResponseBodyAllocationId() {}

  explicit CreateStorageGatewayResponseBodyAllocationId(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateStorageGatewayResponseBodyAllocationId() = default;
};
class CreateStorageGatewayResponseBodyUnAllocationId : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceId{};

  CreateStorageGatewayResponseBodyUnAllocationId() {}

  explicit CreateStorageGatewayResponseBodyUnAllocationId(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateStorageGatewayResponseBodyUnAllocationId() = default;
};
class CreateStorageGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<CreateStorageGatewayResponseBodyAllocationId>> allocationId{};
  shared_ptr<string> bizStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<CreateStorageGatewayResponseBodyUnAllocationId>> unAllocationId{};

  CreateStorageGatewayResponseBody() {}

  explicit CreateStorageGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      vector<boost::any> temp1;
      for(auto item1:*allocationId){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AllocationId"] = boost::any(temp1);
    }
    if (bizStatusCode) {
      res["BizStatusCode"] = boost::any(*bizStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (unAllocationId) {
      vector<boost::any> temp1;
      for(auto item1:*unAllocationId){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UnAllocationId"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      if (typeid(vector<boost::any>) == m["AllocationId"].type()) {
        vector<CreateStorageGatewayResponseBodyAllocationId> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AllocationId"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateStorageGatewayResponseBodyAllocationId model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        allocationId = make_shared<vector<CreateStorageGatewayResponseBodyAllocationId>>(expect1);
      }
    }
    if (m.find("BizStatusCode") != m.end() && !m["BizStatusCode"].empty()) {
      bizStatusCode = make_shared<string>(boost::any_cast<string>(m["BizStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UnAllocationId") != m.end() && !m["UnAllocationId"].empty()) {
      if (typeid(vector<boost::any>) == m["UnAllocationId"].type()) {
        vector<CreateStorageGatewayResponseBodyUnAllocationId> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UnAllocationId"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateStorageGatewayResponseBodyUnAllocationId model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        unAllocationId = make_shared<vector<CreateStorageGatewayResponseBodyUnAllocationId>>(expect1);
      }
    }
  }


  virtual ~CreateStorageGatewayResponseBody() = default;
};
class CreateStorageGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateStorageGatewayResponseBody> body{};

  CreateStorageGatewayResponse() {}

  explicit CreateStorageGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateStorageGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateStorageGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~CreateStorageGatewayResponse() = default;
};
class CreateStorageVolumeRequest : public Darabonba::Model {
public:
  shared_ptr<string> authPassword{};
  shared_ptr<string> authProtocol{};
  shared_ptr<string> authUser{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> gatewayId{};
  shared_ptr<string> isAuth{};
  shared_ptr<string> isEnable{};
  shared_ptr<string> storageId{};
  shared_ptr<string> volumeName{};

  CreateStorageVolumeRequest() {}

  explicit CreateStorageVolumeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authPassword) {
      res["AuthPassword"] = boost::any(*authPassword);
    }
    if (authProtocol) {
      res["AuthProtocol"] = boost::any(*authProtocol);
    }
    if (authUser) {
      res["AuthUser"] = boost::any(*authUser);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (isAuth) {
      res["IsAuth"] = boost::any(*isAuth);
    }
    if (isEnable) {
      res["IsEnable"] = boost::any(*isEnable);
    }
    if (storageId) {
      res["StorageId"] = boost::any(*storageId);
    }
    if (volumeName) {
      res["VolumeName"] = boost::any(*volumeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthPassword") != m.end() && !m["AuthPassword"].empty()) {
      authPassword = make_shared<string>(boost::any_cast<string>(m["AuthPassword"]));
    }
    if (m.find("AuthProtocol") != m.end() && !m["AuthProtocol"].empty()) {
      authProtocol = make_shared<string>(boost::any_cast<string>(m["AuthProtocol"]));
    }
    if (m.find("AuthUser") != m.end() && !m["AuthUser"].empty()) {
      authUser = make_shared<string>(boost::any_cast<string>(m["AuthUser"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<string>(boost::any_cast<string>(m["GatewayId"]));
    }
    if (m.find("IsAuth") != m.end() && !m["IsAuth"].empty()) {
      isAuth = make_shared<string>(boost::any_cast<string>(m["IsAuth"]));
    }
    if (m.find("IsEnable") != m.end() && !m["IsEnable"].empty()) {
      isEnable = make_shared<string>(boost::any_cast<string>(m["IsEnable"]));
    }
    if (m.find("StorageId") != m.end() && !m["StorageId"].empty()) {
      storageId = make_shared<string>(boost::any_cast<string>(m["StorageId"]));
    }
    if (m.find("VolumeName") != m.end() && !m["VolumeName"].empty()) {
      volumeName = make_shared<string>(boost::any_cast<string>(m["VolumeName"]));
    }
  }


  virtual ~CreateStorageVolumeRequest() = default;
};
class CreateStorageVolumeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> volumeId{};

  CreateStorageVolumeResponseBody() {}

  explicit CreateStorageVolumeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (volumeId) {
      res["VolumeId"] = boost::any(*volumeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VolumeId") != m.end() && !m["VolumeId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VolumeId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VolumeId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      volumeId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateStorageVolumeResponseBody() = default;
};
class CreateStorageVolumeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateStorageVolumeResponseBody> body{};

  CreateStorageVolumeResponse() {}

  explicit CreateStorageVolumeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateStorageVolumeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateStorageVolumeResponseBody>(model1);
      }
    }
  }


  virtual ~CreateStorageVolumeResponse() = default;
};
class CreateVSwitchRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateVSwitchRequestTag() {}

  explicit CreateVSwitchRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateVSwitchRequestTag() = default;
};
class CreateVSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> networkId{};
  shared_ptr<vector<CreateVSwitchRequestTag>> tag{};
  shared_ptr<string> vSwitchName{};

  CreateVSwitchRequest() {}

  explicit CreateVSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateVSwitchRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateVSwitchRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateVSwitchRequestTag>>(expect1);
      }
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
  }


  virtual ~CreateVSwitchRequest() = default;
};
class CreateVSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vSwitchId{};

  CreateVSwitchResponseBody() {}

  explicit CreateVSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateVSwitchResponseBody() = default;
};
class CreateVSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVSwitchResponseBody> body{};

  CreateVSwitchResponse() {}

  explicit CreateVSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVSwitchResponse() = default;
};
class DeleteApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> timeout{};

  DeleteApplicationRequest() {}

  explicit DeleteApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~DeleteApplicationRequest() = default;
};
class DeleteApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteApplicationResponseBody() {}

  explicit DeleteApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteApplicationResponseBody() = default;
};
class DeleteApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteApplicationResponseBody> body{};

  DeleteApplicationResponse() {}

  explicit DeleteApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApplicationResponse() = default;
};
class DeleteBucketRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucketName{};

  DeleteBucketRequest() {}

  explicit DeleteBucketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
  }


  virtual ~DeleteBucketRequest() = default;
};
class DeleteBucketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteBucketResponseBody() {}

  explicit DeleteBucketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBucketResponseBody() = default;
};
class DeleteBucketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBucketResponseBody> body{};

  DeleteBucketResponse() {}

  explicit DeleteBucketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBucketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBucketResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBucketResponse() = default;
};
class DeleteBucketLifecycleRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucketName{};
  shared_ptr<string> ruleId{};

  DeleteBucketLifecycleRequest() {}

  explicit DeleteBucketLifecycleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DeleteBucketLifecycleRequest() = default;
};
class DeleteBucketLifecycleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteBucketLifecycleResponseBody() {}

  explicit DeleteBucketLifecycleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBucketLifecycleResponseBody() = default;
};
class DeleteBucketLifecycleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBucketLifecycleResponseBody> body{};

  DeleteBucketLifecycleResponse() {}

  explicit DeleteBucketLifecycleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBucketLifecycleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBucketLifecycleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBucketLifecycleResponse() = default;
};
class DeleteDiskRequest : public Darabonba::Model {
public:
  shared_ptr<string> diskId{};

  DeleteDiskRequest() {}

  explicit DeleteDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
  }


  virtual ~DeleteDiskRequest() = default;
};
class DeleteDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  DeleteDiskResponseBody() {}

  explicit DeleteDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDiskResponseBody() = default;
};
class DeleteDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDiskResponseBody> body{};

  DeleteDiskResponse() {}

  explicit DeleteDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDiskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDiskResponse() = default;
};
class DeleteEipRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DeleteEipRequest() {}

  explicit DeleteEipRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteEipRequest() = default;
};
class DeleteEipResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEipResponseBody() {}

  explicit DeleteEipResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEipResponseBody() = default;
};
class DeleteEipResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEipResponseBody> body{};

  DeleteEipResponse() {}

  explicit DeleteEipResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEipResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEipResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEipResponse() = default;
};
class DeleteEnsRouteEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> routeEntryId{};

  DeleteEnsRouteEntryRequest() {}

  explicit DeleteEnsRouteEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeEntryId) {
      res["RouteEntryId"] = boost::any(*routeEntryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteEntryId") != m.end() && !m["RouteEntryId"].empty()) {
      routeEntryId = make_shared<string>(boost::any_cast<string>(m["RouteEntryId"]));
    }
  }


  virtual ~DeleteEnsRouteEntryRequest() = default;
};
class DeleteEnsRouteEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEnsRouteEntryResponseBody() {}

  explicit DeleteEnsRouteEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEnsRouteEntryResponseBody() = default;
};
class DeleteEnsRouteEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEnsRouteEntryResponseBody> body{};

  DeleteEnsRouteEntryResponse() {}

  explicit DeleteEnsRouteEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEnsRouteEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEnsRouteEntryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEnsRouteEntryResponse() = default;
};
class DeleteEnsSaleConditionControlRequestSaleControlsConditionControls : public Darabonba::Model {
public:
  shared_ptr<string> conditionControlModuleCode{};
  shared_ptr<string> conditionControlModuleValue{};

  DeleteEnsSaleConditionControlRequestSaleControlsConditionControls() {}

  explicit DeleteEnsSaleConditionControlRequestSaleControlsConditionControls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionControlModuleCode) {
      res["ConditionControlModuleCode"] = boost::any(*conditionControlModuleCode);
    }
    if (conditionControlModuleValue) {
      res["ConditionControlModuleValue"] = boost::any(*conditionControlModuleValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionControlModuleCode") != m.end() && !m["ConditionControlModuleCode"].empty()) {
      conditionControlModuleCode = make_shared<string>(boost::any_cast<string>(m["ConditionControlModuleCode"]));
    }
    if (m.find("ConditionControlModuleValue") != m.end() && !m["ConditionControlModuleValue"].empty()) {
      conditionControlModuleValue = make_shared<string>(boost::any_cast<string>(m["ConditionControlModuleValue"]));
    }
  }


  virtual ~DeleteEnsSaleConditionControlRequestSaleControlsConditionControls() = default;
};
class DeleteEnsSaleConditionControlRequestSaleControls : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteEnsSaleConditionControlRequestSaleControlsConditionControls>> conditionControls{};
  shared_ptr<string> moduleCode{};
  shared_ptr<string> orderType{};

  DeleteEnsSaleConditionControlRequestSaleControls() {}

  explicit DeleteEnsSaleConditionControlRequestSaleControls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionControls) {
      vector<boost::any> temp1;
      for(auto item1:*conditionControls){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConditionControls"] = boost::any(temp1);
    }
    if (moduleCode) {
      res["ModuleCode"] = boost::any(*moduleCode);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionControls") != m.end() && !m["ConditionControls"].empty()) {
      if (typeid(vector<boost::any>) == m["ConditionControls"].type()) {
        vector<DeleteEnsSaleConditionControlRequestSaleControlsConditionControls> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConditionControls"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteEnsSaleConditionControlRequestSaleControlsConditionControls model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditionControls = make_shared<vector<DeleteEnsSaleConditionControlRequestSaleControlsConditionControls>>(expect1);
      }
    }
    if (m.find("ModuleCode") != m.end() && !m["ModuleCode"].empty()) {
      moduleCode = make_shared<string>(boost::any_cast<string>(m["ModuleCode"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
  }


  virtual ~DeleteEnsSaleConditionControlRequestSaleControls() = default;
};
class DeleteEnsSaleConditionControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliUidAccount{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> customAccount{};
  shared_ptr<vector<DeleteEnsSaleConditionControlRequestSaleControls>> saleControls{};

  DeleteEnsSaleConditionControlRequest() {}

  explicit DeleteEnsSaleConditionControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUidAccount) {
      res["AliUidAccount"] = boost::any(*aliUidAccount);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (customAccount) {
      res["CustomAccount"] = boost::any(*customAccount);
    }
    if (saleControls) {
      vector<boost::any> temp1;
      for(auto item1:*saleControls){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SaleControls"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUidAccount") != m.end() && !m["AliUidAccount"].empty()) {
      aliUidAccount = make_shared<string>(boost::any_cast<string>(m["AliUidAccount"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CustomAccount") != m.end() && !m["CustomAccount"].empty()) {
      customAccount = make_shared<string>(boost::any_cast<string>(m["CustomAccount"]));
    }
    if (m.find("SaleControls") != m.end() && !m["SaleControls"].empty()) {
      if (typeid(vector<boost::any>) == m["SaleControls"].type()) {
        vector<DeleteEnsSaleConditionControlRequestSaleControls> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SaleControls"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteEnsSaleConditionControlRequestSaleControls model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        saleControls = make_shared<vector<DeleteEnsSaleConditionControlRequestSaleControls>>(expect1);
      }
    }
  }


  virtual ~DeleteEnsSaleConditionControlRequest() = default;
};
class DeleteEnsSaleConditionControlShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliUidAccount{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> customAccount{};
  shared_ptr<string> saleControlsShrink{};

  DeleteEnsSaleConditionControlShrinkRequest() {}

  explicit DeleteEnsSaleConditionControlShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUidAccount) {
      res["AliUidAccount"] = boost::any(*aliUidAccount);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (customAccount) {
      res["CustomAccount"] = boost::any(*customAccount);
    }
    if (saleControlsShrink) {
      res["SaleControls"] = boost::any(*saleControlsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUidAccount") != m.end() && !m["AliUidAccount"].empty()) {
      aliUidAccount = make_shared<string>(boost::any_cast<string>(m["AliUidAccount"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CustomAccount") != m.end() && !m["CustomAccount"].empty()) {
      customAccount = make_shared<string>(boost::any_cast<string>(m["CustomAccount"]));
    }
    if (m.find("SaleControls") != m.end() && !m["SaleControls"].empty()) {
      saleControlsShrink = make_shared<string>(boost::any_cast<string>(m["SaleControls"]));
    }
  }


  virtual ~DeleteEnsSaleConditionControlShrinkRequest() = default;
};
class DeleteEnsSaleConditionControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEnsSaleConditionControlResponseBody() {}

  explicit DeleteEnsSaleConditionControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEnsSaleConditionControlResponseBody() = default;
};
class DeleteEnsSaleConditionControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEnsSaleConditionControlResponseBody> body{};

  DeleteEnsSaleConditionControlResponse() {}

  explicit DeleteEnsSaleConditionControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEnsSaleConditionControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEnsSaleConditionControlResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEnsSaleConditionControlResponse() = default;
};
class DeleteEnsSaleControlRequestSaleControls : public Darabonba::Model {
public:
  shared_ptr<string> moduleCode{};
  shared_ptr<string> orderType{};

  DeleteEnsSaleControlRequestSaleControls() {}

  explicit DeleteEnsSaleControlRequestSaleControls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moduleCode) {
      res["ModuleCode"] = boost::any(*moduleCode);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModuleCode") != m.end() && !m["ModuleCode"].empty()) {
      moduleCode = make_shared<string>(boost::any_cast<string>(m["ModuleCode"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
  }


  virtual ~DeleteEnsSaleControlRequestSaleControls() = default;
};
class DeleteEnsSaleControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliUidAccount{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> customAccount{};
  shared_ptr<vector<DeleteEnsSaleControlRequestSaleControls>> saleControls{};

  DeleteEnsSaleControlRequest() {}

  explicit DeleteEnsSaleControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUidAccount) {
      res["AliUidAccount"] = boost::any(*aliUidAccount);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (customAccount) {
      res["CustomAccount"] = boost::any(*customAccount);
    }
    if (saleControls) {
      vector<boost::any> temp1;
      for(auto item1:*saleControls){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SaleControls"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUidAccount") != m.end() && !m["AliUidAccount"].empty()) {
      aliUidAccount = make_shared<string>(boost::any_cast<string>(m["AliUidAccount"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CustomAccount") != m.end() && !m["CustomAccount"].empty()) {
      customAccount = make_shared<string>(boost::any_cast<string>(m["CustomAccount"]));
    }
    if (m.find("SaleControls") != m.end() && !m["SaleControls"].empty()) {
      if (typeid(vector<boost::any>) == m["SaleControls"].type()) {
        vector<DeleteEnsSaleControlRequestSaleControls> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SaleControls"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteEnsSaleControlRequestSaleControls model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        saleControls = make_shared<vector<DeleteEnsSaleControlRequestSaleControls>>(expect1);
      }
    }
  }


  virtual ~DeleteEnsSaleControlRequest() = default;
};
class DeleteEnsSaleControlShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliUidAccount{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> customAccount{};
  shared_ptr<string> saleControlsShrink{};

  DeleteEnsSaleControlShrinkRequest() {}

  explicit DeleteEnsSaleControlShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUidAccount) {
      res["AliUidAccount"] = boost::any(*aliUidAccount);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (customAccount) {
      res["CustomAccount"] = boost::any(*customAccount);
    }
    if (saleControlsShrink) {
      res["SaleControls"] = boost::any(*saleControlsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUidAccount") != m.end() && !m["AliUidAccount"].empty()) {
      aliUidAccount = make_shared<string>(boost::any_cast<string>(m["AliUidAccount"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CustomAccount") != m.end() && !m["CustomAccount"].empty()) {
      customAccount = make_shared<string>(boost::any_cast<string>(m["CustomAccount"]));
    }
    if (m.find("SaleControls") != m.end() && !m["SaleControls"].empty()) {
      saleControlsShrink = make_shared<string>(boost::any_cast<string>(m["SaleControls"]));
    }
  }


  virtual ~DeleteEnsSaleControlShrinkRequest() = default;
};
class DeleteEnsSaleControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEnsSaleControlResponseBody() {}

  explicit DeleteEnsSaleControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEnsSaleControlResponseBody() = default;
};
class DeleteEnsSaleControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEnsSaleControlResponseBody> body{};

  DeleteEnsSaleControlResponse() {}

  explicit DeleteEnsSaleControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEnsSaleControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEnsSaleControlResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEnsSaleControlResponse() = default;
};
class DeleteEpnInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};

  DeleteEpnInstanceRequest() {}

  explicit DeleteEpnInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
  }


  virtual ~DeleteEpnInstanceRequest() = default;
};
class DeleteEpnInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEpnInstanceResponseBody() {}

  explicit DeleteEpnInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEpnInstanceResponseBody() = default;
};
class DeleteEpnInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEpnInstanceResponseBody> body{};

  DeleteEpnInstanceResponse() {}

  explicit DeleteEpnInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEpnInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEpnInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEpnInstanceResponse() = default;
};
class DeleteFileSystemRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> fileSystemId{};

  DeleteFileSystemRequest() {}

  explicit DeleteFileSystemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (fileSystemId) {
      res["FileSystemId"] = boost::any(*fileSystemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("FileSystemId") != m.end() && !m["FileSystemId"].empty()) {
      fileSystemId = make_shared<string>(boost::any_cast<string>(m["FileSystemId"]));
    }
  }


  virtual ~DeleteFileSystemRequest() = default;
};
class DeleteFileSystemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteFileSystemResponseBody() {}

  explicit DeleteFileSystemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFileSystemResponseBody() = default;
};
class DeleteFileSystemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFileSystemResponseBody> body{};

  DeleteFileSystemResponse() {}

  explicit DeleteFileSystemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFileSystemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFileSystemResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFileSystemResponse() = default;
};
class DeleteForwardEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> forwardEntryId{};

  DeleteForwardEntryRequest() {}

  explicit DeleteForwardEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardEntryId) {
      res["ForwardEntryId"] = boost::any(*forwardEntryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardEntryId") != m.end() && !m["ForwardEntryId"].empty()) {
      forwardEntryId = make_shared<string>(boost::any_cast<string>(m["ForwardEntryId"]));
    }
  }


  virtual ~DeleteForwardEntryRequest() = default;
};
class DeleteForwardEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteForwardEntryResponseBody() {}

  explicit DeleteForwardEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteForwardEntryResponseBody() = default;
};
class DeleteForwardEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteForwardEntryResponseBody> body{};

  DeleteForwardEntryResponse() {}

  explicit DeleteForwardEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteForwardEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteForwardEntryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteForwardEntryResponse() = default;
};
class DeleteHaVipsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> haVipIds{};

  DeleteHaVipsRequest() {}

  explicit DeleteHaVipsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (haVipIds) {
      res["HaVipIds"] = boost::any(*haVipIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HaVipIds") != m.end() && !m["HaVipIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HaVipIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HaVipIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      haVipIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteHaVipsRequest() = default;
};
class DeleteHaVipsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> haVipIdsShrink{};

  DeleteHaVipsShrinkRequest() {}

  explicit DeleteHaVipsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (haVipIdsShrink) {
      res["HaVipIds"] = boost::any(*haVipIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HaVipIds") != m.end() && !m["HaVipIds"].empty()) {
      haVipIdsShrink = make_shared<string>(boost::any_cast<string>(m["HaVipIds"]));
    }
  }


  virtual ~DeleteHaVipsShrinkRequest() = default;
};
class DeleteHaVipsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteHaVipsResponseBody() {}

  explicit DeleteHaVipsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteHaVipsResponseBody() = default;
};
class DeleteHaVipsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteHaVipsResponseBody> body{};

  DeleteHaVipsResponse() {}

  explicit DeleteHaVipsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHaVipsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHaVipsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHaVipsResponse() = default;
};
class DeleteImageRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};

  DeleteImageRequest() {}

  explicit DeleteImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
  }


  virtual ~DeleteImageRequest() = default;
};
class DeleteImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  DeleteImageResponseBody() {}

  explicit DeleteImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteImageResponseBody() = default;
};
class DeleteImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteImageResponseBody> body{};

  DeleteImageResponse() {}

  explicit DeleteImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteImageResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteImageResponse() = default;
};
class DeleteKeyPairsRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyPairId{};
  shared_ptr<string> keyPairName{};

  DeleteKeyPairsRequest() {}

  explicit DeleteKeyPairsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPairId) {
      res["KeyPairId"] = boost::any(*keyPairId);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPairId") != m.end() && !m["KeyPairId"].empty()) {
      keyPairId = make_shared<string>(boost::any_cast<string>(m["KeyPairId"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
  }


  virtual ~DeleteKeyPairsRequest() = default;
};
class DeleteKeyPairsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteKeyPairsResponseBody() {}

  explicit DeleteKeyPairsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteKeyPairsResponseBody() = default;
};
class DeleteKeyPairsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteKeyPairsResponseBody> body{};

  DeleteKeyPairsResponse() {}

  explicit DeleteKeyPairsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteKeyPairsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteKeyPairsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteKeyPairsResponse() = default;
};
class DeleteLoadBalancerListenerRequest : public Darabonba::Model {
public:
  shared_ptr<long> listenerPort{};
  shared_ptr<string> listenerProtocol{};
  shared_ptr<string> loadBalancerId{};

  DeleteLoadBalancerListenerRequest() {}

  explicit DeleteLoadBalancerListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (listenerProtocol) {
      res["ListenerProtocol"] = boost::any(*listenerProtocol);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("ListenerProtocol") != m.end() && !m["ListenerProtocol"].empty()) {
      listenerProtocol = make_shared<string>(boost::any_cast<string>(m["ListenerProtocol"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~DeleteLoadBalancerListenerRequest() = default;
};
class DeleteLoadBalancerListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLoadBalancerListenerResponseBody() {}

  explicit DeleteLoadBalancerListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLoadBalancerListenerResponseBody() = default;
};
class DeleteLoadBalancerListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLoadBalancerListenerResponseBody> body{};

  DeleteLoadBalancerListenerResponse() {}

  explicit DeleteLoadBalancerListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLoadBalancerListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLoadBalancerListenerResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLoadBalancerListenerResponse() = default;
};
class DeleteMountTargetRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> fileSystemId{};
  shared_ptr<string> mountTargetName{};

  DeleteMountTargetRequest() {}

  explicit DeleteMountTargetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (fileSystemId) {
      res["FileSystemId"] = boost::any(*fileSystemId);
    }
    if (mountTargetName) {
      res["MountTargetName"] = boost::any(*mountTargetName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("FileSystemId") != m.end() && !m["FileSystemId"].empty()) {
      fileSystemId = make_shared<string>(boost::any_cast<string>(m["FileSystemId"]));
    }
    if (m.find("MountTargetName") != m.end() && !m["MountTargetName"].empty()) {
      mountTargetName = make_shared<string>(boost::any_cast<string>(m["MountTargetName"]));
    }
  }


  virtual ~DeleteMountTargetRequest() = default;
};
class DeleteMountTargetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteMountTargetResponseBody() {}

  explicit DeleteMountTargetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMountTargetResponseBody() = default;
};
class DeleteMountTargetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMountTargetResponseBody> body{};

  DeleteMountTargetResponse() {}

  explicit DeleteMountTargetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMountTargetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMountTargetResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMountTargetResponse() = default;
};
class DeleteNatGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<bool> forceDelete{};
  shared_ptr<string> natGatewayId{};

  DeleteNatGatewayRequest() {}

  explicit DeleteNatGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forceDelete) {
      res["ForceDelete"] = boost::any(*forceDelete);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForceDelete") != m.end() && !m["ForceDelete"].empty()) {
      forceDelete = make_shared<bool>(boost::any_cast<bool>(m["ForceDelete"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
  }


  virtual ~DeleteNatGatewayRequest() = default;
};
class DeleteNatGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNatGatewayResponseBody() {}

  explicit DeleteNatGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNatGatewayResponseBody() = default;
};
class DeleteNatGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNatGatewayResponseBody> body{};

  DeleteNatGatewayResponse() {}

  explicit DeleteNatGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNatGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNatGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNatGatewayResponse() = default;
};
class DeleteNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkId{};

  DeleteNetworkRequest() {}

  explicit DeleteNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
  }


  virtual ~DeleteNetworkRequest() = default;
};
class DeleteNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNetworkResponseBody() {}

  explicit DeleteNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNetworkResponseBody() = default;
};
class DeleteNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNetworkResponseBody> body{};

  DeleteNetworkResponse() {}

  explicit DeleteNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNetworkResponse() = default;
};
class DeleteNetworkAclRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkAclId{};

  DeleteNetworkAclRequest() {}

  explicit DeleteNetworkAclRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
  }


  virtual ~DeleteNetworkAclRequest() = default;
};
class DeleteNetworkAclResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNetworkAclResponseBody() {}

  explicit DeleteNetworkAclResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNetworkAclResponseBody() = default;
};
class DeleteNetworkAclResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNetworkAclResponseBody> body{};

  DeleteNetworkAclResponse() {}

  explicit DeleteNetworkAclResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNetworkAclResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNetworkAclResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNetworkAclResponse() = default;
};
class DeleteNetworkAclEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkAclEntryId{};

  DeleteNetworkAclEntryRequest() {}

  explicit DeleteNetworkAclEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAclEntryId) {
      res["NetworkAclEntryId"] = boost::any(*networkAclEntryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAclEntryId") != m.end() && !m["NetworkAclEntryId"].empty()) {
      networkAclEntryId = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryId"]));
    }
  }


  virtual ~DeleteNetworkAclEntryRequest() = default;
};
class DeleteNetworkAclEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNetworkAclEntryResponseBody() {}

  explicit DeleteNetworkAclEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNetworkAclEntryResponseBody() = default;
};
class DeleteNetworkAclEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNetworkAclEntryResponseBody> body{};

  DeleteNetworkAclEntryResponse() {}

  explicit DeleteNetworkAclEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNetworkAclEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNetworkAclEntryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNetworkAclEntryResponse() = default;
};
class DeleteNetworkInterfacesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> networkInterfaceIds{};

  DeleteNetworkInterfacesRequest() {}

  explicit DeleteNetworkInterfacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceIds) {
      res["NetworkInterfaceIds"] = boost::any(*networkInterfaceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceIds") != m.end() && !m["NetworkInterfaceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NetworkInterfaceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NetworkInterfaceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      networkInterfaceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteNetworkInterfacesRequest() = default;
};
class DeleteNetworkInterfacesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkInterfaceIdsShrink{};

  DeleteNetworkInterfacesShrinkRequest() {}

  explicit DeleteNetworkInterfacesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceIdsShrink) {
      res["NetworkInterfaceIds"] = boost::any(*networkInterfaceIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceIds") != m.end() && !m["NetworkInterfaceIds"].empty()) {
      networkInterfaceIdsShrink = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceIds"]));
    }
  }


  virtual ~DeleteNetworkInterfacesShrinkRequest() = default;
};
class DeleteNetworkInterfacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNetworkInterfacesResponseBody() {}

  explicit DeleteNetworkInterfacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNetworkInterfacesResponseBody() = default;
};
class DeleteNetworkInterfacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNetworkInterfacesResponseBody> body{};

  DeleteNetworkInterfacesResponse() {}

  explicit DeleteNetworkInterfacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNetworkInterfacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNetworkInterfacesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNetworkInterfacesResponse() = default;
};
class DeleteObjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucketName{};
  shared_ptr<string> objectKey{};

  DeleteObjectRequest() {}

  explicit DeleteObjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (objectKey) {
      res["ObjectKey"] = boost::any(*objectKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("ObjectKey") != m.end() && !m["ObjectKey"].empty()) {
      objectKey = make_shared<string>(boost::any_cast<string>(m["ObjectKey"]));
    }
  }


  virtual ~DeleteObjectRequest() = default;
};
class DeleteObjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteObjectResponseBody() {}

  explicit DeleteObjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteObjectResponseBody() = default;
};
class DeleteObjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteObjectResponseBody> body{};

  DeleteObjectResponse() {}

  explicit DeleteObjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteObjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteObjectResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteObjectResponse() = default;
};
class DeleteSDGRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> SDGId{};

  DeleteSDGRequest() {}

  explicit DeleteSDGRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SDGId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SDGId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      SDGId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteSDGRequest() = default;
};
class DeleteSDGShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> SDGIdShrink{};

  DeleteSDGShrinkRequest() {}

  explicit DeleteSDGShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SDGIdShrink) {
      res["SDGId"] = boost::any(*SDGIdShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGIdShrink = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~DeleteSDGShrinkRequest() = default;
};
class DeleteSDGResponseBodyDataResultFailedItemsItem : public Darabonba::Model {
public:
  shared_ptr<string> sdgId{};

  DeleteSDGResponseBodyDataResultFailedItemsItem() {}

  explicit DeleteSDGResponseBodyDataResultFailedItemsItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sdgId) {
      res["SdgId"] = boost::any(*sdgId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SdgId") != m.end() && !m["SdgId"].empty()) {
      sdgId = make_shared<string>(boost::any_cast<string>(m["SdgId"]));
    }
  }


  virtual ~DeleteSDGResponseBodyDataResultFailedItemsItem() = default;
};
class DeleteSDGResponseBodyDataResultFailedItems : public Darabonba::Model {
public:
  shared_ptr<string> errMessage{};
  shared_ptr<DeleteSDGResponseBodyDataResultFailedItemsItem> item{};

  DeleteSDGResponseBodyDataResultFailedItems() {}

  explicit DeleteSDGResponseBodyDataResultFailedItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (item) {
      res["Item"] = item ? boost::any(item->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(map<string, boost::any>) == m["Item"].type()) {
        DeleteSDGResponseBodyDataResultFailedItemsItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Item"]));
        item = make_shared<DeleteSDGResponseBodyDataResultFailedItemsItem>(model1);
      }
    }
  }


  virtual ~DeleteSDGResponseBodyDataResultFailedItems() = default;
};
class DeleteSDGResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<long> failedCount{};
  shared_ptr<vector<DeleteSDGResponseBodyDataResultFailedItems>> failedItems{};
  shared_ptr<long> successCount{};

  DeleteSDGResponseBodyDataResult() {}

  explicit DeleteSDGResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedCount) {
      res["FailedCount"] = boost::any(*failedCount);
    }
    if (failedItems) {
      vector<boost::any> temp1;
      for(auto item1:*failedItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedItems"] = boost::any(temp1);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedCount") != m.end() && !m["FailedCount"].empty()) {
      failedCount = make_shared<long>(boost::any_cast<long>(m["FailedCount"]));
    }
    if (m.find("FailedItems") != m.end() && !m["FailedItems"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedItems"].type()) {
        vector<DeleteSDGResponseBodyDataResultFailedItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteSDGResponseBodyDataResultFailedItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedItems = make_shared<vector<DeleteSDGResponseBodyDataResultFailedItems>>(expect1);
      }
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
  }


  virtual ~DeleteSDGResponseBodyDataResult() = default;
};
class DeleteSDGResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<DeleteSDGResponseBodyDataResult> result{};
  shared_ptr<bool> success{};

  DeleteSDGResponseBodyData() {}

  explicit DeleteSDGResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DeleteSDGResponseBodyDataResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DeleteSDGResponseBodyDataResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteSDGResponseBodyData() = default;
};
class DeleteSDGResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeleteSDGResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DeleteSDGResponseBody() {}

  explicit DeleteSDGResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteSDGResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteSDGResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSDGResponseBody() = default;
};
class DeleteSDGResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSDGResponseBody> body{};

  DeleteSDGResponse() {}

  explicit DeleteSDGResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSDGResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSDGResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSDGResponse() = default;
};
class DeleteSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityGroupId{};

  DeleteSecurityGroupRequest() {}

  explicit DeleteSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~DeleteSecurityGroupRequest() = default;
};
class DeleteSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSecurityGroupResponseBody() {}

  explicit DeleteSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSecurityGroupResponseBody() = default;
};
class DeleteSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSecurityGroupResponseBody> body{};

  DeleteSecurityGroupResponse() {}

  explicit DeleteSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSecurityGroupResponse() = default;
};
class DeleteSnapshotRequest : public Darabonba::Model {
public:
  shared_ptr<string> snapshotId{};

  DeleteSnapshotRequest() {}

  explicit DeleteSnapshotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
  }


  virtual ~DeleteSnapshotRequest() = default;
};
class DeleteSnapshotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSnapshotResponseBody() {}

  explicit DeleteSnapshotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSnapshotResponseBody() = default;
};
class DeleteSnapshotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSnapshotResponseBody> body{};

  DeleteSnapshotResponse() {}

  explicit DeleteSnapshotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSnapshotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSnapshotResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSnapshotResponse() = default;
};
class DeleteSnatEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> snatEntryId{};

  DeleteSnatEntryRequest() {}

  explicit DeleteSnatEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snatEntryId) {
      res["SnatEntryId"] = boost::any(*snatEntryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnatEntryId") != m.end() && !m["SnatEntryId"].empty()) {
      snatEntryId = make_shared<string>(boost::any_cast<string>(m["SnatEntryId"]));
    }
  }


  virtual ~DeleteSnatEntryRequest() = default;
};
class DeleteSnatEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSnatEntryResponseBody() {}

  explicit DeleteSnatEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSnatEntryResponseBody() = default;
};
class DeleteSnatEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSnatEntryResponseBody> body{};

  DeleteSnatEntryResponse() {}

  explicit DeleteSnatEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSnatEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSnatEntryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSnatEntryResponse() = default;
};
class DeleteSnatIpForSnatEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> snatEntryId{};
  shared_ptr<string> snatIp{};

  DeleteSnatIpForSnatEntryRequest() {}

  explicit DeleteSnatIpForSnatEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snatEntryId) {
      res["SnatEntryId"] = boost::any(*snatEntryId);
    }
    if (snatIp) {
      res["SnatIp"] = boost::any(*snatIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnatEntryId") != m.end() && !m["SnatEntryId"].empty()) {
      snatEntryId = make_shared<string>(boost::any_cast<string>(m["SnatEntryId"]));
    }
    if (m.find("SnatIp") != m.end() && !m["SnatIp"].empty()) {
      snatIp = make_shared<string>(boost::any_cast<string>(m["SnatIp"]));
    }
  }


  virtual ~DeleteSnatIpForSnatEntryRequest() = default;
};
class DeleteSnatIpForSnatEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSnatIpForSnatEntryResponseBody() {}

  explicit DeleteSnatIpForSnatEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSnatIpForSnatEntryResponseBody() = default;
};
class DeleteSnatIpForSnatEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSnatIpForSnatEntryResponseBody> body{};

  DeleteSnatIpForSnatEntryResponse() {}

  explicit DeleteSnatIpForSnatEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSnatIpForSnatEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSnatIpForSnatEntryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSnatIpForSnatEntryResponse() = default;
};
class DeleteStorageGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> gatewayId{};

  DeleteStorageGatewayRequest() {}

  explicit DeleteStorageGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<string>(boost::any_cast<string>(m["GatewayId"]));
    }
  }


  virtual ~DeleteStorageGatewayRequest() = default;
};
class DeleteStorageGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteStorageGatewayResponseBody() {}

  explicit DeleteStorageGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteStorageGatewayResponseBody() = default;
};
class DeleteStorageGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteStorageGatewayResponseBody> body{};

  DeleteStorageGatewayResponse() {}

  explicit DeleteStorageGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteStorageGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteStorageGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteStorageGatewayResponse() = default;
};
class DeleteStorageVolumeRequest : public Darabonba::Model {
public:
  shared_ptr<string> volumeId{};

  DeleteStorageVolumeRequest() {}

  explicit DeleteStorageVolumeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (volumeId) {
      res["VolumeId"] = boost::any(*volumeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VolumeId") != m.end() && !m["VolumeId"].empty()) {
      volumeId = make_shared<string>(boost::any_cast<string>(m["VolumeId"]));
    }
  }


  virtual ~DeleteStorageVolumeRequest() = default;
};
class DeleteStorageVolumeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteStorageVolumeResponseBody() {}

  explicit DeleteStorageVolumeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteStorageVolumeResponseBody() = default;
};
class DeleteStorageVolumeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteStorageVolumeResponseBody> body{};

  DeleteStorageVolumeResponse() {}

  explicit DeleteStorageVolumeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteStorageVolumeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteStorageVolumeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteStorageVolumeResponse() = default;
};
class DeleteVSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<string> vSwitchId{};

  DeleteVSwitchRequest() {}

  explicit DeleteVSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DeleteVSwitchRequest() = default;
};
class DeleteVSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVSwitchResponseBody() {}

  explicit DeleteVSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVSwitchResponseBody() = default;
};
class DeleteVSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVSwitchResponseBody> body{};

  DeleteVSwitchResponse() {}

  explicit DeleteVSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVSwitchResponse() = default;
};
class DeployInstanceSDGRequest : public Darabonba::Model {
public:
  shared_ptr<string> deploymentType{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> SDGId{};

  DeployInstanceSDGRequest() {}

  explicit DeployInstanceSDGRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deploymentType) {
      res["DeploymentType"] = boost::any(*deploymentType);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeploymentType") != m.end() && !m["DeploymentType"].empty()) {
      deploymentType = make_shared<string>(boost::any_cast<string>(m["DeploymentType"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~DeployInstanceSDGRequest() = default;
};
class DeployInstanceSDGShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> deploymentType{};
  shared_ptr<string> instanceIdsShrink{};
  shared_ptr<string> SDGId{};

  DeployInstanceSDGShrinkRequest() {}

  explicit DeployInstanceSDGShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deploymentType) {
      res["DeploymentType"] = boost::any(*deploymentType);
    }
    if (instanceIdsShrink) {
      res["InstanceIds"] = boost::any(*instanceIdsShrink);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeploymentType") != m.end() && !m["DeploymentType"].empty()) {
      deploymentType = make_shared<string>(boost::any_cast<string>(m["DeploymentType"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~DeployInstanceSDGShrinkRequest() = default;
};
class DeployInstanceSDGResponseBodyDataResultFailedItems : public Darabonba::Model {
public:
  shared_ptr<string> errMessage{};
  shared_ptr<string> instanceId{};

  DeployInstanceSDGResponseBodyDataResultFailedItems() {}

  explicit DeployInstanceSDGResponseBodyDataResultFailedItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeployInstanceSDGResponseBodyDataResultFailedItems() = default;
};
class DeployInstanceSDGResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<long> failedCount{};
  shared_ptr<vector<DeployInstanceSDGResponseBodyDataResultFailedItems>> failedItems{};
  shared_ptr<long> successCount{};

  DeployInstanceSDGResponseBodyDataResult() {}

  explicit DeployInstanceSDGResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedCount) {
      res["FailedCount"] = boost::any(*failedCount);
    }
    if (failedItems) {
      vector<boost::any> temp1;
      for(auto item1:*failedItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedItems"] = boost::any(temp1);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedCount") != m.end() && !m["FailedCount"].empty()) {
      failedCount = make_shared<long>(boost::any_cast<long>(m["FailedCount"]));
    }
    if (m.find("FailedItems") != m.end() && !m["FailedItems"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedItems"].type()) {
        vector<DeployInstanceSDGResponseBodyDataResultFailedItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeployInstanceSDGResponseBodyDataResultFailedItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedItems = make_shared<vector<DeployInstanceSDGResponseBodyDataResultFailedItems>>(expect1);
      }
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
  }


  virtual ~DeployInstanceSDGResponseBodyDataResult() = default;
};
class DeployInstanceSDGResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<DeployInstanceSDGResponseBodyDataResult> result{};
  shared_ptr<bool> success{};

  DeployInstanceSDGResponseBodyData() {}

  explicit DeployInstanceSDGResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DeployInstanceSDGResponseBodyDataResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DeployInstanceSDGResponseBodyDataResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeployInstanceSDGResponseBodyData() = default;
};
class DeployInstanceSDGResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeployInstanceSDGResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DeployInstanceSDGResponseBody() {}

  explicit DeployInstanceSDGResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeployInstanceSDGResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeployInstanceSDGResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeployInstanceSDGResponseBody() = default;
};
class DeployInstanceSDGResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeployInstanceSDGResponseBody> body{};

  DeployInstanceSDGResponse() {}

  explicit DeployInstanceSDGResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeployInstanceSDGResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeployInstanceSDGResponseBody>(model1);
      }
    }
  }


  virtual ~DeployInstanceSDGResponse() = default;
};
class DeploySDGRequest : public Darabonba::Model {
public:
  shared_ptr<string> deploymentType{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> SDGId{};

  DeploySDGRequest() {}

  explicit DeploySDGRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deploymentType) {
      res["DeploymentType"] = boost::any(*deploymentType);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeploymentType") != m.end() && !m["DeploymentType"].empty()) {
      deploymentType = make_shared<string>(boost::any_cast<string>(m["DeploymentType"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~DeploySDGRequest() = default;
};
class DeploySDGShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> deploymentType{};
  shared_ptr<string> instanceIdsShrink{};
  shared_ptr<string> SDGId{};

  DeploySDGShrinkRequest() {}

  explicit DeploySDGShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deploymentType) {
      res["DeploymentType"] = boost::any(*deploymentType);
    }
    if (instanceIdsShrink) {
      res["InstanceIds"] = boost::any(*instanceIdsShrink);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeploymentType") != m.end() && !m["DeploymentType"].empty()) {
      deploymentType = make_shared<string>(boost::any_cast<string>(m["DeploymentType"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~DeploySDGShrinkRequest() = default;
};
class DeploySDGResponseBodyDataResultFailedItems : public Darabonba::Model {
public:
  shared_ptr<string> errMessage{};
  shared_ptr<string> instanceId{};

  DeploySDGResponseBodyDataResultFailedItems() {}

  explicit DeploySDGResponseBodyDataResultFailedItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeploySDGResponseBodyDataResultFailedItems() = default;
};
class DeploySDGResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<long> failedCount{};
  shared_ptr<vector<DeploySDGResponseBodyDataResultFailedItems>> failedItems{};
  shared_ptr<long> successCount{};

  DeploySDGResponseBodyDataResult() {}

  explicit DeploySDGResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedCount) {
      res["FailedCount"] = boost::any(*failedCount);
    }
    if (failedItems) {
      vector<boost::any> temp1;
      for(auto item1:*failedItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedItems"] = boost::any(temp1);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedCount") != m.end() && !m["FailedCount"].empty()) {
      failedCount = make_shared<long>(boost::any_cast<long>(m["FailedCount"]));
    }
    if (m.find("FailedItems") != m.end() && !m["FailedItems"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedItems"].type()) {
        vector<DeploySDGResponseBodyDataResultFailedItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeploySDGResponseBodyDataResultFailedItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedItems = make_shared<vector<DeploySDGResponseBodyDataResultFailedItems>>(expect1);
      }
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
  }


  virtual ~DeploySDGResponseBodyDataResult() = default;
};
class DeploySDGResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<DeploySDGResponseBodyDataResult> result{};
  shared_ptr<bool> success{};

  DeploySDGResponseBodyData() {}

  explicit DeploySDGResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DeploySDGResponseBodyDataResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DeploySDGResponseBodyDataResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeploySDGResponseBodyData() = default;
};
class DeploySDGResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeploySDGResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DeploySDGResponseBody() {}

  explicit DeploySDGResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeploySDGResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeploySDGResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeploySDGResponseBody() = default;
};
class DeploySDGResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeploySDGResponseBody> body{};

  DeploySDGResponse() {}

  explicit DeploySDGResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeploySDGResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeploySDGResponseBody>(model1);
      }
    }
  }


  virtual ~DeploySDGResponse() = default;
};
class DescribeAICImagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageType{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> maxDate{};
  shared_ptr<string> minDate{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> status{};

  DescribeAICImagesRequest() {}

  explicit DescribeAICImagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageType) {
      res["ImageType"] = boost::any(*imageType);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (maxDate) {
      res["MaxDate"] = boost::any(*maxDate);
    }
    if (minDate) {
      res["MinDate"] = boost::any(*minDate);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageType") != m.end() && !m["ImageType"].empty()) {
      imageType = make_shared<string>(boost::any_cast<string>(m["ImageType"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("MaxDate") != m.end() && !m["MaxDate"].empty()) {
      maxDate = make_shared<string>(boost::any_cast<string>(m["MaxDate"]));
    }
    if (m.find("MinDate") != m.end() && !m["MinDate"].empty()) {
      minDate = make_shared<string>(boost::any_cast<string>(m["MinDate"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeAICImagesRequest() = default;
};
class DescribeAICImagesResponseBodyImages : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> status{};
  shared_ptr<string> user{};

  DescribeAICImagesResponseBodyImages() {}

  explicit DescribeAICImagesResponseBodyImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~DescribeAICImagesResponseBodyImages() = default;
};
class DescribeAICImagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAICImagesResponseBodyImages>> images{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAICImagesResponseBody() {}

  explicit DescribeAICImagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (images) {
      vector<boost::any> temp1;
      for(auto item1:*images){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Images"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(vector<boost::any>) == m["Images"].type()) {
        vector<DescribeAICImagesResponseBodyImages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Images"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAICImagesResponseBodyImages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        images = make_shared<vector<DescribeAICImagesResponseBodyImages>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAICImagesResponseBody() = default;
};
class DescribeAICImagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAICImagesResponseBody> body{};

  DescribeAICImagesResponse() {}

  explicit DescribeAICImagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAICImagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAICImagesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAICImagesResponse() = default;
};
class DescribeARMServerInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> AICSpecs{};
  shared_ptr<bool> describeAICInstances{};
  shared_ptr<vector<string>> ensRegionIds{};
  shared_ptr<string> maxDate{};
  shared_ptr<string> minDate{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> orderByParams{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> serverIds{};
  shared_ptr<vector<string>> serverSpecs{};
  shared_ptr<vector<string>> states{};

  DescribeARMServerInstancesRequest() {}

  explicit DescribeARMServerInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AICSpecs) {
      res["AICSpecs"] = boost::any(*AICSpecs);
    }
    if (describeAICInstances) {
      res["DescribeAICInstances"] = boost::any(*describeAICInstances);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = boost::any(*ensRegionIds);
    }
    if (maxDate) {
      res["MaxDate"] = boost::any(*maxDate);
    }
    if (minDate) {
      res["MinDate"] = boost::any(*minDate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (orderByParams) {
      res["OrderByParams"] = boost::any(*orderByParams);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (serverIds) {
      res["ServerIds"] = boost::any(*serverIds);
    }
    if (serverSpecs) {
      res["ServerSpecs"] = boost::any(*serverSpecs);
    }
    if (states) {
      res["States"] = boost::any(*states);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AICSpecs") != m.end() && !m["AICSpecs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AICSpecs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AICSpecs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      AICSpecs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DescribeAICInstances") != m.end() && !m["DescribeAICInstances"].empty()) {
      describeAICInstances = make_shared<bool>(boost::any_cast<bool>(m["DescribeAICInstances"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnsRegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnsRegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ensRegionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxDate") != m.end() && !m["MaxDate"].empty()) {
      maxDate = make_shared<string>(boost::any_cast<string>(m["MaxDate"]));
    }
    if (m.find("MinDate") != m.end() && !m["MinDate"].empty()) {
      minDate = make_shared<string>(boost::any_cast<string>(m["MinDate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("OrderByParams") != m.end() && !m["OrderByParams"].empty()) {
      orderByParams = make_shared<string>(boost::any_cast<string>(m["OrderByParams"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ServerIds") != m.end() && !m["ServerIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ServerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ServerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      serverIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ServerSpecs") != m.end() && !m["ServerSpecs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ServerSpecs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ServerSpecs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      serverSpecs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("States") != m.end() && !m["States"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["States"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["States"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      states = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeARMServerInstancesRequest() = default;
};
class DescribeARMServerInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> AICSpecsShrink{};
  shared_ptr<bool> describeAICInstances{};
  shared_ptr<string> ensRegionIdsShrink{};
  shared_ptr<string> maxDate{};
  shared_ptr<string> minDate{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> orderByParams{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> serverIdsShrink{};
  shared_ptr<string> serverSpecsShrink{};
  shared_ptr<string> statesShrink{};

  DescribeARMServerInstancesShrinkRequest() {}

  explicit DescribeARMServerInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AICSpecsShrink) {
      res["AICSpecs"] = boost::any(*AICSpecsShrink);
    }
    if (describeAICInstances) {
      res["DescribeAICInstances"] = boost::any(*describeAICInstances);
    }
    if (ensRegionIdsShrink) {
      res["EnsRegionIds"] = boost::any(*ensRegionIdsShrink);
    }
    if (maxDate) {
      res["MaxDate"] = boost::any(*maxDate);
    }
    if (minDate) {
      res["MinDate"] = boost::any(*minDate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (orderByParams) {
      res["OrderByParams"] = boost::any(*orderByParams);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (serverIdsShrink) {
      res["ServerIds"] = boost::any(*serverIdsShrink);
    }
    if (serverSpecsShrink) {
      res["ServerSpecs"] = boost::any(*serverSpecsShrink);
    }
    if (statesShrink) {
      res["States"] = boost::any(*statesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AICSpecs") != m.end() && !m["AICSpecs"].empty()) {
      AICSpecsShrink = make_shared<string>(boost::any_cast<string>(m["AICSpecs"]));
    }
    if (m.find("DescribeAICInstances") != m.end() && !m["DescribeAICInstances"].empty()) {
      describeAICInstances = make_shared<bool>(boost::any_cast<bool>(m["DescribeAICInstances"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      ensRegionIdsShrink = make_shared<string>(boost::any_cast<string>(m["EnsRegionIds"]));
    }
    if (m.find("MaxDate") != m.end() && !m["MaxDate"].empty()) {
      maxDate = make_shared<string>(boost::any_cast<string>(m["MaxDate"]));
    }
    if (m.find("MinDate") != m.end() && !m["MinDate"].empty()) {
      minDate = make_shared<string>(boost::any_cast<string>(m["MinDate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("OrderByParams") != m.end() && !m["OrderByParams"].empty()) {
      orderByParams = make_shared<string>(boost::any_cast<string>(m["OrderByParams"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ServerIds") != m.end() && !m["ServerIds"].empty()) {
      serverIdsShrink = make_shared<string>(boost::any_cast<string>(m["ServerIds"]));
    }
    if (m.find("ServerSpecs") != m.end() && !m["ServerSpecs"].empty()) {
      serverSpecsShrink = make_shared<string>(boost::any_cast<string>(m["ServerSpecs"]));
    }
    if (m.find("States") != m.end() && !m["States"].empty()) {
      statesShrink = make_shared<string>(boost::any_cast<string>(m["States"]));
    }
  }


  virtual ~DescribeARMServerInstancesShrinkRequest() = default;
};
class DescribeARMServerInstancesResponseBodyServersAICInstancesNetworkAttributes : public Darabonba::Model {
public:
  shared_ptr<string> ipAddress{};
  shared_ptr<string> networkId{};
  shared_ptr<string> vSwitchId{};

  DescribeARMServerInstancesResponseBodyServersAICInstancesNetworkAttributes() {}

  explicit DescribeARMServerInstancesResponseBodyServersAICInstancesNetworkAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeARMServerInstancesResponseBodyServersAICInstancesNetworkAttributes() = default;
};
class DescribeARMServerInstancesResponseBodyServersAICInstancesSdgDeployInfo : public Darabonba::Model {
public:
  shared_ptr<string> SDGId{};
  shared_ptr<string> status{};

  DescribeARMServerInstancesResponseBodyServersAICInstancesSdgDeployInfo() {}

  explicit DescribeARMServerInstancesResponseBodyServersAICInstancesSdgDeployInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeARMServerInstancesResponseBodyServersAICInstancesSdgDeployInfo() = default;
};
class DescribeARMServerInstancesResponseBodyServersAICInstances : public Darabonba::Model {
public:
  shared_ptr<long> frequency{};
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> latestAction{};
  shared_ptr<string> name{};
  shared_ptr<DescribeARMServerInstancesResponseBodyServersAICInstancesNetworkAttributes> networkAttributes{};
  shared_ptr<string> resolution{};
  shared_ptr<DescribeARMServerInstancesResponseBodyServersAICInstancesSdgDeployInfo> sdgDeployInfo{};
  shared_ptr<string> spec{};
  shared_ptr<string> state{};
  shared_ptr<string> status{};

  DescribeARMServerInstancesResponseBodyServersAICInstances() {}

  explicit DescribeARMServerInstancesResponseBodyServersAICInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frequency) {
      res["Frequency"] = boost::any(*frequency);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (latestAction) {
      res["LatestAction"] = boost::any(*latestAction);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkAttributes) {
      res["NetworkAttributes"] = networkAttributes ? boost::any(networkAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resolution) {
      res["Resolution"] = boost::any(*resolution);
    }
    if (sdgDeployInfo) {
      res["SdgDeployInfo"] = sdgDeployInfo ? boost::any(sdgDeployInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Frequency") != m.end() && !m["Frequency"].empty()) {
      frequency = make_shared<long>(boost::any_cast<long>(m["Frequency"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LatestAction") != m.end() && !m["LatestAction"].empty()) {
      latestAction = make_shared<string>(boost::any_cast<string>(m["LatestAction"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkAttributes") != m.end() && !m["NetworkAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkAttributes"].type()) {
        DescribeARMServerInstancesResponseBodyServersAICInstancesNetworkAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkAttributes"]));
        networkAttributes = make_shared<DescribeARMServerInstancesResponseBodyServersAICInstancesNetworkAttributes>(model1);
      }
    }
    if (m.find("Resolution") != m.end() && !m["Resolution"].empty()) {
      resolution = make_shared<string>(boost::any_cast<string>(m["Resolution"]));
    }
    if (m.find("SdgDeployInfo") != m.end() && !m["SdgDeployInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SdgDeployInfo"].type()) {
        DescribeARMServerInstancesResponseBodyServersAICInstancesSdgDeployInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SdgDeployInfo"]));
        sdgDeployInfo = make_shared<DescribeARMServerInstancesResponseBodyServersAICInstancesSdgDeployInfo>(model1);
      }
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeARMServerInstancesResponseBodyServersAICInstances() = default;
};
class DescribeARMServerInstancesResponseBodyServersTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeARMServerInstancesResponseBodyServersTags() {}

  explicit DescribeARMServerInstancesResponseBodyServersTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeARMServerInstancesResponseBodyServersTags() = default;
};
class DescribeARMServerInstancesResponseBodyServers : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeARMServerInstancesResponseBodyServersAICInstances>> AICInstances{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> latestAction{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> payType{};
  shared_ptr<string> serverId{};
  shared_ptr<string> specName{};
  shared_ptr<string> state{};
  shared_ptr<string> status{};
  shared_ptr<vector<DescribeARMServerInstancesResponseBodyServersTags>> tags{};

  DescribeARMServerInstancesResponseBodyServers() {}

  explicit DescribeARMServerInstancesResponseBodyServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AICInstances) {
      vector<boost::any> temp1;
      for(auto item1:*AICInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AICInstances"] = boost::any(temp1);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (latestAction) {
      res["LatestAction"] = boost::any(*latestAction);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AICInstances") != m.end() && !m["AICInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["AICInstances"].type()) {
        vector<DescribeARMServerInstancesResponseBodyServersAICInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AICInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeARMServerInstancesResponseBodyServersAICInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        AICInstances = make_shared<vector<DescribeARMServerInstancesResponseBodyServersAICInstances>>(expect1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("LatestAction") != m.end() && !m["LatestAction"].empty()) {
      latestAction = make_shared<string>(boost::any_cast<string>(m["LatestAction"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeARMServerInstancesResponseBodyServersTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeARMServerInstancesResponseBodyServersTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeARMServerInstancesResponseBodyServersTags>>(expect1);
      }
    }
  }


  virtual ~DescribeARMServerInstancesResponseBodyServers() = default;
};
class DescribeARMServerInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeARMServerInstancesResponseBodyServers>> servers{};
  shared_ptr<long> totalCount{};

  DescribeARMServerInstancesResponseBody() {}

  explicit DescribeARMServerInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (servers) {
      vector<boost::any> temp1;
      for(auto item1:*servers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Servers"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Servers") != m.end() && !m["Servers"].empty()) {
      if (typeid(vector<boost::any>) == m["Servers"].type()) {
        vector<DescribeARMServerInstancesResponseBodyServers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Servers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeARMServerInstancesResponseBodyServers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        servers = make_shared<vector<DescribeARMServerInstancesResponseBodyServers>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeARMServerInstancesResponseBody() = default;
};
class DescribeARMServerInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeARMServerInstancesResponseBody> body{};

  DescribeARMServerInstancesResponse() {}

  explicit DescribeARMServerInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeARMServerInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeARMServerInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeARMServerInstancesResponse() = default;
};
class DescribeApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appVersions{};
  shared_ptr<string> level{};
  shared_ptr<string> outDetailStatParams{};
  shared_ptr<string> resourceSelector{};

  DescribeApplicationRequest() {}

  explicit DescribeApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appVersions) {
      res["AppVersions"] = boost::any(*appVersions);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (outDetailStatParams) {
      res["OutDetailStatParams"] = boost::any(*outDetailStatParams);
    }
    if (resourceSelector) {
      res["ResourceSelector"] = boost::any(*resourceSelector);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppVersions") != m.end() && !m["AppVersions"].empty()) {
      appVersions = make_shared<string>(boost::any_cast<string>(m["AppVersions"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("OutDetailStatParams") != m.end() && !m["OutDetailStatParams"].empty()) {
      outDetailStatParams = make_shared<string>(boost::any_cast<string>(m["OutDetailStatParams"]));
    }
    if (m.find("ResourceSelector") != m.end() && !m["ResourceSelector"].empty()) {
      resourceSelector = make_shared<string>(boost::any_cast<string>(m["ResourceSelector"]));
    }
  }


  virtual ~DescribeApplicationRequest() = default;
};
class DescribeApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> application{};
  shared_ptr<string> requestId{};

  DescribeApplicationResponseBody() {}

  explicit DescribeApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (application) {
      res["Application"] = boost::any(*application);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      application = make_shared<string>(boost::any_cast<string>(m["Application"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApplicationResponseBody() = default;
};
class DescribeApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApplicationResponseBody> body{};

  DescribeApplicationResponse() {}

  explicit DescribeApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApplicationResponse() = default;
};
class DescribeAvailableResourceResponseBodyImagesImage : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};

  DescribeAvailableResourceResponseBodyImagesImage() {}

  explicit DescribeAvailableResourceResponseBodyImagesImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
  }


  virtual ~DescribeAvailableResourceResponseBodyImagesImage() = default;
};
class DescribeAvailableResourceResponseBodyImages : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAvailableResourceResponseBodyImagesImage>> image{};

  DescribeAvailableResourceResponseBodyImages() {}

  explicit DescribeAvailableResourceResponseBodyImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      vector<boost::any> temp1;
      for(auto item1:*image){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Image"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      if (typeid(vector<boost::any>) == m["Image"].type()) {
        vector<DescribeAvailableResourceResponseBodyImagesImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Image"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableResourceResponseBodyImagesImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        image = make_shared<vector<DescribeAvailableResourceResponseBodyImagesImage>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableResourceResponseBodyImages() = default;
};
class DescribeAvailableResourceResponseBodySupportResourcesSupportResource : public Darabonba::Model {
public:
  shared_ptr<string> dataDiskSize{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceSpec{};
  shared_ptr<string> supportResourcesCount{};
  shared_ptr<string> systemDiskSize{};

  DescribeAvailableResourceResponseBodySupportResourcesSupportResource() {}

  explicit DescribeAvailableResourceResponseBodySupportResourcesSupportResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceSpec) {
      res["InstanceSpec"] = boost::any(*instanceSpec);
    }
    if (supportResourcesCount) {
      res["SupportResourcesCount"] = boost::any(*supportResourcesCount);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<string>(boost::any_cast<string>(m["DataDiskSize"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceSpec") != m.end() && !m["InstanceSpec"].empty()) {
      instanceSpec = make_shared<string>(boost::any_cast<string>(m["InstanceSpec"]));
    }
    if (m.find("SupportResourcesCount") != m.end() && !m["SupportResourcesCount"].empty()) {
      supportResourcesCount = make_shared<string>(boost::any_cast<string>(m["SupportResourcesCount"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<string>(boost::any_cast<string>(m["SystemDiskSize"]));
    }
  }


  virtual ~DescribeAvailableResourceResponseBodySupportResourcesSupportResource() = default;
};
class DescribeAvailableResourceResponseBodySupportResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAvailableResourceResponseBodySupportResourcesSupportResource>> supportResource{};

  DescribeAvailableResourceResponseBodySupportResources() {}

  explicit DescribeAvailableResourceResponseBodySupportResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportResource) {
      vector<boost::any> temp1;
      for(auto item1:*supportResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportResource") != m.end() && !m["SupportResource"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportResource"].type()) {
        vector<DescribeAvailableResourceResponseBodySupportResourcesSupportResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableResourceResponseBodySupportResourcesSupportResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportResource = make_shared<vector<DescribeAvailableResourceResponseBodySupportResourcesSupportResource>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableResourceResponseBodySupportResources() = default;
};
class DescribeAvailableResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeAvailableResourceResponseBodyImages> images{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAvailableResourceResponseBodySupportResources> supportResources{};

  DescribeAvailableResourceResponseBody() {}

  explicit DescribeAvailableResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (images) {
      res["Images"] = images ? boost::any(images->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (supportResources) {
      res["SupportResources"] = supportResources ? boost::any(supportResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(map<string, boost::any>) == m["Images"].type()) {
        DescribeAvailableResourceResponseBodyImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Images"]));
        images = make_shared<DescribeAvailableResourceResponseBodyImages>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SupportResources") != m.end() && !m["SupportResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportResources"].type()) {
        DescribeAvailableResourceResponseBodySupportResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportResources"]));
        supportResources = make_shared<DescribeAvailableResourceResponseBodySupportResources>(model1);
      }
    }
  }


  virtual ~DescribeAvailableResourceResponseBody() = default;
};
class DescribeAvailableResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAvailableResourceResponseBody> body{};

  DescribeAvailableResourceResponse() {}

  explicit DescribeAvailableResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAvailableResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAvailableResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAvailableResourceResponse() = default;
};
class DescribeAvailableResourceInfoResponseBodyImagesImage : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<long> imageSize{};

  DescribeAvailableResourceInfoResponseBodyImagesImage() {}

  explicit DescribeAvailableResourceInfoResponseBodyImagesImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (imageSize) {
      res["ImageSize"] = boost::any(*imageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("ImageSize") != m.end() && !m["ImageSize"].empty()) {
      imageSize = make_shared<long>(boost::any_cast<long>(m["ImageSize"]));
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBodyImagesImage() = default;
};
class DescribeAvailableResourceInfoResponseBodyImages : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAvailableResourceInfoResponseBodyImagesImage>> image{};

  DescribeAvailableResourceInfoResponseBodyImages() {}

  explicit DescribeAvailableResourceInfoResponseBodyImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      vector<boost::any> temp1;
      for(auto item1:*image){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Image"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      if (typeid(vector<boost::any>) == m["Image"].type()) {
        vector<DescribeAvailableResourceInfoResponseBodyImagesImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Image"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableResourceInfoResponseBodyImagesImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        image = make_shared<vector<DescribeAvailableResourceInfoResponseBodyImagesImage>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBodyImages() = default;
};
class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceBandwidthTypes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> bandwidthType{};

  DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceBandwidthTypes() {}

  explicit DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceBandwidthTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthType) {
      res["BandwidthType"] = boost::any(*bandwidthType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthType") != m.end() && !m["BandwidthType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BandwidthType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BandwidthType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      bandwidthType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceBandwidthTypes() = default;
};
class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ensRegionId{};

  DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIds() {}

  explicit DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnsRegionId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnsRegionId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ensRegionId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIds() = default;
};
class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtendsEnsRegionId : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> enName{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> isp{};
  shared_ptr<string> name{};
  shared_ptr<string> province{};

  DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtendsEnsRegionId() {}

  explicit DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtendsEnsRegionId(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (enName) {
      res["EnName"] = boost::any(*enName);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("EnName") != m.end() && !m["EnName"].empty()) {
      enName = make_shared<string>(boost::any_cast<string>(m["EnName"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtendsEnsRegionId() = default;
};
class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtends : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtendsEnsRegionId>> ensRegionId{};

  DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtends() {}

  explicit DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtends(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      vector<boost::any> temp1;
      for(auto item1:*ensRegionId){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnsRegionId"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      if (typeid(vector<boost::any>) == m["EnsRegionId"].type()) {
        vector<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtendsEnsRegionId> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnsRegionId"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtendsEnsRegionId model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ensRegionId = make_shared<vector<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtendsEnsRegionId>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtends() = default;
};
class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceInstanceSpeces : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceSpec{};

  DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceInstanceSpeces() {}

  explicit DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceInstanceSpeces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceSpec) {
      res["InstanceSpec"] = boost::any(*instanceSpec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceSpec") != m.end() && !m["InstanceSpec"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceSpec"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceSpec"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceSpec = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceInstanceSpeces() = default;
};
class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceIsp : public Darabonba::Model {
public:
  shared_ptr<vector<string>> isp{};

  DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceIsp() {}

  explicit DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceIsp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Isp"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Isp"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      isp = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceIsp() = default;
};
class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResource : public Darabonba::Model {
public:
  shared_ptr<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceBandwidthTypes> bandwidthTypes{};
  shared_ptr<long> dataDiskMaxSize{};
  shared_ptr<long> dataDiskMinSize{};
  shared_ptr<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIds> ensRegionIds{};
  shared_ptr<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtends> ensRegionIdsExtends{};
  shared_ptr<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceInstanceSpeces> instanceSpeces{};
  shared_ptr<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceIsp> isp{};
  shared_ptr<long> systemDiskMaxSize{};
  shared_ptr<long> systemDiskMinSize{};

  DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResource() {}

  explicit DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthTypes) {
      res["BandwidthTypes"] = bandwidthTypes ? boost::any(bandwidthTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataDiskMaxSize) {
      res["DataDiskMaxSize"] = boost::any(*dataDiskMaxSize);
    }
    if (dataDiskMinSize) {
      res["DataDiskMinSize"] = boost::any(*dataDiskMinSize);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = ensRegionIds ? boost::any(ensRegionIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ensRegionIdsExtends) {
      res["EnsRegionIdsExtends"] = ensRegionIdsExtends ? boost::any(ensRegionIdsExtends->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceSpeces) {
      res["InstanceSpeces"] = instanceSpeces ? boost::any(instanceSpeces->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isp) {
      res["Isp"] = isp ? boost::any(isp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (systemDiskMaxSize) {
      res["SystemDiskMaxSize"] = boost::any(*systemDiskMaxSize);
    }
    if (systemDiskMinSize) {
      res["SystemDiskMinSize"] = boost::any(*systemDiskMinSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthTypes") != m.end() && !m["BandwidthTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["BandwidthTypes"].type()) {
        DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceBandwidthTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BandwidthTypes"]));
        bandwidthTypes = make_shared<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceBandwidthTypes>(model1);
      }
    }
    if (m.find("DataDiskMaxSize") != m.end() && !m["DataDiskMaxSize"].empty()) {
      dataDiskMaxSize = make_shared<long>(boost::any_cast<long>(m["DataDiskMaxSize"]));
    }
    if (m.find("DataDiskMinSize") != m.end() && !m["DataDiskMinSize"].empty()) {
      dataDiskMinSize = make_shared<long>(boost::any_cast<long>(m["DataDiskMinSize"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["EnsRegionIds"].type()) {
        DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EnsRegionIds"]));
        ensRegionIds = make_shared<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIds>(model1);
      }
    }
    if (m.find("EnsRegionIdsExtends") != m.end() && !m["EnsRegionIdsExtends"].empty()) {
      if (typeid(map<string, boost::any>) == m["EnsRegionIdsExtends"].type()) {
        DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtends model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EnsRegionIdsExtends"]));
        ensRegionIdsExtends = make_shared<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtends>(model1);
      }
    }
    if (m.find("InstanceSpeces") != m.end() && !m["InstanceSpeces"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceSpeces"].type()) {
        DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceInstanceSpeces model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceSpeces"]));
        instanceSpeces = make_shared<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceInstanceSpeces>(model1);
      }
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Isp"].type()) {
        DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceIsp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Isp"]));
        isp = make_shared<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceIsp>(model1);
      }
    }
    if (m.find("SystemDiskMaxSize") != m.end() && !m["SystemDiskMaxSize"].empty()) {
      systemDiskMaxSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskMaxSize"]));
    }
    if (m.find("SystemDiskMinSize") != m.end() && !m["SystemDiskMinSize"].empty()) {
      systemDiskMinSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskMinSize"]));
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResource() = default;
};
class DescribeAvailableResourceInfoResponseBodySupportResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResource>> supportResource{};

  DescribeAvailableResourceInfoResponseBodySupportResources() {}

  explicit DescribeAvailableResourceInfoResponseBodySupportResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportResource) {
      vector<boost::any> temp1;
      for(auto item1:*supportResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportResource") != m.end() && !m["SupportResource"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportResource"].type()) {
        vector<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportResource = make_shared<vector<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResource>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBodySupportResources() = default;
};
class DescribeAvailableResourceInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAvailableResourceInfoResponseBodyImages> images{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAvailableResourceInfoResponseBodySupportResources> supportResources{};

  DescribeAvailableResourceInfoResponseBody() {}

  explicit DescribeAvailableResourceInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (images) {
      res["Images"] = images ? boost::any(images->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (supportResources) {
      res["SupportResources"] = supportResources ? boost::any(supportResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(map<string, boost::any>) == m["Images"].type()) {
        DescribeAvailableResourceInfoResponseBodyImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Images"]));
        images = make_shared<DescribeAvailableResourceInfoResponseBodyImages>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SupportResources") != m.end() && !m["SupportResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportResources"].type()) {
        DescribeAvailableResourceInfoResponseBodySupportResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportResources"]));
        supportResources = make_shared<DescribeAvailableResourceInfoResponseBodySupportResources>(model1);
      }
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBody() = default;
};
class DescribeAvailableResourceInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAvailableResourceInfoResponseBody> body{};

  DescribeAvailableResourceInfoResponse() {}

  explicit DescribeAvailableResourceInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAvailableResourceInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAvailableResourceInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAvailableResourceInfoResponse() = default;
};
class DescribeBandWithdChargeTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bandWithTypeInfo{};
  shared_ptr<string> chargeContractType{};
  shared_ptr<string> chargeCycleInfo{};
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  DescribeBandWithdChargeTypeResponseBody() {}

  explicit DescribeBandWithdChargeTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWithTypeInfo) {
      res["BandWithTypeInfo"] = boost::any(*bandWithTypeInfo);
    }
    if (chargeContractType) {
      res["ChargeContractType"] = boost::any(*chargeContractType);
    }
    if (chargeCycleInfo) {
      res["ChargeCycleInfo"] = boost::any(*chargeCycleInfo);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWithTypeInfo") != m.end() && !m["BandWithTypeInfo"].empty()) {
      bandWithTypeInfo = make_shared<string>(boost::any_cast<string>(m["BandWithTypeInfo"]));
    }
    if (m.find("ChargeContractType") != m.end() && !m["ChargeContractType"].empty()) {
      chargeContractType = make_shared<string>(boost::any_cast<string>(m["ChargeContractType"]));
    }
    if (m.find("ChargeCycleInfo") != m.end() && !m["ChargeCycleInfo"].empty()) {
      chargeCycleInfo = make_shared<string>(boost::any_cast<string>(m["ChargeCycleInfo"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBandWithdChargeTypeResponseBody() = default;
};
class DescribeBandWithdChargeTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBandWithdChargeTypeResponseBody> body{};

  DescribeBandWithdChargeTypeResponse() {}

  explicit DescribeBandWithdChargeTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBandWithdChargeTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBandWithdChargeTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBandWithdChargeTypeResponse() = default;
};
class DescribeBandwitdhByInternetChargeTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> isp{};
  shared_ptr<string> startTime{};

  DescribeBandwitdhByInternetChargeTypeRequest() {}

  explicit DescribeBandwitdhByInternetChargeTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeBandwitdhByInternetChargeTypeRequest() = default;
};
class DescribeBandwitdhByInternetChargeTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> bandwidthValue{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> timeStamp{};

  DescribeBandwitdhByInternetChargeTypeResponseBody() {}

  explicit DescribeBandwitdhByInternetChargeTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthValue) {
      res["BandwidthValue"] = boost::any(*bandwidthValue);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthValue") != m.end() && !m["BandwidthValue"].empty()) {
      bandwidthValue = make_shared<long>(boost::any_cast<long>(m["BandwidthValue"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeBandwitdhByInternetChargeTypeResponseBody() = default;
};
class DescribeBandwitdhByInternetChargeTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBandwitdhByInternetChargeTypeResponseBody> body{};

  DescribeBandwitdhByInternetChargeTypeResponse() {}

  explicit DescribeBandwitdhByInternetChargeTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBandwitdhByInternetChargeTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBandwitdhByInternetChargeTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBandwitdhByInternetChargeTypeResponse() = default;
};
class DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResourceAbility : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ability{};

  DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResourceAbility() {}

  explicit DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResourceAbility(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ability) {
      res["Ability"] = boost::any(*ability);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ability") != m.end() && !m["Ability"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ability"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ability"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ability = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResourceAbility() = default;
};
class DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResource : public Darabonba::Model {
public:
  shared_ptr<DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResourceAbility> ability{};
  shared_ptr<long> canBuyCount{};
  shared_ptr<string> category{};
  shared_ptr<long> defaultDiskSize{};
  shared_ptr<long> diskMaxSize{};
  shared_ptr<long> diskMinSize{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> ensRegionName{};

  DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResource() {}

  explicit DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ability) {
      res["Ability"] = ability ? boost::any(ability->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (canBuyCount) {
      res["CanBuyCount"] = boost::any(*canBuyCount);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (defaultDiskSize) {
      res["DefaultDiskSize"] = boost::any(*defaultDiskSize);
    }
    if (diskMaxSize) {
      res["DiskMaxSize"] = boost::any(*diskMaxSize);
    }
    if (diskMinSize) {
      res["DiskMinSize"] = boost::any(*diskMinSize);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionName) {
      res["EnsRegionName"] = boost::any(*ensRegionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ability") != m.end() && !m["Ability"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ability"].type()) {
        DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResourceAbility model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ability"]));
        ability = make_shared<DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResourceAbility>(model1);
      }
    }
    if (m.find("CanBuyCount") != m.end() && !m["CanBuyCount"].empty()) {
      canBuyCount = make_shared<long>(boost::any_cast<long>(m["CanBuyCount"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DefaultDiskSize") != m.end() && !m["DefaultDiskSize"].empty()) {
      defaultDiskSize = make_shared<long>(boost::any_cast<long>(m["DefaultDiskSize"]));
    }
    if (m.find("DiskMaxSize") != m.end() && !m["DiskMaxSize"].empty()) {
      diskMaxSize = make_shared<long>(boost::any_cast<long>(m["DiskMaxSize"]));
    }
    if (m.find("DiskMinSize") != m.end() && !m["DiskMinSize"].empty()) {
      diskMinSize = make_shared<long>(boost::any_cast<long>(m["DiskMinSize"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionName") != m.end() && !m["EnsRegionName"].empty()) {
      ensRegionName = make_shared<string>(boost::any_cast<string>(m["EnsRegionName"]));
    }
  }


  virtual ~DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResource() = default;
};
class DescribeCloudDiskAvailableResourceInfoResponseBodySupportResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResource>> supportResource{};

  DescribeCloudDiskAvailableResourceInfoResponseBodySupportResources() {}

  explicit DescribeCloudDiskAvailableResourceInfoResponseBodySupportResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportResource) {
      vector<boost::any> temp1;
      for(auto item1:*supportResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportResource") != m.end() && !m["SupportResource"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportResource"].type()) {
        vector<DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportResource = make_shared<vector<DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResource>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudDiskAvailableResourceInfoResponseBodySupportResources() = default;
};
class DescribeCloudDiskAvailableResourceInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeCloudDiskAvailableResourceInfoResponseBodySupportResources> supportResources{};

  DescribeCloudDiskAvailableResourceInfoResponseBody() {}

  explicit DescribeCloudDiskAvailableResourceInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (supportResources) {
      res["SupportResources"] = supportResources ? boost::any(supportResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SupportResources") != m.end() && !m["SupportResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportResources"].type()) {
        DescribeCloudDiskAvailableResourceInfoResponseBodySupportResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportResources"]));
        supportResources = make_shared<DescribeCloudDiskAvailableResourceInfoResponseBodySupportResources>(model1);
      }
    }
  }


  virtual ~DescribeCloudDiskAvailableResourceInfoResponseBody() = default;
};
class DescribeCloudDiskAvailableResourceInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudDiskAvailableResourceInfoResponseBody> body{};

  DescribeCloudDiskAvailableResourceInfoResponse() {}

  explicit DescribeCloudDiskAvailableResourceInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudDiskAvailableResourceInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudDiskAvailableResourceInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudDiskAvailableResourceInfoResponse() = default;
};
class DescribeCloudDiskTypesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<vector<string>> ensRegionIds{};

  DescribeCloudDiskTypesRequest() {}

  explicit DescribeCloudDiskTypesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = boost::any(*ensRegionIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnsRegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnsRegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ensRegionIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCloudDiskTypesRequest() = default;
};
class DescribeCloudDiskTypesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> ensRegionIdsShrink{};

  DescribeCloudDiskTypesShrinkRequest() {}

  explicit DescribeCloudDiskTypesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionIdsShrink) {
      res["EnsRegionIds"] = boost::any(*ensRegionIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      ensRegionIdsShrink = make_shared<string>(boost::any_cast<string>(m["EnsRegionIds"]));
    }
  }


  virtual ~DescribeCloudDiskTypesShrinkRequest() = default;
};
class DescribeCloudDiskTypesResponseBodySupportResourcesSupportResource : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> ensRegionId{};

  DescribeCloudDiskTypesResponseBodySupportResourcesSupportResource() {}

  explicit DescribeCloudDiskTypesResponseBodySupportResourcesSupportResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
  }


  virtual ~DescribeCloudDiskTypesResponseBodySupportResourcesSupportResource() = default;
};
class DescribeCloudDiskTypesResponseBodySupportResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudDiskTypesResponseBodySupportResourcesSupportResource>> supportResource{};

  DescribeCloudDiskTypesResponseBodySupportResources() {}

  explicit DescribeCloudDiskTypesResponseBodySupportResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportResource) {
      vector<boost::any> temp1;
      for(auto item1:*supportResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportResource") != m.end() && !m["SupportResource"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportResource"].type()) {
        vector<DescribeCloudDiskTypesResponseBodySupportResourcesSupportResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudDiskTypesResponseBodySupportResourcesSupportResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportResource = make_shared<vector<DescribeCloudDiskTypesResponseBodySupportResourcesSupportResource>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudDiskTypesResponseBodySupportResources() = default;
};
class DescribeCloudDiskTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeCloudDiskTypesResponseBodySupportResources> supportResources{};

  DescribeCloudDiskTypesResponseBody() {}

  explicit DescribeCloudDiskTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (supportResources) {
      res["SupportResources"] = supportResources ? boost::any(supportResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SupportResources") != m.end() && !m["SupportResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportResources"].type()) {
        DescribeCloudDiskTypesResponseBodySupportResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportResources"]));
        supportResources = make_shared<DescribeCloudDiskTypesResponseBodySupportResources>(model1);
      }
    }
  }


  virtual ~DescribeCloudDiskTypesResponseBody() = default;
};
class DescribeCloudDiskTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudDiskTypesResponseBody> body{};

  DescribeCloudDiskTypesResponse() {}

  explicit DescribeCloudDiskTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudDiskTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudDiskTypesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudDiskTypesResponse() = default;
};
class DescribeClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};

  DescribeClusterRequest() {}

  explicit DescribeClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~DescribeClusterRequest() = default;
};
class DescribeClusterResponseBodyClusters : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> currentVersion{};
  shared_ptr<string> name{};
  shared_ptr<string> nextVersion{};
  shared_ptr<string> status{};

  DescribeClusterResponseBodyClusters() {}

  explicit DescribeClusterResponseBodyClusters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (currentVersion) {
      res["CurrentVersion"] = boost::any(*currentVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nextVersion) {
      res["NextVersion"] = boost::any(*nextVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CurrentVersion") != m.end() && !m["CurrentVersion"].empty()) {
      currentVersion = make_shared<string>(boost::any_cast<string>(m["CurrentVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NextVersion") != m.end() && !m["NextVersion"].empty()) {
      nextVersion = make_shared<string>(boost::any_cast<string>(m["NextVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeClusterResponseBodyClusters() = default;
};
class DescribeClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterResponseBodyClusters>> clusters{};
  shared_ptr<string> requestId{};

  DescribeClusterResponseBody() {}

  explicit DescribeClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusters) {
      vector<boost::any> temp1;
      for(auto item1:*clusters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Clusters"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clusters") != m.end() && !m["Clusters"].empty()) {
      if (typeid(vector<boost::any>) == m["Clusters"].type()) {
        vector<DescribeClusterResponseBodyClusters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Clusters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterResponseBodyClusters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusters = make_shared<vector<DescribeClusterResponseBodyClusters>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeClusterResponseBody() = default;
};
class DescribeClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterResponseBody> body{};

  DescribeClusterResponse() {}

  explicit DescribeClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterResponse() = default;
};
class DescribeClusterKubeConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};

  DescribeClusterKubeConfigRequest() {}

  explicit DescribeClusterKubeConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~DescribeClusterKubeConfigRequest() = default;
};
class DescribeClusterKubeConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> kubeconfig{};
  shared_ptr<string> requestId{};

  DescribeClusterKubeConfigResponseBody() {}

  explicit DescribeClusterKubeConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (kubeconfig) {
      res["Kubeconfig"] = boost::any(*kubeconfig);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Kubeconfig") != m.end() && !m["Kubeconfig"].empty()) {
      kubeconfig = make_shared<string>(boost::any_cast<string>(m["Kubeconfig"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeClusterKubeConfigResponseBody() = default;
};
class DescribeClusterKubeConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterKubeConfigResponseBody> body{};

  DescribeClusterKubeConfigResponse() {}

  explicit DescribeClusterKubeConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterKubeConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterKubeConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterKubeConfigResponse() = default;
};
class DescribeCreatePrePaidInstanceResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DescribeCreatePrePaidInstanceResultRequest() {}

  explicit DescribeCreatePrePaidInstanceResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeCreatePrePaidInstanceResultRequest() = default;
};
class DescribeCreatePrePaidInstanceResultResponseBodyInstanceCreateResult : public Darabonba::Model {
public:
  shared_ptr<string> instanceCreateStatus{};
  shared_ptr<string> instanceId{};

  DescribeCreatePrePaidInstanceResultResponseBodyInstanceCreateResult() {}

  explicit DescribeCreatePrePaidInstanceResultResponseBodyInstanceCreateResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceCreateStatus) {
      res["InstanceCreateStatus"] = boost::any(*instanceCreateStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceCreateStatus") != m.end() && !m["InstanceCreateStatus"].empty()) {
      instanceCreateStatus = make_shared<string>(boost::any_cast<string>(m["InstanceCreateStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeCreatePrePaidInstanceResultResponseBodyInstanceCreateResult() = default;
};
class DescribeCreatePrePaidInstanceResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCreatePrePaidInstanceResultResponseBodyInstanceCreateResult> instanceCreateResult{};
  shared_ptr<string> requestId{};

  DescribeCreatePrePaidInstanceResultResponseBody() {}

  explicit DescribeCreatePrePaidInstanceResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceCreateResult) {
      res["InstanceCreateResult"] = instanceCreateResult ? boost::any(instanceCreateResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceCreateResult") != m.end() && !m["InstanceCreateResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceCreateResult"].type()) {
        DescribeCreatePrePaidInstanceResultResponseBodyInstanceCreateResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceCreateResult"]));
        instanceCreateResult = make_shared<DescribeCreatePrePaidInstanceResultResponseBodyInstanceCreateResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCreatePrePaidInstanceResultResponseBody() = default;
};
class DescribeCreatePrePaidInstanceResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCreatePrePaidInstanceResultResponseBody> body{};

  DescribeCreatePrePaidInstanceResultResponse() {}

  explicit DescribeCreatePrePaidInstanceResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCreatePrePaidInstanceResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCreatePrePaidInstanceResultResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCreatePrePaidInstanceResultResponse() = default;
};
class DescribeDataDistResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataNames{};
  shared_ptr<string> dataVersions{};
  shared_ptr<vector<string>> ensRegionIds{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> maxDate{};
  shared_ptr<string> minDate{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeDataDistResultRequest() {}

  explicit DescribeDataDistResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataNames) {
      res["DataNames"] = boost::any(*dataNames);
    }
    if (dataVersions) {
      res["DataVersions"] = boost::any(*dataVersions);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = boost::any(*ensRegionIds);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (maxDate) {
      res["MaxDate"] = boost::any(*maxDate);
    }
    if (minDate) {
      res["MinDate"] = boost::any(*minDate);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataNames") != m.end() && !m["DataNames"].empty()) {
      dataNames = make_shared<string>(boost::any_cast<string>(m["DataNames"]));
    }
    if (m.find("DataVersions") != m.end() && !m["DataVersions"].empty()) {
      dataVersions = make_shared<string>(boost::any_cast<string>(m["DataVersions"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnsRegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnsRegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ensRegionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("MaxDate") != m.end() && !m["MaxDate"].empty()) {
      maxDate = make_shared<string>(boost::any_cast<string>(m["MaxDate"]));
    }
    if (m.find("MinDate") != m.end() && !m["MinDate"].empty()) {
      minDate = make_shared<string>(boost::any_cast<string>(m["MinDate"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeDataDistResultRequest() = default;
};
class DescribeDataDistResultShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataNames{};
  shared_ptr<string> dataVersions{};
  shared_ptr<string> ensRegionIdsShrink{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> maxDate{};
  shared_ptr<string> minDate{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeDataDistResultShrinkRequest() {}

  explicit DescribeDataDistResultShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataNames) {
      res["DataNames"] = boost::any(*dataNames);
    }
    if (dataVersions) {
      res["DataVersions"] = boost::any(*dataVersions);
    }
    if (ensRegionIdsShrink) {
      res["EnsRegionIds"] = boost::any(*ensRegionIdsShrink);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (maxDate) {
      res["MaxDate"] = boost::any(*maxDate);
    }
    if (minDate) {
      res["MinDate"] = boost::any(*minDate);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataNames") != m.end() && !m["DataNames"].empty()) {
      dataNames = make_shared<string>(boost::any_cast<string>(m["DataNames"]));
    }
    if (m.find("DataVersions") != m.end() && !m["DataVersions"].empty()) {
      dataVersions = make_shared<string>(boost::any_cast<string>(m["DataVersions"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      ensRegionIdsShrink = make_shared<string>(boost::any_cast<string>(m["EnsRegionIds"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("MaxDate") != m.end() && !m["MaxDate"].empty()) {
      maxDate = make_shared<string>(boost::any_cast<string>(m["MaxDate"]));
    }
    if (m.find("MinDate") != m.end() && !m["MinDate"].empty()) {
      minDate = make_shared<string>(boost::any_cast<string>(m["MinDate"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeDataDistResultShrinkRequest() = default;
};
class DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstancesInstance : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> statusDescrip{};
  shared_ptr<string> updateTime{};

  DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstancesInstance() {}

  explicit DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstancesInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (statusDescrip) {
      res["StatusDescrip"] = boost::any(*statusDescrip);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StatusDescrip") != m.end() && !m["StatusDescrip"].empty()) {
      statusDescrip = make_shared<string>(boost::any_cast<string>(m["StatusDescrip"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstancesInstance() = default;
};
class DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstancesInstance>> instance{};

  DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstances() {}

  explicit DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      vector<boost::any> temp1;
      for(auto item1:*instance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(vector<boost::any>) == m["Instance"].type()) {
        vector<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstancesInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstancesInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instance = make_shared<vector<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstancesInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstances() = default;
};
class DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStat : public Darabonba::Model {
public:
  shared_ptr<string> instanceCount{};
  shared_ptr<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstances> instances{};
  shared_ptr<string> status{};

  DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStat() {}

  explicit DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (instances) {
      res["Instances"] = instances ? boost::any(instances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<string>(boost::any_cast<string>(m["InstanceCount"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instances"].type()) {
        DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instances"]));
        instances = make_shared<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstances>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStat() = default;
};
class DescribeDataDistResultResponseBodyDistResultsDistResultStatusStats : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStat>> statusStat{};

  DescribeDataDistResultResponseBodyDistResultsDistResultStatusStats() {}

  explicit DescribeDataDistResultResponseBodyDistResultsDistResultStatusStats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (statusStat) {
      vector<boost::any> temp1;
      for(auto item1:*statusStat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StatusStat"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StatusStat") != m.end() && !m["StatusStat"].empty()) {
      if (typeid(vector<boost::any>) == m["StatusStat"].type()) {
        vector<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StatusStat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statusStat = make_shared<vector<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStat>>(expect1);
      }
    }
  }


  virtual ~DescribeDataDistResultResponseBodyDistResultsDistResultStatusStats() = default;
};
class DescribeDataDistResultResponseBodyDistResultsDistResult : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStats> statusStats{};
  shared_ptr<string> version{};

  DescribeDataDistResultResponseBodyDistResultsDistResult() {}

  explicit DescribeDataDistResultResponseBodyDistResultsDistResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (statusStats) {
      res["StatusStats"] = statusStats ? boost::any(statusStats->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StatusStats") != m.end() && !m["StatusStats"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatusStats"].type()) {
        DescribeDataDistResultResponseBodyDistResultsDistResultStatusStats model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatusStats"]));
        statusStats = make_shared<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStats>(model1);
      }
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeDataDistResultResponseBodyDistResultsDistResult() = default;
};
class DescribeDataDistResultResponseBodyDistResults : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDataDistResultResponseBodyDistResultsDistResult>> distResult{};

  DescribeDataDistResultResponseBodyDistResults() {}

  explicit DescribeDataDistResultResponseBodyDistResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distResult) {
      vector<boost::any> temp1;
      for(auto item1:*distResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DistResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistResult") != m.end() && !m["DistResult"].empty()) {
      if (typeid(vector<boost::any>) == m["DistResult"].type()) {
        vector<DescribeDataDistResultResponseBodyDistResultsDistResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DistResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataDistResultResponseBodyDistResultsDistResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        distResult = make_shared<vector<DescribeDataDistResultResponseBodyDistResultsDistResult>>(expect1);
      }
    }
  }


  virtual ~DescribeDataDistResultResponseBodyDistResults() = default;
};
class DescribeDataDistResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDataDistResultResponseBodyDistResults> distResults{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDataDistResultResponseBody() {}

  explicit DescribeDataDistResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distResults) {
      res["DistResults"] = distResults ? boost::any(distResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistResults") != m.end() && !m["DistResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["DistResults"].type()) {
        DescribeDataDistResultResponseBodyDistResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DistResults"]));
        distResults = make_shared<DescribeDataDistResultResponseBodyDistResults>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDataDistResultResponseBody() = default;
};
class DescribeDataDistResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDataDistResultResponseBody> body{};

  DescribeDataDistResultResponse() {}

  explicit DescribeDataDistResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDataDistResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDataDistResultResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDataDistResultResponse() = default;
};
class DescribeDataDownloadURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataName{};
  shared_ptr<string> dataVersion{};
  shared_ptr<long> expireTimeout{};
  shared_ptr<string> serverFilterStrategy{};

  DescribeDataDownloadURLRequest() {}

  explicit DescribeDataDownloadURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataName) {
      res["DataName"] = boost::any(*dataName);
    }
    if (dataVersion) {
      res["DataVersion"] = boost::any(*dataVersion);
    }
    if (expireTimeout) {
      res["ExpireTimeout"] = boost::any(*expireTimeout);
    }
    if (serverFilterStrategy) {
      res["ServerFilterStrategy"] = boost::any(*serverFilterStrategy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataName") != m.end() && !m["DataName"].empty()) {
      dataName = make_shared<string>(boost::any_cast<string>(m["DataName"]));
    }
    if (m.find("DataVersion") != m.end() && !m["DataVersion"].empty()) {
      dataVersion = make_shared<string>(boost::any_cast<string>(m["DataVersion"]));
    }
    if (m.find("ExpireTimeout") != m.end() && !m["ExpireTimeout"].empty()) {
      expireTimeout = make_shared<long>(boost::any_cast<long>(m["ExpireTimeout"]));
    }
    if (m.find("ServerFilterStrategy") != m.end() && !m["ServerFilterStrategy"].empty()) {
      serverFilterStrategy = make_shared<string>(boost::any_cast<string>(m["ServerFilterStrategy"]));
    }
  }


  virtual ~DescribeDataDownloadURLRequest() = default;
};
class DescribeDataDownloadURLResponseBodyDataServerList : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<string> regionId{};

  DescribeDataDownloadURLResponseBodyDataServerList() {}

  explicit DescribeDataDownloadURLResponseBodyDataServerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeDataDownloadURLResponseBodyDataServerList() = default;
};
class DescribeDataDownloadURLResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> expireTime{};
  shared_ptr<vector<DescribeDataDownloadURLResponseBodyDataServerList>> serverList{};
  shared_ptr<string> url{};

  DescribeDataDownloadURLResponseBodyData() {}

  explicit DescribeDataDownloadURLResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (serverList) {
      vector<boost::any> temp1;
      for(auto item1:*serverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServerList"] = boost::any(temp1);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("ServerList") != m.end() && !m["ServerList"].empty()) {
      if (typeid(vector<boost::any>) == m["ServerList"].type()) {
        vector<DescribeDataDownloadURLResponseBodyDataServerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServerList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataDownloadURLResponseBodyDataServerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serverList = make_shared<vector<DescribeDataDownloadURLResponseBodyDataServerList>>(expect1);
      }
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribeDataDownloadURLResponseBodyData() = default;
};
class DescribeDataDownloadURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeDataDownloadURLResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DescribeDataDownloadURLResponseBody() {}

  explicit DescribeDataDownloadURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeDataDownloadURLResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeDataDownloadURLResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDataDownloadURLResponseBody() = default;
};
class DescribeDataDownloadURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDataDownloadURLResponseBody> body{};

  DescribeDataDownloadURLResponse() {}

  explicit DescribeDataDownloadURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDataDownloadURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDataDownloadURLResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDataDownloadURLResponse() = default;
};
class DescribeDataPushResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataNames{};
  shared_ptr<string> dataVersions{};
  shared_ptr<string> maxDate{};
  shared_ptr<string> minDate{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionIds{};

  DescribeDataPushResultRequest() {}

  explicit DescribeDataPushResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataNames) {
      res["DataNames"] = boost::any(*dataNames);
    }
    if (dataVersions) {
      res["DataVersions"] = boost::any(*dataVersions);
    }
    if (maxDate) {
      res["MaxDate"] = boost::any(*maxDate);
    }
    if (minDate) {
      res["MinDate"] = boost::any(*minDate);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionIds) {
      res["RegionIds"] = boost::any(*regionIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataNames") != m.end() && !m["DataNames"].empty()) {
      dataNames = make_shared<string>(boost::any_cast<string>(m["DataNames"]));
    }
    if (m.find("DataVersions") != m.end() && !m["DataVersions"].empty()) {
      dataVersions = make_shared<string>(boost::any_cast<string>(m["DataVersions"]));
    }
    if (m.find("MaxDate") != m.end() && !m["MaxDate"].empty()) {
      maxDate = make_shared<string>(boost::any_cast<string>(m["MaxDate"]));
    }
    if (m.find("MinDate") != m.end() && !m["MinDate"].empty()) {
      minDate = make_shared<string>(boost::any_cast<string>(m["MinDate"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionIds") != m.end() && !m["RegionIds"].empty()) {
      regionIds = make_shared<string>(boost::any_cast<string>(m["RegionIds"]));
    }
  }


  virtual ~DescribeDataPushResultRequest() = default;
};
class DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIdsRegionId : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> statusDescrip{};
  shared_ptr<string> updateTime{};

  DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIdsRegionId() {}

  explicit DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIdsRegionId(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (statusDescrip) {
      res["StatusDescrip"] = boost::any(*statusDescrip);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StatusDescrip") != m.end() && !m["StatusDescrip"].empty()) {
      statusDescrip = make_shared<string>(boost::any_cast<string>(m["StatusDescrip"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIdsRegionId() = default;
};
class DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIds : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIdsRegionId>> regionId{};

  DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIds() {}

  explicit DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      vector<boost::any> temp1;
      for(auto item1:*regionId){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegionId"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      if (typeid(vector<boost::any>) == m["RegionId"].type()) {
        vector<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIdsRegionId> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegionId"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIdsRegionId model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regionId = make_shared<vector<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIdsRegionId>>(expect1);
      }
    }
  }


  virtual ~DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIds() = default;
};
class DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStat : public Darabonba::Model {
public:
  shared_ptr<long> regionIdCount{};
  shared_ptr<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIds> regionIds{};
  shared_ptr<string> status{};

  DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStat() {}

  explicit DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionIdCount) {
      res["RegionIdCount"] = boost::any(*regionIdCount);
    }
    if (regionIds) {
      res["RegionIds"] = regionIds ? boost::any(regionIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionIdCount") != m.end() && !m["RegionIdCount"].empty()) {
      regionIdCount = make_shared<long>(boost::any_cast<long>(m["RegionIdCount"]));
    }
    if (m.find("RegionIds") != m.end() && !m["RegionIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionIds"].type()) {
        DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionIds"]));
        regionIds = make_shared<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIds>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStat() = default;
};
class DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatS : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStat>> statusStat{};

  DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatS() {}

  explicit DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (statusStat) {
      vector<boost::any> temp1;
      for(auto item1:*statusStat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StatusStat"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StatusStat") != m.end() && !m["StatusStat"].empty()) {
      if (typeid(vector<boost::any>) == m["StatusStat"].type()) {
        vector<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StatusStat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statusStat = make_shared<vector<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStat>>(expect1);
      }
    }
  }


  virtual ~DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatS() = default;
};
class DescribeDataPushResultResponseBodyPushResultsPushResult : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatS> statusStatS{};
  shared_ptr<string> version{};

  DescribeDataPushResultResponseBodyPushResultsPushResult() {}

  explicit DescribeDataPushResultResponseBodyPushResultsPushResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (statusStatS) {
      res["StatusStatS"] = statusStatS ? boost::any(statusStatS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StatusStatS") != m.end() && !m["StatusStatS"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatusStatS"].type()) {
        DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatusStatS"]));
        statusStatS = make_shared<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatS>(model1);
      }
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeDataPushResultResponseBodyPushResultsPushResult() = default;
};
class DescribeDataPushResultResponseBodyPushResults : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDataPushResultResponseBodyPushResultsPushResult>> pushResult{};

  DescribeDataPushResultResponseBodyPushResults() {}

  explicit DescribeDataPushResultResponseBodyPushResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushResult) {
      vector<boost::any> temp1;
      for(auto item1:*pushResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PushResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushResult") != m.end() && !m["PushResult"].empty()) {
      if (typeid(vector<boost::any>) == m["PushResult"].type()) {
        vector<DescribeDataPushResultResponseBodyPushResultsPushResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PushResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataPushResultResponseBodyPushResultsPushResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pushResult = make_shared<vector<DescribeDataPushResultResponseBodyPushResultsPushResult>>(expect1);
      }
    }
  }


  virtual ~DescribeDataPushResultResponseBodyPushResults() = default;
};
class DescribeDataPushResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribeDataPushResultResponseBodyPushResults> pushResults{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDataPushResultResponseBody() {}

  explicit DescribeDataPushResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pushResults) {
      res["PushResults"] = pushResults ? boost::any(pushResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PushResults") != m.end() && !m["PushResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["PushResults"].type()) {
        DescribeDataPushResultResponseBodyPushResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PushResults"]));
        pushResults = make_shared<DescribeDataPushResultResponseBodyPushResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDataPushResultResponseBody() = default;
};
class DescribeDataPushResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDataPushResultResponseBody> body{};

  DescribeDataPushResultResponse() {}

  explicit DescribeDataPushResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDataPushResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDataPushResultResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDataPushResultResponse() = default;
};
class DescribeDeviceServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> orderId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> serviceId{};

  DescribeDeviceServiceRequest() {}

  explicit DescribeDeviceServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["ServiceId"]));
    }
  }


  virtual ~DescribeDeviceServiceRequest() = default;
};
class DescribeDeviceServiceResponseBodyAppMetaData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> appStableVersion{};
  shared_ptr<string> appType{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};

  DescribeDeviceServiceResponseBodyAppMetaData() {}

  explicit DescribeDeviceServiceResponseBodyAppMetaData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appStableVersion) {
      res["AppStableVersion"] = boost::any(*appStableVersion);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppStableVersion") != m.end() && !m["AppStableVersion"].empty()) {
      appStableVersion = make_shared<string>(boost::any_cast<string>(m["AppStableVersion"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~DescribeDeviceServiceResponseBodyAppMetaData() = default;
};
class DescribeDeviceServiceResponseBodyAppStatus : public Darabonba::Model {
public:
  shared_ptr<string> phase{};
  shared_ptr<string> statusDescrip{};
  shared_ptr<string> updateTime{};

  DescribeDeviceServiceResponseBodyAppStatus() {}

  explicit DescribeDeviceServiceResponseBodyAppStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (statusDescrip) {
      res["StatusDescrip"] = boost::any(*statusDescrip);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("StatusDescrip") != m.end() && !m["StatusDescrip"].empty()) {
      statusDescrip = make_shared<string>(boost::any_cast<string>(m["StatusDescrip"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeDeviceServiceResponseBodyAppStatus() = default;
};
class DescribeDeviceServiceResponseBodyResourceDetailInfos : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> ID{};
  shared_ptr<string> IP{};
  shared_ptr<string> ISP{};
  shared_ptr<string> imageID{};
  shared_ptr<string> mac{};
  shared_ptr<string> regionID{};
  shared_ptr<string> server{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeDeviceServiceResponseBodyResourceDetailInfos() {}

  explicit DescribeDeviceServiceResponseBodyResourceDetailInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (ID) {
      res["ID"] = boost::any(*ID);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (imageID) {
      res["ImageID"] = boost::any(*imageID);
    }
    if (mac) {
      res["Mac"] = boost::any(*mac);
    }
    if (regionID) {
      res["RegionID"] = boost::any(*regionID);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ID") != m.end() && !m["ID"].empty()) {
      ID = make_shared<string>(boost::any_cast<string>(m["ID"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("ImageID") != m.end() && !m["ImageID"].empty()) {
      imageID = make_shared<string>(boost::any_cast<string>(m["ImageID"]));
    }
    if (m.find("Mac") != m.end() && !m["Mac"].empty()) {
      mac = make_shared<string>(boost::any_cast<string>(m["Mac"]));
    }
    if (m.find("RegionID") != m.end() && !m["RegionID"].empty()) {
      regionID = make_shared<string>(boost::any_cast<string>(m["RegionID"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDeviceServiceResponseBodyResourceDetailInfos() = default;
};
class DescribeDeviceServiceResponseBodyResourceInfosDeviceInfosNetwork : public Darabonba::Model {
public:
  shared_ptr<string> containerPorts{};
  shared_ptr<string> externalIp{};
  shared_ptr<string> hostPorts{};
  shared_ptr<string> protocol{};

  DescribeDeviceServiceResponseBodyResourceInfosDeviceInfosNetwork() {}

  explicit DescribeDeviceServiceResponseBodyResourceInfosDeviceInfosNetwork(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerPorts) {
      res["ContainerPorts"] = boost::any(*containerPorts);
    }
    if (externalIp) {
      res["ExternalIp"] = boost::any(*externalIp);
    }
    if (hostPorts) {
      res["HostPorts"] = boost::any(*hostPorts);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerPorts") != m.end() && !m["ContainerPorts"].empty()) {
      containerPorts = make_shared<string>(boost::any_cast<string>(m["ContainerPorts"]));
    }
    if (m.find("ExternalIp") != m.end() && !m["ExternalIp"].empty()) {
      externalIp = make_shared<string>(boost::any_cast<string>(m["ExternalIp"]));
    }
    if (m.find("HostPorts") != m.end() && !m["HostPorts"].empty()) {
      hostPorts = make_shared<string>(boost::any_cast<string>(m["HostPorts"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~DescribeDeviceServiceResponseBodyResourceInfosDeviceInfosNetwork() = default;
};
class DescribeDeviceServiceResponseBodyResourceInfosDeviceInfos : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeDeviceServiceResponseBodyResourceInfosDeviceInfosNetwork>> network{};
  shared_ptr<string> status{};

  DescribeDeviceServiceResponseBodyResourceInfosDeviceInfos() {}

  explicit DescribeDeviceServiceResponseBodyResourceInfosDeviceInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (network) {
      vector<boost::any> temp1;
      for(auto item1:*network){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Network"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Network") != m.end() && !m["Network"].empty()) {
      if (typeid(vector<boost::any>) == m["Network"].type()) {
        vector<DescribeDeviceServiceResponseBodyResourceInfosDeviceInfosNetwork> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Network"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeviceServiceResponseBodyResourceInfosDeviceInfosNetwork model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        network = make_shared<vector<DescribeDeviceServiceResponseBodyResourceInfosDeviceInfosNetwork>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDeviceServiceResponseBodyResourceInfosDeviceInfos() = default;
};
class DescribeDeviceServiceResponseBodyResourceInfosInternalIps : public Darabonba::Model {
public:
  shared_ptr<string> ip{};

  DescribeDeviceServiceResponseBodyResourceInfosInternalIps() {}

  explicit DescribeDeviceServiceResponseBodyResourceInfosInternalIps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
  }


  virtual ~DescribeDeviceServiceResponseBodyResourceInfosInternalIps() = default;
};
class DescribeDeviceServiceResponseBodyResourceInfosPublicIps : public Darabonba::Model {
public:
  shared_ptr<string> ip{};

  DescribeDeviceServiceResponseBodyResourceInfosPublicIps() {}

  explicit DescribeDeviceServiceResponseBodyResourceInfosPublicIps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
  }


  virtual ~DescribeDeviceServiceResponseBodyResourceInfosPublicIps() = default;
};
class DescribeDeviceServiceResponseBodyResourceInfos : public Darabonba::Model {
public:
  shared_ptr<string> appVersion{};
  shared_ptr<string> areaCode{};
  shared_ptr<string> areaName{};
  shared_ptr<string> createTime{};
  shared_ptr<vector<DescribeDeviceServiceResponseBodyResourceInfosDeviceInfos>> deviceInfos{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceStatus{};
  shared_ptr<vector<DescribeDeviceServiceResponseBodyResourceInfosInternalIps>> internalIps{};
  shared_ptr<vector<DescribeDeviceServiceResponseBodyResourceInfosPublicIps>> publicIps{};
  shared_ptr<string> regionCode{};
  shared_ptr<string> regionId{};
  shared_ptr<string> regionName{};

  DescribeDeviceServiceResponseBodyResourceInfos() {}

  explicit DescribeDeviceServiceResponseBodyResourceInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (areaCode) {
      res["AreaCode"] = boost::any(*areaCode);
    }
    if (areaName) {
      res["AreaName"] = boost::any(*areaName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deviceInfos) {
      vector<boost::any> temp1;
      for(auto item1:*deviceInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceInfos"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceStatus) {
      res["InstanceStatus"] = boost::any(*instanceStatus);
    }
    if (internalIps) {
      vector<boost::any> temp1;
      for(auto item1:*internalIps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InternalIps"] = boost::any(temp1);
    }
    if (publicIps) {
      vector<boost::any> temp1;
      for(auto item1:*publicIps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PublicIps"] = boost::any(temp1);
    }
    if (regionCode) {
      res["RegionCode"] = boost::any(*regionCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("AreaCode") != m.end() && !m["AreaCode"].empty()) {
      areaCode = make_shared<string>(boost::any_cast<string>(m["AreaCode"]));
    }
    if (m.find("AreaName") != m.end() && !m["AreaName"].empty()) {
      areaName = make_shared<string>(boost::any_cast<string>(m["AreaName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeviceInfos") != m.end() && !m["DeviceInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceInfos"].type()) {
        vector<DescribeDeviceServiceResponseBodyResourceInfosDeviceInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeviceServiceResponseBodyResourceInfosDeviceInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceInfos = make_shared<vector<DescribeDeviceServiceResponseBodyResourceInfosDeviceInfos>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceStatus") != m.end() && !m["InstanceStatus"].empty()) {
      instanceStatus = make_shared<string>(boost::any_cast<string>(m["InstanceStatus"]));
    }
    if (m.find("InternalIps") != m.end() && !m["InternalIps"].empty()) {
      if (typeid(vector<boost::any>) == m["InternalIps"].type()) {
        vector<DescribeDeviceServiceResponseBodyResourceInfosInternalIps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InternalIps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeviceServiceResponseBodyResourceInfosInternalIps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        internalIps = make_shared<vector<DescribeDeviceServiceResponseBodyResourceInfosInternalIps>>(expect1);
      }
    }
    if (m.find("PublicIps") != m.end() && !m["PublicIps"].empty()) {
      if (typeid(vector<boost::any>) == m["PublicIps"].type()) {
        vector<DescribeDeviceServiceResponseBodyResourceInfosPublicIps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PublicIps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeviceServiceResponseBodyResourceInfosPublicIps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        publicIps = make_shared<vector<DescribeDeviceServiceResponseBodyResourceInfosPublicIps>>(expect1);
      }
    }
    if (m.find("RegionCode") != m.end() && !m["RegionCode"].empty()) {
      regionCode = make_shared<string>(boost::any_cast<string>(m["RegionCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
  }


  virtual ~DescribeDeviceServiceResponseBodyResourceInfos() = default;
};
class DescribeDeviceServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDeviceServiceResponseBodyAppMetaData> appMetaData{};
  shared_ptr<DescribeDeviceServiceResponseBodyAppStatus> appStatus{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDeviceServiceResponseBodyResourceDetailInfos>> resourceDetailInfos{};
  shared_ptr<vector<DescribeDeviceServiceResponseBodyResourceInfos>> resourceInfos{};

  DescribeDeviceServiceResponseBody() {}

  explicit DescribeDeviceServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appMetaData) {
      res["AppMetaData"] = appMetaData ? boost::any(appMetaData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (appStatus) {
      res["AppStatus"] = appStatus ? boost::any(appStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceDetailInfos) {
      vector<boost::any> temp1;
      for(auto item1:*resourceDetailInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceDetailInfos"] = boost::any(temp1);
    }
    if (resourceInfos) {
      vector<boost::any> temp1;
      for(auto item1:*resourceInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppMetaData") != m.end() && !m["AppMetaData"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppMetaData"].type()) {
        DescribeDeviceServiceResponseBodyAppMetaData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppMetaData"]));
        appMetaData = make_shared<DescribeDeviceServiceResponseBodyAppMetaData>(model1);
      }
    }
    if (m.find("AppStatus") != m.end() && !m["AppStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppStatus"].type()) {
        DescribeDeviceServiceResponseBodyAppStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppStatus"]));
        appStatus = make_shared<DescribeDeviceServiceResponseBodyAppStatus>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceDetailInfos") != m.end() && !m["ResourceDetailInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceDetailInfos"].type()) {
        vector<DescribeDeviceServiceResponseBodyResourceDetailInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceDetailInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeviceServiceResponseBodyResourceDetailInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceDetailInfos = make_shared<vector<DescribeDeviceServiceResponseBodyResourceDetailInfos>>(expect1);
      }
    }
    if (m.find("ResourceInfos") != m.end() && !m["ResourceInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceInfos"].type()) {
        vector<DescribeDeviceServiceResponseBodyResourceInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeviceServiceResponseBodyResourceInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceInfos = make_shared<vector<DescribeDeviceServiceResponseBodyResourceInfos>>(expect1);
      }
    }
  }


  virtual ~DescribeDeviceServiceResponseBody() = default;
};
class DescribeDeviceServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDeviceServiceResponseBody> body{};

  DescribeDeviceServiceResponse() {}

  explicit DescribeDeviceServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeviceServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeviceServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeviceServiceResponse() = default;
};
class DescribeDiskIopsListRequest : public Darabonba::Model {
public:
  shared_ptr<string> diskId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDiskIopsListRequest() {}

  explicit DescribeDiskIopsListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDiskIopsListRequest() = default;
};
class DescribeDiskIopsListResponseBodyDiskIopsList : public Darabonba::Model {
public:
  shared_ptr<string> bizTime{};
  shared_ptr<string> diskId{};
  shared_ptr<long> readBytes{};
  shared_ptr<long> readLatency{};
  shared_ptr<long> readOps{};
  shared_ptr<string> regionId{};
  shared_ptr<long> writeBytes{};
  shared_ptr<long> writeLatency{};
  shared_ptr<long> writeOps{};

  DescribeDiskIopsListResponseBodyDiskIopsList() {}

  explicit DescribeDiskIopsListResponseBodyDiskIopsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizTime) {
      res["BizTime"] = boost::any(*bizTime);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (readBytes) {
      res["ReadBytes"] = boost::any(*readBytes);
    }
    if (readLatency) {
      res["ReadLatency"] = boost::any(*readLatency);
    }
    if (readOps) {
      res["ReadOps"] = boost::any(*readOps);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (writeBytes) {
      res["WriteBytes"] = boost::any(*writeBytes);
    }
    if (writeLatency) {
      res["WriteLatency"] = boost::any(*writeLatency);
    }
    if (writeOps) {
      res["WriteOps"] = boost::any(*writeOps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizTime") != m.end() && !m["BizTime"].empty()) {
      bizTime = make_shared<string>(boost::any_cast<string>(m["BizTime"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("ReadBytes") != m.end() && !m["ReadBytes"].empty()) {
      readBytes = make_shared<long>(boost::any_cast<long>(m["ReadBytes"]));
    }
    if (m.find("ReadLatency") != m.end() && !m["ReadLatency"].empty()) {
      readLatency = make_shared<long>(boost::any_cast<long>(m["ReadLatency"]));
    }
    if (m.find("ReadOps") != m.end() && !m["ReadOps"].empty()) {
      readOps = make_shared<long>(boost::any_cast<long>(m["ReadOps"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("WriteBytes") != m.end() && !m["WriteBytes"].empty()) {
      writeBytes = make_shared<long>(boost::any_cast<long>(m["WriteBytes"]));
    }
    if (m.find("WriteLatency") != m.end() && !m["WriteLatency"].empty()) {
      writeLatency = make_shared<long>(boost::any_cast<long>(m["WriteLatency"]));
    }
    if (m.find("WriteOps") != m.end() && !m["WriteOps"].empty()) {
      writeOps = make_shared<long>(boost::any_cast<long>(m["WriteOps"]));
    }
  }


  virtual ~DescribeDiskIopsListResponseBodyDiskIopsList() = default;
};
class DescribeDiskIopsListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDiskIopsListResponseBodyDiskIopsList>> diskIopsList{};
  shared_ptr<string> requestId{};

  DescribeDiskIopsListResponseBody() {}

  explicit DescribeDiskIopsListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskIopsList) {
      vector<boost::any> temp1;
      for(auto item1:*diskIopsList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiskIopsList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskIopsList") != m.end() && !m["DiskIopsList"].empty()) {
      if (typeid(vector<boost::any>) == m["DiskIopsList"].type()) {
        vector<DescribeDiskIopsListResponseBodyDiskIopsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiskIopsList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDiskIopsListResponseBodyDiskIopsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diskIopsList = make_shared<vector<DescribeDiskIopsListResponseBodyDiskIopsList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDiskIopsListResponseBody() = default;
};
class DescribeDiskIopsListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDiskIopsListResponseBody> body{};

  DescribeDiskIopsListResponse() {}

  explicit DescribeDiskIopsListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDiskIopsListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDiskIopsListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDiskIopsListResponse() = default;
};
class DescribeDisksRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> diskChargeType{};
  shared_ptr<string> diskId{};
  shared_ptr<string> diskIds{};
  shared_ptr<string> diskName{};
  shared_ptr<string> diskType{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> ensRegionIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> orderByParams{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeDisksRequest() {}

  explicit DescribeDisksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (diskChargeType) {
      res["DiskChargeType"] = boost::any(*diskChargeType);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (diskIds) {
      res["DiskIds"] = boost::any(*diskIds);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = boost::any(*ensRegionIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (orderByParams) {
      res["OrderByParams"] = boost::any(*orderByParams);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DiskChargeType") != m.end() && !m["DiskChargeType"].empty()) {
      diskChargeType = make_shared<string>(boost::any_cast<string>(m["DiskChargeType"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("DiskIds") != m.end() && !m["DiskIds"].empty()) {
      diskIds = make_shared<string>(boost::any_cast<string>(m["DiskIds"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      ensRegionIds = make_shared<string>(boost::any_cast<string>(m["EnsRegionIds"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrderByParams") != m.end() && !m["OrderByParams"].empty()) {
      orderByParams = make_shared<string>(boost::any_cast<string>(m["OrderByParams"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDisksRequest() = default;
};
class DescribeDisksResponseBodyDisksDisksTagsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDisksResponseBodyDisksDisksTagsTags() {}

  explicit DescribeDisksResponseBodyDisksDisksTagsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDisksResponseBodyDisksDisksTagsTags() = default;
};
class DescribeDisksResponseBodyDisksDisksTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDisksResponseBodyDisksDisksTagsTags>> tags{};

  DescribeDisksResponseBodyDisksDisksTags() {}

  explicit DescribeDisksResponseBodyDisksDisksTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeDisksResponseBodyDisksDisksTagsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDisksResponseBodyDisksDisksTagsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeDisksResponseBodyDisksDisksTagsTags>>(expect1);
      }
    }
  }


  virtual ~DescribeDisksResponseBodyDisksDisksTags() = default;
};
class DescribeDisksResponseBodyDisksDisks : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> creationTime{};
  shared_ptr<bool> deleteWithInstance{};
  shared_ptr<string> description{};
  shared_ptr<string> diskChargeType{};
  shared_ptr<string> diskId{};
  shared_ptr<string> diskName{};
  shared_ptr<bool> encrypted{};
  shared_ptr<string> encryptedKeyId{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<bool> portable{};
  shared_ptr<string> serialId{};
  shared_ptr<long> size{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> status{};
  shared_ptr<DescribeDisksResponseBodyDisksDisksTags> tags{};
  shared_ptr<string> type{};

  DescribeDisksResponseBodyDisksDisks() {}

  explicit DescribeDisksResponseBodyDisksDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (diskChargeType) {
      res["DiskChargeType"] = boost::any(*diskChargeType);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (encryptedKeyId) {
      res["EncryptedKeyId"] = boost::any(*encryptedKeyId);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (portable) {
      res["Portable"] = boost::any(*portable);
    }
    if (serialId) {
      res["SerialId"] = boost::any(*serialId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<bool>(boost::any_cast<bool>(m["DeleteWithInstance"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DiskChargeType") != m.end() && !m["DiskChargeType"].empty()) {
      diskChargeType = make_shared<string>(boost::any_cast<string>(m["DiskChargeType"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["Encrypted"]));
    }
    if (m.find("EncryptedKeyId") != m.end() && !m["EncryptedKeyId"].empty()) {
      encryptedKeyId = make_shared<string>(boost::any_cast<string>(m["EncryptedKeyId"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Portable") != m.end() && !m["Portable"].empty()) {
      portable = make_shared<bool>(boost::any_cast<bool>(m["Portable"]));
    }
    if (m.find("SerialId") != m.end() && !m["SerialId"].empty()) {
      serialId = make_shared<string>(boost::any_cast<string>(m["SerialId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeDisksResponseBodyDisksDisksTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeDisksResponseBodyDisksDisksTags>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDisksResponseBodyDisksDisks() = default;
};
class DescribeDisksResponseBodyDisks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDisksResponseBodyDisksDisks>> disks{};

  DescribeDisksResponseBodyDisks() {}

  explicit DescribeDisksResponseBodyDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disks) {
      vector<boost::any> temp1;
      for(auto item1:*disks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Disks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Disks") != m.end() && !m["Disks"].empty()) {
      if (typeid(vector<boost::any>) == m["Disks"].type()) {
        vector<DescribeDisksResponseBodyDisksDisks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Disks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDisksResponseBodyDisksDisks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        disks = make_shared<vector<DescribeDisksResponseBodyDisksDisks>>(expect1);
      }
    }
  }


  virtual ~DescribeDisksResponseBodyDisks() = default;
};
class DescribeDisksResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeDisksResponseBodyDisks> disks{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDisksResponseBody() {}

  explicit DescribeDisksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (disks) {
      res["Disks"] = disks ? boost::any(disks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Disks") != m.end() && !m["Disks"].empty()) {
      if (typeid(map<string, boost::any>) == m["Disks"].type()) {
        DescribeDisksResponseBodyDisks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Disks"]));
        disks = make_shared<DescribeDisksResponseBodyDisks>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDisksResponseBody() = default;
};
class DescribeDisksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDisksResponseBody> body{};

  DescribeDisksResponse() {}

  explicit DescribeDisksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDisksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDisksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDisksResponse() = default;
};
class DescribeElbAvailableResourceInfoResponseBodyElbAvailableResourceInfo : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ability{};
  shared_ptr<string> area{};
  shared_ptr<string> canBuyCount{};
  shared_ptr<string> enName{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<vector<string>> loadBalancerSpec{};
  shared_ptr<string> name{};
  shared_ptr<string> province{};

  DescribeElbAvailableResourceInfoResponseBodyElbAvailableResourceInfo() {}

  explicit DescribeElbAvailableResourceInfoResponseBodyElbAvailableResourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ability) {
      res["Ability"] = boost::any(*ability);
    }
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (canBuyCount) {
      res["CanBuyCount"] = boost::any(*canBuyCount);
    }
    if (enName) {
      res["EnName"] = boost::any(*enName);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (loadBalancerSpec) {
      res["LoadBalancerSpec"] = boost::any(*loadBalancerSpec);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ability") != m.end() && !m["Ability"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ability"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ability"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ability = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("CanBuyCount") != m.end() && !m["CanBuyCount"].empty()) {
      canBuyCount = make_shared<string>(boost::any_cast<string>(m["CanBuyCount"]));
    }
    if (m.find("EnName") != m.end() && !m["EnName"].empty()) {
      enName = make_shared<string>(boost::any_cast<string>(m["EnName"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("LoadBalancerSpec") != m.end() && !m["LoadBalancerSpec"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LoadBalancerSpec"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LoadBalancerSpec"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      loadBalancerSpec = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~DescribeElbAvailableResourceInfoResponseBodyElbAvailableResourceInfo() = default;
};
class DescribeElbAvailableResourceInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeElbAvailableResourceInfoResponseBodyElbAvailableResourceInfo>> elbAvailableResourceInfo{};
  shared_ptr<string> requestId{};

  DescribeElbAvailableResourceInfoResponseBody() {}

  explicit DescribeElbAvailableResourceInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (elbAvailableResourceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*elbAvailableResourceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ElbAvailableResourceInfo"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ElbAvailableResourceInfo") != m.end() && !m["ElbAvailableResourceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ElbAvailableResourceInfo"].type()) {
        vector<DescribeElbAvailableResourceInfoResponseBodyElbAvailableResourceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ElbAvailableResourceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeElbAvailableResourceInfoResponseBodyElbAvailableResourceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        elbAvailableResourceInfo = make_shared<vector<DescribeElbAvailableResourceInfoResponseBodyElbAvailableResourceInfo>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeElbAvailableResourceInfoResponseBody() = default;
};
class DescribeElbAvailableResourceInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeElbAvailableResourceInfoResponseBody> body{};

  DescribeElbAvailableResourceInfoResponse() {}

  explicit DescribeElbAvailableResourceInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeElbAvailableResourceInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeElbAvailableResourceInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeElbAvailableResourceInfoResponse() = default;
};
class DescribeEnsCommodityCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};

  DescribeEnsCommodityCodeRequest() {}

  explicit DescribeEnsCommodityCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
  }


  virtual ~DescribeEnsCommodityCodeRequest() = default;
};
class DescribeEnsCommodityCodeResponseBodyCommodityCodeInfo : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<string> commodityName{};

  DescribeEnsCommodityCodeResponseBodyCommodityCodeInfo() {}

  explicit DescribeEnsCommodityCodeResponseBodyCommodityCodeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (commodityName) {
      res["CommodityName"] = boost::any(*commodityName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CommodityName") != m.end() && !m["CommodityName"].empty()) {
      commodityName = make_shared<string>(boost::any_cast<string>(m["CommodityName"]));
    }
  }


  virtual ~DescribeEnsCommodityCodeResponseBodyCommodityCodeInfo() = default;
};
class DescribeEnsCommodityCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEnsCommodityCodeResponseBodyCommodityCodeInfo>> commodityCodeInfo{};
  shared_ptr<string> requestId{};

  DescribeEnsCommodityCodeResponseBody() {}

  explicit DescribeEnsCommodityCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCodeInfo) {
      vector<boost::any> temp1;
      for(auto item1:*commodityCodeInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CommodityCodeInfo"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCodeInfo") != m.end() && !m["CommodityCodeInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["CommodityCodeInfo"].type()) {
        vector<DescribeEnsCommodityCodeResponseBodyCommodityCodeInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CommodityCodeInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsCommodityCodeResponseBodyCommodityCodeInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        commodityCodeInfo = make_shared<vector<DescribeEnsCommodityCodeResponseBodyCommodityCodeInfo>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEnsCommodityCodeResponseBody() = default;
};
class DescribeEnsCommodityCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnsCommodityCodeResponseBody> body{};

  DescribeEnsCommodityCodeResponse() {}

  explicit DescribeEnsCommodityCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsCommodityCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsCommodityCodeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsCommodityCodeResponse() = default;
};
class DescribeEnsCommodityModuleCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<string> moduleCode{};

  DescribeEnsCommodityModuleCodeRequest() {}

  explicit DescribeEnsCommodityModuleCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (moduleCode) {
      res["ModuleCode"] = boost::any(*moduleCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("ModuleCode") != m.end() && !m["ModuleCode"].empty()) {
      moduleCode = make_shared<string>(boost::any_cast<string>(m["ModuleCode"]));
    }
  }


  virtual ~DescribeEnsCommodityModuleCodeRequest() = default;
};
class DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfoModuleCodesInfo : public Darabonba::Model {
public:
  shared_ptr<string> moduleCode{};
  shared_ptr<string> moduleName{};

  DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfoModuleCodesInfo() {}

  explicit DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfoModuleCodesInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moduleCode) {
      res["ModuleCode"] = boost::any(*moduleCode);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModuleCode") != m.end() && !m["ModuleCode"].empty()) {
      moduleCode = make_shared<string>(boost::any_cast<string>(m["ModuleCode"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
  }


  virtual ~DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfoModuleCodesInfo() = default;
};
class DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfo : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<vector<DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfoModuleCodesInfo>> moduleCodesInfo{};

  DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfo() {}

  explicit DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (moduleCodesInfo) {
      vector<boost::any> temp1;
      for(auto item1:*moduleCodesInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ModuleCodesInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("ModuleCodesInfo") != m.end() && !m["ModuleCodesInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ModuleCodesInfo"].type()) {
        vector<DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfoModuleCodesInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ModuleCodesInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfoModuleCodesInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        moduleCodesInfo = make_shared<vector<DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfoModuleCodesInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfo() = default;
};
class DescribeEnsCommodityModuleCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfo>> commodityCodesInfo{};
  shared_ptr<string> requestId{};

  DescribeEnsCommodityModuleCodeResponseBody() {}

  explicit DescribeEnsCommodityModuleCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCodesInfo) {
      vector<boost::any> temp1;
      for(auto item1:*commodityCodesInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CommodityCodesInfo"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCodesInfo") != m.end() && !m["CommodityCodesInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["CommodityCodesInfo"].type()) {
        vector<DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CommodityCodesInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        commodityCodesInfo = make_shared<vector<DescribeEnsCommodityModuleCodeResponseBodyCommodityCodesInfo>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEnsCommodityModuleCodeResponseBody() = default;
};
class DescribeEnsCommodityModuleCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnsCommodityModuleCodeResponseBody> body{};

  DescribeEnsCommodityModuleCodeResponse() {}

  explicit DescribeEnsCommodityModuleCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsCommodityModuleCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsCommodityModuleCodeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsCommodityModuleCodeResponse() = default;
};
class DescribeEnsEipAddressesRequest : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> associatedInstanceId{};
  shared_ptr<string> associatedInstanceType{};
  shared_ptr<string> eipAddress{};
  shared_ptr<string> eipName{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<vector<string>> ensRegionIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> standby{};

  DescribeEnsEipAddressesRequest() {}

  explicit DescribeEnsEipAddressesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (associatedInstanceId) {
      res["AssociatedInstanceId"] = boost::any(*associatedInstanceId);
    }
    if (associatedInstanceType) {
      res["AssociatedInstanceType"] = boost::any(*associatedInstanceType);
    }
    if (eipAddress) {
      res["EipAddress"] = boost::any(*eipAddress);
    }
    if (eipName) {
      res["EipName"] = boost::any(*eipName);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = boost::any(*ensRegionIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (standby) {
      res["Standby"] = boost::any(*standby);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("AssociatedInstanceId") != m.end() && !m["AssociatedInstanceId"].empty()) {
      associatedInstanceId = make_shared<string>(boost::any_cast<string>(m["AssociatedInstanceId"]));
    }
    if (m.find("AssociatedInstanceType") != m.end() && !m["AssociatedInstanceType"].empty()) {
      associatedInstanceType = make_shared<string>(boost::any_cast<string>(m["AssociatedInstanceType"]));
    }
    if (m.find("EipAddress") != m.end() && !m["EipAddress"].empty()) {
      eipAddress = make_shared<string>(boost::any_cast<string>(m["EipAddress"]));
    }
    if (m.find("EipName") != m.end() && !m["EipName"].empty()) {
      eipName = make_shared<string>(boost::any_cast<string>(m["EipName"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnsRegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnsRegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ensRegionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Standby") != m.end() && !m["Standby"].empty()) {
      standby = make_shared<string>(boost::any_cast<string>(m["Standby"]));
    }
  }


  virtual ~DescribeEnsEipAddressesRequest() = default;
};
class DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};
  shared_ptr<string> value{};

  DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTagsTag() {}

  explicit DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTagsTag() = default;
};
class DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTagsTag>> tag{};

  DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTags() {}

  explicit DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTags() = default;
};
class DescribeEnsEipAddressesResponseBodyEipAddressesEipAddress : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> allocationTime{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> ipStatus{};
  shared_ptr<string> isp{};
  shared_ptr<string> name{};
  shared_ptr<bool> standby{};
  shared_ptr<string> status{};
  shared_ptr<DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTags> tags{};

  DescribeEnsEipAddressesResponseBodyEipAddressesEipAddress() {}

  explicit DescribeEnsEipAddressesResponseBodyEipAddressesEipAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (allocationTime) {
      res["AllocationTime"] = boost::any(*allocationTime);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (ipStatus) {
      res["IpStatus"] = boost::any(*ipStatus);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (standby) {
      res["Standby"] = boost::any(*standby);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("AllocationTime") != m.end() && !m["AllocationTime"].empty()) {
      allocationTime = make_shared<string>(boost::any_cast<string>(m["AllocationTime"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("IpStatus") != m.end() && !m["IpStatus"].empty()) {
      ipStatus = make_shared<string>(boost::any_cast<string>(m["IpStatus"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Standby") != m.end() && !m["Standby"].empty()) {
      standby = make_shared<bool>(boost::any_cast<bool>(m["Standby"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeEnsEipAddressesResponseBodyEipAddressesEipAddressTags>(model1);
      }
    }
  }


  virtual ~DescribeEnsEipAddressesResponseBodyEipAddressesEipAddress() = default;
};
class DescribeEnsEipAddressesResponseBodyEipAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEnsEipAddressesResponseBodyEipAddressesEipAddress>> eipAddress{};

  DescribeEnsEipAddressesResponseBodyEipAddresses() {}

  explicit DescribeEnsEipAddressesResponseBodyEipAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipAddress) {
      vector<boost::any> temp1;
      for(auto item1:*eipAddress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EipAddress"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipAddress") != m.end() && !m["EipAddress"].empty()) {
      if (typeid(vector<boost::any>) == m["EipAddress"].type()) {
        vector<DescribeEnsEipAddressesResponseBodyEipAddressesEipAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EipAddress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsEipAddressesResponseBodyEipAddressesEipAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eipAddress = make_shared<vector<DescribeEnsEipAddressesResponseBodyEipAddressesEipAddress>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsEipAddressesResponseBodyEipAddresses() = default;
};
class DescribeEnsEipAddressesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeEnsEipAddressesResponseBodyEipAddresses> eipAddresses{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeEnsEipAddressesResponseBody() {}

  explicit DescribeEnsEipAddressesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipAddresses) {
      res["EipAddresses"] = eipAddresses ? boost::any(eipAddresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipAddresses") != m.end() && !m["EipAddresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["EipAddresses"].type()) {
        DescribeEnsEipAddressesResponseBodyEipAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EipAddresses"]));
        eipAddresses = make_shared<DescribeEnsEipAddressesResponseBodyEipAddresses>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeEnsEipAddressesResponseBody() = default;
};
class DescribeEnsEipAddressesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnsEipAddressesResponseBody> body{};

  DescribeEnsEipAddressesResponse() {}

  explicit DescribeEnsEipAddressesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsEipAddressesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsEipAddressesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsEipAddressesResponse() = default;
};
class DescribeEnsNetDistrictRequest : public Darabonba::Model {
public:
  shared_ptr<string> netDistrictCode{};
  shared_ptr<string> netLevelCode{};

  DescribeEnsNetDistrictRequest() {}

  explicit DescribeEnsNetDistrictRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (netDistrictCode) {
      res["NetDistrictCode"] = boost::any(*netDistrictCode);
    }
    if (netLevelCode) {
      res["NetLevelCode"] = boost::any(*netLevelCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetDistrictCode") != m.end() && !m["NetDistrictCode"].empty()) {
      netDistrictCode = make_shared<string>(boost::any_cast<string>(m["NetDistrictCode"]));
    }
    if (m.find("NetLevelCode") != m.end() && !m["NetLevelCode"].empty()) {
      netLevelCode = make_shared<string>(boost::any_cast<string>(m["NetLevelCode"]));
    }
  }


  virtual ~DescribeEnsNetDistrictRequest() = default;
};
class DescribeEnsNetDistrictResponseBodyEnsNetDistrictsEnsNetDistrict : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionIdCount{};
  shared_ptr<string> netDistrictCode{};
  shared_ptr<string> netDistrictEnName{};
  shared_ptr<string> netDistrictFatherCode{};
  shared_ptr<string> netDistrictLevel{};
  shared_ptr<string> netDistrictName{};

  DescribeEnsNetDistrictResponseBodyEnsNetDistrictsEnsNetDistrict() {}

  explicit DescribeEnsNetDistrictResponseBodyEnsNetDistrictsEnsNetDistrict(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionIdCount) {
      res["EnsRegionIdCount"] = boost::any(*ensRegionIdCount);
    }
    if (netDistrictCode) {
      res["NetDistrictCode"] = boost::any(*netDistrictCode);
    }
    if (netDistrictEnName) {
      res["NetDistrictEnName"] = boost::any(*netDistrictEnName);
    }
    if (netDistrictFatherCode) {
      res["NetDistrictFatherCode"] = boost::any(*netDistrictFatherCode);
    }
    if (netDistrictLevel) {
      res["NetDistrictLevel"] = boost::any(*netDistrictLevel);
    }
    if (netDistrictName) {
      res["NetDistrictName"] = boost::any(*netDistrictName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionIdCount") != m.end() && !m["EnsRegionIdCount"].empty()) {
      ensRegionIdCount = make_shared<string>(boost::any_cast<string>(m["EnsRegionIdCount"]));
    }
    if (m.find("NetDistrictCode") != m.end() && !m["NetDistrictCode"].empty()) {
      netDistrictCode = make_shared<string>(boost::any_cast<string>(m["NetDistrictCode"]));
    }
    if (m.find("NetDistrictEnName") != m.end() && !m["NetDistrictEnName"].empty()) {
      netDistrictEnName = make_shared<string>(boost::any_cast<string>(m["NetDistrictEnName"]));
    }
    if (m.find("NetDistrictFatherCode") != m.end() && !m["NetDistrictFatherCode"].empty()) {
      netDistrictFatherCode = make_shared<string>(boost::any_cast<string>(m["NetDistrictFatherCode"]));
    }
    if (m.find("NetDistrictLevel") != m.end() && !m["NetDistrictLevel"].empty()) {
      netDistrictLevel = make_shared<string>(boost::any_cast<string>(m["NetDistrictLevel"]));
    }
    if (m.find("NetDistrictName") != m.end() && !m["NetDistrictName"].empty()) {
      netDistrictName = make_shared<string>(boost::any_cast<string>(m["NetDistrictName"]));
    }
  }


  virtual ~DescribeEnsNetDistrictResponseBodyEnsNetDistrictsEnsNetDistrict() = default;
};
class DescribeEnsNetDistrictResponseBodyEnsNetDistricts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEnsNetDistrictResponseBodyEnsNetDistrictsEnsNetDistrict>> ensNetDistrict{};

  DescribeEnsNetDistrictResponseBodyEnsNetDistricts() {}

  explicit DescribeEnsNetDistrictResponseBodyEnsNetDistricts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensNetDistrict) {
      vector<boost::any> temp1;
      for(auto item1:*ensNetDistrict){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnsNetDistrict"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsNetDistrict") != m.end() && !m["EnsNetDistrict"].empty()) {
      if (typeid(vector<boost::any>) == m["EnsNetDistrict"].type()) {
        vector<DescribeEnsNetDistrictResponseBodyEnsNetDistrictsEnsNetDistrict> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnsNetDistrict"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsNetDistrictResponseBodyEnsNetDistrictsEnsNetDistrict model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ensNetDistrict = make_shared<vector<DescribeEnsNetDistrictResponseBodyEnsNetDistrictsEnsNetDistrict>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsNetDistrictResponseBodyEnsNetDistricts() = default;
};
class DescribeEnsNetDistrictResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeEnsNetDistrictResponseBodyEnsNetDistricts> ensNetDistricts{};
  shared_ptr<string> requestId{};

  DescribeEnsNetDistrictResponseBody() {}

  explicit DescribeEnsNetDistrictResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (ensNetDistricts) {
      res["EnsNetDistricts"] = ensNetDistricts ? boost::any(ensNetDistricts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("EnsNetDistricts") != m.end() && !m["EnsNetDistricts"].empty()) {
      if (typeid(map<string, boost::any>) == m["EnsNetDistricts"].type()) {
        DescribeEnsNetDistrictResponseBodyEnsNetDistricts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EnsNetDistricts"]));
        ensNetDistricts = make_shared<DescribeEnsNetDistrictResponseBodyEnsNetDistricts>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEnsNetDistrictResponseBody() = default;
};
class DescribeEnsNetDistrictResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnsNetDistrictResponseBody> body{};

  DescribeEnsNetDistrictResponse() {}

  explicit DescribeEnsNetDistrictResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsNetDistrictResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsNetDistrictResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsNetDistrictResponse() = default;
};
class DescribeEnsNetLevelResponseBodyEnsNetLevelsEnsNetLevel : public Darabonba::Model {
public:
  shared_ptr<string> ensNetLevelCode{};

  DescribeEnsNetLevelResponseBodyEnsNetLevelsEnsNetLevel() {}

  explicit DescribeEnsNetLevelResponseBodyEnsNetLevelsEnsNetLevel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensNetLevelCode) {
      res["EnsNetLevelCode"] = boost::any(*ensNetLevelCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsNetLevelCode") != m.end() && !m["EnsNetLevelCode"].empty()) {
      ensNetLevelCode = make_shared<string>(boost::any_cast<string>(m["EnsNetLevelCode"]));
    }
  }


  virtual ~DescribeEnsNetLevelResponseBodyEnsNetLevelsEnsNetLevel() = default;
};
class DescribeEnsNetLevelResponseBodyEnsNetLevels : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEnsNetLevelResponseBodyEnsNetLevelsEnsNetLevel>> ensNetLevel{};

  DescribeEnsNetLevelResponseBodyEnsNetLevels() {}

  explicit DescribeEnsNetLevelResponseBodyEnsNetLevels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensNetLevel) {
      vector<boost::any> temp1;
      for(auto item1:*ensNetLevel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnsNetLevel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsNetLevel") != m.end() && !m["EnsNetLevel"].empty()) {
      if (typeid(vector<boost::any>) == m["EnsNetLevel"].type()) {
        vector<DescribeEnsNetLevelResponseBodyEnsNetLevelsEnsNetLevel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnsNetLevel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsNetLevelResponseBodyEnsNetLevelsEnsNetLevel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ensNetLevel = make_shared<vector<DescribeEnsNetLevelResponseBodyEnsNetLevelsEnsNetLevel>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsNetLevelResponseBodyEnsNetLevels() = default;
};
class DescribeEnsNetLevelResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeEnsNetLevelResponseBodyEnsNetLevels> ensNetLevels{};
  shared_ptr<string> requestId{};

  DescribeEnsNetLevelResponseBody() {}

  explicit DescribeEnsNetLevelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (ensNetLevels) {
      res["EnsNetLevels"] = ensNetLevels ? boost::any(ensNetLevels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("EnsNetLevels") != m.end() && !m["EnsNetLevels"].empty()) {
      if (typeid(map<string, boost::any>) == m["EnsNetLevels"].type()) {
        DescribeEnsNetLevelResponseBodyEnsNetLevels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EnsNetLevels"]));
        ensNetLevels = make_shared<DescribeEnsNetLevelResponseBodyEnsNetLevels>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEnsNetLevelResponseBody() = default;
};
class DescribeEnsNetLevelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnsNetLevelResponseBody> body{};

  DescribeEnsNetLevelResponse() {}

  explicit DescribeEnsNetLevelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsNetLevelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsNetLevelResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsNetLevelResponse() = default;
};
class DescribeEnsNetSaleDistrictRequest : public Darabonba::Model {
public:
  shared_ptr<string> netDistrictCode{};
  shared_ptr<string> netLevelCode{};

  DescribeEnsNetSaleDistrictRequest() {}

  explicit DescribeEnsNetSaleDistrictRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (netDistrictCode) {
      res["NetDistrictCode"] = boost::any(*netDistrictCode);
    }
    if (netLevelCode) {
      res["NetLevelCode"] = boost::any(*netLevelCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetDistrictCode") != m.end() && !m["NetDistrictCode"].empty()) {
      netDistrictCode = make_shared<string>(boost::any_cast<string>(m["NetDistrictCode"]));
    }
    if (m.find("NetLevelCode") != m.end() && !m["NetLevelCode"].empty()) {
      netLevelCode = make_shared<string>(boost::any_cast<string>(m["NetLevelCode"]));
    }
  }


  virtual ~DescribeEnsNetSaleDistrictRequest() = default;
};
class DescribeEnsNetSaleDistrictResponseBodyEnsNetDistrictsEnsNetDistrict : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionIdCount{};
  shared_ptr<string> instanceCount{};
  shared_ptr<string> netDistrictCode{};
  shared_ptr<string> netDistrictEnName{};
  shared_ptr<string> netDistrictFatherCode{};
  shared_ptr<string> netDistrictLevel{};
  shared_ptr<string> netDistrictName{};

  DescribeEnsNetSaleDistrictResponseBodyEnsNetDistrictsEnsNetDistrict() {}

  explicit DescribeEnsNetSaleDistrictResponseBodyEnsNetDistrictsEnsNetDistrict(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionIdCount) {
      res["EnsRegionIdCount"] = boost::any(*ensRegionIdCount);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (netDistrictCode) {
      res["NetDistrictCode"] = boost::any(*netDistrictCode);
    }
    if (netDistrictEnName) {
      res["NetDistrictEnName"] = boost::any(*netDistrictEnName);
    }
    if (netDistrictFatherCode) {
      res["NetDistrictFatherCode"] = boost::any(*netDistrictFatherCode);
    }
    if (netDistrictLevel) {
      res["NetDistrictLevel"] = boost::any(*netDistrictLevel);
    }
    if (netDistrictName) {
      res["NetDistrictName"] = boost::any(*netDistrictName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionIdCount") != m.end() && !m["EnsRegionIdCount"].empty()) {
      ensRegionIdCount = make_shared<string>(boost::any_cast<string>(m["EnsRegionIdCount"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<string>(boost::any_cast<string>(m["InstanceCount"]));
    }
    if (m.find("NetDistrictCode") != m.end() && !m["NetDistrictCode"].empty()) {
      netDistrictCode = make_shared<string>(boost::any_cast<string>(m["NetDistrictCode"]));
    }
    if (m.find("NetDistrictEnName") != m.end() && !m["NetDistrictEnName"].empty()) {
      netDistrictEnName = make_shared<string>(boost::any_cast<string>(m["NetDistrictEnName"]));
    }
    if (m.find("NetDistrictFatherCode") != m.end() && !m["NetDistrictFatherCode"].empty()) {
      netDistrictFatherCode = make_shared<string>(boost::any_cast<string>(m["NetDistrictFatherCode"]));
    }
    if (m.find("NetDistrictLevel") != m.end() && !m["NetDistrictLevel"].empty()) {
      netDistrictLevel = make_shared<string>(boost::any_cast<string>(m["NetDistrictLevel"]));
    }
    if (m.find("NetDistrictName") != m.end() && !m["NetDistrictName"].empty()) {
      netDistrictName = make_shared<string>(boost::any_cast<string>(m["NetDistrictName"]));
    }
  }


  virtual ~DescribeEnsNetSaleDistrictResponseBodyEnsNetDistrictsEnsNetDistrict() = default;
};
class DescribeEnsNetSaleDistrictResponseBodyEnsNetDistricts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEnsNetSaleDistrictResponseBodyEnsNetDistrictsEnsNetDistrict>> ensNetDistrict{};

  DescribeEnsNetSaleDistrictResponseBodyEnsNetDistricts() {}

  explicit DescribeEnsNetSaleDistrictResponseBodyEnsNetDistricts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensNetDistrict) {
      vector<boost::any> temp1;
      for(auto item1:*ensNetDistrict){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnsNetDistrict"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsNetDistrict") != m.end() && !m["EnsNetDistrict"].empty()) {
      if (typeid(vector<boost::any>) == m["EnsNetDistrict"].type()) {
        vector<DescribeEnsNetSaleDistrictResponseBodyEnsNetDistrictsEnsNetDistrict> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnsNetDistrict"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsNetSaleDistrictResponseBodyEnsNetDistrictsEnsNetDistrict model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ensNetDistrict = make_shared<vector<DescribeEnsNetSaleDistrictResponseBodyEnsNetDistrictsEnsNetDistrict>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsNetSaleDistrictResponseBodyEnsNetDistricts() = default;
};
class DescribeEnsNetSaleDistrictResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeEnsNetSaleDistrictResponseBodyEnsNetDistricts> ensNetDistricts{};
  shared_ptr<string> requestId{};

  DescribeEnsNetSaleDistrictResponseBody() {}

  explicit DescribeEnsNetSaleDistrictResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (ensNetDistricts) {
      res["EnsNetDistricts"] = ensNetDistricts ? boost::any(ensNetDistricts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("EnsNetDistricts") != m.end() && !m["EnsNetDistricts"].empty()) {
      if (typeid(map<string, boost::any>) == m["EnsNetDistricts"].type()) {
        DescribeEnsNetSaleDistrictResponseBodyEnsNetDistricts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EnsNetDistricts"]));
        ensNetDistricts = make_shared<DescribeEnsNetSaleDistrictResponseBodyEnsNetDistricts>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEnsNetSaleDistrictResponseBody() = default;
};
class DescribeEnsNetSaleDistrictResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnsNetSaleDistrictResponseBody> body{};

  DescribeEnsNetSaleDistrictResponse() {}

  explicit DescribeEnsNetSaleDistrictResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsNetSaleDistrictResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsNetSaleDistrictResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsNetSaleDistrictResponse() = default;
};
class DescribeEnsRegionIdIpv6InfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};

  DescribeEnsRegionIdIpv6InfoRequest() {}

  explicit DescribeEnsRegionIdIpv6InfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
  }


  virtual ~DescribeEnsRegionIdIpv6InfoRequest() = default;
};
class DescribeEnsRegionIdIpv6InfoResponseBodySupportIpv6Info : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<bool> supportIpv6{};

  DescribeEnsRegionIdIpv6InfoResponseBodySupportIpv6Info() {}

  explicit DescribeEnsRegionIdIpv6InfoResponseBodySupportIpv6Info(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (supportIpv6) {
      res["SupportIpv6"] = boost::any(*supportIpv6);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("SupportIpv6") != m.end() && !m["SupportIpv6"].empty()) {
      supportIpv6 = make_shared<bool>(boost::any_cast<bool>(m["SupportIpv6"]));
    }
  }


  virtual ~DescribeEnsRegionIdIpv6InfoResponseBodySupportIpv6Info() = default;
};
class DescribeEnsRegionIdIpv6InfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeEnsRegionIdIpv6InfoResponseBodySupportIpv6Info> supportIpv6Info{};

  DescribeEnsRegionIdIpv6InfoResponseBody() {}

  explicit DescribeEnsRegionIdIpv6InfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (supportIpv6Info) {
      res["SupportIpv6Info"] = supportIpv6Info ? boost::any(supportIpv6Info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SupportIpv6Info") != m.end() && !m["SupportIpv6Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportIpv6Info"].type()) {
        DescribeEnsRegionIdIpv6InfoResponseBodySupportIpv6Info model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportIpv6Info"]));
        supportIpv6Info = make_shared<DescribeEnsRegionIdIpv6InfoResponseBodySupportIpv6Info>(model1);
      }
    }
  }


  virtual ~DescribeEnsRegionIdIpv6InfoResponseBody() = default;
};
class DescribeEnsRegionIdIpv6InfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnsRegionIdIpv6InfoResponseBody> body{};

  DescribeEnsRegionIdIpv6InfoResponse() {}

  explicit DescribeEnsRegionIdIpv6InfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsRegionIdIpv6InfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsRegionIdIpv6InfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsRegionIdIpv6InfoResponse() = default;
};
class DescribeEnsRegionIdResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> isp{};
  shared_ptr<string> orderByParams{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> startTime{};

  DescribeEnsRegionIdResourceRequest() {}

  explicit DescribeEnsRegionIdResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (orderByParams) {
      res["OrderByParams"] = boost::any(*orderByParams);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("OrderByParams") != m.end() && !m["OrderByParams"].empty()) {
      orderByParams = make_shared<string>(boost::any_cast<string>(m["OrderByParams"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeEnsRegionIdResourceRequest() = default;
};
class DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResourcesEnsRegionIdResource : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> areaCode{};
  shared_ptr<string> bizDate{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> ensRegionIdName{};
  shared_ptr<long> instanceCount{};
  shared_ptr<long> internetBandwidth{};
  shared_ptr<string> isp{};
  shared_ptr<long> VCpu{};

  DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResourcesEnsRegionIdResource() {}

  explicit DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResourcesEnsRegionIdResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (areaCode) {
      res["AreaCode"] = boost::any(*areaCode);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionIdName) {
      res["EnsRegionIdName"] = boost::any(*ensRegionIdName);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (internetBandwidth) {
      res["InternetBandwidth"] = boost::any(*internetBandwidth);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (VCpu) {
      res["VCpu"] = boost::any(*VCpu);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("AreaCode") != m.end() && !m["AreaCode"].empty()) {
      areaCode = make_shared<string>(boost::any_cast<string>(m["AreaCode"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionIdName") != m.end() && !m["EnsRegionIdName"].empty()) {
      ensRegionIdName = make_shared<string>(boost::any_cast<string>(m["EnsRegionIdName"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("InternetBandwidth") != m.end() && !m["InternetBandwidth"].empty()) {
      internetBandwidth = make_shared<long>(boost::any_cast<long>(m["InternetBandwidth"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("VCpu") != m.end() && !m["VCpu"].empty()) {
      VCpu = make_shared<long>(boost::any_cast<long>(m["VCpu"]));
    }
  }


  virtual ~DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResourcesEnsRegionIdResource() = default;
};
class DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResourcesEnsRegionIdResource>> ensRegionIdResource{};

  DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResources() {}

  explicit DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionIdResource) {
      vector<boost::any> temp1;
      for(auto item1:*ensRegionIdResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnsRegionIdResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionIdResource") != m.end() && !m["EnsRegionIdResource"].empty()) {
      if (typeid(vector<boost::any>) == m["EnsRegionIdResource"].type()) {
        vector<DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResourcesEnsRegionIdResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnsRegionIdResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResourcesEnsRegionIdResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ensRegionIdResource = make_shared<vector<DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResourcesEnsRegionIdResource>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResources() = default;
};
class DescribeEnsRegionIdResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResources> ensRegionIdResources{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeEnsRegionIdResourceResponseBody() {}

  explicit DescribeEnsRegionIdResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionIdResources) {
      res["EnsRegionIdResources"] = ensRegionIdResources ? boost::any(ensRegionIdResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionIdResources") != m.end() && !m["EnsRegionIdResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["EnsRegionIdResources"].type()) {
        DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EnsRegionIdResources"]));
        ensRegionIdResources = make_shared<DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResources>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeEnsRegionIdResourceResponseBody() = default;
};
class DescribeEnsRegionIdResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnsRegionIdResourceResponseBody> body{};

  DescribeEnsRegionIdResourceResponse() {}

  explicit DescribeEnsRegionIdResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsRegionIdResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsRegionIdResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsRegionIdResourceResponse() = default;
};
class DescribeEnsRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};

  DescribeEnsRegionsRequest() {}

  explicit DescribeEnsRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
  }


  virtual ~DescribeEnsRegionsRequest() = default;
};
class DescribeEnsRegionsResponseBodyEnsRegionsEnsRegions : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> enName{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> name{};
  shared_ptr<string> province{};

  DescribeEnsRegionsResponseBodyEnsRegionsEnsRegions() {}

  explicit DescribeEnsRegionsResponseBodyEnsRegionsEnsRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (enName) {
      res["EnName"] = boost::any(*enName);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("EnName") != m.end() && !m["EnName"].empty()) {
      enName = make_shared<string>(boost::any_cast<string>(m["EnName"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~DescribeEnsRegionsResponseBodyEnsRegionsEnsRegions() = default;
};
class DescribeEnsRegionsResponseBodyEnsRegions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEnsRegionsResponseBodyEnsRegionsEnsRegions>> ensRegions{};

  DescribeEnsRegionsResponseBodyEnsRegions() {}

  explicit DescribeEnsRegionsResponseBodyEnsRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegions) {
      vector<boost::any> temp1;
      for(auto item1:*ensRegions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnsRegions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegions") != m.end() && !m["EnsRegions"].empty()) {
      if (typeid(vector<boost::any>) == m["EnsRegions"].type()) {
        vector<DescribeEnsRegionsResponseBodyEnsRegionsEnsRegions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnsRegions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsRegionsResponseBodyEnsRegionsEnsRegions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ensRegions = make_shared<vector<DescribeEnsRegionsResponseBodyEnsRegionsEnsRegions>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsRegionsResponseBodyEnsRegions() = default;
};
class DescribeEnsRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeEnsRegionsResponseBodyEnsRegions> ensRegions{};
  shared_ptr<string> requestId{};

  DescribeEnsRegionsResponseBody() {}

  explicit DescribeEnsRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (ensRegions) {
      res["EnsRegions"] = ensRegions ? boost::any(ensRegions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("EnsRegions") != m.end() && !m["EnsRegions"].empty()) {
      if (typeid(map<string, boost::any>) == m["EnsRegions"].type()) {
        DescribeEnsRegionsResponseBodyEnsRegions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EnsRegions"]));
        ensRegions = make_shared<DescribeEnsRegionsResponseBodyEnsRegions>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEnsRegionsResponseBody() = default;
};
class DescribeEnsRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnsRegionsResponseBody> body{};

  DescribeEnsRegionsResponse() {}

  explicit DescribeEnsRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsRegionsResponse() = default;
};
class DescribeEnsResourceUsageRequest : public Darabonba::Model {
public:
  shared_ptr<string> expiredEndTime{};
  shared_ptr<string> expiredStartTime{};

  DescribeEnsResourceUsageRequest() {}

  explicit DescribeEnsResourceUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expiredEndTime) {
      res["ExpiredEndTime"] = boost::any(*expiredEndTime);
    }
    if (expiredStartTime) {
      res["ExpiredStartTime"] = boost::any(*expiredStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpiredEndTime") != m.end() && !m["ExpiredEndTime"].empty()) {
      expiredEndTime = make_shared<string>(boost::any_cast<string>(m["ExpiredEndTime"]));
    }
    if (m.find("ExpiredStartTime") != m.end() && !m["ExpiredStartTime"].empty()) {
      expiredStartTime = make_shared<string>(boost::any_cast<string>(m["ExpiredStartTime"]));
    }
  }


  virtual ~DescribeEnsResourceUsageRequest() = default;
};
class DescribeEnsResourceUsageResponseBodyEnsResourceUsage : public Darabonba::Model {
public:
  shared_ptr<long> computeResourceCount{};
  shared_ptr<long> cpuSum{};
  shared_ptr<long> diskCount{};
  shared_ptr<long> downCount{};
  shared_ptr<long> expiredCount{};
  shared_ptr<long> expiringCount{};
  shared_ptr<long> gpuSum{};
  shared_ptr<long> instanceCount{};
  shared_ptr<long> runningCount{};
  shared_ptr<string> serviceType{};
  shared_ptr<long> storageSum{};

  DescribeEnsResourceUsageResponseBodyEnsResourceUsage() {}

  explicit DescribeEnsResourceUsageResponseBodyEnsResourceUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (computeResourceCount) {
      res["ComputeResourceCount"] = boost::any(*computeResourceCount);
    }
    if (cpuSum) {
      res["CpuSum"] = boost::any(*cpuSum);
    }
    if (diskCount) {
      res["DiskCount"] = boost::any(*diskCount);
    }
    if (downCount) {
      res["DownCount"] = boost::any(*downCount);
    }
    if (expiredCount) {
      res["ExpiredCount"] = boost::any(*expiredCount);
    }
    if (expiringCount) {
      res["ExpiringCount"] = boost::any(*expiringCount);
    }
    if (gpuSum) {
      res["GpuSum"] = boost::any(*gpuSum);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (runningCount) {
      res["RunningCount"] = boost::any(*runningCount);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (storageSum) {
      res["StorageSum"] = boost::any(*storageSum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComputeResourceCount") != m.end() && !m["ComputeResourceCount"].empty()) {
      computeResourceCount = make_shared<long>(boost::any_cast<long>(m["ComputeResourceCount"]));
    }
    if (m.find("CpuSum") != m.end() && !m["CpuSum"].empty()) {
      cpuSum = make_shared<long>(boost::any_cast<long>(m["CpuSum"]));
    }
    if (m.find("DiskCount") != m.end() && !m["DiskCount"].empty()) {
      diskCount = make_shared<long>(boost::any_cast<long>(m["DiskCount"]));
    }
    if (m.find("DownCount") != m.end() && !m["DownCount"].empty()) {
      downCount = make_shared<long>(boost::any_cast<long>(m["DownCount"]));
    }
    if (m.find("ExpiredCount") != m.end() && !m["ExpiredCount"].empty()) {
      expiredCount = make_shared<long>(boost::any_cast<long>(m["ExpiredCount"]));
    }
    if (m.find("ExpiringCount") != m.end() && !m["ExpiringCount"].empty()) {
      expiringCount = make_shared<long>(boost::any_cast<long>(m["ExpiringCount"]));
    }
    if (m.find("GpuSum") != m.end() && !m["GpuSum"].empty()) {
      gpuSum = make_shared<long>(boost::any_cast<long>(m["GpuSum"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("RunningCount") != m.end() && !m["RunningCount"].empty()) {
      runningCount = make_shared<long>(boost::any_cast<long>(m["RunningCount"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("StorageSum") != m.end() && !m["StorageSum"].empty()) {
      storageSum = make_shared<long>(boost::any_cast<long>(m["StorageSum"]));
    }
  }


  virtual ~DescribeEnsResourceUsageResponseBodyEnsResourceUsage() = default;
};
class DescribeEnsResourceUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEnsResourceUsageResponseBodyEnsResourceUsage>> ensResourceUsage{};
  shared_ptr<string> requestId{};

  DescribeEnsResourceUsageResponseBody() {}

  explicit DescribeEnsResourceUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensResourceUsage) {
      vector<boost::any> temp1;
      for(auto item1:*ensResourceUsage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnsResourceUsage"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsResourceUsage") != m.end() && !m["EnsResourceUsage"].empty()) {
      if (typeid(vector<boost::any>) == m["EnsResourceUsage"].type()) {
        vector<DescribeEnsResourceUsageResponseBodyEnsResourceUsage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnsResourceUsage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsResourceUsageResponseBodyEnsResourceUsage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ensResourceUsage = make_shared<vector<DescribeEnsResourceUsageResponseBodyEnsResourceUsage>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEnsResourceUsageResponseBody() = default;
};
class DescribeEnsResourceUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnsResourceUsageResponseBody> body{};

  DescribeEnsResourceUsageResponse() {}

  explicit DescribeEnsResourceUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsResourceUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsResourceUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsResourceUsageResponse() = default;
};
class DescribeEnsRouteEntryListRequest : public Darabonba::Model {
public:
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> nextHopId{};
  shared_ptr<string> nextHopType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> routeEntryId{};
  shared_ptr<string> routeEntryName{};
  shared_ptr<string> routeEntryType{};
  shared_ptr<string> routeTableId{};

  DescribeEnsRouteEntryListRequest() {}

  explicit DescribeEnsRouteEntryListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (nextHopId) {
      res["NextHopId"] = boost::any(*nextHopId);
    }
    if (nextHopType) {
      res["NextHopType"] = boost::any(*nextHopType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (routeEntryId) {
      res["RouteEntryId"] = boost::any(*routeEntryId);
    }
    if (routeEntryName) {
      res["RouteEntryName"] = boost::any(*routeEntryName);
    }
    if (routeEntryType) {
      res["RouteEntryType"] = boost::any(*routeEntryType);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("NextHopId") != m.end() && !m["NextHopId"].empty()) {
      nextHopId = make_shared<string>(boost::any_cast<string>(m["NextHopId"]));
    }
    if (m.find("NextHopType") != m.end() && !m["NextHopType"].empty()) {
      nextHopType = make_shared<string>(boost::any_cast<string>(m["NextHopType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RouteEntryId") != m.end() && !m["RouteEntryId"].empty()) {
      routeEntryId = make_shared<string>(boost::any_cast<string>(m["RouteEntryId"]));
    }
    if (m.find("RouteEntryName") != m.end() && !m["RouteEntryName"].empty()) {
      routeEntryName = make_shared<string>(boost::any_cast<string>(m["RouteEntryName"]));
    }
    if (m.find("RouteEntryType") != m.end() && !m["RouteEntryType"].empty()) {
      routeEntryType = make_shared<string>(boost::any_cast<string>(m["RouteEntryType"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
  }


  virtual ~DescribeEnsRouteEntryListRequest() = default;
};
class DescribeEnsRouteEntryListResponseBodyRouteEntrysNextHops : public Darabonba::Model {
public:
  shared_ptr<string> nextHopId{};
  shared_ptr<string> nextHopName{};
  shared_ptr<string> nextHopType{};

  DescribeEnsRouteEntryListResponseBodyRouteEntrysNextHops() {}

  explicit DescribeEnsRouteEntryListResponseBodyRouteEntrysNextHops(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextHopId) {
      res["NextHopId"] = boost::any(*nextHopId);
    }
    if (nextHopName) {
      res["NextHopName"] = boost::any(*nextHopName);
    }
    if (nextHopType) {
      res["NextHopType"] = boost::any(*nextHopType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextHopId") != m.end() && !m["NextHopId"].empty()) {
      nextHopId = make_shared<string>(boost::any_cast<string>(m["NextHopId"]));
    }
    if (m.find("NextHopName") != m.end() && !m["NextHopName"].empty()) {
      nextHopName = make_shared<string>(boost::any_cast<string>(m["NextHopName"]));
    }
    if (m.find("NextHopType") != m.end() && !m["NextHopType"].empty()) {
      nextHopType = make_shared<string>(boost::any_cast<string>(m["NextHopType"]));
    }
  }


  virtual ~DescribeEnsRouteEntryListResponseBodyRouteEntrysNextHops() = default;
};
class DescribeEnsRouteEntryListResponseBodyRouteEntrys : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<vector<DescribeEnsRouteEntryListResponseBodyRouteEntrysNextHops>> nextHops{};
  shared_ptr<string> routeEntryId{};
  shared_ptr<string> routeEntryName{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> sourceCidrBlock{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeEnsRouteEntryListResponseBodyRouteEntrys() {}

  explicit DescribeEnsRouteEntryListResponseBodyRouteEntrys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (nextHops) {
      vector<boost::any> temp1;
      for(auto item1:*nextHops){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NextHops"] = boost::any(temp1);
    }
    if (routeEntryId) {
      res["RouteEntryId"] = boost::any(*routeEntryId);
    }
    if (routeEntryName) {
      res["RouteEntryName"] = boost::any(*routeEntryName);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (sourceCidrBlock) {
      res["SourceCidrBlock"] = boost::any(*sourceCidrBlock);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("NextHops") != m.end() && !m["NextHops"].empty()) {
      if (typeid(vector<boost::any>) == m["NextHops"].type()) {
        vector<DescribeEnsRouteEntryListResponseBodyRouteEntrysNextHops> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NextHops"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsRouteEntryListResponseBodyRouteEntrysNextHops model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nextHops = make_shared<vector<DescribeEnsRouteEntryListResponseBodyRouteEntrysNextHops>>(expect1);
      }
    }
    if (m.find("RouteEntryId") != m.end() && !m["RouteEntryId"].empty()) {
      routeEntryId = make_shared<string>(boost::any_cast<string>(m["RouteEntryId"]));
    }
    if (m.find("RouteEntryName") != m.end() && !m["RouteEntryName"].empty()) {
      routeEntryName = make_shared<string>(boost::any_cast<string>(m["RouteEntryName"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("SourceCidrBlock") != m.end() && !m["SourceCidrBlock"].empty()) {
      sourceCidrBlock = make_shared<string>(boost::any_cast<string>(m["SourceCidrBlock"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeEnsRouteEntryListResponseBodyRouteEntrys() = default;
};
class DescribeEnsRouteEntryListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeEnsRouteEntryListResponseBodyRouteEntrys>> routeEntrys{};
  shared_ptr<long> totalCount{};

  DescribeEnsRouteEntryListResponseBody() {}

  explicit DescribeEnsRouteEntryListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routeEntrys) {
      vector<boost::any> temp1;
      for(auto item1:*routeEntrys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouteEntrys"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouteEntrys") != m.end() && !m["RouteEntrys"].empty()) {
      if (typeid(vector<boost::any>) == m["RouteEntrys"].type()) {
        vector<DescribeEnsRouteEntryListResponseBodyRouteEntrys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouteEntrys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsRouteEntryListResponseBodyRouteEntrys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeEntrys = make_shared<vector<DescribeEnsRouteEntryListResponseBodyRouteEntrys>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeEnsRouteEntryListResponseBody() = default;
};
class DescribeEnsRouteEntryListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnsRouteEntryListResponseBody> body{};

  DescribeEnsRouteEntryListResponse() {}

  explicit DescribeEnsRouteEntryListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsRouteEntryListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsRouteEntryListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsRouteEntryListResponse() = default;
};
class DescribeEnsRouteTablesRequest : public Darabonba::Model {
public:
  shared_ptr<string> associateType{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<vector<string>> ensRegionIds{};
  shared_ptr<string> networkId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> routeTableName{};
  shared_ptr<string> type{};

  DescribeEnsRouteTablesRequest() {}

  explicit DescribeEnsRouteTablesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associateType) {
      res["AssociateType"] = boost::any(*associateType);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = boost::any(*ensRegionIds);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (routeTableName) {
      res["RouteTableName"] = boost::any(*routeTableName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociateType") != m.end() && !m["AssociateType"].empty()) {
      associateType = make_shared<string>(boost::any_cast<string>(m["AssociateType"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnsRegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnsRegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ensRegionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("RouteTableName") != m.end() && !m["RouteTableName"].empty()) {
      routeTableName = make_shared<string>(boost::any_cast<string>(m["RouteTableName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeEnsRouteTablesRequest() = default;
};
class DescribeEnsRouteTablesResponseBodyRouteTables : public Darabonba::Model {
public:
  shared_ptr<string> associateType{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<bool> isDefaultGatewayRouteTable{};
  shared_ptr<string> networkId{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> routeTableName{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<vector<string>> vSwitchIds{};

  DescribeEnsRouteTablesResponseBodyRouteTables() {}

  explicit DescribeEnsRouteTablesResponseBodyRouteTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associateType) {
      res["AssociateType"] = boost::any(*associateType);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (isDefaultGatewayRouteTable) {
      res["IsDefaultGatewayRouteTable"] = boost::any(*isDefaultGatewayRouteTable);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (routeTableName) {
      res["RouteTableName"] = boost::any(*routeTableName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociateType") != m.end() && !m["AssociateType"].empty()) {
      associateType = make_shared<string>(boost::any_cast<string>(m["AssociateType"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("IsDefaultGatewayRouteTable") != m.end() && !m["IsDefaultGatewayRouteTable"].empty()) {
      isDefaultGatewayRouteTable = make_shared<bool>(boost::any_cast<bool>(m["IsDefaultGatewayRouteTable"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("RouteTableName") != m.end() && !m["RouteTableName"].empty()) {
      routeTableName = make_shared<string>(boost::any_cast<string>(m["RouteTableName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeEnsRouteTablesResponseBodyRouteTables() = default;
};
class DescribeEnsRouteTablesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeEnsRouteTablesResponseBodyRouteTables>> routeTables{};
  shared_ptr<long> totalCount{};

  DescribeEnsRouteTablesResponseBody() {}

  explicit DescribeEnsRouteTablesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routeTables) {
      vector<boost::any> temp1;
      for(auto item1:*routeTables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouteTables"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouteTables") != m.end() && !m["RouteTables"].empty()) {
      if (typeid(vector<boost::any>) == m["RouteTables"].type()) {
        vector<DescribeEnsRouteTablesResponseBodyRouteTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouteTables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsRouteTablesResponseBodyRouteTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeTables = make_shared<vector<DescribeEnsRouteTablesResponseBodyRouteTables>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeEnsRouteTablesResponseBody() = default;
};
class DescribeEnsRouteTablesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnsRouteTablesResponseBody> body{};

  DescribeEnsRouteTablesResponse() {}

  explicit DescribeEnsRouteTablesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsRouteTablesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsRouteTablesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsRouteTablesResponse() = default;
};
class DescribeEnsSaleControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliUidAccount{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> customAccount{};
  shared_ptr<string> moduleCode{};
  shared_ptr<string> orderType{};

  DescribeEnsSaleControlRequest() {}

  explicit DescribeEnsSaleControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUidAccount) {
      res["AliUidAccount"] = boost::any(*aliUidAccount);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (customAccount) {
      res["CustomAccount"] = boost::any(*customAccount);
    }
    if (moduleCode) {
      res["ModuleCode"] = boost::any(*moduleCode);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUidAccount") != m.end() && !m["AliUidAccount"].empty()) {
      aliUidAccount = make_shared<string>(boost::any_cast<string>(m["AliUidAccount"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CustomAccount") != m.end() && !m["CustomAccount"].empty()) {
      customAccount = make_shared<string>(boost::any_cast<string>(m["CustomAccount"]));
    }
    if (m.find("ModuleCode") != m.end() && !m["ModuleCode"].empty()) {
      moduleCode = make_shared<string>(boost::any_cast<string>(m["ModuleCode"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
  }


  virtual ~DescribeEnsSaleControlRequest() = default;
};
class DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue : public Darabonba::Model {
public:
  shared_ptr<string> moduleMaxValue{};
  shared_ptr<string> moduleMinValue{};
  shared_ptr<vector<string>> moduleValue{};

  DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue() {}

  explicit DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moduleMaxValue) {
      res["ModuleMaxValue"] = boost::any(*moduleMaxValue);
    }
    if (moduleMinValue) {
      res["ModuleMinValue"] = boost::any(*moduleMinValue);
    }
    if (moduleValue) {
      res["ModuleValue"] = boost::any(*moduleValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModuleMaxValue") != m.end() && !m["ModuleMaxValue"].empty()) {
      moduleMaxValue = make_shared<string>(boost::any_cast<string>(m["ModuleMaxValue"]));
    }
    if (m.find("ModuleMinValue") != m.end() && !m["ModuleMinValue"].empty()) {
      moduleMinValue = make_shared<string>(boost::any_cast<string>(m["ModuleMinValue"]));
    }
    if (m.find("ModuleValue") != m.end() && !m["ModuleValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ModuleValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ModuleValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      moduleValue = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue() = default;
};
class DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue> moduleValue{};
  shared_ptr<string> operator_{};

  DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl() {}

  explicit DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (moduleValue) {
      res["ModuleValue"] = moduleValue ? boost::any(moduleValue->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModuleValue") != m.end() && !m["ModuleValue"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModuleValue"].type()) {
        DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModuleValue"]));
        moduleValue = make_shared<DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue>(model1);
      }
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
  }


  virtual ~DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl() = default;
};
class DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl : public Darabonba::Model {
public:
  shared_ptr<string> conditionControlModuleCode{};
  shared_ptr<string> conditionControlModuleValue{};

  DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl() {}

  explicit DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionControlModuleCode) {
      res["ConditionControlModuleCode"] = boost::any(*conditionControlModuleCode);
    }
    if (conditionControlModuleValue) {
      res["ConditionControlModuleValue"] = boost::any(*conditionControlModuleValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionControlModuleCode") != m.end() && !m["ConditionControlModuleCode"].empty()) {
      conditionControlModuleCode = make_shared<string>(boost::any_cast<string>(m["ConditionControlModuleCode"]));
    }
    if (m.find("ConditionControlModuleValue") != m.end() && !m["ConditionControlModuleValue"].empty()) {
      conditionControlModuleValue = make_shared<string>(boost::any_cast<string>(m["ConditionControlModuleValue"]));
    }
  }


  virtual ~DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl() = default;
};
class DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue : public Darabonba::Model {
public:
  shared_ptr<string> moduleMaxValue{};
  shared_ptr<string> moduleMinValue{};
  shared_ptr<vector<string>> moduleValue{};

  DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue() {}

  explicit DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moduleMaxValue) {
      res["ModuleMaxValue"] = boost::any(*moduleMaxValue);
    }
    if (moduleMinValue) {
      res["ModuleMinValue"] = boost::any(*moduleMinValue);
    }
    if (moduleValue) {
      res["ModuleValue"] = boost::any(*moduleValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModuleMaxValue") != m.end() && !m["ModuleMaxValue"].empty()) {
      moduleMaxValue = make_shared<string>(boost::any_cast<string>(m["ModuleMaxValue"]));
    }
    if (m.find("ModuleMinValue") != m.end() && !m["ModuleMinValue"].empty()) {
      moduleMinValue = make_shared<string>(boost::any_cast<string>(m["ModuleMinValue"]));
    }
    if (m.find("ModuleValue") != m.end() && !m["ModuleValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ModuleValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ModuleValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      moduleValue = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue() = default;
};
class DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl : public Darabonba::Model {
public:
  shared_ptr<DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl> conditionControl{};
  shared_ptr<string> description{};
  shared_ptr<DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue> moduleValue{};
  shared_ptr<string> operator_{};

  DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl() {}

  explicit DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionControl) {
      res["ConditionControl"] = conditionControl ? boost::any(conditionControl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (moduleValue) {
      res["ModuleValue"] = moduleValue ? boost::any(moduleValue->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionControl") != m.end() && !m["ConditionControl"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConditionControl"].type()) {
        DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConditionControl"]));
        conditionControl = make_shared<DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModuleValue") != m.end() && !m["ModuleValue"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModuleValue"].type()) {
        DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModuleValue"]));
        moduleValue = make_shared<DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue>(model1);
      }
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
  }


  virtual ~DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl() = default;
};
class DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItem : public Darabonba::Model {
public:
  shared_ptr<DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl> basicSaleControl{};
  shared_ptr<vector<DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl>> conditionSaleControl{};

  DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItem() {}

  explicit DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (basicSaleControl) {
      res["BasicSaleControl"] = basicSaleControl ? boost::any(basicSaleControl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conditionSaleControl) {
      vector<boost::any> temp1;
      for(auto item1:*conditionSaleControl){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConditionSaleControl"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BasicSaleControl") != m.end() && !m["BasicSaleControl"].empty()) {
      if (typeid(map<string, boost::any>) == m["BasicSaleControl"].type()) {
        DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BasicSaleControl"]));
        basicSaleControl = make_shared<DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl>(model1);
      }
    }
    if (m.find("ConditionSaleControl") != m.end() && !m["ConditionSaleControl"].empty()) {
      if (typeid(vector<boost::any>) == m["ConditionSaleControl"].type()) {
        vector<DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConditionSaleControl"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditionSaleControl = make_shared<vector<DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItem() = default;
};
class DescribeEnsSaleControlResponseBodySaleControlSaleControlItems : public Darabonba::Model {
public:
  shared_ptr<string> moduleCode{};
  shared_ptr<DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItem> saleControlItem{};

  DescribeEnsSaleControlResponseBodySaleControlSaleControlItems() {}

  explicit DescribeEnsSaleControlResponseBodySaleControlSaleControlItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moduleCode) {
      res["ModuleCode"] = boost::any(*moduleCode);
    }
    if (saleControlItem) {
      res["SaleControlItem"] = saleControlItem ? boost::any(saleControlItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModuleCode") != m.end() && !m["ModuleCode"].empty()) {
      moduleCode = make_shared<string>(boost::any_cast<string>(m["ModuleCode"]));
    }
    if (m.find("SaleControlItem") != m.end() && !m["SaleControlItem"].empty()) {
      if (typeid(map<string, boost::any>) == m["SaleControlItem"].type()) {
        DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SaleControlItem"]));
        saleControlItem = make_shared<DescribeEnsSaleControlResponseBodySaleControlSaleControlItemsSaleControlItem>(model1);
      }
    }
  }


  virtual ~DescribeEnsSaleControlResponseBodySaleControlSaleControlItems() = default;
};
class DescribeEnsSaleControlResponseBodySaleControl : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<string> orderType{};
  shared_ptr<vector<DescribeEnsSaleControlResponseBodySaleControlSaleControlItems>> saleControlItems{};

  DescribeEnsSaleControlResponseBodySaleControl() {}

  explicit DescribeEnsSaleControlResponseBodySaleControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (saleControlItems) {
      vector<boost::any> temp1;
      for(auto item1:*saleControlItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SaleControlItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("SaleControlItems") != m.end() && !m["SaleControlItems"].empty()) {
      if (typeid(vector<boost::any>) == m["SaleControlItems"].type()) {
        vector<DescribeEnsSaleControlResponseBodySaleControlSaleControlItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SaleControlItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsSaleControlResponseBodySaleControlSaleControlItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        saleControlItems = make_shared<vector<DescribeEnsSaleControlResponseBodySaleControlSaleControlItems>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsSaleControlResponseBodySaleControl() = default;
};
class DescribeEnsSaleControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeEnsSaleControlResponseBodySaleControl>> saleControl{};

  DescribeEnsSaleControlResponseBody() {}

  explicit DescribeEnsSaleControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (saleControl) {
      vector<boost::any> temp1;
      for(auto item1:*saleControl){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SaleControl"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SaleControl") != m.end() && !m["SaleControl"].empty()) {
      if (typeid(vector<boost::any>) == m["SaleControl"].type()) {
        vector<DescribeEnsSaleControlResponseBodySaleControl> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SaleControl"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsSaleControlResponseBodySaleControl model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        saleControl = make_shared<vector<DescribeEnsSaleControlResponseBodySaleControl>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsSaleControlResponseBody() = default;
};
class DescribeEnsSaleControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnsSaleControlResponseBody> body{};

  DescribeEnsSaleControlResponse() {}

  explicit DescribeEnsSaleControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsSaleControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsSaleControlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsSaleControlResponse() = default;
};
class DescribeEnsSaleControlAvailableResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<string> customAccount{};
  shared_ptr<string> orderType{};

  DescribeEnsSaleControlAvailableResourceRequest() {}

  explicit DescribeEnsSaleControlAvailableResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (customAccount) {
      res["CustomAccount"] = boost::any(*customAccount);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CustomAccount") != m.end() && !m["CustomAccount"].empty()) {
      customAccount = make_shared<string>(boost::any_cast<string>(m["CustomAccount"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
  }


  virtual ~DescribeEnsSaleControlAvailableResourceRequest() = default;
};
class DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableDiskType : public Darabonba::Model {
public:
  shared_ptr<string> diskName{};
  shared_ptr<string> diskType{};

  DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableDiskType() {}

  explicit DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableDiskType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
  }


  virtual ~DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableDiskType() = default;
};
class DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableRegion : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> city{};
  shared_ptr<string> country{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> ensRegionName{};
  shared_ptr<string> isp{};
  shared_ptr<string> province{};

  DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableRegion() {}

  explicit DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableRegion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionName) {
      res["EnsRegionName"] = boost::any(*ensRegionName);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionName") != m.end() && !m["EnsRegionName"].empty()) {
      ensRegionName = make_shared<string>(boost::any_cast<string>(m["EnsRegionName"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableRegion() = default;
};
class DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableSpec : public Darabonba::Model {
public:
  shared_ptr<string> cores{};
  shared_ptr<string> memory{};
  shared_ptr<string> specName{};
  shared_ptr<string> specValue{};

  DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableSpec() {}

  explicit DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    if (specValue) {
      res["SpecValue"] = boost::any(*specValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<string>(boost::any_cast<string>(m["Cores"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<string>(boost::any_cast<string>(m["Memory"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
    if (m.find("SpecValue") != m.end() && !m["SpecValue"].empty()) {
      specValue = make_shared<string>(boost::any_cast<string>(m["SpecValue"]));
    }
  }


  virtual ~DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableSpec() = default;
};
class DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageTypeAvailableDefaultStorageType : public Darabonba::Model {
public:
  shared_ptr<string> storageName{};
  shared_ptr<string> storageType{};

  DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageTypeAvailableDefaultStorageType() {}

  explicit DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageTypeAvailableDefaultStorageType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (storageName) {
      res["StorageName"] = boost::any(*storageName);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StorageName") != m.end() && !m["StorageName"].empty()) {
      storageName = make_shared<string>(boost::any_cast<string>(m["StorageName"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageTypeAvailableDefaultStorageType() = default;
};
class DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageTypeAvailableSpecialStorageType : public Darabonba::Model {
public:
  shared_ptr<string> storageType{};
  shared_ptr<string> storageName{};
  shared_ptr<string> ensRegionId{};

  DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageTypeAvailableSpecialStorageType() {}

  explicit DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageTypeAvailableSpecialStorageType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    if (storageName) {
      res["StorageName"] = boost::any(*storageName);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
    if (m.find("StorageName") != m.end() && !m["StorageName"].empty()) {
      storageName = make_shared<string>(boost::any_cast<string>(m["StorageName"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
  }


  virtual ~DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageTypeAvailableSpecialStorageType() = default;
};
class DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageType : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageTypeAvailableDefaultStorageType>> availableDefaultStorageType{};
  shared_ptr<vector<vector<undefined>>> availableSpecialStorageType{};

  DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageType() {}

  explicit DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableDefaultStorageType) {
      vector<boost::any> temp1;
      for(auto item1:*availableDefaultStorageType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableDefaultStorageType"] = boost::any(temp1);
    }
    if (availableSpecialStorageType) {
      vector<boost::any> temp1;
      for(auto item1:*availableSpecialStorageType){
        vector<boost::any> temp2;
        for(auto item2:item1){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1 = boost::any(temp2);
      }
      res["AvailableSpecialStorageType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableDefaultStorageType") != m.end() && !m["AvailableDefaultStorageType"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableDefaultStorageType"].type()) {
        vector<DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageTypeAvailableDefaultStorageType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableDefaultStorageType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageTypeAvailableDefaultStorageType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableDefaultStorageType = make_shared<vector<DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageTypeAvailableDefaultStorageType>>(expect1);
      }
    }
    if (m.find("AvailableSpecialStorageType") != m.end() && !m["AvailableSpecialStorageType"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableSpecialStorageType"].type()) {
        vector<vector<undefined>> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableSpecialStorageType"])){
          if (typeid(vector<boost::any>) == item1.type()) {
            vector<undefined> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                undefined model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1.push_back(expect2);
          }
        }
        availableSpecialStorageType = make_shared<vector<vector<undefined>>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageType() = default;
};
class DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResource : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableDiskType>> availableDiskType{};
  shared_ptr<vector<DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableRegion>> availableRegion{};
  shared_ptr<vector<DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableSpec>> availableSpec{};
  shared_ptr<DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageType> availableStorageType{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> orderType{};

  DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResource() {}

  explicit DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableDiskType) {
      vector<boost::any> temp1;
      for(auto item1:*availableDiskType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableDiskType"] = boost::any(temp1);
    }
    if (availableRegion) {
      vector<boost::any> temp1;
      for(auto item1:*availableRegion){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableRegion"] = boost::any(temp1);
    }
    if (availableSpec) {
      vector<boost::any> temp1;
      for(auto item1:*availableSpec){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableSpec"] = boost::any(temp1);
    }
    if (availableStorageType) {
      res["AvailableStorageType"] = availableStorageType ? boost::any(availableStorageType->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableDiskType") != m.end() && !m["AvailableDiskType"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableDiskType"].type()) {
        vector<DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableDiskType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableDiskType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableDiskType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableDiskType = make_shared<vector<DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableDiskType>>(expect1);
      }
    }
    if (m.find("AvailableRegion") != m.end() && !m["AvailableRegion"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableRegion"].type()) {
        vector<DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableRegion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableRegion"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableRegion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableRegion = make_shared<vector<DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableRegion>>(expect1);
      }
    }
    if (m.find("AvailableSpec") != m.end() && !m["AvailableSpec"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableSpec"].type()) {
        vector<DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableSpec> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableSpec"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableSpec model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableSpec = make_shared<vector<DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableSpec>>(expect1);
      }
    }
    if (m.find("AvailableStorageType") != m.end() && !m["AvailableStorageType"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvailableStorageType"].type()) {
        DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageType model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvailableStorageType"]));
        availableStorageType = make_shared<DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResourceAvailableStorageType>(model1);
      }
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
  }


  virtual ~DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResource() = default;
};
class DescribeEnsSaleControlAvailableResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResource>> saleControlAvailableResource{};

  DescribeEnsSaleControlAvailableResourceResponseBody() {}

  explicit DescribeEnsSaleControlAvailableResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (saleControlAvailableResource) {
      vector<boost::any> temp1;
      for(auto item1:*saleControlAvailableResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SaleControlAvailableResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SaleControlAvailableResource") != m.end() && !m["SaleControlAvailableResource"].empty()) {
      if (typeid(vector<boost::any>) == m["SaleControlAvailableResource"].type()) {
        vector<DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SaleControlAvailableResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        saleControlAvailableResource = make_shared<vector<DescribeEnsSaleControlAvailableResourceResponseBodySaleControlAvailableResource>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsSaleControlAvailableResourceResponseBody() = default;
};
class DescribeEnsSaleControlAvailableResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnsSaleControlAvailableResourceResponseBody> body{};

  DescribeEnsSaleControlAvailableResourceResponse() {}

  explicit DescribeEnsSaleControlAvailableResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsSaleControlAvailableResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsSaleControlAvailableResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsSaleControlAvailableResourceResponse() = default;
};
class DescribeEnsSaleControlStockRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliUidAccount{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> customAccount{};
  shared_ptr<string> moduleCode{};
  shared_ptr<string> orderType{};

  DescribeEnsSaleControlStockRequest() {}

  explicit DescribeEnsSaleControlStockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUidAccount) {
      res["AliUidAccount"] = boost::any(*aliUidAccount);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (customAccount) {
      res["CustomAccount"] = boost::any(*customAccount);
    }
    if (moduleCode) {
      res["ModuleCode"] = boost::any(*moduleCode);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUidAccount") != m.end() && !m["AliUidAccount"].empty()) {
      aliUidAccount = make_shared<string>(boost::any_cast<string>(m["AliUidAccount"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CustomAccount") != m.end() && !m["CustomAccount"].empty()) {
      customAccount = make_shared<string>(boost::any_cast<string>(m["CustomAccount"]));
    }
    if (m.find("ModuleCode") != m.end() && !m["ModuleCode"].empty()) {
      moduleCode = make_shared<string>(boost::any_cast<string>(m["ModuleCode"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
  }


  virtual ~DescribeEnsSaleControlStockRequest() = default;
};
class DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue : public Darabonba::Model {
public:
  shared_ptr<string> moduleMaxValue{};
  shared_ptr<string> moduleMinValue{};

  DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue() {}

  explicit DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moduleMaxValue) {
      res["ModuleMaxValue"] = boost::any(*moduleMaxValue);
    }
    if (moduleMinValue) {
      res["ModuleMinValue"] = boost::any(*moduleMinValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModuleMaxValue") != m.end() && !m["ModuleMaxValue"].empty()) {
      moduleMaxValue = make_shared<string>(boost::any_cast<string>(m["ModuleMaxValue"]));
    }
    if (m.find("ModuleMinValue") != m.end() && !m["ModuleMinValue"].empty()) {
      moduleMinValue = make_shared<string>(boost::any_cast<string>(m["ModuleMinValue"]));
    }
  }


  virtual ~DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue() = default;
};
class DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl : public Darabonba::Model {
public:
  shared_ptr<DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue> moduleValue{};
  shared_ptr<string> stockValue{};

  DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl() {}

  explicit DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moduleValue) {
      res["ModuleValue"] = moduleValue ? boost::any(moduleValue->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stockValue) {
      res["StockValue"] = boost::any(*stockValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModuleValue") != m.end() && !m["ModuleValue"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModuleValue"].type()) {
        DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModuleValue"]));
        moduleValue = make_shared<DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControlModuleValue>(model1);
      }
    }
    if (m.find("StockValue") != m.end() && !m["StockValue"].empty()) {
      stockValue = make_shared<string>(boost::any_cast<string>(m["StockValue"]));
    }
  }


  virtual ~DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl() = default;
};
class DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl : public Darabonba::Model {
public:
  shared_ptr<string> conditionControlModuleCode{};
  shared_ptr<string> conditionControlModuleValue{};

  DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl() {}

  explicit DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionControlModuleCode) {
      res["ConditionControlModuleCode"] = boost::any(*conditionControlModuleCode);
    }
    if (conditionControlModuleValue) {
      res["ConditionControlModuleValue"] = boost::any(*conditionControlModuleValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionControlModuleCode") != m.end() && !m["ConditionControlModuleCode"].empty()) {
      conditionControlModuleCode = make_shared<string>(boost::any_cast<string>(m["ConditionControlModuleCode"]));
    }
    if (m.find("ConditionControlModuleValue") != m.end() && !m["ConditionControlModuleValue"].empty()) {
      conditionControlModuleValue = make_shared<string>(boost::any_cast<string>(m["ConditionControlModuleValue"]));
    }
  }


  virtual ~DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl() = default;
};
class DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue : public Darabonba::Model {
public:
  shared_ptr<string> moduleMaxValue{};
  shared_ptr<string> moduleMinValue{};

  DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue() {}

  explicit DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moduleMaxValue) {
      res["ModuleMaxValue"] = boost::any(*moduleMaxValue);
    }
    if (moduleMinValue) {
      res["ModuleMinValue"] = boost::any(*moduleMinValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModuleMaxValue") != m.end() && !m["ModuleMaxValue"].empty()) {
      moduleMaxValue = make_shared<string>(boost::any_cast<string>(m["ModuleMaxValue"]));
    }
    if (m.find("ModuleMinValue") != m.end() && !m["ModuleMinValue"].empty()) {
      moduleMinValue = make_shared<string>(boost::any_cast<string>(m["ModuleMinValue"]));
    }
  }


  virtual ~DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue() = default;
};
class DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl : public Darabonba::Model {
public:
  shared_ptr<DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl> conditionControl{};
  shared_ptr<DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue> moduleValue{};
  shared_ptr<string> stockValue{};

  DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl() {}

  explicit DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionControl) {
      res["ConditionControl"] = conditionControl ? boost::any(conditionControl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (moduleValue) {
      res["ModuleValue"] = moduleValue ? boost::any(moduleValue->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stockValue) {
      res["StockValue"] = boost::any(*stockValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionControl") != m.end() && !m["ConditionControl"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConditionControl"].type()) {
        DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConditionControl"]));
        conditionControl = make_shared<DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlConditionControl>(model1);
      }
    }
    if (m.find("ModuleValue") != m.end() && !m["ModuleValue"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModuleValue"].type()) {
        DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModuleValue"]));
        moduleValue = make_shared<DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControlModuleValue>(model1);
      }
    }
    if (m.find("StockValue") != m.end() && !m["StockValue"].empty()) {
      stockValue = make_shared<string>(boost::any_cast<string>(m["StockValue"]));
    }
  }


  virtual ~DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl() = default;
};
class DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItem : public Darabonba::Model {
public:
  shared_ptr<DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl> basicSaleControl{};
  shared_ptr<vector<DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl>> conditionSaleControl{};

  DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItem() {}

  explicit DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (basicSaleControl) {
      res["BasicSaleControl"] = basicSaleControl ? boost::any(basicSaleControl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conditionSaleControl) {
      vector<boost::any> temp1;
      for(auto item1:*conditionSaleControl){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConditionSaleControl"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BasicSaleControl") != m.end() && !m["BasicSaleControl"].empty()) {
      if (typeid(map<string, boost::any>) == m["BasicSaleControl"].type()) {
        DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BasicSaleControl"]));
        basicSaleControl = make_shared<DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemBasicSaleControl>(model1);
      }
    }
    if (m.find("ConditionSaleControl") != m.end() && !m["ConditionSaleControl"].empty()) {
      if (typeid(vector<boost::any>) == m["ConditionSaleControl"].type()) {
        vector<DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConditionSaleControl"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditionSaleControl = make_shared<vector<DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItemConditionSaleControl>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItem() = default;
};
class DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItems : public Darabonba::Model {
public:
  shared_ptr<string> moduleCode{};
  shared_ptr<DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItem> saleControlItem{};

  DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItems() {}

  explicit DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moduleCode) {
      res["ModuleCode"] = boost::any(*moduleCode);
    }
    if (saleControlItem) {
      res["SaleControlItem"] = saleControlItem ? boost::any(saleControlItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModuleCode") != m.end() && !m["ModuleCode"].empty()) {
      moduleCode = make_shared<string>(boost::any_cast<string>(m["ModuleCode"]));
    }
    if (m.find("SaleControlItem") != m.end() && !m["SaleControlItem"].empty()) {
      if (typeid(map<string, boost::any>) == m["SaleControlItem"].type()) {
        DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SaleControlItem"]));
        saleControlItem = make_shared<DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItemsSaleControlItem>(model1);
      }
    }
  }


  virtual ~DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItems() = default;
};
class DescribeEnsSaleControlStockResponseBodySaleControl : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<string> orderType{};
  shared_ptr<vector<DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItems>> saleControlItems{};

  DescribeEnsSaleControlStockResponseBodySaleControl() {}

  explicit DescribeEnsSaleControlStockResponseBodySaleControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (saleControlItems) {
      vector<boost::any> temp1;
      for(auto item1:*saleControlItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SaleControlItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("SaleControlItems") != m.end() && !m["SaleControlItems"].empty()) {
      if (typeid(vector<boost::any>) == m["SaleControlItems"].type()) {
        vector<DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SaleControlItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        saleControlItems = make_shared<vector<DescribeEnsSaleControlStockResponseBodySaleControlSaleControlItems>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsSaleControlStockResponseBodySaleControl() = default;
};
class DescribeEnsSaleControlStockResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeEnsSaleControlStockResponseBodySaleControl>> saleControl{};

  DescribeEnsSaleControlStockResponseBody() {}

  explicit DescribeEnsSaleControlStockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (saleControl) {
      vector<boost::any> temp1;
      for(auto item1:*saleControl){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SaleControl"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SaleControl") != m.end() && !m["SaleControl"].empty()) {
      if (typeid(vector<boost::any>) == m["SaleControl"].type()) {
        vector<DescribeEnsSaleControlStockResponseBodySaleControl> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SaleControl"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsSaleControlStockResponseBodySaleControl model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        saleControl = make_shared<vector<DescribeEnsSaleControlStockResponseBodySaleControl>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsSaleControlStockResponseBody() = default;
};
class DescribeEnsSaleControlStockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEnsSaleControlStockResponseBody> body{};

  DescribeEnsSaleControlStockResponse() {}

  explicit DescribeEnsSaleControlStockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsSaleControlStockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsSaleControlStockResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsSaleControlStockResponse() = default;
};
class DescribeEpnBandWidthDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> isp{};
  shared_ptr<string> networkingModel{};
  shared_ptr<string> period{};
  shared_ptr<string> startTime{};

  DescribeEpnBandWidthDataRequest() {}

  explicit DescribeEpnBandWidthDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (networkingModel) {
      res["NetworkingModel"] = boost::any(*networkingModel);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("NetworkingModel") != m.end() && !m["NetworkingModel"].empty()) {
      networkingModel = make_shared<string>(boost::any_cast<string>(m["NetworkingModel"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeEpnBandWidthDataRequest() = default;
};
class DescribeEpnBandWidthDataResponseBodyMonitorDataBandWidthMonitorData : public Darabonba::Model {
public:
  shared_ptr<long> downBandWidth{};
  shared_ptr<long> internetRX{};
  shared_ptr<long> internetTX{};
  shared_ptr<string> timeStamp{};
  shared_ptr<long> upBandWidth{};

  DescribeEpnBandWidthDataResponseBodyMonitorDataBandWidthMonitorData() {}

  explicit DescribeEpnBandWidthDataResponseBodyMonitorDataBandWidthMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downBandWidth) {
      res["DownBandWidth"] = boost::any(*downBandWidth);
    }
    if (internetRX) {
      res["InternetRX"] = boost::any(*internetRX);
    }
    if (internetTX) {
      res["InternetTX"] = boost::any(*internetTX);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (upBandWidth) {
      res["UpBandWidth"] = boost::any(*upBandWidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownBandWidth") != m.end() && !m["DownBandWidth"].empty()) {
      downBandWidth = make_shared<long>(boost::any_cast<long>(m["DownBandWidth"]));
    }
    if (m.find("InternetRX") != m.end() && !m["InternetRX"].empty()) {
      internetRX = make_shared<long>(boost::any_cast<long>(m["InternetRX"]));
    }
    if (m.find("InternetTX") != m.end() && !m["InternetTX"].empty()) {
      internetTX = make_shared<long>(boost::any_cast<long>(m["InternetTX"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("UpBandWidth") != m.end() && !m["UpBandWidth"].empty()) {
      upBandWidth = make_shared<long>(boost::any_cast<long>(m["UpBandWidth"]));
    }
  }


  virtual ~DescribeEpnBandWidthDataResponseBodyMonitorDataBandWidthMonitorData() = default;
};
class DescribeEpnBandWidthDataResponseBodyMonitorData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEpnBandWidthDataResponseBodyMonitorDataBandWidthMonitorData>> bandWidthMonitorData{};
  shared_ptr<long> maxDownBandWidth{};
  shared_ptr<long> maxUpBandWidth{};

  DescribeEpnBandWidthDataResponseBodyMonitorData() {}

  explicit DescribeEpnBandWidthDataResponseBodyMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidthMonitorData) {
      vector<boost::any> temp1;
      for(auto item1:*bandWidthMonitorData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BandWidthMonitorData"] = boost::any(temp1);
    }
    if (maxDownBandWidth) {
      res["MaxDownBandWidth"] = boost::any(*maxDownBandWidth);
    }
    if (maxUpBandWidth) {
      res["MaxUpBandWidth"] = boost::any(*maxUpBandWidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidthMonitorData") != m.end() && !m["BandWidthMonitorData"].empty()) {
      if (typeid(vector<boost::any>) == m["BandWidthMonitorData"].type()) {
        vector<DescribeEpnBandWidthDataResponseBodyMonitorDataBandWidthMonitorData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BandWidthMonitorData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEpnBandWidthDataResponseBodyMonitorDataBandWidthMonitorData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bandWidthMonitorData = make_shared<vector<DescribeEpnBandWidthDataResponseBodyMonitorDataBandWidthMonitorData>>(expect1);
      }
    }
    if (m.find("MaxDownBandWidth") != m.end() && !m["MaxDownBandWidth"].empty()) {
      maxDownBandWidth = make_shared<long>(boost::any_cast<long>(m["MaxDownBandWidth"]));
    }
    if (m.find("MaxUpBandWidth") != m.end() && !m["MaxUpBandWidth"].empty()) {
      maxUpBandWidth = make_shared<long>(boost::any_cast<long>(m["MaxUpBandWidth"]));
    }
  }


  virtual ~DescribeEpnBandWidthDataResponseBodyMonitorData() = default;
};
class DescribeEpnBandWidthDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeEpnBandWidthDataResponseBodyMonitorData> monitorData{};
  shared_ptr<string> requestId{};

  DescribeEpnBandWidthDataResponseBody() {}

  explicit DescribeEpnBandWidthDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorData) {
      res["MonitorData"] = monitorData ? boost::any(monitorData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorData") != m.end() && !m["MonitorData"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonitorData"].type()) {
        DescribeEpnBandWidthDataResponseBodyMonitorData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonitorData"]));
        monitorData = make_shared<DescribeEpnBandWidthDataResponseBodyMonitorData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEpnBandWidthDataResponseBody() = default;
};
class DescribeEpnBandWidthDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEpnBandWidthDataResponseBody> body{};

  DescribeEpnBandWidthDataResponse() {}

  explicit DescribeEpnBandWidthDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEpnBandWidthDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEpnBandWidthDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEpnBandWidthDataResponse() = default;
};
class DescribeEpnBandwitdhByInternetChargeTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> isp{};
  shared_ptr<string> networkingModel{};
  shared_ptr<string> startTime{};

  DescribeEpnBandwitdhByInternetChargeTypeRequest() {}

  explicit DescribeEpnBandwitdhByInternetChargeTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (networkingModel) {
      res["NetworkingModel"] = boost::any(*networkingModel);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("NetworkingModel") != m.end() && !m["NetworkingModel"].empty()) {
      networkingModel = make_shared<string>(boost::any_cast<string>(m["NetworkingModel"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeEpnBandwitdhByInternetChargeTypeRequest() = default;
};
class DescribeEpnBandwitdhByInternetChargeTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> bandwidthValue{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> timeStamp{};

  DescribeEpnBandwitdhByInternetChargeTypeResponseBody() {}

  explicit DescribeEpnBandwitdhByInternetChargeTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthValue) {
      res["BandwidthValue"] = boost::any(*bandwidthValue);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthValue") != m.end() && !m["BandwidthValue"].empty()) {
      bandwidthValue = make_shared<long>(boost::any_cast<long>(m["BandwidthValue"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeEpnBandwitdhByInternetChargeTypeResponseBody() = default;
};
class DescribeEpnBandwitdhByInternetChargeTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEpnBandwitdhByInternetChargeTypeResponseBody> body{};

  DescribeEpnBandwitdhByInternetChargeTypeResponse() {}

  explicit DescribeEpnBandwitdhByInternetChargeTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEpnBandwitdhByInternetChargeTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEpnBandwitdhByInternetChargeTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEpnBandwitdhByInternetChargeTypeResponse() = default;
};
class DescribeEpnInstanceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};

  DescribeEpnInstanceAttributeRequest() {}

  explicit DescribeEpnInstanceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
  }


  virtual ~DescribeEpnInstanceAttributeRequest() = default;
};
class DescribeEpnInstanceAttributeResponseBodyConfVersions : public Darabonba::Model {
public:
  shared_ptr<string> confVersion{};
  shared_ptr<string> ensRegionId{};

  DescribeEpnInstanceAttributeResponseBodyConfVersions() {}

  explicit DescribeEpnInstanceAttributeResponseBodyConfVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confVersion) {
      res["ConfVersion"] = boost::any(*confVersion);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfVersion") != m.end() && !m["ConfVersion"].empty()) {
      confVersion = make_shared<string>(boost::any_cast<string>(m["ConfVersion"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
  }


  virtual ~DescribeEpnInstanceAttributeResponseBodyConfVersions() = default;
};
class DescribeEpnInstanceAttributeResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> isp{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> publicIpAddress{};
  shared_ptr<string> status{};

  DescribeEpnInstanceAttributeResponseBodyInstances() {}

  explicit DescribeEpnInstanceAttributeResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (publicIpAddress) {
      res["PublicIpAddress"] = boost::any(*publicIpAddress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("PublicIpAddress") != m.end() && !m["PublicIpAddress"].empty()) {
      publicIpAddress = make_shared<string>(boost::any_cast<string>(m["PublicIpAddress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeEpnInstanceAttributeResponseBodyInstances() = default;
};
class DescribeEpnInstanceAttributeResponseBodyVSwitches : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vSwitchName{};

  DescribeEpnInstanceAttributeResponseBodyVSwitches() {}

  explicit DescribeEpnInstanceAttributeResponseBodyVSwitches(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
  }


  virtual ~DescribeEpnInstanceAttributeResponseBodyVSwitches() = default;
};
class DescribeEpnInstanceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEpnInstanceAttributeResponseBodyConfVersions>> confVersions{};
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> EPNInstanceName{};
  shared_ptr<vector<DescribeEpnInstanceAttributeResponseBodyInstances>> instances{};
  shared_ptr<string> networkingModel{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeEpnInstanceAttributeResponseBodyVSwitches>> vSwitches{};

  DescribeEpnInstanceAttributeResponseBody() {}

  explicit DescribeEpnInstanceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confVersions) {
      vector<boost::any> temp1;
      for(auto item1:*confVersions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfVersions"] = boost::any(temp1);
    }
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (EPNInstanceName) {
      res["EPNInstanceName"] = boost::any(*EPNInstanceName);
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (networkingModel) {
      res["NetworkingModel"] = boost::any(*networkingModel);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vSwitches) {
      vector<boost::any> temp1;
      for(auto item1:*vSwitches){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VSwitches"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfVersions") != m.end() && !m["ConfVersions"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfVersions"].type()) {
        vector<DescribeEpnInstanceAttributeResponseBodyConfVersions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfVersions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEpnInstanceAttributeResponseBodyConfVersions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        confVersions = make_shared<vector<DescribeEpnInstanceAttributeResponseBodyConfVersions>>(expect1);
      }
    }
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("EPNInstanceName") != m.end() && !m["EPNInstanceName"].empty()) {
      EPNInstanceName = make_shared<string>(boost::any_cast<string>(m["EPNInstanceName"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<DescribeEpnInstanceAttributeResponseBodyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEpnInstanceAttributeResponseBodyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<DescribeEpnInstanceAttributeResponseBodyInstances>>(expect1);
      }
    }
    if (m.find("NetworkingModel") != m.end() && !m["NetworkingModel"].empty()) {
      networkingModel = make_shared<string>(boost::any_cast<string>(m["NetworkingModel"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VSwitches") != m.end() && !m["VSwitches"].empty()) {
      if (typeid(vector<boost::any>) == m["VSwitches"].type()) {
        vector<DescribeEpnInstanceAttributeResponseBodyVSwitches> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VSwitches"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEpnInstanceAttributeResponseBodyVSwitches model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vSwitches = make_shared<vector<DescribeEpnInstanceAttributeResponseBodyVSwitches>>(expect1);
      }
    }
  }


  virtual ~DescribeEpnInstanceAttributeResponseBody() = default;
};
class DescribeEpnInstanceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEpnInstanceAttributeResponseBody> body{};

  DescribeEpnInstanceAttributeResponse() {}

  explicit DescribeEpnInstanceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEpnInstanceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEpnInstanceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEpnInstanceAttributeResponse() = default;
};
class DescribeEpnInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> EPNInstanceName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeEpnInstancesRequest() {}

  explicit DescribeEpnInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (EPNInstanceName) {
      res["EPNInstanceName"] = boost::any(*EPNInstanceName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("EPNInstanceName") != m.end() && !m["EPNInstanceName"].empty()) {
      EPNInstanceName = make_shared<string>(boost::any_cast<string>(m["EPNInstanceName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeEpnInstancesRequest() = default;
};
class DescribeEpnInstancesResponseBodyEPNInstancesEPNInstance : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> EPNInstanceName{};
  shared_ptr<string> EPNInstanceType{};
  shared_ptr<string> endTime{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> networkingModel{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  DescribeEpnInstancesResponseBodyEPNInstancesEPNInstance() {}

  explicit DescribeEpnInstancesResponseBodyEPNInstancesEPNInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (EPNInstanceName) {
      res["EPNInstanceName"] = boost::any(*EPNInstanceName);
    }
    if (EPNInstanceType) {
      res["EPNInstanceType"] = boost::any(*EPNInstanceType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (networkingModel) {
      res["NetworkingModel"] = boost::any(*networkingModel);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("EPNInstanceName") != m.end() && !m["EPNInstanceName"].empty()) {
      EPNInstanceName = make_shared<string>(boost::any_cast<string>(m["EPNInstanceName"]));
    }
    if (m.find("EPNInstanceType") != m.end() && !m["EPNInstanceType"].empty()) {
      EPNInstanceType = make_shared<string>(boost::any_cast<string>(m["EPNInstanceType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("NetworkingModel") != m.end() && !m["NetworkingModel"].empty()) {
      networkingModel = make_shared<string>(boost::any_cast<string>(m["NetworkingModel"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeEpnInstancesResponseBodyEPNInstancesEPNInstance() = default;
};
class DescribeEpnInstancesResponseBodyEPNInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEpnInstancesResponseBodyEPNInstancesEPNInstance>> EPNInstance{};

  DescribeEpnInstancesResponseBodyEPNInstances() {}

  explicit DescribeEpnInstancesResponseBodyEPNInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstance) {
      vector<boost::any> temp1;
      for(auto item1:*EPNInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EPNInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstance") != m.end() && !m["EPNInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["EPNInstance"].type()) {
        vector<DescribeEpnInstancesResponseBodyEPNInstancesEPNInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EPNInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEpnInstancesResponseBodyEPNInstancesEPNInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        EPNInstance = make_shared<vector<DescribeEpnInstancesResponseBodyEPNInstancesEPNInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeEpnInstancesResponseBodyEPNInstances() = default;
};
class DescribeEpnInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeEpnInstancesResponseBodyEPNInstances> EPNInstances{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeEpnInstancesResponseBody() {}

  explicit DescribeEpnInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstances) {
      res["EPNInstances"] = EPNInstances ? boost::any(EPNInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstances") != m.end() && !m["EPNInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["EPNInstances"].type()) {
        DescribeEpnInstancesResponseBodyEPNInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EPNInstances"]));
        EPNInstances = make_shared<DescribeEpnInstancesResponseBodyEPNInstances>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeEpnInstancesResponseBody() = default;
};
class DescribeEpnInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEpnInstancesResponseBody> body{};

  DescribeEpnInstancesResponse() {}

  explicit DescribeEpnInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEpnInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEpnInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEpnInstancesResponse() = default;
};
class DescribeEpnMeasurementDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<string> startDate{};

  DescribeEpnMeasurementDataRequest() {}

  explicit DescribeEpnMeasurementDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
  }


  virtual ~DescribeEpnMeasurementDataRequest() = default;
};
class DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData : public Darabonba::Model {
public:
  shared_ptr<string> costCode{};
  shared_ptr<string> costName{};
  shared_ptr<string> costType{};
  shared_ptr<long> costVal{};
  shared_ptr<string> ispLine{};

  DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData() {}

  explicit DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costCode) {
      res["CostCode"] = boost::any(*costCode);
    }
    if (costName) {
      res["CostName"] = boost::any(*costName);
    }
    if (costType) {
      res["CostType"] = boost::any(*costType);
    }
    if (costVal) {
      res["CostVal"] = boost::any(*costVal);
    }
    if (ispLine) {
      res["IspLine"] = boost::any(*ispLine);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CostCode") != m.end() && !m["CostCode"].empty()) {
      costCode = make_shared<string>(boost::any_cast<string>(m["CostCode"]));
    }
    if (m.find("CostName") != m.end() && !m["CostName"].empty()) {
      costName = make_shared<string>(boost::any_cast<string>(m["CostName"]));
    }
    if (m.find("CostType") != m.end() && !m["CostType"].empty()) {
      costType = make_shared<string>(boost::any_cast<string>(m["CostType"]));
    }
    if (m.find("CostVal") != m.end() && !m["CostVal"].empty()) {
      costVal = make_shared<long>(boost::any_cast<long>(m["CostVal"]));
    }
    if (m.find("IspLine") != m.end() && !m["IspLine"].empty()) {
      ispLine = make_shared<string>(boost::any_cast<string>(m["IspLine"]));
    }
  }


  virtual ~DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData() = default;
};
class DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData>> bandWidthFeeData{};

  DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas() {}

  explicit DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidthFeeData) {
      vector<boost::any> temp1;
      for(auto item1:*bandWidthFeeData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BandWidthFeeData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidthFeeData") != m.end() && !m["BandWidthFeeData"].empty()) {
      if (typeid(vector<boost::any>) == m["BandWidthFeeData"].type()) {
        vector<DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BandWidthFeeData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bandWidthFeeData = make_shared<vector<DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData>>(expect1);
      }
    }
  }


  virtual ~DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas() = default;
};
class DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementData : public Darabonba::Model {
public:
  shared_ptr<DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas> bandWidthFeeDatas{};
  shared_ptr<string> chargeModel{};
  shared_ptr<string> costCycle{};
  shared_ptr<string> costEndTime{};
  shared_ptr<string> costStartTime{};

  DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementData() {}

  explicit DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidthFeeDatas) {
      res["BandWidthFeeDatas"] = bandWidthFeeDatas ? boost::any(bandWidthFeeDatas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (chargeModel) {
      res["ChargeModel"] = boost::any(*chargeModel);
    }
    if (costCycle) {
      res["CostCycle"] = boost::any(*costCycle);
    }
    if (costEndTime) {
      res["CostEndTime"] = boost::any(*costEndTime);
    }
    if (costStartTime) {
      res["CostStartTime"] = boost::any(*costStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidthFeeDatas") != m.end() && !m["BandWidthFeeDatas"].empty()) {
      if (typeid(map<string, boost::any>) == m["BandWidthFeeDatas"].type()) {
        DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BandWidthFeeDatas"]));
        bandWidthFeeDatas = make_shared<DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas>(model1);
      }
    }
    if (m.find("ChargeModel") != m.end() && !m["ChargeModel"].empty()) {
      chargeModel = make_shared<string>(boost::any_cast<string>(m["ChargeModel"]));
    }
    if (m.find("CostCycle") != m.end() && !m["CostCycle"].empty()) {
      costCycle = make_shared<string>(boost::any_cast<string>(m["CostCycle"]));
    }
    if (m.find("CostEndTime") != m.end() && !m["CostEndTime"].empty()) {
      costEndTime = make_shared<string>(boost::any_cast<string>(m["CostEndTime"]));
    }
    if (m.find("CostStartTime") != m.end() && !m["CostStartTime"].empty()) {
      costStartTime = make_shared<string>(boost::any_cast<string>(m["CostStartTime"]));
    }
  }


  virtual ~DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementData() = default;
};
class DescribeEpnMeasurementDataResponseBodyMeasurementDatas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementData>> measurementData{};

  DescribeEpnMeasurementDataResponseBodyMeasurementDatas() {}

  explicit DescribeEpnMeasurementDataResponseBodyMeasurementDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (measurementData) {
      vector<boost::any> temp1;
      for(auto item1:*measurementData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MeasurementData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MeasurementData") != m.end() && !m["MeasurementData"].empty()) {
      if (typeid(vector<boost::any>) == m["MeasurementData"].type()) {
        vector<DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MeasurementData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        measurementData = make_shared<vector<DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementData>>(expect1);
      }
    }
  }


  virtual ~DescribeEpnMeasurementDataResponseBodyMeasurementDatas() = default;
};
class DescribeEpnMeasurementDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeEpnMeasurementDataResponseBodyMeasurementDatas> measurementDatas{};
  shared_ptr<string> requestId{};

  DescribeEpnMeasurementDataResponseBody() {}

  explicit DescribeEpnMeasurementDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (measurementDatas) {
      res["MeasurementDatas"] = measurementDatas ? boost::any(measurementDatas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MeasurementDatas") != m.end() && !m["MeasurementDatas"].empty()) {
      if (typeid(map<string, boost::any>) == m["MeasurementDatas"].type()) {
        DescribeEpnMeasurementDataResponseBodyMeasurementDatas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MeasurementDatas"]));
        measurementDatas = make_shared<DescribeEpnMeasurementDataResponseBodyMeasurementDatas>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEpnMeasurementDataResponseBody() = default;
};
class DescribeEpnMeasurementDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEpnMeasurementDataResponseBody> body{};

  DescribeEpnMeasurementDataResponse() {}

  explicit DescribeEpnMeasurementDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEpnMeasurementDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEpnMeasurementDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEpnMeasurementDataResponse() = default;
};
class DescribeExportImageInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeExportImageInfoRequest() {}

  explicit DescribeExportImageInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeExportImageInfoRequest() = default;
};
class DescribeExportImageInfoResponseBodyImagesImage : public Darabonba::Model {
public:
  shared_ptr<string> architecture{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> exportedImageURL{};
  shared_ptr<string> imageExportStatus{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> imageOwnerAlias{};
  shared_ptr<string> platform{};

  DescribeExportImageInfoResponseBodyImagesImage() {}

  explicit DescribeExportImageInfoResponseBodyImagesImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (exportedImageURL) {
      res["ExportedImageURL"] = boost::any(*exportedImageURL);
    }
    if (imageExportStatus) {
      res["ImageExportStatus"] = boost::any(*imageExportStatus);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (imageOwnerAlias) {
      res["ImageOwnerAlias"] = boost::any(*imageOwnerAlias);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("ExportedImageURL") != m.end() && !m["ExportedImageURL"].empty()) {
      exportedImageURL = make_shared<string>(boost::any_cast<string>(m["ExportedImageURL"]));
    }
    if (m.find("ImageExportStatus") != m.end() && !m["ImageExportStatus"].empty()) {
      imageExportStatus = make_shared<string>(boost::any_cast<string>(m["ImageExportStatus"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("ImageOwnerAlias") != m.end() && !m["ImageOwnerAlias"].empty()) {
      imageOwnerAlias = make_shared<string>(boost::any_cast<string>(m["ImageOwnerAlias"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
  }


  virtual ~DescribeExportImageInfoResponseBodyImagesImage() = default;
};
class DescribeExportImageInfoResponseBodyImages : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeExportImageInfoResponseBodyImagesImage>> image{};

  DescribeExportImageInfoResponseBodyImages() {}

  explicit DescribeExportImageInfoResponseBodyImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      vector<boost::any> temp1;
      for(auto item1:*image){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Image"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      if (typeid(vector<boost::any>) == m["Image"].type()) {
        vector<DescribeExportImageInfoResponseBodyImagesImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Image"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExportImageInfoResponseBodyImagesImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        image = make_shared<vector<DescribeExportImageInfoResponseBodyImagesImage>>(expect1);
      }
    }
  }


  virtual ~DescribeExportImageInfoResponseBodyImages() = default;
};
class DescribeExportImageInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeExportImageInfoResponseBodyImages> images{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeExportImageInfoResponseBody() {}

  explicit DescribeExportImageInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (images) {
      res["Images"] = images ? boost::any(images->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(map<string, boost::any>) == m["Images"].type()) {
        DescribeExportImageInfoResponseBodyImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Images"]));
        images = make_shared<DescribeExportImageInfoResponseBodyImages>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeExportImageInfoResponseBody() = default;
};
class DescribeExportImageInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExportImageInfoResponseBody> body{};

  DescribeExportImageInfoResponse() {}

  explicit DescribeExportImageInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExportImageInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExportImageInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExportImageInfoResponse() = default;
};
class DescribeExportImageStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};

  DescribeExportImageStatusRequest() {}

  explicit DescribeExportImageStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
  }


  virtual ~DescribeExportImageStatusRequest() = default;
};
class DescribeExportImageStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> imageExportStatus{};
  shared_ptr<string> requestId{};

  DescribeExportImageStatusResponseBody() {}

  explicit DescribeExportImageStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageExportStatus) {
      res["ImageExportStatus"] = boost::any(*imageExportStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageExportStatus") != m.end() && !m["ImageExportStatus"].empty()) {
      imageExportStatus = make_shared<string>(boost::any_cast<string>(m["ImageExportStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeExportImageStatusResponseBody() = default;
};
class DescribeExportImageStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExportImageStatusResponseBody> body{};

  DescribeExportImageStatusResponse() {}

  explicit DescribeExportImageStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExportImageStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExportImageStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExportImageStatusResponse() = default;
};
class DescribeFileSystemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> fileSystemId{};
  shared_ptr<string> fileSystemName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeFileSystemsRequest() {}

  explicit DescribeFileSystemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (fileSystemId) {
      res["FileSystemId"] = boost::any(*fileSystemId);
    }
    if (fileSystemName) {
      res["FileSystemName"] = boost::any(*fileSystemName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("FileSystemId") != m.end() && !m["FileSystemId"].empty()) {
      fileSystemId = make_shared<string>(boost::any_cast<string>(m["FileSystemId"]));
    }
    if (m.find("FileSystemName") != m.end() && !m["FileSystemName"].empty()) {
      fileSystemName = make_shared<string>(boost::any_cast<string>(m["FileSystemName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeFileSystemsRequest() = default;
};
class DescribeFileSystemsResponseBodyFileSystemsMountTargets : public Darabonba::Model {
public:
  shared_ptr<string> mountTargetDomain{};
  shared_ptr<string> mountTargetName{};
  shared_ptr<string> netWorkId{};
  shared_ptr<string> status{};

  DescribeFileSystemsResponseBodyFileSystemsMountTargets() {}

  explicit DescribeFileSystemsResponseBodyFileSystemsMountTargets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountTargetDomain) {
      res["MountTargetDomain"] = boost::any(*mountTargetDomain);
    }
    if (mountTargetName) {
      res["MountTargetName"] = boost::any(*mountTargetName);
    }
    if (netWorkId) {
      res["NetWorkId"] = boost::any(*netWorkId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountTargetDomain") != m.end() && !m["MountTargetDomain"].empty()) {
      mountTargetDomain = make_shared<string>(boost::any_cast<string>(m["MountTargetDomain"]));
    }
    if (m.find("MountTargetName") != m.end() && !m["MountTargetName"].empty()) {
      mountTargetName = make_shared<string>(boost::any_cast<string>(m["MountTargetName"]));
    }
    if (m.find("NetWorkId") != m.end() && !m["NetWorkId"].empty()) {
      netWorkId = make_shared<string>(boost::any_cast<string>(m["NetWorkId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeFileSystemsResponseBodyFileSystemsMountTargets() = default;
};
class DescribeFileSystemsResponseBodyFileSystems : public Darabonba::Model {
public:
  shared_ptr<long> capacity{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> fileSystemId{};
  shared_ptr<string> fileSystemName{};
  shared_ptr<long> meteredSize{};
  shared_ptr<vector<DescribeFileSystemsResponseBodyFileSystemsMountTargets>> mountTargets{};
  shared_ptr<string> payType{};
  shared_ptr<string> protocolType{};
  shared_ptr<string> status{};
  shared_ptr<string> storageType{};

  DescribeFileSystemsResponseBodyFileSystems() {}

  explicit DescribeFileSystemsResponseBodyFileSystems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacity) {
      res["Capacity"] = boost::any(*capacity);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (fileSystemId) {
      res["FileSystemId"] = boost::any(*fileSystemId);
    }
    if (fileSystemName) {
      res["FileSystemName"] = boost::any(*fileSystemName);
    }
    if (meteredSize) {
      res["MeteredSize"] = boost::any(*meteredSize);
    }
    if (mountTargets) {
      vector<boost::any> temp1;
      for(auto item1:*mountTargets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MountTargets"] = boost::any(temp1);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Capacity") != m.end() && !m["Capacity"].empty()) {
      capacity = make_shared<long>(boost::any_cast<long>(m["Capacity"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("FileSystemId") != m.end() && !m["FileSystemId"].empty()) {
      fileSystemId = make_shared<string>(boost::any_cast<string>(m["FileSystemId"]));
    }
    if (m.find("FileSystemName") != m.end() && !m["FileSystemName"].empty()) {
      fileSystemName = make_shared<string>(boost::any_cast<string>(m["FileSystemName"]));
    }
    if (m.find("MeteredSize") != m.end() && !m["MeteredSize"].empty()) {
      meteredSize = make_shared<long>(boost::any_cast<long>(m["MeteredSize"]));
    }
    if (m.find("MountTargets") != m.end() && !m["MountTargets"].empty()) {
      if (typeid(vector<boost::any>) == m["MountTargets"].type()) {
        vector<DescribeFileSystemsResponseBodyFileSystemsMountTargets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MountTargets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFileSystemsResponseBodyFileSystemsMountTargets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mountTargets = make_shared<vector<DescribeFileSystemsResponseBodyFileSystemsMountTargets>>(expect1);
      }
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~DescribeFileSystemsResponseBodyFileSystems() = default;
};
class DescribeFileSystemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFileSystemsResponseBodyFileSystems>> fileSystems{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeFileSystemsResponseBody() {}

  explicit DescribeFileSystemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSystems) {
      vector<boost::any> temp1;
      for(auto item1:*fileSystems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileSystems"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileSystems") != m.end() && !m["FileSystems"].empty()) {
      if (typeid(vector<boost::any>) == m["FileSystems"].type()) {
        vector<DescribeFileSystemsResponseBodyFileSystems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileSystems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFileSystemsResponseBodyFileSystems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileSystems = make_shared<vector<DescribeFileSystemsResponseBodyFileSystems>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeFileSystemsResponseBody() = default;
};
class DescribeFileSystemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFileSystemsResponseBody> body{};

  DescribeFileSystemsResponse() {}

  explicit DescribeFileSystemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFileSystemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFileSystemsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFileSystemsResponse() = default;
};
class DescribeForwardTableEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> externalIp{};
  shared_ptr<string> forwardEntryId{};
  shared_ptr<string> forwardEntryName{};
  shared_ptr<string> internalIp{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeForwardTableEntriesRequest() {}

  explicit DescribeForwardTableEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (externalIp) {
      res["ExternalIp"] = boost::any(*externalIp);
    }
    if (forwardEntryId) {
      res["ForwardEntryId"] = boost::any(*forwardEntryId);
    }
    if (forwardEntryName) {
      res["ForwardEntryName"] = boost::any(*forwardEntryName);
    }
    if (internalIp) {
      res["InternalIp"] = boost::any(*internalIp);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExternalIp") != m.end() && !m["ExternalIp"].empty()) {
      externalIp = make_shared<string>(boost::any_cast<string>(m["ExternalIp"]));
    }
    if (m.find("ForwardEntryId") != m.end() && !m["ForwardEntryId"].empty()) {
      forwardEntryId = make_shared<string>(boost::any_cast<string>(m["ForwardEntryId"]));
    }
    if (m.find("ForwardEntryName") != m.end() && !m["ForwardEntryName"].empty()) {
      forwardEntryName = make_shared<string>(boost::any_cast<string>(m["ForwardEntryName"]));
    }
    if (m.find("InternalIp") != m.end() && !m["InternalIp"].empty()) {
      internalIp = make_shared<string>(boost::any_cast<string>(m["InternalIp"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeForwardTableEntriesRequest() = default;
};
class DescribeForwardTableEntriesResponseBodyForwardTableEntries : public Darabonba::Model {
public:
  shared_ptr<string> externalIp{};
  shared_ptr<string> externalPort{};
  shared_ptr<string> forwardEntryId{};
  shared_ptr<string> forwardEntryName{};
  shared_ptr<string> healthCheckPort{};
  shared_ptr<string> internalIp{};
  shared_ptr<string> internalPort{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> standbyExternalIp{};
  shared_ptr<string> standbyStatus{};
  shared_ptr<string> status{};

  DescribeForwardTableEntriesResponseBodyForwardTableEntries() {}

  explicit DescribeForwardTableEntriesResponseBodyForwardTableEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (externalIp) {
      res["ExternalIp"] = boost::any(*externalIp);
    }
    if (externalPort) {
      res["ExternalPort"] = boost::any(*externalPort);
    }
    if (forwardEntryId) {
      res["ForwardEntryId"] = boost::any(*forwardEntryId);
    }
    if (forwardEntryName) {
      res["ForwardEntryName"] = boost::any(*forwardEntryName);
    }
    if (healthCheckPort) {
      res["HealthCheckPort"] = boost::any(*healthCheckPort);
    }
    if (internalIp) {
      res["InternalIp"] = boost::any(*internalIp);
    }
    if (internalPort) {
      res["InternalPort"] = boost::any(*internalPort);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (standbyExternalIp) {
      res["StandbyExternalIp"] = boost::any(*standbyExternalIp);
    }
    if (standbyStatus) {
      res["StandbyStatus"] = boost::any(*standbyStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExternalIp") != m.end() && !m["ExternalIp"].empty()) {
      externalIp = make_shared<string>(boost::any_cast<string>(m["ExternalIp"]));
    }
    if (m.find("ExternalPort") != m.end() && !m["ExternalPort"].empty()) {
      externalPort = make_shared<string>(boost::any_cast<string>(m["ExternalPort"]));
    }
    if (m.find("ForwardEntryId") != m.end() && !m["ForwardEntryId"].empty()) {
      forwardEntryId = make_shared<string>(boost::any_cast<string>(m["ForwardEntryId"]));
    }
    if (m.find("ForwardEntryName") != m.end() && !m["ForwardEntryName"].empty()) {
      forwardEntryName = make_shared<string>(boost::any_cast<string>(m["ForwardEntryName"]));
    }
    if (m.find("HealthCheckPort") != m.end() && !m["HealthCheckPort"].empty()) {
      healthCheckPort = make_shared<string>(boost::any_cast<string>(m["HealthCheckPort"]));
    }
    if (m.find("InternalIp") != m.end() && !m["InternalIp"].empty()) {
      internalIp = make_shared<string>(boost::any_cast<string>(m["InternalIp"]));
    }
    if (m.find("InternalPort") != m.end() && !m["InternalPort"].empty()) {
      internalPort = make_shared<string>(boost::any_cast<string>(m["InternalPort"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("StandbyExternalIp") != m.end() && !m["StandbyExternalIp"].empty()) {
      standbyExternalIp = make_shared<string>(boost::any_cast<string>(m["StandbyExternalIp"]));
    }
    if (m.find("StandbyStatus") != m.end() && !m["StandbyStatus"].empty()) {
      standbyStatus = make_shared<string>(boost::any_cast<string>(m["StandbyStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeForwardTableEntriesResponseBodyForwardTableEntries() = default;
};
class DescribeForwardTableEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeForwardTableEntriesResponseBodyForwardTableEntries>> forwardTableEntries{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};

  DescribeForwardTableEntriesResponseBody() {}

  explicit DescribeForwardTableEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardTableEntries) {
      vector<boost::any> temp1;
      for(auto item1:*forwardTableEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ForwardTableEntries"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardTableEntries") != m.end() && !m["ForwardTableEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["ForwardTableEntries"].type()) {
        vector<DescribeForwardTableEntriesResponseBodyForwardTableEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ForwardTableEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeForwardTableEntriesResponseBodyForwardTableEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        forwardTableEntries = make_shared<vector<DescribeForwardTableEntriesResponseBodyForwardTableEntries>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~DescribeForwardTableEntriesResponseBody() = default;
};
class DescribeForwardTableEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeForwardTableEntriesResponseBody> body{};

  DescribeForwardTableEntriesResponse() {}

  explicit DescribeForwardTableEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeForwardTableEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeForwardTableEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeForwardTableEntriesResponse() = default;
};
class DescribeHaVipsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<vector<string>> ensRegionIds{};
  shared_ptr<string> haVipAddress{};
  shared_ptr<string> haVipId{};
  shared_ptr<string> name{};
  shared_ptr<string> networkId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> status{};
  shared_ptr<string> vSwitchId{};

  DescribeHaVipsRequest() {}

  explicit DescribeHaVipsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = boost::any(*ensRegionIds);
    }
    if (haVipAddress) {
      res["HaVipAddress"] = boost::any(*haVipAddress);
    }
    if (haVipId) {
      res["HaVipId"] = boost::any(*haVipId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnsRegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnsRegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ensRegionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HaVipAddress") != m.end() && !m["HaVipAddress"].empty()) {
      haVipAddress = make_shared<string>(boost::any_cast<string>(m["HaVipAddress"]));
    }
    if (m.find("HaVipId") != m.end() && !m["HaVipId"].empty()) {
      haVipId = make_shared<string>(boost::any_cast<string>(m["HaVipId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeHaVipsRequest() = default;
};
class DescribeHaVipsResponseBodyHaVipsAssociatedEipAddresses : public Darabonba::Model {
public:
  shared_ptr<string> eip{};
  shared_ptr<string> eipId{};

  DescribeHaVipsResponseBodyHaVipsAssociatedEipAddresses() {}

  explicit DescribeHaVipsResponseBodyHaVipsAssociatedEipAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eip) {
      res["Eip"] = boost::any(*eip);
    }
    if (eipId) {
      res["EipId"] = boost::any(*eipId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Eip") != m.end() && !m["Eip"].empty()) {
      eip = make_shared<string>(boost::any_cast<string>(m["Eip"]));
    }
    if (m.find("EipId") != m.end() && !m["EipId"].empty()) {
      eipId = make_shared<string>(boost::any_cast<string>(m["EipId"]));
    }
  }


  virtual ~DescribeHaVipsResponseBodyHaVipsAssociatedEipAddresses() = default;
};
class DescribeHaVipsResponseBodyHaVipsAssociatedInstances : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> status{};

  DescribeHaVipsResponseBodyHaVipsAssociatedInstances() {}

  explicit DescribeHaVipsResponseBodyHaVipsAssociatedInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeHaVipsResponseBodyHaVipsAssociatedInstances() = default;
};
class DescribeHaVipsResponseBodyHaVips : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHaVipsResponseBodyHaVipsAssociatedEipAddresses>> associatedEipAddresses{};
  shared_ptr<vector<DescribeHaVipsResponseBodyHaVipsAssociatedInstances>> associatedInstances{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> haVipId{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> name{};
  shared_ptr<string> networkId{};
  shared_ptr<string> status{};
  shared_ptr<string> vSwitchId{};

  DescribeHaVipsResponseBodyHaVips() {}

  explicit DescribeHaVipsResponseBodyHaVips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associatedEipAddresses) {
      vector<boost::any> temp1;
      for(auto item1:*associatedEipAddresses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AssociatedEipAddresses"] = boost::any(temp1);
    }
    if (associatedInstances) {
      vector<boost::any> temp1;
      for(auto item1:*associatedInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AssociatedInstances"] = boost::any(temp1);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (haVipId) {
      res["HaVipId"] = boost::any(*haVipId);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociatedEipAddresses") != m.end() && !m["AssociatedEipAddresses"].empty()) {
      if (typeid(vector<boost::any>) == m["AssociatedEipAddresses"].type()) {
        vector<DescribeHaVipsResponseBodyHaVipsAssociatedEipAddresses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AssociatedEipAddresses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHaVipsResponseBodyHaVipsAssociatedEipAddresses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        associatedEipAddresses = make_shared<vector<DescribeHaVipsResponseBodyHaVipsAssociatedEipAddresses>>(expect1);
      }
    }
    if (m.find("AssociatedInstances") != m.end() && !m["AssociatedInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["AssociatedInstances"].type()) {
        vector<DescribeHaVipsResponseBodyHaVipsAssociatedInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AssociatedInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHaVipsResponseBodyHaVipsAssociatedInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        associatedInstances = make_shared<vector<DescribeHaVipsResponseBodyHaVipsAssociatedInstances>>(expect1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("HaVipId") != m.end() && !m["HaVipId"].empty()) {
      haVipId = make_shared<string>(boost::any_cast<string>(m["HaVipId"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeHaVipsResponseBodyHaVips() = default;
};
class DescribeHaVipsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHaVipsResponseBodyHaVips>> haVips{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};

  DescribeHaVipsResponseBody() {}

  explicit DescribeHaVipsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (haVips) {
      vector<boost::any> temp1;
      for(auto item1:*haVips){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HaVips"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HaVips") != m.end() && !m["HaVips"].empty()) {
      if (typeid(vector<boost::any>) == m["HaVips"].type()) {
        vector<DescribeHaVipsResponseBodyHaVips> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HaVips"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHaVipsResponseBodyHaVips model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        haVips = make_shared<vector<DescribeHaVipsResponseBodyHaVips>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~DescribeHaVipsResponseBody() = default;
};
class DescribeHaVipsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHaVipsResponseBody> body{};

  DescribeHaVipsResponse() {}

  explicit DescribeHaVipsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHaVipsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHaVipsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHaVipsResponse() = default;
};
class DescribeImageInfosRequest : public Darabonba::Model {
public:
  shared_ptr<string> osType{};

  DescribeImageInfosRequest() {}

  explicit DescribeImageInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
  }


  virtual ~DescribeImageInfosRequest() = default;
};
class DescribeImageInfosResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping : public Darabonba::Model {
public:
  shared_ptr<string> format{};
  shared_ptr<string> size{};
  shared_ptr<string> type{};
  shared_ptr<string> imageId{};

  DescribeImageInfosResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping() {}

  explicit DescribeImageInfosResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (imageId) {
      res["imageId"] = boost::any(*imageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("imageId") != m.end() && !m["imageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["imageId"]));
    }
  }


  virtual ~DescribeImageInfosResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping() = default;
};
class DescribeImageInfosResponseBodyImagesImageDiskDeviceMappings : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageInfosResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping>> diskDeviceMapping{};

  DescribeImageInfosResponseBodyImagesImageDiskDeviceMappings() {}

  explicit DescribeImageInfosResponseBodyImagesImageDiskDeviceMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskDeviceMapping) {
      vector<boost::any> temp1;
      for(auto item1:*diskDeviceMapping){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiskDeviceMapping"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskDeviceMapping") != m.end() && !m["DiskDeviceMapping"].empty()) {
      if (typeid(vector<boost::any>) == m["DiskDeviceMapping"].type()) {
        vector<DescribeImageInfosResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiskDeviceMapping"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageInfosResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diskDeviceMapping = make_shared<vector<DescribeImageInfosResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping>>(expect1);
      }
    }
  }


  virtual ~DescribeImageInfosResponseBodyImagesImageDiskDeviceMappings() = default;
};
class DescribeImageInfosResponseBodyImagesImage : public Darabonba::Model {
public:
  shared_ptr<string> computeType{};
  shared_ptr<string> description{};
  shared_ptr<DescribeImageInfosResponseBodyImagesImageDiskDeviceMappings> diskDeviceMappings{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageSize{};
  shared_ptr<string> imageVersion{};
  shared_ptr<string> OSName{};
  shared_ptr<string> OSType{};
  shared_ptr<string> regionId{};

  DescribeImageInfosResponseBodyImagesImage() {}

  explicit DescribeImageInfosResponseBodyImagesImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (computeType) {
      res["ComputeType"] = boost::any(*computeType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (diskDeviceMappings) {
      res["DiskDeviceMappings"] = diskDeviceMappings ? boost::any(diskDeviceMappings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageSize) {
      res["ImageSize"] = boost::any(*imageSize);
    }
    if (imageVersion) {
      res["ImageVersion"] = boost::any(*imageVersion);
    }
    if (OSName) {
      res["OSName"] = boost::any(*OSName);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComputeType") != m.end() && !m["ComputeType"].empty()) {
      computeType = make_shared<string>(boost::any_cast<string>(m["ComputeType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DiskDeviceMappings") != m.end() && !m["DiskDeviceMappings"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskDeviceMappings"].type()) {
        DescribeImageInfosResponseBodyImagesImageDiskDeviceMappings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskDeviceMappings"]));
        diskDeviceMappings = make_shared<DescribeImageInfosResponseBodyImagesImageDiskDeviceMappings>(model1);
      }
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageSize") != m.end() && !m["ImageSize"].empty()) {
      imageSize = make_shared<string>(boost::any_cast<string>(m["ImageSize"]));
    }
    if (m.find("ImageVersion") != m.end() && !m["ImageVersion"].empty()) {
      imageVersion = make_shared<string>(boost::any_cast<string>(m["ImageVersion"]));
    }
    if (m.find("OSName") != m.end() && !m["OSName"].empty()) {
      OSName = make_shared<string>(boost::any_cast<string>(m["OSName"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeImageInfosResponseBodyImagesImage() = default;
};
class DescribeImageInfosResponseBodyImages : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageInfosResponseBodyImagesImage>> image{};

  DescribeImageInfosResponseBodyImages() {}

  explicit DescribeImageInfosResponseBodyImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      vector<boost::any> temp1;
      for(auto item1:*image){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Image"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      if (typeid(vector<boost::any>) == m["Image"].type()) {
        vector<DescribeImageInfosResponseBodyImagesImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Image"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageInfosResponseBodyImagesImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        image = make_shared<vector<DescribeImageInfosResponseBodyImagesImage>>(expect1);
      }
    }
  }


  virtual ~DescribeImageInfosResponseBodyImages() = default;
};
class DescribeImageInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeImageInfosResponseBodyImages> images{};
  shared_ptr<string> requestId{};

  DescribeImageInfosResponseBody() {}

  explicit DescribeImageInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (images) {
      res["Images"] = images ? boost::any(images->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(map<string, boost::any>) == m["Images"].type()) {
        DescribeImageInfosResponseBodyImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Images"]));
        images = make_shared<DescribeImageInfosResponseBodyImages>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeImageInfosResponseBody() = default;
};
class DescribeImageInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageInfosResponseBody> body{};

  DescribeImageInfosResponse() {}

  explicit DescribeImageInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageInfosResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageInfosResponse() = default;
};
class DescribeImageSharePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<long> aliyunId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};

  DescribeImageSharePermissionRequest() {}

  explicit DescribeImageSharePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunId) {
      res["AliyunId"] = boost::any(*aliyunId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunId") != m.end() && !m["AliyunId"].empty()) {
      aliyunId = make_shared<long>(boost::any_cast<long>(m["AliyunId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
  }


  virtual ~DescribeImageSharePermissionRequest() = default;
};
class DescribeImageSharePermissionResponseBodyAccountsAccount : public Darabonba::Model {
public:
  shared_ptr<string> aliyunUid{};

  DescribeImageSharePermissionResponseBodyAccountsAccount() {}

  explicit DescribeImageSharePermissionResponseBodyAccountsAccount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["AliyunUid"]));
    }
  }


  virtual ~DescribeImageSharePermissionResponseBodyAccountsAccount() = default;
};
class DescribeImageSharePermissionResponseBodyAccounts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageSharePermissionResponseBodyAccountsAccount>> account{};

  DescribeImageSharePermissionResponseBodyAccounts() {}

  explicit DescribeImageSharePermissionResponseBodyAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      vector<boost::any> temp1;
      for(auto item1:*account){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Account"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      if (typeid(vector<boost::any>) == m["Account"].type()) {
        vector<DescribeImageSharePermissionResponseBodyAccountsAccount> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Account"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageSharePermissionResponseBodyAccountsAccount model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        account = make_shared<vector<DescribeImageSharePermissionResponseBodyAccountsAccount>>(expect1);
      }
    }
  }


  virtual ~DescribeImageSharePermissionResponseBodyAccounts() = default;
};
class DescribeImageSharePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeImageSharePermissionResponseBodyAccounts> accounts{};
  shared_ptr<string> imageId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeImageSharePermissionResponseBody() {}

  explicit DescribeImageSharePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accounts) {
      res["Accounts"] = accounts ? boost::any(accounts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Accounts") != m.end() && !m["Accounts"].empty()) {
      if (typeid(map<string, boost::any>) == m["Accounts"].type()) {
        DescribeImageSharePermissionResponseBodyAccounts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Accounts"]));
        accounts = make_shared<DescribeImageSharePermissionResponseBodyAccounts>(model1);
      }
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeImageSharePermissionResponseBody() = default;
};
class DescribeImageSharePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageSharePermissionResponseBody> body{};

  DescribeImageSharePermissionResponse() {}

  explicit DescribeImageSharePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageSharePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageSharePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageSharePermissionResponse() = default;
};
class DescribeImagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> status{};

  DescribeImagesRequest() {}

  explicit DescribeImagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeImagesRequest() = default;
};
class DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping : public Darabonba::Model {
public:
  shared_ptr<string> format{};
  shared_ptr<string> size{};
  shared_ptr<string> type{};
  shared_ptr<string> imageId{};

  DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping() {}

  explicit DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (imageId) {
      res["imageId"] = boost::any(*imageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("imageId") != m.end() && !m["imageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["imageId"]));
    }
  }


  virtual ~DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping() = default;
};
class DescribeImagesResponseBodyImagesImageDiskDeviceMappings : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping>> diskDeviceMapping{};

  DescribeImagesResponseBodyImagesImageDiskDeviceMappings() {}

  explicit DescribeImagesResponseBodyImagesImageDiskDeviceMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskDeviceMapping) {
      vector<boost::any> temp1;
      for(auto item1:*diskDeviceMapping){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiskDeviceMapping"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskDeviceMapping") != m.end() && !m["DiskDeviceMapping"].empty()) {
      if (typeid(vector<boost::any>) == m["DiskDeviceMapping"].type()) {
        vector<DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiskDeviceMapping"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diskDeviceMapping = make_shared<vector<DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping>>(expect1);
      }
    }
  }


  virtual ~DescribeImagesResponseBodyImagesImageDiskDeviceMappings() = default;
};
class DescribeImagesResponseBodyImagesImage : public Darabonba::Model {
public:
  shared_ptr<string> architecture{};
  shared_ptr<string> creationTime{};
  shared_ptr<DescribeImagesResponseBodyImagesImageDiskDeviceMappings> diskDeviceMappings{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> imageOwnerAlias{};
  shared_ptr<string> imageSize{};
  shared_ptr<string> platform{};
  shared_ptr<string> regionId{};
  shared_ptr<string> snapshotId{};

  DescribeImagesResponseBodyImagesImage() {}

  explicit DescribeImagesResponseBodyImagesImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (diskDeviceMappings) {
      res["DiskDeviceMappings"] = diskDeviceMappings ? boost::any(diskDeviceMappings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (imageOwnerAlias) {
      res["ImageOwnerAlias"] = boost::any(*imageOwnerAlias);
    }
    if (imageSize) {
      res["ImageSize"] = boost::any(*imageSize);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DiskDeviceMappings") != m.end() && !m["DiskDeviceMappings"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskDeviceMappings"].type()) {
        DescribeImagesResponseBodyImagesImageDiskDeviceMappings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskDeviceMappings"]));
        diskDeviceMappings = make_shared<DescribeImagesResponseBodyImagesImageDiskDeviceMappings>(model1);
      }
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("ImageOwnerAlias") != m.end() && !m["ImageOwnerAlias"].empty()) {
      imageOwnerAlias = make_shared<string>(boost::any_cast<string>(m["ImageOwnerAlias"]));
    }
    if (m.find("ImageSize") != m.end() && !m["ImageSize"].empty()) {
      imageSize = make_shared<string>(boost::any_cast<string>(m["ImageSize"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
  }


  virtual ~DescribeImagesResponseBodyImagesImage() = default;
};
class DescribeImagesResponseBodyImages : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImagesResponseBodyImagesImage>> image{};

  DescribeImagesResponseBodyImages() {}

  explicit DescribeImagesResponseBodyImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      vector<boost::any> temp1;
      for(auto item1:*image){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Image"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      if (typeid(vector<boost::any>) == m["Image"].type()) {
        vector<DescribeImagesResponseBodyImagesImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Image"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImagesResponseBodyImagesImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        image = make_shared<vector<DescribeImagesResponseBodyImagesImage>>(expect1);
      }
    }
  }


  virtual ~DescribeImagesResponseBodyImages() = default;
};
class DescribeImagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeImagesResponseBodyImages> images{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeImagesResponseBody() {}

  explicit DescribeImagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (images) {
      res["Images"] = images ? boost::any(images->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(map<string, boost::any>) == m["Images"].type()) {
        DescribeImagesResponseBodyImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Images"]));
        images = make_shared<DescribeImagesResponseBodyImages>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeImagesResponseBody() = default;
};
class DescribeImagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImagesResponseBody> body{};

  DescribeImagesResponse() {}

  explicit DescribeImagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImagesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImagesResponse() = default;
};
class DescribeInstanceAutoRenewAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIds{};
  shared_ptr<long> ownerId{};

  DescribeInstanceAutoRenewAttributeRequest() {}

  explicit DescribeInstanceAutoRenewAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeInstanceAutoRenewAttributeRequest() = default;
};
class DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenewal{};
  shared_ptr<string> duration{};
  shared_ptr<string> instanceId{};

  DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute() {}

  explicit DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenewal) {
      res["AutoRenewal"] = boost::any(*autoRenewal);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenewal") != m.end() && !m["AutoRenewal"].empty()) {
      autoRenewal = make_shared<bool>(boost::any_cast<bool>(m["AutoRenewal"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute() = default;
};
class DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute>> instanceRenewAttribute{};

  DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes() {}

  explicit DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceRenewAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*instanceRenewAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceRenewAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceRenewAttribute") != m.end() && !m["InstanceRenewAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceRenewAttribute"].type()) {
        vector<DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceRenewAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceRenewAttribute = make_shared<vector<DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes() = default;
};
class DescribeInstanceAutoRenewAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes> instanceRenewAttributes{};
  shared_ptr<string> requestId{};

  DescribeInstanceAutoRenewAttributeResponseBody() {}

  explicit DescribeInstanceAutoRenewAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (instanceRenewAttributes) {
      res["InstanceRenewAttributes"] = instanceRenewAttributes ? boost::any(instanceRenewAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("InstanceRenewAttributes") != m.end() && !m["InstanceRenewAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceRenewAttributes"].type()) {
        DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceRenewAttributes"]));
        instanceRenewAttributes = make_shared<DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceAutoRenewAttributeResponseBody() = default;
};
class DescribeInstanceAutoRenewAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceAutoRenewAttributeResponseBody> body{};

  DescribeInstanceAutoRenewAttributeResponse() {}

  explicit DescribeInstanceAutoRenewAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceAutoRenewAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceAutoRenewAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceAutoRenewAttributeResponse() = default;
};
class DescribeInstanceBandwidthDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> startTime{};

  DescribeInstanceBandwidthDetailRequest() {}

  explicit DescribeInstanceBandwidthDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeInstanceBandwidthDetailRequest() = default;
};
class DescribeInstanceBandwidthDetailResponseBodyBandwidths : public Darabonba::Model {
public:
  shared_ptr<long> aliUid{};
  shared_ptr<string> bizTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<long> flowType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ip{};
  shared_ptr<string> isp{};
  shared_ptr<long> rxBw{};
  shared_ptr<string> serviceType{};
  shared_ptr<long> txBw{};

  DescribeInstanceBandwidthDetailResponseBodyBandwidths() {}

  explicit DescribeInstanceBandwidthDetailResponseBodyBandwidths(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (bizTime) {
      res["BizTime"] = boost::any(*bizTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (flowType) {
      res["FlowType"] = boost::any(*flowType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (rxBw) {
      res["RxBw"] = boost::any(*rxBw);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (txBw) {
      res["TxBw"] = boost::any(*txBw);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("BizTime") != m.end() && !m["BizTime"].empty()) {
      bizTime = make_shared<string>(boost::any_cast<string>(m["BizTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("FlowType") != m.end() && !m["FlowType"].empty()) {
      flowType = make_shared<long>(boost::any_cast<long>(m["FlowType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("RxBw") != m.end() && !m["RxBw"].empty()) {
      rxBw = make_shared<long>(boost::any_cast<long>(m["RxBw"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("TxBw") != m.end() && !m["TxBw"].empty()) {
      txBw = make_shared<long>(boost::any_cast<long>(m["TxBw"]));
    }
  }


  virtual ~DescribeInstanceBandwidthDetailResponseBodyBandwidths() = default;
};
class DescribeInstanceBandwidthDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceBandwidthDetailResponseBodyBandwidths>> bandwidths{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeInstanceBandwidthDetailResponseBody() {}

  explicit DescribeInstanceBandwidthDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidths) {
      vector<boost::any> temp1;
      for(auto item1:*bandwidths){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Bandwidths"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidths") != m.end() && !m["Bandwidths"].empty()) {
      if (typeid(vector<boost::any>) == m["Bandwidths"].type()) {
        vector<DescribeInstanceBandwidthDetailResponseBodyBandwidths> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Bandwidths"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceBandwidthDetailResponseBodyBandwidths model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bandwidths = make_shared<vector<DescribeInstanceBandwidthDetailResponseBodyBandwidths>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeInstanceBandwidthDetailResponseBody() = default;
};
class DescribeInstanceBandwidthDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceBandwidthDetailResponseBody> body{};

  DescribeInstanceBandwidthDetailResponse() {}

  explicit DescribeInstanceBandwidthDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceBandwidthDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceBandwidthDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceBandwidthDetailResponse() = default;
};
class DescribeInstanceBootConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> bootSet{};
  shared_ptr<string> bootType{};
  shared_ptr<string> diskSet{};
  shared_ptr<string> instanceId{};

  DescribeInstanceBootConfigurationRequest() {}

  explicit DescribeInstanceBootConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bootSet) {
      res["BootSet"] = boost::any(*bootSet);
    }
    if (bootType) {
      res["BootType"] = boost::any(*bootType);
    }
    if (diskSet) {
      res["DiskSet"] = boost::any(*diskSet);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BootSet") != m.end() && !m["BootSet"].empty()) {
      bootSet = make_shared<string>(boost::any_cast<string>(m["BootSet"]));
    }
    if (m.find("BootType") != m.end() && !m["BootType"].empty()) {
      bootType = make_shared<string>(boost::any_cast<string>(m["BootType"]));
    }
    if (m.find("DiskSet") != m.end() && !m["DiskSet"].empty()) {
      diskSet = make_shared<string>(boost::any_cast<string>(m["DiskSet"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeInstanceBootConfigurationRequest() = default;
};
class DescribeInstanceBootConfigurationResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<string> bootSet{};
  shared_ptr<string> bootType{};
  shared_ptr<string> diskSet{};
  shared_ptr<string> instanceId{};

  DescribeInstanceBootConfigurationResponseBodyInstances() {}

  explicit DescribeInstanceBootConfigurationResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bootSet) {
      res["BootSet"] = boost::any(*bootSet);
    }
    if (bootType) {
      res["BootType"] = boost::any(*bootType);
    }
    if (diskSet) {
      res["DiskSet"] = boost::any(*diskSet);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BootSet") != m.end() && !m["BootSet"].empty()) {
      bootSet = make_shared<string>(boost::any_cast<string>(m["BootSet"]));
    }
    if (m.find("BootType") != m.end() && !m["BootType"].empty()) {
      bootType = make_shared<string>(boost::any_cast<string>(m["BootType"]));
    }
    if (m.find("DiskSet") != m.end() && !m["DiskSet"].empty()) {
      diskSet = make_shared<string>(boost::any_cast<string>(m["DiskSet"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeInstanceBootConfigurationResponseBodyInstances() = default;
};
class DescribeInstanceBootConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceBootConfigurationResponseBodyInstances> instances{};
  shared_ptr<string> requestId{};

  DescribeInstanceBootConfigurationResponseBody() {}

  explicit DescribeInstanceBootConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      res["Instances"] = instances ? boost::any(instances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instances"].type()) {
        DescribeInstanceBootConfigurationResponseBodyInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instances"]));
        instances = make_shared<DescribeInstanceBootConfigurationResponseBodyInstances>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceBootConfigurationResponseBody() = default;
};
class DescribeInstanceBootConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceBootConfigurationResponseBody> body{};

  DescribeInstanceBootConfigurationResponse() {}

  explicit DescribeInstanceBootConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceBootConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceBootConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceBootConfigurationResponse() = default;
};
class DescribeInstanceMonitorDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> period{};
  shared_ptr<string> startTime{};

  DescribeInstanceMonitorDataRequest() {}

  explicit DescribeInstanceMonitorDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeInstanceMonitorDataRequest() = default;
};
class DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData : public Darabonba::Model {
public:
  shared_ptr<string> CPU{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> memory{};

  DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData() {}

  explicit DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (CPU) {
      res["CPU"] = boost::any(*CPU);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CPU") != m.end() && !m["CPU"].empty()) {
      CPU = make_shared<string>(boost::any_cast<string>(m["CPU"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<string>(boost::any_cast<string>(m["Memory"]));
    }
  }


  virtual ~DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData() = default;
};
class DescribeInstanceMonitorDataResponseBodyMonitorData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData>> instanceMonitorData{};

  DescribeInstanceMonitorDataResponseBodyMonitorData() {}

  explicit DescribeInstanceMonitorDataResponseBodyMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceMonitorData) {
      vector<boost::any> temp1;
      for(auto item1:*instanceMonitorData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceMonitorData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceMonitorData") != m.end() && !m["InstanceMonitorData"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceMonitorData"].type()) {
        vector<DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceMonitorData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceMonitorData = make_shared<vector<DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceMonitorDataResponseBodyMonitorData() = default;
};
class DescribeInstanceMonitorDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeInstanceMonitorDataResponseBodyMonitorData> monitorData{};
  shared_ptr<string> requestId{};

  DescribeInstanceMonitorDataResponseBody() {}

  explicit DescribeInstanceMonitorDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (monitorData) {
      res["MonitorData"] = monitorData ? boost::any(monitorData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("MonitorData") != m.end() && !m["MonitorData"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonitorData"].type()) {
        DescribeInstanceMonitorDataResponseBodyMonitorData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonitorData"]));
        monitorData = make_shared<DescribeInstanceMonitorDataResponseBodyMonitorData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceMonitorDataResponseBody() = default;
};
class DescribeInstanceMonitorDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceMonitorDataResponseBody> body{};

  DescribeInstanceMonitorDataResponse() {}

  explicit DescribeInstanceMonitorDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceMonitorDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceMonitorDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceMonitorDataResponse() = default;
};
class DescribeInstanceSDGStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> SDGIds{};
  shared_ptr<string> status{};

  DescribeInstanceSDGStatusRequest() {}

  explicit DescribeInstanceSDGStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (SDGIds) {
      res["SDGIds"] = boost::any(*SDGIds);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SDGIds") != m.end() && !m["SDGIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SDGIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SDGIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      SDGIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeInstanceSDGStatusRequest() = default;
};
class DescribeInstanceSDGStatusShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> SDGIdsShrink{};
  shared_ptr<string> status{};

  DescribeInstanceSDGStatusShrinkRequest() {}

  explicit DescribeInstanceSDGStatusShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (SDGIdsShrink) {
      res["SDGIds"] = boost::any(*SDGIdsShrink);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SDGIds") != m.end() && !m["SDGIds"].empty()) {
      SDGIdsShrink = make_shared<string>(boost::any_cast<string>(m["SDGIds"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeInstanceSDGStatusShrinkRequest() = default;
};
class DescribeInstanceSDGStatusResponseBodyDeploymentStatus : public Darabonba::Model {
public:
  shared_ptr<long> blockRwSplitSize{};
  shared_ptr<long> cacheSize{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mountType{};
  shared_ptr<string> phase{};
  shared_ptr<string> SDGId{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};

  DescribeInstanceSDGStatusResponseBodyDeploymentStatus() {}

  explicit DescribeInstanceSDGStatusResponseBodyDeploymentStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockRwSplitSize) {
      res["BlockRwSplitSize"] = boost::any(*blockRwSplitSize);
    }
    if (cacheSize) {
      res["CacheSize"] = boost::any(*cacheSize);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mountType) {
      res["MountType"] = boost::any(*mountType);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockRwSplitSize") != m.end() && !m["BlockRwSplitSize"].empty()) {
      blockRwSplitSize = make_shared<long>(boost::any_cast<long>(m["BlockRwSplitSize"]));
    }
    if (m.find("CacheSize") != m.end() && !m["CacheSize"].empty()) {
      cacheSize = make_shared<long>(boost::any_cast<long>(m["CacheSize"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MountType") != m.end() && !m["MountType"].empty()) {
      mountType = make_shared<string>(boost::any_cast<string>(m["MountType"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeInstanceSDGStatusResponseBodyDeploymentStatus() = default;
};
class DescribeInstanceSDGStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceSDGStatusResponseBodyDeploymentStatus>> deploymentStatus{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};

  DescribeInstanceSDGStatusResponseBody() {}

  explicit DescribeInstanceSDGStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deploymentStatus) {
      vector<boost::any> temp1;
      for(auto item1:*deploymentStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeploymentStatus"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeploymentStatus") != m.end() && !m["DeploymentStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["DeploymentStatus"].type()) {
        vector<DescribeInstanceSDGStatusResponseBodyDeploymentStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeploymentStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceSDGStatusResponseBodyDeploymentStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deploymentStatus = make_shared<vector<DescribeInstanceSDGStatusResponseBodyDeploymentStatus>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~DescribeInstanceSDGStatusResponseBody() = default;
};
class DescribeInstanceSDGStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceSDGStatusResponseBody> body{};

  DescribeInstanceSDGStatusResponse() {}

  explicit DescribeInstanceSDGStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceSDGStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceSDGStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceSDGStatusResponse() = default;
};
class DescribeInstanceSpecResponseBodyInstanceSpecsInstanceSpec : public Darabonba::Model {
public:
  shared_ptr<string> core{};
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> memory{};

  DescribeInstanceSpecResponseBodyInstanceSpecsInstanceSpec() {}

  explicit DescribeInstanceSpecResponseBodyInstanceSpecsInstanceSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (core) {
      res["Core"] = boost::any(*core);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Core") != m.end() && !m["Core"].empty()) {
      core = make_shared<string>(boost::any_cast<string>(m["Core"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<string>(boost::any_cast<string>(m["Memory"]));
    }
  }


  virtual ~DescribeInstanceSpecResponseBodyInstanceSpecsInstanceSpec() = default;
};
class DescribeInstanceSpecResponseBodyInstanceSpecs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceSpecResponseBodyInstanceSpecsInstanceSpec>> instanceSpec{};

  DescribeInstanceSpecResponseBodyInstanceSpecs() {}

  explicit DescribeInstanceSpecResponseBodyInstanceSpecs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceSpec) {
      vector<boost::any> temp1;
      for(auto item1:*instanceSpec){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceSpec"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceSpec") != m.end() && !m["InstanceSpec"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceSpec"].type()) {
        vector<DescribeInstanceSpecResponseBodyInstanceSpecsInstanceSpec> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceSpec"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceSpecResponseBodyInstanceSpecsInstanceSpec model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceSpec = make_shared<vector<DescribeInstanceSpecResponseBodyInstanceSpecsInstanceSpec>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceSpecResponseBodyInstanceSpecs() = default;
};
class DescribeInstanceSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> bandwidthLimit{};
  shared_ptr<long> code{};
  shared_ptr<long> dataDiskMaxSize{};
  shared_ptr<long> dataDiskMinSize{};
  shared_ptr<DescribeInstanceSpecResponseBodyInstanceSpecs> instanceSpecs{};
  shared_ptr<string> requestId{};
  shared_ptr<long> systemDiskMaxSize{};

  DescribeInstanceSpecResponseBody() {}

  explicit DescribeInstanceSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthLimit) {
      res["BandwidthLimit"] = boost::any(*bandwidthLimit);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dataDiskMaxSize) {
      res["DataDiskMaxSize"] = boost::any(*dataDiskMaxSize);
    }
    if (dataDiskMinSize) {
      res["DataDiskMinSize"] = boost::any(*dataDiskMinSize);
    }
    if (instanceSpecs) {
      res["InstanceSpecs"] = instanceSpecs ? boost::any(instanceSpecs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (systemDiskMaxSize) {
      res["SystemDiskMaxSize"] = boost::any(*systemDiskMaxSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthLimit") != m.end() && !m["BandwidthLimit"].empty()) {
      bandwidthLimit = make_shared<long>(boost::any_cast<long>(m["BandwidthLimit"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("DataDiskMaxSize") != m.end() && !m["DataDiskMaxSize"].empty()) {
      dataDiskMaxSize = make_shared<long>(boost::any_cast<long>(m["DataDiskMaxSize"]));
    }
    if (m.find("DataDiskMinSize") != m.end() && !m["DataDiskMinSize"].empty()) {
      dataDiskMinSize = make_shared<long>(boost::any_cast<long>(m["DataDiskMinSize"]));
    }
    if (m.find("InstanceSpecs") != m.end() && !m["InstanceSpecs"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceSpecs"].type()) {
        DescribeInstanceSpecResponseBodyInstanceSpecs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceSpecs"]));
        instanceSpecs = make_shared<DescribeInstanceSpecResponseBodyInstanceSpecs>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SystemDiskMaxSize") != m.end() && !m["SystemDiskMaxSize"].empty()) {
      systemDiskMaxSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskMaxSize"]));
    }
  }


  virtual ~DescribeInstanceSpecResponseBody() = default;
};
class DescribeInstanceSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceSpecResponseBody> body{};

  DescribeInstanceSpecResponse() {}

  explicit DescribeInstanceSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceSpecResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceSpecResponse() = default;
};
class DescribeInstanceTypesResponseBodyInstanceTypesInstanceType : public Darabonba::Model {
public:
  shared_ptr<long> cpuCoreCount{};
  shared_ptr<string> instanceTypeId{};
  shared_ptr<string> instanceTypeName{};
  shared_ptr<long> memorySize{};

  DescribeInstanceTypesResponseBodyInstanceTypesInstanceType() {}

  explicit DescribeInstanceTypesResponseBodyInstanceTypesInstanceType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuCoreCount) {
      res["CpuCoreCount"] = boost::any(*cpuCoreCount);
    }
    if (instanceTypeId) {
      res["InstanceTypeId"] = boost::any(*instanceTypeId);
    }
    if (instanceTypeName) {
      res["InstanceTypeName"] = boost::any(*instanceTypeName);
    }
    if (memorySize) {
      res["MemorySize"] = boost::any(*memorySize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CpuCoreCount") != m.end() && !m["CpuCoreCount"].empty()) {
      cpuCoreCount = make_shared<long>(boost::any_cast<long>(m["CpuCoreCount"]));
    }
    if (m.find("InstanceTypeId") != m.end() && !m["InstanceTypeId"].empty()) {
      instanceTypeId = make_shared<string>(boost::any_cast<string>(m["InstanceTypeId"]));
    }
    if (m.find("InstanceTypeName") != m.end() && !m["InstanceTypeName"].empty()) {
      instanceTypeName = make_shared<string>(boost::any_cast<string>(m["InstanceTypeName"]));
    }
    if (m.find("MemorySize") != m.end() && !m["MemorySize"].empty()) {
      memorySize = make_shared<long>(boost::any_cast<long>(m["MemorySize"]));
    }
  }


  virtual ~DescribeInstanceTypesResponseBodyInstanceTypesInstanceType() = default;
};
class DescribeInstanceTypesResponseBodyInstanceTypes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceTypesResponseBodyInstanceTypesInstanceType>> instanceType{};

  DescribeInstanceTypesResponseBodyInstanceTypes() {}

  explicit DescribeInstanceTypesResponseBodyInstanceTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      vector<boost::any> temp1;
      for(auto item1:*instanceType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceType"].type()) {
        vector<DescribeInstanceTypesResponseBodyInstanceTypesInstanceType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceTypesResponseBodyInstanceTypesInstanceType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceType = make_shared<vector<DescribeInstanceTypesResponseBodyInstanceTypesInstanceType>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceTypesResponseBodyInstanceTypes() = default;
};
class DescribeInstanceTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeInstanceTypesResponseBodyInstanceTypes> instanceTypes{};
  shared_ptr<string> requestId{};

  DescribeInstanceTypesResponseBody() {}

  explicit DescribeInstanceTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = instanceTypes ? boost::any(instanceTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTypes"].type()) {
        DescribeInstanceTypesResponseBodyInstanceTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTypes"]));
        instanceTypes = make_shared<DescribeInstanceTypesResponseBodyInstanceTypes>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceTypesResponseBody() = default;
};
class DescribeInstanceTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceTypesResponseBody> body{};

  DescribeInstanceTypesResponse() {}

  explicit DescribeInstanceTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceTypesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceTypesResponse() = default;
};
class DescribeInstanceVncUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DescribeInstanceVncUrlRequest() {}

  explicit DescribeInstanceVncUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeInstanceVncUrlRequest() = default;
};
class DescribeInstanceVncUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vncUrl{};

  DescribeInstanceVncUrlResponseBody() {}

  explicit DescribeInstanceVncUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vncUrl) {
      res["VncUrl"] = boost::any(*vncUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VncUrl") != m.end() && !m["VncUrl"].empty()) {
      vncUrl = make_shared<string>(boost::any_cast<string>(m["VncUrl"]));
    }
  }


  virtual ~DescribeInstanceVncUrlResponseBody() = default;
};
class DescribeInstanceVncUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceVncUrlResponseBody> body{};

  DescribeInstanceVncUrlResponse() {}

  explicit DescribeInstanceVncUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceVncUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceVncUrlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceVncUrlResponse() = default;
};
class DescribeInstancesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeInstancesRequestTags() {}

  explicit DescribeInstancesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeInstancesRequestTags() = default;
};
class DescribeInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> ensRegionIds{};
  shared_ptr<string> ensServiceId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceResourceType{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> networkId{};
  shared_ptr<string> orderByParams{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> searchKey{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> serviceStatus{};
  shared_ptr<string> status{};
  shared_ptr<vector<DescribeInstancesRequestTags>> tags{};
  shared_ptr<string> vSwitchId{};

  DescribeInstancesRequest() {}

  explicit DescribeInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = boost::any(*ensRegionIds);
    }
    if (ensServiceId) {
      res["EnsServiceId"] = boost::any(*ensServiceId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceResourceType) {
      res["InstanceResourceType"] = boost::any(*instanceResourceType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (orderByParams) {
      res["OrderByParams"] = boost::any(*orderByParams);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (serviceStatus) {
      res["ServiceStatus"] = boost::any(*serviceStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      ensRegionIds = make_shared<string>(boost::any_cast<string>(m["EnsRegionIds"]));
    }
    if (m.find("EnsServiceId") != m.end() && !m["EnsServiceId"].empty()) {
      ensServiceId = make_shared<string>(boost::any_cast<string>(m["EnsServiceId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceResourceType") != m.end() && !m["InstanceResourceType"].empty()) {
      instanceResourceType = make_shared<string>(boost::any_cast<string>(m["InstanceResourceType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("OrderByParams") != m.end() && !m["OrderByParams"].empty()) {
      orderByParams = make_shared<string>(boost::any_cast<string>(m["OrderByParams"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("ServiceStatus") != m.end() && !m["ServiceStatus"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ServiceStatus"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ServiceStatus"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      serviceStatus = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeInstancesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeInstancesRequestTags>>(expect1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeInstancesRequest() = default;
};
class DescribeInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> ensRegionIds{};
  shared_ptr<string> ensServiceId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceResourceType{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> networkId{};
  shared_ptr<string> orderByParams{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> searchKey{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> serviceStatusShrink{};
  shared_ptr<string> status{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<string> vSwitchId{};

  DescribeInstancesShrinkRequest() {}

  explicit DescribeInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = boost::any(*ensRegionIds);
    }
    if (ensServiceId) {
      res["EnsServiceId"] = boost::any(*ensServiceId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceResourceType) {
      res["InstanceResourceType"] = boost::any(*instanceResourceType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (orderByParams) {
      res["OrderByParams"] = boost::any(*orderByParams);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (serviceStatusShrink) {
      res["ServiceStatus"] = boost::any(*serviceStatusShrink);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      ensRegionIds = make_shared<string>(boost::any_cast<string>(m["EnsRegionIds"]));
    }
    if (m.find("EnsServiceId") != m.end() && !m["EnsServiceId"].empty()) {
      ensServiceId = make_shared<string>(boost::any_cast<string>(m["EnsServiceId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceResourceType") != m.end() && !m["InstanceResourceType"].empty()) {
      instanceResourceType = make_shared<string>(boost::any_cast<string>(m["InstanceResourceType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("OrderByParams") != m.end() && !m["OrderByParams"].empty()) {
      orderByParams = make_shared<string>(boost::any_cast<string>(m["OrderByParams"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("ServiceStatus") != m.end() && !m["ServiceStatus"].empty()) {
      serviceStatusShrink = make_shared<string>(boost::any_cast<string>(m["ServiceStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeInstancesShrinkRequest() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceDataDiskDataDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> diskId{};
  shared_ptr<string> diskName{};
  shared_ptr<long> diskSize{};
  shared_ptr<string> encryptKeyId{};
  shared_ptr<bool> encrypted{};
  shared_ptr<long> size{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> diskType{};
  shared_ptr<string> name{};
  shared_ptr<long> storage{};
  shared_ptr<string> uuid{};

  DescribeInstancesResponseBodyInstancesInstanceDataDiskDataDisk() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceDataDiskDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (diskSize) {
      res["DiskSize"] = boost::any(*diskSize);
    }
    if (encryptKeyId) {
      res["EncryptKeyId"] = boost::any(*encryptKeyId);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (deviceType) {
      res["device_type"] = boost::any(*deviceType);
    }
    if (diskType) {
      res["disk_type"] = boost::any(*diskType);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (storage) {
      res["storage"] = boost::any(*storage);
    }
    if (uuid) {
      res["uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      diskSize = make_shared<long>(boost::any_cast<long>(m["DiskSize"]));
    }
    if (m.find("EncryptKeyId") != m.end() && !m["EncryptKeyId"].empty()) {
      encryptKeyId = make_shared<string>(boost::any_cast<string>(m["EncryptKeyId"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["Encrypted"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("device_type") != m.end() && !m["device_type"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["device_type"]));
    }
    if (m.find("disk_type") != m.end() && !m["disk_type"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["disk_type"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("storage") != m.end() && !m["storage"].empty()) {
      storage = make_shared<long>(boost::any_cast<long>(m["storage"]));
    }
    if (m.find("uuid") != m.end() && !m["uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["uuid"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceDataDiskDataDisk() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceDataDisk : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstanceDataDiskDataDisk>> dataDisk{};

  DescribeInstancesResponseBodyInstancesInstanceDataDisk() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstanceDataDiskDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstanceDataDiskDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<DescribeInstancesResponseBodyInstancesInstanceDataDiskDataDisk>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceDataDisk() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ipAddress{};

  DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipAddress = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceNetworkAttributesPrivateIpAddress : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ipAddress{};

  DescribeInstancesResponseBodyInstancesInstanceNetworkAttributesPrivateIpAddress() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceNetworkAttributesPrivateIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipAddress = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceNetworkAttributesPrivateIpAddress() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceNetworkAttributes : public Darabonba::Model {
public:
  shared_ptr<string> networkId{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceNetworkAttributesPrivateIpAddress> privateIpAddress{};
  shared_ptr<string> vSwitchId{};

  DescribeInstancesResponseBodyInstancesInstanceNetworkAttributes() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceNetworkAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = privateIpAddress ? boost::any(privateIpAddress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivateIpAddress"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceNetworkAttributesPrivateIpAddress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivateIpAddress"]));
        privateIpAddress = make_shared<DescribeInstancesResponseBodyInstancesInstanceNetworkAttributesPrivateIpAddress>(model1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceNetworkAttributes() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6SetsIpv6Set : public Darabonba::Model {
public:
  shared_ptr<string> ipv6Address{};

  DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6SetsIpv6Set() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6SetsIpv6Set(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      ipv6Address = make_shared<string>(boost::any_cast<string>(m["Ipv6Address"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6SetsIpv6Set() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6Sets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6SetsIpv6Set>> ipv6Set{};

  DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6Sets() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6Sets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Set) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6Set){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6Set"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Set") != m.end() && !m["Ipv6Set"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6Set"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6SetsIpv6Set> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6Set"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6SetsIpv6Set model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6Set = make_shared<vector<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6SetsIpv6Set>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6Sets() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSetsPrivateIpSet : public Darabonba::Model {
public:
  shared_ptr<bool> primary{};
  shared_ptr<string> privateIpAddress{};

  DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSetsPrivateIpSet() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSetsPrivateIpSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (primary) {
      res["Primary"] = boost::any(*primary);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Primary") != m.end() && !m["Primary"].empty()) {
      primary = make_shared<bool>(boost::any_cast<bool>(m["Primary"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSetsPrivateIpSet() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSetsPrivateIpSet>> privateIpSet{};

  DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSets() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateIpSet) {
      vector<boost::any> temp1;
      for(auto item1:*privateIpSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrivateIpSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateIpSet") != m.end() && !m["PrivateIpSet"].empty()) {
      if (typeid(vector<boost::any>) == m["PrivateIpSet"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSetsPrivateIpSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrivateIpSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSetsPrivateIpSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        privateIpSet = make_shared<vector<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSetsPrivateIpSet>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSets() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaces : public Darabonba::Model {
public:
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6Sets> ipv6Sets{};
  shared_ptr<string> macAddress{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> primaryIpAddress{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSets> privateIpSets{};
  shared_ptr<string> type{};

  DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaces() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Sets) {
      res["Ipv6Sets"] = ipv6Sets ? boost::any(ipv6Sets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (macAddress) {
      res["MacAddress"] = boost::any(*macAddress);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (primaryIpAddress) {
      res["PrimaryIpAddress"] = boost::any(*primaryIpAddress);
    }
    if (privateIpSets) {
      res["PrivateIpSets"] = privateIpSets ? boost::any(privateIpSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Sets") != m.end() && !m["Ipv6Sets"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6Sets"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6Sets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6Sets"]));
        ipv6Sets = make_shared<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesIpv6Sets>(model1);
      }
    }
    if (m.find("MacAddress") != m.end() && !m["MacAddress"].empty()) {
      macAddress = make_shared<string>(boost::any_cast<string>(m["MacAddress"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("PrimaryIpAddress") != m.end() && !m["PrimaryIpAddress"].empty()) {
      primaryIpAddress = make_shared<string>(boost::any_cast<string>(m["PrimaryIpAddress"]));
    }
    if (m.find("PrivateIpSets") != m.end() && !m["PrivateIpSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivateIpSets"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivateIpSets"]));
        privateIpSets = make_shared<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacesPrivateIpSets>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaces() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaces>> networkInterfaces{};

  DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaces) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterfaces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterfaces"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaces") != m.end() && !m["NetworkInterfaces"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterfaces"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterfaces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterfaces = make_shared<vector<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaces>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces() = default;
};
class DescribeInstancesResponseBodyInstancesInstancePrivateIpAddressesPrivateIpAddress : public Darabonba::Model {
public:
  shared_ptr<string> gateWay{};
  shared_ptr<string> ip{};
  shared_ptr<string> isp{};

  DescribeInstancesResponseBodyInstancesInstancePrivateIpAddressesPrivateIpAddress() {}

  explicit DescribeInstancesResponseBodyInstancesInstancePrivateIpAddressesPrivateIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gateWay) {
      res["GateWay"] = boost::any(*gateWay);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GateWay") != m.end() && !m["GateWay"].empty()) {
      gateWay = make_shared<string>(boost::any_cast<string>(m["GateWay"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstancePrivateIpAddressesPrivateIpAddress() = default;
};
class DescribeInstancesResponseBodyInstancesInstancePrivateIpAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstancePrivateIpAddressesPrivateIpAddress>> privateIpAddress{};

  DescribeInstancesResponseBodyInstancesInstancePrivateIpAddresses() {}

  explicit DescribeInstancesResponseBodyInstancesInstancePrivateIpAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateIpAddress) {
      vector<boost::any> temp1;
      for(auto item1:*privateIpAddress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrivateIpAddress"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      if (typeid(vector<boost::any>) == m["PrivateIpAddress"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstancePrivateIpAddressesPrivateIpAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrivateIpAddress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstancePrivateIpAddressesPrivateIpAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        privateIpAddress = make_shared<vector<DescribeInstancesResponseBodyInstancesInstancePrivateIpAddressesPrivateIpAddress>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstancePrivateIpAddresses() = default;
};
class DescribeInstancesResponseBodyInstancesInstancePublicIpAddress : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ipAddress{};

  DescribeInstancesResponseBodyInstancesInstancePublicIpAddress() {}

  explicit DescribeInstancesResponseBodyInstancesInstancePublicIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipAddress = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstancePublicIpAddress() = default;
};
class DescribeInstancesResponseBodyInstancesInstancePublicIpAddressesPublicIpAddress : public Darabonba::Model {
public:
  shared_ptr<string> gateWay{};
  shared_ptr<string> ip{};
  shared_ptr<string> isp{};

  DescribeInstancesResponseBodyInstancesInstancePublicIpAddressesPublicIpAddress() {}

  explicit DescribeInstancesResponseBodyInstancesInstancePublicIpAddressesPublicIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gateWay) {
      res["GateWay"] = boost::any(*gateWay);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GateWay") != m.end() && !m["GateWay"].empty()) {
      gateWay = make_shared<string>(boost::any_cast<string>(m["GateWay"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstancePublicIpAddressesPublicIpAddress() = default;
};
class DescribeInstancesResponseBodyInstancesInstancePublicIpAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstancePublicIpAddressesPublicIpAddress>> publicIpAddress{};

  DescribeInstancesResponseBodyInstancesInstancePublicIpAddresses() {}

  explicit DescribeInstancesResponseBodyInstancesInstancePublicIpAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (publicIpAddress) {
      vector<boost::any> temp1;
      for(auto item1:*publicIpAddress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PublicIpAddress"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PublicIpAddress") != m.end() && !m["PublicIpAddress"].empty()) {
      if (typeid(vector<boost::any>) == m["PublicIpAddress"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstancePublicIpAddressesPublicIpAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PublicIpAddress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstancePublicIpAddressesPublicIpAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        publicIpAddress = make_shared<vector<DescribeInstancesResponseBodyInstancesInstancePublicIpAddressesPublicIpAddress>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstancePublicIpAddresses() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> securityGroupId{};

  DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> diskId{};
  shared_ptr<string> diskName{};
  shared_ptr<long> size{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> diskType{};
  shared_ptr<string> name{};
  shared_ptr<long> storage{};
  shared_ptr<string> uuid{};

  DescribeInstancesResponseBodyInstancesInstanceSystemDisk() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (deviceType) {
      res["device_type"] = boost::any(*deviceType);
    }
    if (diskType) {
      res["disk_type"] = boost::any(*diskType);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (storage) {
      res["storage"] = boost::any(*storage);
    }
    if (uuid) {
      res["uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("device_type") != m.end() && !m["device_type"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["device_type"]));
    }
    if (m.find("disk_type") != m.end() && !m["disk_type"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["disk_type"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("storage") != m.end() && !m["storage"].empty()) {
      storage = make_shared<long>(boost::any_cast<long>(m["storage"]));
    }
    if (m.find("uuid") != m.end() && !m["uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["uuid"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceSystemDisk() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceTagsTags : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeInstancesResponseBodyInstancesInstanceTagsTags() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceTagsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceTagsTags() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstanceTagsTags>> tags{};

  DescribeInstancesResponseBodyInstancesInstanceTags() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstanceTagsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstanceTagsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeInstancesResponseBodyInstancesInstanceTagsTags>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceTags() = default;
};
class DescribeInstancesResponseBodyInstancesInstance : public Darabonba::Model {
public:
  shared_ptr<string> autoReleaseTime{};
  shared_ptr<string> cpu{};
  shared_ptr<string> creationTime{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceDataDisk> dataDisk{};
  shared_ptr<long> disk{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> hostName{};
  shared_ptr<string> imageId{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress> innerIpAddress{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceResourceType{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> keyPairName{};
  shared_ptr<long> memory{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceNetworkAttributes> networkAttributes{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces> networkInterfaces{};
  shared_ptr<string> OSName{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstancePrivateIpAddresses> privateIpAddresses{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstancePublicIpAddress> publicIpAddress{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstancePublicIpAddresses> publicIpAddresses{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds> securityGroupIds{};
  shared_ptr<string> serviceStatus{};
  shared_ptr<string> specName{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> status{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceSystemDisk> systemDisk{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceTags> tags{};

  DescribeInstancesResponseBodyInstancesInstance() {}

  explicit DescribeInstancesResponseBodyInstancesInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoReleaseTime) {
      res["AutoReleaseTime"] = boost::any(*autoReleaseTime);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (dataDisk) {
      res["DataDisk"] = dataDisk ? boost::any(dataDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (disk) {
      res["Disk"] = boost::any(*disk);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (innerIpAddress) {
      res["InnerIpAddress"] = innerIpAddress ? boost::any(innerIpAddress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceResourceType) {
      res["InstanceResourceType"] = boost::any(*instanceResourceType);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (networkAttributes) {
      res["NetworkAttributes"] = networkAttributes ? boost::any(networkAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkInterfaces) {
      res["NetworkInterfaces"] = networkInterfaces ? boost::any(networkInterfaces->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (OSName) {
      res["OSName"] = boost::any(*OSName);
    }
    if (privateIpAddresses) {
      res["PrivateIpAddresses"] = privateIpAddresses ? boost::any(privateIpAddresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (publicIpAddress) {
      res["PublicIpAddress"] = publicIpAddress ? boost::any(publicIpAddress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (publicIpAddresses) {
      res["PublicIpAddresses"] = publicIpAddresses ? boost::any(publicIpAddresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = securityGroupIds ? boost::any(securityGroupIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceStatus) {
      res["ServiceStatus"] = boost::any(*serviceStatus);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoReleaseTime") != m.end() && !m["AutoReleaseTime"].empty()) {
      autoReleaseTime = make_shared<string>(boost::any_cast<string>(m["AutoReleaseTime"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<string>(boost::any_cast<string>(m["Cpu"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataDisk"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceDataDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataDisk"]));
        dataDisk = make_shared<DescribeInstancesResponseBodyInstancesInstanceDataDisk>(model1);
      }
    }
    if (m.find("Disk") != m.end() && !m["Disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["Disk"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InnerIpAddress") != m.end() && !m["InnerIpAddress"].empty()) {
      if (typeid(map<string, boost::any>) == m["InnerIpAddress"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InnerIpAddress"]));
        innerIpAddress = make_shared<DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceResourceType") != m.end() && !m["InstanceResourceType"].empty()) {
      instanceResourceType = make_shared<string>(boost::any_cast<string>(m["InstanceResourceType"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("NetworkAttributes") != m.end() && !m["NetworkAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkAttributes"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceNetworkAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkAttributes"]));
        networkAttributes = make_shared<DescribeInstancesResponseBodyInstancesInstanceNetworkAttributes>(model1);
      }
    }
    if (m.find("NetworkInterfaces") != m.end() && !m["NetworkInterfaces"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkInterfaces"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkInterfaces"]));
        networkInterfaces = make_shared<DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces>(model1);
      }
    }
    if (m.find("OSName") != m.end() && !m["OSName"].empty()) {
      OSName = make_shared<string>(boost::any_cast<string>(m["OSName"]));
    }
    if (m.find("PrivateIpAddresses") != m.end() && !m["PrivateIpAddresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivateIpAddresses"].type()) {
        DescribeInstancesResponseBodyInstancesInstancePrivateIpAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivateIpAddresses"]));
        privateIpAddresses = make_shared<DescribeInstancesResponseBodyInstancesInstancePrivateIpAddresses>(model1);
      }
    }
    if (m.find("PublicIpAddress") != m.end() && !m["PublicIpAddress"].empty()) {
      if (typeid(map<string, boost::any>) == m["PublicIpAddress"].type()) {
        DescribeInstancesResponseBodyInstancesInstancePublicIpAddress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PublicIpAddress"]));
        publicIpAddress = make_shared<DescribeInstancesResponseBodyInstancesInstancePublicIpAddress>(model1);
      }
    }
    if (m.find("PublicIpAddresses") != m.end() && !m["PublicIpAddresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["PublicIpAddresses"].type()) {
        DescribeInstancesResponseBodyInstancesInstancePublicIpAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PublicIpAddresses"]));
        publicIpAddresses = make_shared<DescribeInstancesResponseBodyInstancesInstancePublicIpAddresses>(model1);
      }
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroupIds"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroupIds"]));
        securityGroupIds = make_shared<DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds>(model1);
      }
    }
    if (m.find("ServiceStatus") != m.end() && !m["ServiceStatus"].empty()) {
      serviceStatus = make_shared<string>(boost::any_cast<string>(m["ServiceStatus"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<DescribeInstancesResponseBodyInstancesInstanceSystemDisk>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeInstancesResponseBodyInstancesInstanceTags>(model1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstance() = default;
};
class DescribeInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstance>> instance{};

  DescribeInstancesResponseBodyInstances() {}

  explicit DescribeInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      vector<boost::any> temp1;
      for(auto item1:*instance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(vector<boost::any>) == m["Instance"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instance = make_shared<vector<DescribeInstancesResponseBodyInstancesInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstances() = default;
};
class DescribeInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeInstancesResponseBodyInstances> instances{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeInstancesResponseBody() {}

  explicit DescribeInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (instances) {
      res["Instances"] = instances ? boost::any(instances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instances"].type()) {
        DescribeInstancesResponseBodyInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instances"]));
        instances = make_shared<DescribeInstancesResponseBodyInstances>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeInstancesResponseBody() = default;
};
class DescribeInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstancesResponseBody> body{};

  DescribeInstancesResponse() {}

  explicit DescribeInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstancesResponse() = default;
};
class DescribeKeyPairsRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyPairId{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};

  DescribeKeyPairsRequest() {}

  explicit DescribeKeyPairsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPairId) {
      res["KeyPairId"] = boost::any(*keyPairId);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPairId") != m.end() && !m["KeyPairId"].empty()) {
      keyPairId = make_shared<string>(boost::any_cast<string>(m["KeyPairId"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
  }


  virtual ~DescribeKeyPairsRequest() = default;
};
class DescribeKeyPairsResponseBodyKeyPairsKeyPair : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> keyPairFingerPrint{};
  shared_ptr<string> keyPairId{};
  shared_ptr<string> keyPairName{};

  DescribeKeyPairsResponseBodyKeyPairsKeyPair() {}

  explicit DescribeKeyPairsResponseBodyKeyPairsKeyPair(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (keyPairFingerPrint) {
      res["KeyPairFingerPrint"] = boost::any(*keyPairFingerPrint);
    }
    if (keyPairId) {
      res["KeyPairId"] = boost::any(*keyPairId);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("KeyPairFingerPrint") != m.end() && !m["KeyPairFingerPrint"].empty()) {
      keyPairFingerPrint = make_shared<string>(boost::any_cast<string>(m["KeyPairFingerPrint"]));
    }
    if (m.find("KeyPairId") != m.end() && !m["KeyPairId"].empty()) {
      keyPairId = make_shared<string>(boost::any_cast<string>(m["KeyPairId"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
  }


  virtual ~DescribeKeyPairsResponseBodyKeyPairsKeyPair() = default;
};
class DescribeKeyPairsResponseBodyKeyPairs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeKeyPairsResponseBodyKeyPairsKeyPair>> keyPair{};

  DescribeKeyPairsResponseBodyKeyPairs() {}

  explicit DescribeKeyPairsResponseBodyKeyPairs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPair) {
      vector<boost::any> temp1;
      for(auto item1:*keyPair){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["KeyPair"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPair") != m.end() && !m["KeyPair"].empty()) {
      if (typeid(vector<boost::any>) == m["KeyPair"].type()) {
        vector<DescribeKeyPairsResponseBodyKeyPairsKeyPair> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["KeyPair"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeKeyPairsResponseBodyKeyPairsKeyPair model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        keyPair = make_shared<vector<DescribeKeyPairsResponseBodyKeyPairsKeyPair>>(expect1);
      }
    }
  }


  virtual ~DescribeKeyPairsResponseBodyKeyPairs() = default;
};
class DescribeKeyPairsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeKeyPairsResponseBodyKeyPairs> keyPairs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeKeyPairsResponseBody() {}

  explicit DescribeKeyPairsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPairs) {
      res["KeyPairs"] = keyPairs ? boost::any(keyPairs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPairs") != m.end() && !m["KeyPairs"].empty()) {
      if (typeid(map<string, boost::any>) == m["KeyPairs"].type()) {
        DescribeKeyPairsResponseBodyKeyPairs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["KeyPairs"]));
        keyPairs = make_shared<DescribeKeyPairsResponseBodyKeyPairs>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeKeyPairsResponseBody() = default;
};
class DescribeKeyPairsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeKeyPairsResponseBody> body{};

  DescribeKeyPairsResponse() {}

  explicit DescribeKeyPairsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeKeyPairsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeKeyPairsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeKeyPairsResponse() = default;
};
class DescribeLoadBalancerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> loadBalancerId{};

  DescribeLoadBalancerAttributeRequest() {}

  explicit DescribeLoadBalancerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~DescribeLoadBalancerAttributeRequest() = default;
};
class DescribeLoadBalancerAttributeResponseBodyBackendServers : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<string> port{};
  shared_ptr<string> serverId{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  DescribeLoadBalancerAttributeResponseBodyBackendServers() {}

  explicit DescribeLoadBalancerAttributeResponseBodyBackendServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DescribeLoadBalancerAttributeResponseBodyBackendServers() = default;
};
class DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocols : public Darabonba::Model {
public:
  shared_ptr<long> backendServerPort{};
  shared_ptr<string> description{};
  shared_ptr<long> forwardPort{};
  shared_ptr<string> listenerForward{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> listenerProtocol{};

  DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocols() {}

  explicit DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocols(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServerPort) {
      res["BackendServerPort"] = boost::any(*backendServerPort);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (forwardPort) {
      res["ForwardPort"] = boost::any(*forwardPort);
    }
    if (listenerForward) {
      res["ListenerForward"] = boost::any(*listenerForward);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (listenerProtocol) {
      res["ListenerProtocol"] = boost::any(*listenerProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServerPort") != m.end() && !m["BackendServerPort"].empty()) {
      backendServerPort = make_shared<long>(boost::any_cast<long>(m["BackendServerPort"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ForwardPort") != m.end() && !m["ForwardPort"].empty()) {
      forwardPort = make_shared<long>(boost::any_cast<long>(m["ForwardPort"]));
    }
    if (m.find("ListenerForward") != m.end() && !m["ListenerForward"].empty()) {
      listenerForward = make_shared<string>(boost::any_cast<string>(m["ListenerForward"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("ListenerProtocol") != m.end() && !m["ListenerProtocol"].empty()) {
      listenerProtocol = make_shared<string>(boost::any_cast<string>(m["ListenerProtocol"]));
    }
  }


  virtual ~DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocols() = default;
};
class DescribeLoadBalancerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> addressIPVersion{};
  shared_ptr<vector<DescribeLoadBalancerAttributeResponseBodyBackendServers>> backendServers{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> createTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<vector<string>> listenerPorts{};
  shared_ptr<vector<DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocols>> listenerPortsAndProtocols{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> loadBalancerName{};
  shared_ptr<string> loadBalancerSpec{};
  shared_ptr<string> loadBalancerStatus{};
  shared_ptr<string> networkId{};
  shared_ptr<string> payType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vSwitchId{};

  DescribeLoadBalancerAttributeResponseBody() {}

  explicit DescribeLoadBalancerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (addressIPVersion) {
      res["AddressIPVersion"] = boost::any(*addressIPVersion);
    }
    if (backendServers) {
      vector<boost::any> temp1;
      for(auto item1:*backendServers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendServers"] = boost::any(temp1);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (listenerPorts) {
      res["ListenerPorts"] = boost::any(*listenerPorts);
    }
    if (listenerPortsAndProtocols) {
      vector<boost::any> temp1;
      for(auto item1:*listenerPortsAndProtocols){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ListenerPortsAndProtocols"] = boost::any(temp1);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (loadBalancerName) {
      res["LoadBalancerName"] = boost::any(*loadBalancerName);
    }
    if (loadBalancerSpec) {
      res["LoadBalancerSpec"] = boost::any(*loadBalancerSpec);
    }
    if (loadBalancerStatus) {
      res["LoadBalancerStatus"] = boost::any(*loadBalancerStatus);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AddressIPVersion") != m.end() && !m["AddressIPVersion"].empty()) {
      addressIPVersion = make_shared<string>(boost::any_cast<string>(m["AddressIPVersion"]));
    }
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendServers"].type()) {
        vector<DescribeLoadBalancerAttributeResponseBodyBackendServers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendServers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLoadBalancerAttributeResponseBodyBackendServers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendServers = make_shared<vector<DescribeLoadBalancerAttributeResponseBodyBackendServers>>(expect1);
      }
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("ListenerPorts") != m.end() && !m["ListenerPorts"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ListenerPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ListenerPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      listenerPorts = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ListenerPortsAndProtocols") != m.end() && !m["ListenerPortsAndProtocols"].empty()) {
      if (typeid(vector<boost::any>) == m["ListenerPortsAndProtocols"].type()) {
        vector<DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocols> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ListenerPortsAndProtocols"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocols model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        listenerPortsAndProtocols = make_shared<vector<DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocols>>(expect1);
      }
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("LoadBalancerName") != m.end() && !m["LoadBalancerName"].empty()) {
      loadBalancerName = make_shared<string>(boost::any_cast<string>(m["LoadBalancerName"]));
    }
    if (m.find("LoadBalancerSpec") != m.end() && !m["LoadBalancerSpec"].empty()) {
      loadBalancerSpec = make_shared<string>(boost::any_cast<string>(m["LoadBalancerSpec"]));
    }
    if (m.find("LoadBalancerStatus") != m.end() && !m["LoadBalancerStatus"].empty()) {
      loadBalancerStatus = make_shared<string>(boost::any_cast<string>(m["LoadBalancerStatus"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeLoadBalancerAttributeResponseBody() = default;
};
class DescribeLoadBalancerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLoadBalancerAttributeResponseBody> body{};

  DescribeLoadBalancerAttributeResponse() {}

  explicit DescribeLoadBalancerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoadBalancerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoadBalancerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoadBalancerAttributeResponse() = default;
};
class DescribeLoadBalancerHTTPListenerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};

  DescribeLoadBalancerHTTPListenerAttributeRequest() {}

  explicit DescribeLoadBalancerHTTPListenerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~DescribeLoadBalancerHTTPListenerAttributeRequest() = default;
};
class DescribeLoadBalancerHTTPListenerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> backendServerPort{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> description{};
  shared_ptr<long> forwardPort{};
  shared_ptr<string> healthCheck{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckMethod{};
  shared_ptr<long> healthCheckTimeout{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<string> listenerForward{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> requestId{};
  shared_ptr<long> requestTimeout{};
  shared_ptr<string> scheduler{};
  shared_ptr<string> serverCertificateId{};
  shared_ptr<string> status{};
  shared_ptr<long> unhealthyThreshold{};
  shared_ptr<string> XForwardedFor{};

  DescribeLoadBalancerHTTPListenerAttributeResponseBody() {}

  explicit DescribeLoadBalancerHTTPListenerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServerPort) {
      res["BackendServerPort"] = boost::any(*backendServerPort);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (forwardPort) {
      res["ForwardPort"] = boost::any(*forwardPort);
    }
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckMethod) {
      res["HealthCheckMethod"] = boost::any(*healthCheckMethod);
    }
    if (healthCheckTimeout) {
      res["HealthCheckTimeout"] = boost::any(*healthCheckTimeout);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (listenerForward) {
      res["ListenerForward"] = boost::any(*listenerForward);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestTimeout) {
      res["RequestTimeout"] = boost::any(*requestTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (serverCertificateId) {
      res["ServerCertificateId"] = boost::any(*serverCertificateId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    if (XForwardedFor) {
      res["XForwardedFor"] = boost::any(*XForwardedFor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServerPort") != m.end() && !m["BackendServerPort"].empty()) {
      backendServerPort = make_shared<long>(boost::any_cast<long>(m["BackendServerPort"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ForwardPort") != m.end() && !m["ForwardPort"].empty()) {
      forwardPort = make_shared<long>(boost::any_cast<long>(m["ForwardPort"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckMethod") != m.end() && !m["HealthCheckMethod"].empty()) {
      healthCheckMethod = make_shared<string>(boost::any_cast<string>(m["HealthCheckMethod"]));
    }
    if (m.find("HealthCheckTimeout") != m.end() && !m["HealthCheckTimeout"].empty()) {
      healthCheckTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckTimeout"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("ListenerForward") != m.end() && !m["ListenerForward"].empty()) {
      listenerForward = make_shared<string>(boost::any_cast<string>(m["ListenerForward"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestTimeout") != m.end() && !m["RequestTimeout"].empty()) {
      requestTimeout = make_shared<long>(boost::any_cast<long>(m["RequestTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("ServerCertificateId") != m.end() && !m["ServerCertificateId"].empty()) {
      serverCertificateId = make_shared<string>(boost::any_cast<string>(m["ServerCertificateId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
    if (m.find("XForwardedFor") != m.end() && !m["XForwardedFor"].empty()) {
      XForwardedFor = make_shared<string>(boost::any_cast<string>(m["XForwardedFor"]));
    }
  }


  virtual ~DescribeLoadBalancerHTTPListenerAttributeResponseBody() = default;
};
class DescribeLoadBalancerHTTPListenerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLoadBalancerHTTPListenerAttributeResponseBody> body{};

  DescribeLoadBalancerHTTPListenerAttributeResponse() {}

  explicit DescribeLoadBalancerHTTPListenerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoadBalancerHTTPListenerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoadBalancerHTTPListenerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoadBalancerHTTPListenerAttributeResponse() = default;
};
class DescribeLoadBalancerHTTPSListenerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};

  DescribeLoadBalancerHTTPSListenerAttributeRequest() {}

  explicit DescribeLoadBalancerHTTPSListenerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~DescribeLoadBalancerHTTPSListenerAttributeRequest() = default;
};
class DescribeLoadBalancerHTTPSListenerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> backendServerPort{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> description{};
  shared_ptr<long> forwardPort{};
  shared_ptr<string> healthCheck{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckMethod{};
  shared_ptr<long> healthCheckTimeout{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<string> listenerForward{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> requestId{};
  shared_ptr<long> requestTimeout{};
  shared_ptr<string> scheduler{};
  shared_ptr<string> serverCertificateId{};
  shared_ptr<string> status{};
  shared_ptr<long> unhealthyThreshold{};

  DescribeLoadBalancerHTTPSListenerAttributeResponseBody() {}

  explicit DescribeLoadBalancerHTTPSListenerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServerPort) {
      res["BackendServerPort"] = boost::any(*backendServerPort);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (forwardPort) {
      res["ForwardPort"] = boost::any(*forwardPort);
    }
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckMethod) {
      res["HealthCheckMethod"] = boost::any(*healthCheckMethod);
    }
    if (healthCheckTimeout) {
      res["HealthCheckTimeout"] = boost::any(*healthCheckTimeout);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (listenerForward) {
      res["ListenerForward"] = boost::any(*listenerForward);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestTimeout) {
      res["RequestTimeout"] = boost::any(*requestTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (serverCertificateId) {
      res["ServerCertificateId"] = boost::any(*serverCertificateId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServerPort") != m.end() && !m["BackendServerPort"].empty()) {
      backendServerPort = make_shared<long>(boost::any_cast<long>(m["BackendServerPort"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ForwardPort") != m.end() && !m["ForwardPort"].empty()) {
      forwardPort = make_shared<long>(boost::any_cast<long>(m["ForwardPort"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckMethod") != m.end() && !m["HealthCheckMethod"].empty()) {
      healthCheckMethod = make_shared<string>(boost::any_cast<string>(m["HealthCheckMethod"]));
    }
    if (m.find("HealthCheckTimeout") != m.end() && !m["HealthCheckTimeout"].empty()) {
      healthCheckTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckTimeout"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("ListenerForward") != m.end() && !m["ListenerForward"].empty()) {
      listenerForward = make_shared<string>(boost::any_cast<string>(m["ListenerForward"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestTimeout") != m.end() && !m["RequestTimeout"].empty()) {
      requestTimeout = make_shared<long>(boost::any_cast<long>(m["RequestTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("ServerCertificateId") != m.end() && !m["ServerCertificateId"].empty()) {
      serverCertificateId = make_shared<string>(boost::any_cast<string>(m["ServerCertificateId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~DescribeLoadBalancerHTTPSListenerAttributeResponseBody() = default;
};
class DescribeLoadBalancerHTTPSListenerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLoadBalancerHTTPSListenerAttributeResponseBody> body{};

  DescribeLoadBalancerHTTPSListenerAttributeResponse() {}

  explicit DescribeLoadBalancerHTTPSListenerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoadBalancerHTTPSListenerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoadBalancerHTTPSListenerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoadBalancerHTTPSListenerAttributeResponse() = default;
};
class DescribeLoadBalancerListenMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> proto{};
  shared_ptr<string> startTime{};
  shared_ptr<string> VPort{};

  DescribeLoadBalancerListenMonitorRequest() {}

  explicit DescribeLoadBalancerListenMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (proto) {
      res["Proto"] = boost::any(*proto);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (VPort) {
      res["VPort"] = boost::any(*VPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("Proto") != m.end() && !m["Proto"].empty()) {
      proto = make_shared<string>(boost::any_cast<string>(m["Proto"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("VPort") != m.end() && !m["VPort"].empty()) {
      VPort = make_shared<string>(boost::any_cast<string>(m["VPort"]));
    }
  }


  virtual ~DescribeLoadBalancerListenMonitorRequest() = default;
};
class DescribeLoadBalancerListenMonitorResponseBodyLoadBalancerMonitorListenData : public Darabonba::Model {
public:
  shared_ptr<string> actConns{};
  shared_ptr<string> bizTime{};
  shared_ptr<string> conns{};
  shared_ptr<string> dropConns{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> inActConns{};
  shared_ptr<string> inBytes{};
  shared_ptr<string> inDropBytes{};
  shared_ptr<string> inDropPkts{};
  shared_ptr<string> inPkts{};
  shared_ptr<string> inValidRsNum{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> outBytes{};
  shared_ptr<string> outDropBytes{};
  shared_ptr<string> outDropPkts{};
  shared_ptr<string> outPkts{};
  shared_ptr<string> proto{};
  shared_ptr<string> VPort{};
  shared_ptr<string> validRsNum{};
  shared_ptr<string> vip{};
  shared_ptr<string> vni{};

  DescribeLoadBalancerListenMonitorResponseBodyLoadBalancerMonitorListenData() {}

  explicit DescribeLoadBalancerListenMonitorResponseBodyLoadBalancerMonitorListenData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actConns) {
      res["ActConns"] = boost::any(*actConns);
    }
    if (bizTime) {
      res["BizTime"] = boost::any(*bizTime);
    }
    if (conns) {
      res["Conns"] = boost::any(*conns);
    }
    if (dropConns) {
      res["DropConns"] = boost::any(*dropConns);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (inActConns) {
      res["InActConns"] = boost::any(*inActConns);
    }
    if (inBytes) {
      res["InBytes"] = boost::any(*inBytes);
    }
    if (inDropBytes) {
      res["InDropBytes"] = boost::any(*inDropBytes);
    }
    if (inDropPkts) {
      res["InDropPkts"] = boost::any(*inDropPkts);
    }
    if (inPkts) {
      res["InPkts"] = boost::any(*inPkts);
    }
    if (inValidRsNum) {
      res["InValidRsNum"] = boost::any(*inValidRsNum);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (outBytes) {
      res["OutBytes"] = boost::any(*outBytes);
    }
    if (outDropBytes) {
      res["OutDropBytes"] = boost::any(*outDropBytes);
    }
    if (outDropPkts) {
      res["OutDropPkts"] = boost::any(*outDropPkts);
    }
    if (outPkts) {
      res["OutPkts"] = boost::any(*outPkts);
    }
    if (proto) {
      res["Proto"] = boost::any(*proto);
    }
    if (VPort) {
      res["VPort"] = boost::any(*VPort);
    }
    if (validRsNum) {
      res["ValidRsNum"] = boost::any(*validRsNum);
    }
    if (vip) {
      res["Vip"] = boost::any(*vip);
    }
    if (vni) {
      res["Vni"] = boost::any(*vni);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActConns") != m.end() && !m["ActConns"].empty()) {
      actConns = make_shared<string>(boost::any_cast<string>(m["ActConns"]));
    }
    if (m.find("BizTime") != m.end() && !m["BizTime"].empty()) {
      bizTime = make_shared<string>(boost::any_cast<string>(m["BizTime"]));
    }
    if (m.find("Conns") != m.end() && !m["Conns"].empty()) {
      conns = make_shared<string>(boost::any_cast<string>(m["Conns"]));
    }
    if (m.find("DropConns") != m.end() && !m["DropConns"].empty()) {
      dropConns = make_shared<string>(boost::any_cast<string>(m["DropConns"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InActConns") != m.end() && !m["InActConns"].empty()) {
      inActConns = make_shared<string>(boost::any_cast<string>(m["InActConns"]));
    }
    if (m.find("InBytes") != m.end() && !m["InBytes"].empty()) {
      inBytes = make_shared<string>(boost::any_cast<string>(m["InBytes"]));
    }
    if (m.find("InDropBytes") != m.end() && !m["InDropBytes"].empty()) {
      inDropBytes = make_shared<string>(boost::any_cast<string>(m["InDropBytes"]));
    }
    if (m.find("InDropPkts") != m.end() && !m["InDropPkts"].empty()) {
      inDropPkts = make_shared<string>(boost::any_cast<string>(m["InDropPkts"]));
    }
    if (m.find("InPkts") != m.end() && !m["InPkts"].empty()) {
      inPkts = make_shared<string>(boost::any_cast<string>(m["InPkts"]));
    }
    if (m.find("InValidRsNum") != m.end() && !m["InValidRsNum"].empty()) {
      inValidRsNum = make_shared<string>(boost::any_cast<string>(m["InValidRsNum"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("OutBytes") != m.end() && !m["OutBytes"].empty()) {
      outBytes = make_shared<string>(boost::any_cast<string>(m["OutBytes"]));
    }
    if (m.find("OutDropBytes") != m.end() && !m["OutDropBytes"].empty()) {
      outDropBytes = make_shared<string>(boost::any_cast<string>(m["OutDropBytes"]));
    }
    if (m.find("OutDropPkts") != m.end() && !m["OutDropPkts"].empty()) {
      outDropPkts = make_shared<string>(boost::any_cast<string>(m["OutDropPkts"]));
    }
    if (m.find("OutPkts") != m.end() && !m["OutPkts"].empty()) {
      outPkts = make_shared<string>(boost::any_cast<string>(m["OutPkts"]));
    }
    if (m.find("Proto") != m.end() && !m["Proto"].empty()) {
      proto = make_shared<string>(boost::any_cast<string>(m["Proto"]));
    }
    if (m.find("VPort") != m.end() && !m["VPort"].empty()) {
      VPort = make_shared<string>(boost::any_cast<string>(m["VPort"]));
    }
    if (m.find("ValidRsNum") != m.end() && !m["ValidRsNum"].empty()) {
      validRsNum = make_shared<string>(boost::any_cast<string>(m["ValidRsNum"]));
    }
    if (m.find("Vip") != m.end() && !m["Vip"].empty()) {
      vip = make_shared<string>(boost::any_cast<string>(m["Vip"]));
    }
    if (m.find("Vni") != m.end() && !m["Vni"].empty()) {
      vni = make_shared<string>(boost::any_cast<string>(m["Vni"]));
    }
  }


  virtual ~DescribeLoadBalancerListenMonitorResponseBodyLoadBalancerMonitorListenData() = default;
};
class DescribeLoadBalancerListenMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLoadBalancerListenMonitorResponseBodyLoadBalancerMonitorListenData>> loadBalancerMonitorListenData{};
  shared_ptr<string> requestId{};

  DescribeLoadBalancerListenMonitorResponseBody() {}

  explicit DescribeLoadBalancerListenMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerMonitorListenData) {
      vector<boost::any> temp1;
      for(auto item1:*loadBalancerMonitorListenData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LoadBalancerMonitorListenData"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerMonitorListenData") != m.end() && !m["LoadBalancerMonitorListenData"].empty()) {
      if (typeid(vector<boost::any>) == m["LoadBalancerMonitorListenData"].type()) {
        vector<DescribeLoadBalancerListenMonitorResponseBodyLoadBalancerMonitorListenData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LoadBalancerMonitorListenData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLoadBalancerListenMonitorResponseBodyLoadBalancerMonitorListenData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        loadBalancerMonitorListenData = make_shared<vector<DescribeLoadBalancerListenMonitorResponseBodyLoadBalancerMonitorListenData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLoadBalancerListenMonitorResponseBody() = default;
};
class DescribeLoadBalancerListenMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLoadBalancerListenMonitorResponseBody> body{};

  DescribeLoadBalancerListenMonitorResponse() {}

  explicit DescribeLoadBalancerListenMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoadBalancerListenMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoadBalancerListenMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoadBalancerListenMonitorResponse() = default;
};
class DescribeLoadBalancerListenersRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeLoadBalancerListenersRequest() {}

  explicit DescribeLoadBalancerListenersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeLoadBalancerListenersRequest() = default;
};
class DescribeLoadBalancerListenersResponseBodyListenersListener : public Darabonba::Model {
public:
  shared_ptr<long> backendServerPort{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> forwardPort{};
  shared_ptr<string> listenerForward{};
  shared_ptr<string> listenerPort{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> protocol{};
  shared_ptr<string> status{};

  DescribeLoadBalancerListenersResponseBodyListenersListener() {}

  explicit DescribeLoadBalancerListenersResponseBodyListenersListener(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServerPort) {
      res["BackendServerPort"] = boost::any(*backendServerPort);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (forwardPort) {
      res["ForwardPort"] = boost::any(*forwardPort);
    }
    if (listenerForward) {
      res["ListenerForward"] = boost::any(*listenerForward);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServerPort") != m.end() && !m["BackendServerPort"].empty()) {
      backendServerPort = make_shared<long>(boost::any_cast<long>(m["BackendServerPort"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ForwardPort") != m.end() && !m["ForwardPort"].empty()) {
      forwardPort = make_shared<string>(boost::any_cast<string>(m["ForwardPort"]));
    }
    if (m.find("ListenerForward") != m.end() && !m["ListenerForward"].empty()) {
      listenerForward = make_shared<string>(boost::any_cast<string>(m["ListenerForward"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<string>(boost::any_cast<string>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeLoadBalancerListenersResponseBodyListenersListener() = default;
};
class DescribeLoadBalancerListenersResponseBodyListeners : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLoadBalancerListenersResponseBodyListenersListener>> listener{};

  DescribeLoadBalancerListenersResponseBodyListeners() {}

  explicit DescribeLoadBalancerListenersResponseBodyListeners(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listener) {
      vector<boost::any> temp1;
      for(auto item1:*listener){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Listener"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Listener") != m.end() && !m["Listener"].empty()) {
      if (typeid(vector<boost::any>) == m["Listener"].type()) {
        vector<DescribeLoadBalancerListenersResponseBodyListenersListener> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Listener"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLoadBalancerListenersResponseBodyListenersListener model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        listener = make_shared<vector<DescribeLoadBalancerListenersResponseBodyListenersListener>>(expect1);
      }
    }
  }


  virtual ~DescribeLoadBalancerListenersResponseBodyListeners() = default;
};
class DescribeLoadBalancerListenersResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLoadBalancerListenersResponseBodyListeners> listeners{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeLoadBalancerListenersResponseBody() {}

  explicit DescribeLoadBalancerListenersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listeners) {
      res["Listeners"] = listeners ? boost::any(listeners->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Listeners") != m.end() && !m["Listeners"].empty()) {
      if (typeid(map<string, boost::any>) == m["Listeners"].type()) {
        DescribeLoadBalancerListenersResponseBodyListeners model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Listeners"]));
        listeners = make_shared<DescribeLoadBalancerListenersResponseBodyListeners>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeLoadBalancerListenersResponseBody() = default;
};
class DescribeLoadBalancerListenersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLoadBalancerListenersResponseBody> body{};

  DescribeLoadBalancerListenersResponse() {}

  explicit DescribeLoadBalancerListenersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoadBalancerListenersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoadBalancerListenersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoadBalancerListenersResponse() = default;
};
class DescribeLoadBalancerSpecRequest : public Darabonba::Model {
public:
  shared_ptr<string> loadBalancerSpec{};

  DescribeLoadBalancerSpecRequest() {}

  explicit DescribeLoadBalancerSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerSpec) {
      res["LoadBalancerSpec"] = boost::any(*loadBalancerSpec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerSpec") != m.end() && !m["LoadBalancerSpec"].empty()) {
      loadBalancerSpec = make_shared<string>(boost::any_cast<string>(m["LoadBalancerSpec"]));
    }
  }


  virtual ~DescribeLoadBalancerSpecRequest() = default;
};
class DescribeLoadBalancerSpecResponseBodyLoadBalancerSpecs : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> loadBalancerSpec{};

  DescribeLoadBalancerSpecResponseBodyLoadBalancerSpecs() {}

  explicit DescribeLoadBalancerSpecResponseBodyLoadBalancerSpecs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (loadBalancerSpec) {
      res["LoadBalancerSpec"] = boost::any(*loadBalancerSpec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("LoadBalancerSpec") != m.end() && !m["LoadBalancerSpec"].empty()) {
      loadBalancerSpec = make_shared<string>(boost::any_cast<string>(m["LoadBalancerSpec"]));
    }
  }


  virtual ~DescribeLoadBalancerSpecResponseBodyLoadBalancerSpecs() = default;
};
class DescribeLoadBalancerSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLoadBalancerSpecResponseBodyLoadBalancerSpecs>> loadBalancerSpecs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeLoadBalancerSpecResponseBody() {}

  explicit DescribeLoadBalancerSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerSpecs) {
      vector<boost::any> temp1;
      for(auto item1:*loadBalancerSpecs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LoadBalancerSpecs"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerSpecs") != m.end() && !m["LoadBalancerSpecs"].empty()) {
      if (typeid(vector<boost::any>) == m["LoadBalancerSpecs"].type()) {
        vector<DescribeLoadBalancerSpecResponseBodyLoadBalancerSpecs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LoadBalancerSpecs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLoadBalancerSpecResponseBodyLoadBalancerSpecs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        loadBalancerSpecs = make_shared<vector<DescribeLoadBalancerSpecResponseBodyLoadBalancerSpecs>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeLoadBalancerSpecResponseBody() = default;
};
class DescribeLoadBalancerSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLoadBalancerSpecResponseBody> body{};

  DescribeLoadBalancerSpecResponse() {}

  explicit DescribeLoadBalancerSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoadBalancerSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoadBalancerSpecResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoadBalancerSpecResponse() = default;
};
class DescribeLoadBalancerTCPListenerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};

  DescribeLoadBalancerTCPListenerAttributeRequest() {}

  explicit DescribeLoadBalancerTCPListenerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~DescribeLoadBalancerTCPListenerAttributeRequest() = default;
};
class DescribeLoadBalancerTCPListenerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> backendServerPort{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> description{};
  shared_ptr<string> eipTransmit{};
  shared_ptr<long> establishedTimeout{};
  shared_ptr<string> healthCheck{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<long> healthCheckConnectTimeout{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckType{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> listenerPort{};
  shared_ptr<long> persistenceTimeout{};
  shared_ptr<string> requestId{};
  shared_ptr<string> scheduler{};
  shared_ptr<string> status{};
  shared_ptr<long> unhealthyThreshold{};

  DescribeLoadBalancerTCPListenerAttributeResponseBody() {}

  explicit DescribeLoadBalancerTCPListenerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServerPort) {
      res["BackendServerPort"] = boost::any(*backendServerPort);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eipTransmit) {
      res["EipTransmit"] = boost::any(*eipTransmit);
    }
    if (establishedTimeout) {
      res["EstablishedTimeout"] = boost::any(*establishedTimeout);
    }
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckConnectTimeout) {
      res["HealthCheckConnectTimeout"] = boost::any(*healthCheckConnectTimeout);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckType) {
      res["HealthCheckType"] = boost::any(*healthCheckType);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (persistenceTimeout) {
      res["PersistenceTimeout"] = boost::any(*persistenceTimeout);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServerPort") != m.end() && !m["BackendServerPort"].empty()) {
      backendServerPort = make_shared<long>(boost::any_cast<long>(m["BackendServerPort"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EipTransmit") != m.end() && !m["EipTransmit"].empty()) {
      eipTransmit = make_shared<string>(boost::any_cast<string>(m["EipTransmit"]));
    }
    if (m.find("EstablishedTimeout") != m.end() && !m["EstablishedTimeout"].empty()) {
      establishedTimeout = make_shared<long>(boost::any_cast<long>(m["EstablishedTimeout"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckConnectTimeout") != m.end() && !m["HealthCheckConnectTimeout"].empty()) {
      healthCheckConnectTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectTimeout"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckType") != m.end() && !m["HealthCheckType"].empty()) {
      healthCheckType = make_shared<string>(boost::any_cast<string>(m["HealthCheckType"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("PersistenceTimeout") != m.end() && !m["PersistenceTimeout"].empty()) {
      persistenceTimeout = make_shared<long>(boost::any_cast<long>(m["PersistenceTimeout"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~DescribeLoadBalancerTCPListenerAttributeResponseBody() = default;
};
class DescribeLoadBalancerTCPListenerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLoadBalancerTCPListenerAttributeResponseBody> body{};

  DescribeLoadBalancerTCPListenerAttributeResponse() {}

  explicit DescribeLoadBalancerTCPListenerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoadBalancerTCPListenerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoadBalancerTCPListenerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoadBalancerTCPListenerAttributeResponse() = default;
};
class DescribeLoadBalancerUDPListenerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};

  DescribeLoadBalancerUDPListenerAttributeRequest() {}

  explicit DescribeLoadBalancerUDPListenerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~DescribeLoadBalancerUDPListenerAttributeRequest() = default;
};
class DescribeLoadBalancerUDPListenerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> backendServerPort{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> description{};
  shared_ptr<string> eipTransmit{};
  shared_ptr<long> establishedTimeout{};
  shared_ptr<string> healthCheck{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<long> healthCheckConnectTimeout{};
  shared_ptr<string> healthCheckExp{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckReq{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> requestId{};
  shared_ptr<string> scheduler{};
  shared_ptr<string> status{};
  shared_ptr<long> unhealthyThreshold{};

  DescribeLoadBalancerUDPListenerAttributeResponseBody() {}

  explicit DescribeLoadBalancerUDPListenerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServerPort) {
      res["BackendServerPort"] = boost::any(*backendServerPort);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eipTransmit) {
      res["EipTransmit"] = boost::any(*eipTransmit);
    }
    if (establishedTimeout) {
      res["EstablishedTimeout"] = boost::any(*establishedTimeout);
    }
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckConnectTimeout) {
      res["HealthCheckConnectTimeout"] = boost::any(*healthCheckConnectTimeout);
    }
    if (healthCheckExp) {
      res["HealthCheckExp"] = boost::any(*healthCheckExp);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckReq) {
      res["HealthCheckReq"] = boost::any(*healthCheckReq);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServerPort") != m.end() && !m["BackendServerPort"].empty()) {
      backendServerPort = make_shared<long>(boost::any_cast<long>(m["BackendServerPort"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EipTransmit") != m.end() && !m["EipTransmit"].empty()) {
      eipTransmit = make_shared<string>(boost::any_cast<string>(m["EipTransmit"]));
    }
    if (m.find("EstablishedTimeout") != m.end() && !m["EstablishedTimeout"].empty()) {
      establishedTimeout = make_shared<long>(boost::any_cast<long>(m["EstablishedTimeout"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckConnectTimeout") != m.end() && !m["HealthCheckConnectTimeout"].empty()) {
      healthCheckConnectTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectTimeout"]));
    }
    if (m.find("HealthCheckExp") != m.end() && !m["HealthCheckExp"].empty()) {
      healthCheckExp = make_shared<string>(boost::any_cast<string>(m["HealthCheckExp"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckReq") != m.end() && !m["HealthCheckReq"].empty()) {
      healthCheckReq = make_shared<string>(boost::any_cast<string>(m["HealthCheckReq"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~DescribeLoadBalancerUDPListenerAttributeResponseBody() = default;
};
class DescribeLoadBalancerUDPListenerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLoadBalancerUDPListenerAttributeResponseBody> body{};

  DescribeLoadBalancerUDPListenerAttributeResponse() {}

  explicit DescribeLoadBalancerUDPListenerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoadBalancerUDPListenerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoadBalancerUDPListenerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoadBalancerUDPListenerAttributeResponse() = default;
};
class DescribeLoadBalancersRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<vector<string>> ensRegionIds{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> loadBalancerName{};
  shared_ptr<string> loadBalancerStatus{};
  shared_ptr<string> networkId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> serverId{};
  shared_ptr<string> vSwitchId{};

  DescribeLoadBalancersRequest() {}

  explicit DescribeLoadBalancersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = boost::any(*ensRegionIds);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (loadBalancerName) {
      res["LoadBalancerName"] = boost::any(*loadBalancerName);
    }
    if (loadBalancerStatus) {
      res["LoadBalancerStatus"] = boost::any(*loadBalancerStatus);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnsRegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnsRegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ensRegionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("LoadBalancerName") != m.end() && !m["LoadBalancerName"].empty()) {
      loadBalancerName = make_shared<string>(boost::any_cast<string>(m["LoadBalancerName"]));
    }
    if (m.find("LoadBalancerStatus") != m.end() && !m["LoadBalancerStatus"].empty()) {
      loadBalancerStatus = make_shared<string>(boost::any_cast<string>(m["LoadBalancerStatus"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeLoadBalancersRequest() = default;
};
class DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> addressIPVersion{};
  shared_ptr<string> createTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> loadBalancerName{};
  shared_ptr<string> loadBalancerStatus{};
  shared_ptr<string> networkId{};
  shared_ptr<string> payType{};
  shared_ptr<string> vSwitchId{};

  DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer() {}

  explicit DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (addressIPVersion) {
      res["AddressIPVersion"] = boost::any(*addressIPVersion);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (loadBalancerName) {
      res["LoadBalancerName"] = boost::any(*loadBalancerName);
    }
    if (loadBalancerStatus) {
      res["LoadBalancerStatus"] = boost::any(*loadBalancerStatus);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AddressIPVersion") != m.end() && !m["AddressIPVersion"].empty()) {
      addressIPVersion = make_shared<string>(boost::any_cast<string>(m["AddressIPVersion"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("LoadBalancerName") != m.end() && !m["LoadBalancerName"].empty()) {
      loadBalancerName = make_shared<string>(boost::any_cast<string>(m["LoadBalancerName"]));
    }
    if (m.find("LoadBalancerStatus") != m.end() && !m["LoadBalancerStatus"].empty()) {
      loadBalancerStatus = make_shared<string>(boost::any_cast<string>(m["LoadBalancerStatus"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer() = default;
};
class DescribeLoadBalancersResponseBodyLoadBalancers : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer>> loadBalancer{};

  DescribeLoadBalancersResponseBodyLoadBalancers() {}

  explicit DescribeLoadBalancersResponseBodyLoadBalancers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancer) {
      vector<boost::any> temp1;
      for(auto item1:*loadBalancer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LoadBalancer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancer") != m.end() && !m["LoadBalancer"].empty()) {
      if (typeid(vector<boost::any>) == m["LoadBalancer"].type()) {
        vector<DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LoadBalancer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        loadBalancer = make_shared<vector<DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer>>(expect1);
      }
    }
  }


  virtual ~DescribeLoadBalancersResponseBodyLoadBalancers() = default;
};
class DescribeLoadBalancersResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLoadBalancersResponseBodyLoadBalancers> loadBalancers{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeLoadBalancersResponseBody() {}

  explicit DescribeLoadBalancersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancers) {
      res["LoadBalancers"] = loadBalancers ? boost::any(loadBalancers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancers") != m.end() && !m["LoadBalancers"].empty()) {
      if (typeid(map<string, boost::any>) == m["LoadBalancers"].type()) {
        DescribeLoadBalancersResponseBodyLoadBalancers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LoadBalancers"]));
        loadBalancers = make_shared<DescribeLoadBalancersResponseBodyLoadBalancers>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeLoadBalancersResponseBody() = default;
};
class DescribeLoadBalancersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLoadBalancersResponseBody> body{};

  DescribeLoadBalancersResponse() {}

  explicit DescribeLoadBalancersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoadBalancersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoadBalancersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoadBalancersResponse() = default;
};
class DescribeMeasurementDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<string> startDate{};

  DescribeMeasurementDataRequest() {}

  explicit DescribeMeasurementDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
  }


  virtual ~DescribeMeasurementDataRequest() = default;
};
class DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData : public Darabonba::Model {
public:
  shared_ptr<string> costCode{};
  shared_ptr<string> costName{};
  shared_ptr<long> costVal{};

  DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData() {}

  explicit DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costCode) {
      res["CostCode"] = boost::any(*costCode);
    }
    if (costName) {
      res["CostName"] = boost::any(*costName);
    }
    if (costVal) {
      res["CostVal"] = boost::any(*costVal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CostCode") != m.end() && !m["CostCode"].empty()) {
      costCode = make_shared<string>(boost::any_cast<string>(m["CostCode"]));
    }
    if (m.find("CostName") != m.end() && !m["CostName"].empty()) {
      costName = make_shared<string>(boost::any_cast<string>(m["CostName"]));
    }
    if (m.find("CostVal") != m.end() && !m["CostVal"].empty()) {
      costVal = make_shared<long>(boost::any_cast<long>(m["CostVal"]));
    }
  }


  virtual ~DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData() = default;
};
class DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData>> bandWidthFeeData{};

  DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas() {}

  explicit DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidthFeeData) {
      vector<boost::any> temp1;
      for(auto item1:*bandWidthFeeData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BandWidthFeeData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidthFeeData") != m.end() && !m["BandWidthFeeData"].empty()) {
      if (typeid(vector<boost::any>) == m["BandWidthFeeData"].type()) {
        vector<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BandWidthFeeData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bandWidthFeeData = make_shared<vector<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData>>(expect1);
      }
    }
  }


  virtual ~DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas() = default;
};
class DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeData : public Darabonba::Model {
public:
  shared_ptr<long> memory{};
  shared_ptr<long> storage{};
  shared_ptr<long> vcpu{};

  DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeData() {}

  explicit DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (storage) {
      res["Storage"] = boost::any(*storage);
    }
    if (vcpu) {
      res["Vcpu"] = boost::any(*vcpu);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("Storage") != m.end() && !m["Storage"].empty()) {
      storage = make_shared<long>(boost::any_cast<long>(m["Storage"]));
    }
    if (m.find("Vcpu") != m.end() && !m["Vcpu"].empty()) {
      vcpu = make_shared<long>(boost::any_cast<long>(m["Vcpu"]));
    }
  }


  virtual ~DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeData() = default;
};
class DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetailsResourceFeeDataDetail : public Darabonba::Model {
public:
  shared_ptr<string> costCode{};
  shared_ptr<string> costName{};
  shared_ptr<long> costVal{};
  shared_ptr<string> resourceType{};

  DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetailsResourceFeeDataDetail() {}

  explicit DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetailsResourceFeeDataDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costCode) {
      res["CostCode"] = boost::any(*costCode);
    }
    if (costName) {
      res["CostName"] = boost::any(*costName);
    }
    if (costVal) {
      res["CostVal"] = boost::any(*costVal);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CostCode") != m.end() && !m["CostCode"].empty()) {
      costCode = make_shared<string>(boost::any_cast<string>(m["CostCode"]));
    }
    if (m.find("CostName") != m.end() && !m["CostName"].empty()) {
      costName = make_shared<string>(boost::any_cast<string>(m["CostName"]));
    }
    if (m.find("CostVal") != m.end() && !m["CostVal"].empty()) {
      costVal = make_shared<long>(boost::any_cast<long>(m["CostVal"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetailsResourceFeeDataDetail() = default;
};
class DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetailsResourceFeeDataDetail>> resourceFeeDataDetail{};

  DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetails() {}

  explicit DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceFeeDataDetail) {
      vector<boost::any> temp1;
      for(auto item1:*resourceFeeDataDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceFeeDataDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceFeeDataDetail") != m.end() && !m["ResourceFeeDataDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceFeeDataDetail"].type()) {
        vector<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetailsResourceFeeDataDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceFeeDataDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetailsResourceFeeDataDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceFeeDataDetail = make_shared<vector<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetailsResourceFeeDataDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetails() = default;
};
class DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementData : public Darabonba::Model {
public:
  shared_ptr<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas> bandWidthFeeDatas{};
  shared_ptr<string> chargeModel{};
  shared_ptr<string> costCycle{};
  shared_ptr<string> costEndTime{};
  shared_ptr<string> costStartTime{};
  shared_ptr<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeData> resourceFeeData{};
  shared_ptr<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetails> resourceFeeDataDetails{};

  DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementData() {}

  explicit DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidthFeeDatas) {
      res["BandWidthFeeDatas"] = bandWidthFeeDatas ? boost::any(bandWidthFeeDatas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (chargeModel) {
      res["ChargeModel"] = boost::any(*chargeModel);
    }
    if (costCycle) {
      res["CostCycle"] = boost::any(*costCycle);
    }
    if (costEndTime) {
      res["CostEndTime"] = boost::any(*costEndTime);
    }
    if (costStartTime) {
      res["CostStartTime"] = boost::any(*costStartTime);
    }
    if (resourceFeeData) {
      res["ResourceFeeData"] = resourceFeeData ? boost::any(resourceFeeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resourceFeeDataDetails) {
      res["ResourceFeeDataDetails"] = resourceFeeDataDetails ? boost::any(resourceFeeDataDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidthFeeDatas") != m.end() && !m["BandWidthFeeDatas"].empty()) {
      if (typeid(map<string, boost::any>) == m["BandWidthFeeDatas"].type()) {
        DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BandWidthFeeDatas"]));
        bandWidthFeeDatas = make_shared<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas>(model1);
      }
    }
    if (m.find("ChargeModel") != m.end() && !m["ChargeModel"].empty()) {
      chargeModel = make_shared<string>(boost::any_cast<string>(m["ChargeModel"]));
    }
    if (m.find("CostCycle") != m.end() && !m["CostCycle"].empty()) {
      costCycle = make_shared<string>(boost::any_cast<string>(m["CostCycle"]));
    }
    if (m.find("CostEndTime") != m.end() && !m["CostEndTime"].empty()) {
      costEndTime = make_shared<string>(boost::any_cast<string>(m["CostEndTime"]));
    }
    if (m.find("CostStartTime") != m.end() && !m["CostStartTime"].empty()) {
      costStartTime = make_shared<string>(boost::any_cast<string>(m["CostStartTime"]));
    }
    if (m.find("ResourceFeeData") != m.end() && !m["ResourceFeeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceFeeData"].type()) {
        DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceFeeData"]));
        resourceFeeData = make_shared<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeData>(model1);
      }
    }
    if (m.find("ResourceFeeDataDetails") != m.end() && !m["ResourceFeeDataDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceFeeDataDetails"].type()) {
        DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceFeeDataDetails"]));
        resourceFeeDataDetails = make_shared<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetails>(model1);
      }
    }
  }


  virtual ~DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementData() = default;
};
class DescribeMeasurementDataResponseBodyMeasurementDatas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementData>> measurementData{};

  DescribeMeasurementDataResponseBodyMeasurementDatas() {}

  explicit DescribeMeasurementDataResponseBodyMeasurementDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (measurementData) {
      vector<boost::any> temp1;
      for(auto item1:*measurementData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MeasurementData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MeasurementData") != m.end() && !m["MeasurementData"].empty()) {
      if (typeid(vector<boost::any>) == m["MeasurementData"].type()) {
        vector<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MeasurementData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        measurementData = make_shared<vector<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementData>>(expect1);
      }
    }
  }


  virtual ~DescribeMeasurementDataResponseBodyMeasurementDatas() = default;
};
class DescribeMeasurementDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeMeasurementDataResponseBodyMeasurementDatas> measurementDatas{};
  shared_ptr<string> requestId{};

  DescribeMeasurementDataResponseBody() {}

  explicit DescribeMeasurementDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (measurementDatas) {
      res["MeasurementDatas"] = measurementDatas ? boost::any(measurementDatas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MeasurementDatas") != m.end() && !m["MeasurementDatas"].empty()) {
      if (typeid(map<string, boost::any>) == m["MeasurementDatas"].type()) {
        DescribeMeasurementDataResponseBodyMeasurementDatas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MeasurementDatas"]));
        measurementDatas = make_shared<DescribeMeasurementDataResponseBodyMeasurementDatas>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeasurementDataResponseBody() = default;
};
class DescribeMeasurementDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeasurementDataResponseBody> body{};

  DescribeMeasurementDataResponse() {}

  explicit DescribeMeasurementDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeasurementDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeasurementDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeasurementDataResponse() = default;
};
class DescribeMountTargetsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> fileSystemId{};
  shared_ptr<string> mountTargetName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeMountTargetsRequest() {}

  explicit DescribeMountTargetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (fileSystemId) {
      res["FileSystemId"] = boost::any(*fileSystemId);
    }
    if (mountTargetName) {
      res["MountTargetName"] = boost::any(*mountTargetName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("FileSystemId") != m.end() && !m["FileSystemId"].empty()) {
      fileSystemId = make_shared<string>(boost::any_cast<string>(m["FileSystemId"]));
    }
    if (m.find("MountTargetName") != m.end() && !m["MountTargetName"].empty()) {
      mountTargetName = make_shared<string>(boost::any_cast<string>(m["MountTargetName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeMountTargetsRequest() = default;
};
class DescribeMountTargetsResponseBodyMountTargets : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> fileSystemId{};
  shared_ptr<string> mountTargetDomain{};
  shared_ptr<string> mountTargetName{};
  shared_ptr<string> netWorkId{};
  shared_ptr<string> status{};

  DescribeMountTargetsResponseBodyMountTargets() {}

  explicit DescribeMountTargetsResponseBodyMountTargets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (fileSystemId) {
      res["FileSystemId"] = boost::any(*fileSystemId);
    }
    if (mountTargetDomain) {
      res["MountTargetDomain"] = boost::any(*mountTargetDomain);
    }
    if (mountTargetName) {
      res["MountTargetName"] = boost::any(*mountTargetName);
    }
    if (netWorkId) {
      res["NetWorkId"] = boost::any(*netWorkId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("FileSystemId") != m.end() && !m["FileSystemId"].empty()) {
      fileSystemId = make_shared<string>(boost::any_cast<string>(m["FileSystemId"]));
    }
    if (m.find("MountTargetDomain") != m.end() && !m["MountTargetDomain"].empty()) {
      mountTargetDomain = make_shared<string>(boost::any_cast<string>(m["MountTargetDomain"]));
    }
    if (m.find("MountTargetName") != m.end() && !m["MountTargetName"].empty()) {
      mountTargetName = make_shared<string>(boost::any_cast<string>(m["MountTargetName"]));
    }
    if (m.find("NetWorkId") != m.end() && !m["NetWorkId"].empty()) {
      netWorkId = make_shared<string>(boost::any_cast<string>(m["NetWorkId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeMountTargetsResponseBodyMountTargets() = default;
};
class DescribeMountTargetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMountTargetsResponseBodyMountTargets>> mountTargets{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeMountTargetsResponseBody() {}

  explicit DescribeMountTargetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mountTargets) {
      vector<boost::any> temp1;
      for(auto item1:*mountTargets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MountTargets"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MountTargets") != m.end() && !m["MountTargets"].empty()) {
      if (typeid(vector<boost::any>) == m["MountTargets"].type()) {
        vector<DescribeMountTargetsResponseBodyMountTargets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MountTargets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMountTargetsResponseBodyMountTargets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mountTargets = make_shared<vector<DescribeMountTargetsResponseBodyMountTargets>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeMountTargetsResponseBody() = default;
};
class DescribeMountTargetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMountTargetsResponseBody> body{};

  DescribeMountTargetsResponse() {}

  explicit DescribeMountTargetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMountTargetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMountTargetsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMountTargetsResponse() = default;
};
class DescribeNCInformationRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> resourceId{};

  DescribeNCInformationRequest() {}

  explicit DescribeNCInformationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~DescribeNCInformationRequest() = default;
};
class DescribeNCInformationResponseBodyDataCpu : public Darabonba::Model {
public:
  shared_ptr<bool> display{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};

  DescribeNCInformationResponseBodyDataCpu() {}

  explicit DescribeNCInformationResponseBodyDataCpu(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
  }


  virtual ~DescribeNCInformationResponseBodyDataCpu() = default;
};
class DescribeNCInformationResponseBodyDataGpu : public Darabonba::Model {
public:
  shared_ptr<bool> display{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};

  DescribeNCInformationResponseBodyDataGpu() {}

  explicit DescribeNCInformationResponseBodyDataGpu(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
  }


  virtual ~DescribeNCInformationResponseBodyDataGpu() = default;
};
class DescribeNCInformationResponseBodyDataHdd : public Darabonba::Model {
public:
  shared_ptr<bool> display{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};

  DescribeNCInformationResponseBodyDataHdd() {}

  explicit DescribeNCInformationResponseBodyDataHdd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
  }


  virtual ~DescribeNCInformationResponseBodyDataHdd() = default;
};
class DescribeNCInformationResponseBodyDataInfo : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> tag{};
  shared_ptr<string> uuid{};

  DescribeNCInformationResponseBodyDataInfo() {}

  explicit DescribeNCInformationResponseBodyDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeNCInformationResponseBodyDataInfo() = default;
};
class DescribeNCInformationResponseBodyDataMemory : public Darabonba::Model {
public:
  shared_ptr<bool> display{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};

  DescribeNCInformationResponseBodyDataMemory() {}

  explicit DescribeNCInformationResponseBodyDataMemory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
  }


  virtual ~DescribeNCInformationResponseBodyDataMemory() = default;
};
class DescribeNCInformationResponseBodyDataNvme : public Darabonba::Model {
public:
  shared_ptr<bool> display{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};

  DescribeNCInformationResponseBodyDataNvme() {}

  explicit DescribeNCInformationResponseBodyDataNvme(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
  }


  virtual ~DescribeNCInformationResponseBodyDataNvme() = default;
};
class DescribeNCInformationResponseBodyDataSsd : public Darabonba::Model {
public:
  shared_ptr<bool> display{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};

  DescribeNCInformationResponseBodyDataSsd() {}

  explicit DescribeNCInformationResponseBodyDataSsd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
  }


  virtual ~DescribeNCInformationResponseBodyDataSsd() = default;
};
class DescribeNCInformationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<DescribeNCInformationResponseBodyDataCpu> cpu{};
  shared_ptr<DescribeNCInformationResponseBodyDataGpu> gpu{};
  shared_ptr<DescribeNCInformationResponseBodyDataHdd> hdd{};
  shared_ptr<DescribeNCInformationResponseBodyDataInfo> info{};
  shared_ptr<DescribeNCInformationResponseBodyDataMemory> memory{};
  shared_ptr<DescribeNCInformationResponseBodyDataNvme> nvme{};
  shared_ptr<bool> online{};
  shared_ptr<string> region{};
  shared_ptr<DescribeNCInformationResponseBodyDataSsd> ssd{};
  shared_ptr<string> virtual_{};

  DescribeNCInformationResponseBodyData() {}

  explicit DescribeNCInformationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = cpu ? boost::any(cpu->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gpu) {
      res["Gpu"] = gpu ? boost::any(gpu->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hdd) {
      res["Hdd"] = hdd ? boost::any(hdd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (info) {
      res["Info"] = info ? boost::any(info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memory) {
      res["Memory"] = memory ? boost::any(memory->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nvme) {
      res["Nvme"] = nvme ? boost::any(nvme->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (ssd) {
      res["Ssd"] = ssd ? boost::any(ssd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (virtual_) {
      res["Virtual"] = boost::any(*virtual_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cpu"].type()) {
        DescribeNCInformationResponseBodyDataCpu model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cpu"]));
        cpu = make_shared<DescribeNCInformationResponseBodyDataCpu>(model1);
      }
    }
    if (m.find("Gpu") != m.end() && !m["Gpu"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gpu"].type()) {
        DescribeNCInformationResponseBodyDataGpu model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gpu"]));
        gpu = make_shared<DescribeNCInformationResponseBodyDataGpu>(model1);
      }
    }
    if (m.find("Hdd") != m.end() && !m["Hdd"].empty()) {
      if (typeid(map<string, boost::any>) == m["Hdd"].type()) {
        DescribeNCInformationResponseBodyDataHdd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Hdd"]));
        hdd = make_shared<DescribeNCInformationResponseBodyDataHdd>(model1);
      }
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["Info"].type()) {
        DescribeNCInformationResponseBodyDataInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Info"]));
        info = make_shared<DescribeNCInformationResponseBodyDataInfo>(model1);
      }
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      if (typeid(map<string, boost::any>) == m["Memory"].type()) {
        DescribeNCInformationResponseBodyDataMemory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Memory"]));
        memory = make_shared<DescribeNCInformationResponseBodyDataMemory>(model1);
      }
    }
    if (m.find("Nvme") != m.end() && !m["Nvme"].empty()) {
      if (typeid(map<string, boost::any>) == m["Nvme"].type()) {
        DescribeNCInformationResponseBodyDataNvme model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Nvme"]));
        nvme = make_shared<DescribeNCInformationResponseBodyDataNvme>(model1);
      }
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Ssd") != m.end() && !m["Ssd"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ssd"].type()) {
        DescribeNCInformationResponseBodyDataSsd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ssd"]));
        ssd = make_shared<DescribeNCInformationResponseBodyDataSsd>(model1);
      }
    }
    if (m.find("Virtual") != m.end() && !m["Virtual"].empty()) {
      virtual_ = make_shared<string>(boost::any_cast<string>(m["Virtual"]));
    }
  }


  virtual ~DescribeNCInformationResponseBodyData() = default;
};
class DescribeNCInformationResponseBodyPager : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  DescribeNCInformationResponseBodyPager() {}

  explicit DescribeNCInformationResponseBodyPager(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeNCInformationResponseBodyPager() = default;
};
class DescribeNCInformationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<DescribeNCInformationResponseBodyData>> data{};
  shared_ptr<string> desc{};
  shared_ptr<string> msg{};
  shared_ptr<DescribeNCInformationResponseBodyPager> pager{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeNCInformationResponseBody() {}

  explicit DescribeNCInformationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (pager) {
      res["Pager"] = pager ? boost::any(pager->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeNCInformationResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNCInformationResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeNCInformationResponseBodyData>>(expect1);
      }
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Pager") != m.end() && !m["Pager"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pager"].type()) {
        DescribeNCInformationResponseBodyPager model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pager"]));
        pager = make_shared<DescribeNCInformationResponseBodyPager>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeNCInformationResponseBody() = default;
};
class DescribeNCInformationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNCInformationResponseBody> body{};

  DescribeNCInformationResponse() {}

  explicit DescribeNCInformationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNCInformationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNCInformationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNCInformationResponse() = default;
};
class DescribeNatGatewaysRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<vector<string>> ensRegionIds{};
  shared_ptr<string> name{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<vector<string>> natGatewayIds{};
  shared_ptr<string> networkId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> vSwitchId{};

  DescribeNatGatewaysRequest() {}

  explicit DescribeNatGatewaysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = boost::any(*ensRegionIds);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (natGatewayIds) {
      res["NatGatewayIds"] = boost::any(*natGatewayIds);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnsRegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnsRegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ensRegionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("NatGatewayIds") != m.end() && !m["NatGatewayIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NatGatewayIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NatGatewayIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      natGatewayIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeNatGatewaysRequest() = default;
};
class DescribeNatGatewaysResponseBodyNatGatewaysIpLists : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> usingStatus{};

  DescribeNatGatewaysResponseBodyNatGatewaysIpLists() {}

  explicit DescribeNatGatewaysResponseBodyNatGatewaysIpLists(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (usingStatus) {
      res["UsingStatus"] = boost::any(*usingStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("UsingStatus") != m.end() && !m["UsingStatus"].empty()) {
      usingStatus = make_shared<string>(boost::any_cast<string>(m["UsingStatus"]));
    }
  }


  virtual ~DescribeNatGatewaysResponseBodyNatGatewaysIpLists() = default;
};
class DescribeNatGatewaysResponseBodyNatGatewaysTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};
  shared_ptr<string> value{};

  DescribeNatGatewaysResponseBodyNatGatewaysTags() {}

  explicit DescribeNatGatewaysResponseBodyNatGatewaysTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeNatGatewaysResponseBodyNatGatewaysTags() = default;
};
class DescribeNatGatewaysResponseBodyNatGateways : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<vector<DescribeNatGatewaysResponseBodyNatGatewaysIpLists>> ipLists{};
  shared_ptr<string> name{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> networkId{};
  shared_ptr<string> spec{};
  shared_ptr<string> status{};
  shared_ptr<vector<DescribeNatGatewaysResponseBodyNatGatewaysTags>> tags{};
  shared_ptr<string> vSwitchId{};

  DescribeNatGatewaysResponseBodyNatGateways() {}

  explicit DescribeNatGatewaysResponseBodyNatGateways(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ipLists) {
      vector<boost::any> temp1;
      for(auto item1:*ipLists){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpLists"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("IpLists") != m.end() && !m["IpLists"].empty()) {
      if (typeid(vector<boost::any>) == m["IpLists"].type()) {
        vector<DescribeNatGatewaysResponseBodyNatGatewaysIpLists> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpLists"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNatGatewaysResponseBodyNatGatewaysIpLists model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipLists = make_shared<vector<DescribeNatGatewaysResponseBodyNatGatewaysIpLists>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeNatGatewaysResponseBodyNatGatewaysTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNatGatewaysResponseBodyNatGatewaysTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeNatGatewaysResponseBodyNatGatewaysTags>>(expect1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeNatGatewaysResponseBodyNatGateways() = default;
};
class DescribeNatGatewaysResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNatGatewaysResponseBodyNatGateways>> natGateways{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeNatGatewaysResponseBody() {}

  explicit DescribeNatGatewaysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (natGateways) {
      vector<boost::any> temp1;
      for(auto item1:*natGateways){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NatGateways"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NatGateways") != m.end() && !m["NatGateways"].empty()) {
      if (typeid(vector<boost::any>) == m["NatGateways"].type()) {
        vector<DescribeNatGatewaysResponseBodyNatGateways> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NatGateways"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNatGatewaysResponseBodyNatGateways model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        natGateways = make_shared<vector<DescribeNatGatewaysResponseBodyNatGateways>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeNatGatewaysResponseBody() = default;
};
class DescribeNatGatewaysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNatGatewaysResponseBody> body{};

  DescribeNatGatewaysResponse() {}

  explicit DescribeNatGatewaysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNatGatewaysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNatGatewaysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNatGatewaysResponse() = default;
};
class DescribeNetworkAclsRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkAclId{};
  shared_ptr<string> networkAclName{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> resourceId{};

  DescribeNetworkAclsRequest() {}

  explicit DescribeNetworkAclsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (networkAclName) {
      res["NetworkAclName"] = boost::any(*networkAclName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("NetworkAclName") != m.end() && !m["NetworkAclName"].empty()) {
      networkAclName = make_shared<string>(boost::any_cast<string>(m["NetworkAclName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~DescribeNetworkAclsRequest() = default;
};
class DescribeNetworkAclsResponseBodyNetworkAclsEgressAclEntries : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> description{};
  shared_ptr<string> networkAclEntryId{};
  shared_ptr<string> networkAclEntryName{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> protocol{};
  shared_ptr<string> type{};

  DescribeNetworkAclsResponseBodyNetworkAclsEgressAclEntries() {}

  explicit DescribeNetworkAclsResponseBodyNetworkAclsEgressAclEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (networkAclEntryId) {
      res["NetworkAclEntryId"] = boost::any(*networkAclEntryId);
    }
    if (networkAclEntryName) {
      res["NetworkAclEntryName"] = boost::any(*networkAclEntryName);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NetworkAclEntryId") != m.end() && !m["NetworkAclEntryId"].empty()) {
      networkAclEntryId = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryId"]));
    }
    if (m.find("NetworkAclEntryName") != m.end() && !m["NetworkAclEntryName"].empty()) {
      networkAclEntryName = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryName"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeNetworkAclsResponseBodyNetworkAclsEgressAclEntries() = default;
};
class DescribeNetworkAclsResponseBodyNetworkAclsIngressAclEntries : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> description{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> networkAclEntryId{};
  shared_ptr<string> networkAclEntryName{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> protocol{};
  shared_ptr<string> type{};

  DescribeNetworkAclsResponseBodyNetworkAclsIngressAclEntries() {}

  explicit DescribeNetworkAclsResponseBodyNetworkAclsIngressAclEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (networkAclEntryId) {
      res["NetworkAclEntryId"] = boost::any(*networkAclEntryId);
    }
    if (networkAclEntryName) {
      res["NetworkAclEntryName"] = boost::any(*networkAclEntryName);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("NetworkAclEntryId") != m.end() && !m["NetworkAclEntryId"].empty()) {
      networkAclEntryId = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryId"]));
    }
    if (m.find("NetworkAclEntryName") != m.end() && !m["NetworkAclEntryName"].empty()) {
      networkAclEntryName = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryName"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeNetworkAclsResponseBodyNetworkAclsIngressAclEntries() = default;
};
class DescribeNetworkAclsResponseBodyNetworkAclsResources : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> status{};

  DescribeNetworkAclsResponseBodyNetworkAclsResources() {}

  explicit DescribeNetworkAclsResponseBodyNetworkAclsResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeNetworkAclsResponseBodyNetworkAclsResources() = default;
};
class DescribeNetworkAclsResponseBodyNetworkAcls : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<vector<DescribeNetworkAclsResponseBodyNetworkAclsEgressAclEntries>> egressAclEntries{};
  shared_ptr<vector<DescribeNetworkAclsResponseBodyNetworkAclsIngressAclEntries>> ingressAclEntries{};
  shared_ptr<string> networkAclId{};
  shared_ptr<string> networkAclName{};
  shared_ptr<vector<DescribeNetworkAclsResponseBodyNetworkAclsResources>> resources{};
  shared_ptr<string> status{};

  DescribeNetworkAclsResponseBodyNetworkAcls() {}

  explicit DescribeNetworkAclsResponseBodyNetworkAcls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (egressAclEntries) {
      vector<boost::any> temp1;
      for(auto item1:*egressAclEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EgressAclEntries"] = boost::any(temp1);
    }
    if (ingressAclEntries) {
      vector<boost::any> temp1;
      for(auto item1:*ingressAclEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IngressAclEntries"] = boost::any(temp1);
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (networkAclName) {
      res["NetworkAclName"] = boost::any(*networkAclName);
    }
    if (resources) {
      vector<boost::any> temp1;
      for(auto item1:*resources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resources"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EgressAclEntries") != m.end() && !m["EgressAclEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["EgressAclEntries"].type()) {
        vector<DescribeNetworkAclsResponseBodyNetworkAclsEgressAclEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EgressAclEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkAclsResponseBodyNetworkAclsEgressAclEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        egressAclEntries = make_shared<vector<DescribeNetworkAclsResponseBodyNetworkAclsEgressAclEntries>>(expect1);
      }
    }
    if (m.find("IngressAclEntries") != m.end() && !m["IngressAclEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["IngressAclEntries"].type()) {
        vector<DescribeNetworkAclsResponseBodyNetworkAclsIngressAclEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IngressAclEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkAclsResponseBodyNetworkAclsIngressAclEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ingressAclEntries = make_shared<vector<DescribeNetworkAclsResponseBodyNetworkAclsIngressAclEntries>>(expect1);
      }
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("NetworkAclName") != m.end() && !m["NetworkAclName"].empty()) {
      networkAclName = make_shared<string>(boost::any_cast<string>(m["NetworkAclName"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(vector<boost::any>) == m["Resources"].type()) {
        vector<DescribeNetworkAclsResponseBodyNetworkAclsResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkAclsResponseBodyNetworkAclsResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resources = make_shared<vector<DescribeNetworkAclsResponseBodyNetworkAclsResources>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeNetworkAclsResponseBodyNetworkAcls() = default;
};
class DescribeNetworkAclsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkAclsResponseBodyNetworkAcls>> networkAcls{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};

  DescribeNetworkAclsResponseBody() {}

  explicit DescribeNetworkAclsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAcls) {
      vector<boost::any> temp1;
      for(auto item1:*networkAcls){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkAcls"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAcls") != m.end() && !m["NetworkAcls"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkAcls"].type()) {
        vector<DescribeNetworkAclsResponseBodyNetworkAcls> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkAcls"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkAclsResponseBodyNetworkAcls model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkAcls = make_shared<vector<DescribeNetworkAclsResponseBodyNetworkAcls>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~DescribeNetworkAclsResponseBody() = default;
};
class DescribeNetworkAclsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNetworkAclsResponseBody> body{};

  DescribeNetworkAclsResponse() {}

  explicit DescribeNetworkAclsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworkAclsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworkAclsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworkAclsResponse() = default;
};
class DescribeNetworkAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkId{};

  DescribeNetworkAttributeRequest() {}

  explicit DescribeNetworkAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
  }


  virtual ~DescribeNetworkAttributeRequest() = default;
};
class DescribeNetworkAttributeResponseBodyCloudResourcesCloudResourceSetType : public Darabonba::Model {
public:
  shared_ptr<long> resourceCount{};
  shared_ptr<string> resourceType{};

  DescribeNetworkAttributeResponseBodyCloudResourcesCloudResourceSetType() {}

  explicit DescribeNetworkAttributeResponseBodyCloudResourcesCloudResourceSetType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceCount) {
      res["ResourceCount"] = boost::any(*resourceCount);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceCount") != m.end() && !m["ResourceCount"].empty()) {
      resourceCount = make_shared<long>(boost::any_cast<long>(m["ResourceCount"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribeNetworkAttributeResponseBodyCloudResourcesCloudResourceSetType() = default;
};
class DescribeNetworkAttributeResponseBodyCloudResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkAttributeResponseBodyCloudResourcesCloudResourceSetType>> cloudResourceSetType{};

  DescribeNetworkAttributeResponseBodyCloudResources() {}

  explicit DescribeNetworkAttributeResponseBodyCloudResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudResourceSetType) {
      vector<boost::any> temp1;
      for(auto item1:*cloudResourceSetType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CloudResourceSetType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudResourceSetType") != m.end() && !m["CloudResourceSetType"].empty()) {
      if (typeid(vector<boost::any>) == m["CloudResourceSetType"].type()) {
        vector<DescribeNetworkAttributeResponseBodyCloudResourcesCloudResourceSetType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CloudResourceSetType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkAttributeResponseBodyCloudResourcesCloudResourceSetType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cloudResourceSetType = make_shared<vector<DescribeNetworkAttributeResponseBodyCloudResourcesCloudResourceSetType>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkAttributeResponseBodyCloudResources() = default;
};
class DescribeNetworkAttributeResponseBodyHaVipIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> haVipId{};

  DescribeNetworkAttributeResponseBodyHaVipIds() {}

  explicit DescribeNetworkAttributeResponseBodyHaVipIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (haVipId) {
      res["HaVipId"] = boost::any(*haVipId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HaVipId") != m.end() && !m["HaVipId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HaVipId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HaVipId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      haVipId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworkAttributeResponseBodyHaVipIds() = default;
};
class DescribeNetworkAttributeResponseBodyInstanceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceId{};

  DescribeNetworkAttributeResponseBodyInstanceIds() {}

  explicit DescribeNetworkAttributeResponseBodyInstanceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworkAttributeResponseBodyInstanceIds() = default;
};
class DescribeNetworkAttributeResponseBodyLoadBalancerIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> loadBalancerId{};

  DescribeNetworkAttributeResponseBodyLoadBalancerIds() {}

  explicit DescribeNetworkAttributeResponseBodyLoadBalancerIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LoadBalancerId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LoadBalancerId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      loadBalancerId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworkAttributeResponseBodyLoadBalancerIds() = default;
};
class DescribeNetworkAttributeResponseBodyNatGatewayIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> natGatewayId{};

  DescribeNetworkAttributeResponseBodyNatGatewayIds() {}

  explicit DescribeNetworkAttributeResponseBodyNatGatewayIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NatGatewayId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NatGatewayId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      natGatewayId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworkAttributeResponseBodyNatGatewayIds() = default;
};
class DescribeNetworkAttributeResponseBodyNetworkInterfaceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> networkInterfaceId{};

  DescribeNetworkAttributeResponseBodyNetworkInterfaceIds() {}

  explicit DescribeNetworkAttributeResponseBodyNetworkInterfaceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NetworkInterfaceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NetworkInterfaceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      networkInterfaceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworkAttributeResponseBodyNetworkInterfaceIds() = default;
};
class DescribeNetworkAttributeResponseBodyRouteTableIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> routeTableId{};

  DescribeNetworkAttributeResponseBodyRouteTableIds() {}

  explicit DescribeNetworkAttributeResponseBodyRouteTableIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RouteTableId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RouteTableId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      routeTableId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworkAttributeResponseBodyRouteTableIds() = default;
};
class DescribeNetworkAttributeResponseBodyVSwitchIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> vSwitchId{};

  DescribeNetworkAttributeResponseBodyVSwitchIds() {}

  explicit DescribeNetworkAttributeResponseBodyVSwitchIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworkAttributeResponseBodyVSwitchIds() = default;
};
class DescribeNetworkAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<DescribeNetworkAttributeResponseBodyCloudResources> cloudResources{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> gatewayRouteTableId{};
  shared_ptr<DescribeNetworkAttributeResponseBodyHaVipIds> haVipIds{};
  shared_ptr<DescribeNetworkAttributeResponseBodyInstanceIds> instanceIds{};
  shared_ptr<DescribeNetworkAttributeResponseBodyLoadBalancerIds> loadBalancerIds{};
  shared_ptr<DescribeNetworkAttributeResponseBodyNatGatewayIds> natGatewayIds{};
  shared_ptr<string> networkAclId{};
  shared_ptr<string> networkId{};
  shared_ptr<DescribeNetworkAttributeResponseBodyNetworkInterfaceIds> networkInterfaceIds{};
  shared_ptr<string> networkName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> routeTableId{};
  shared_ptr<DescribeNetworkAttributeResponseBodyRouteTableIds> routeTableIds{};
  shared_ptr<string> routerTableId{};
  shared_ptr<string> status{};
  shared_ptr<DescribeNetworkAttributeResponseBodyVSwitchIds> vSwitchIds{};

  DescribeNetworkAttributeResponseBody() {}

  explicit DescribeNetworkAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (cloudResources) {
      res["CloudResources"] = cloudResources ? boost::any(cloudResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (gatewayRouteTableId) {
      res["GatewayRouteTableId"] = boost::any(*gatewayRouteTableId);
    }
    if (haVipIds) {
      res["HaVipIds"] = haVipIds ? boost::any(haVipIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceIds) {
      res["InstanceIds"] = instanceIds ? boost::any(instanceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (loadBalancerIds) {
      res["LoadBalancerIds"] = loadBalancerIds ? boost::any(loadBalancerIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (natGatewayIds) {
      res["NatGatewayIds"] = natGatewayIds ? boost::any(natGatewayIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (networkInterfaceIds) {
      res["NetworkInterfaceIds"] = networkInterfaceIds ? boost::any(networkInterfaceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkName) {
      res["NetworkName"] = boost::any(*networkName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (routeTableIds) {
      res["RouteTableIds"] = routeTableIds ? boost::any(routeTableIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (routerTableId) {
      res["RouterTableId"] = boost::any(*routerTableId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = vSwitchIds ? boost::any(vSwitchIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("CloudResources") != m.end() && !m["CloudResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["CloudResources"].type()) {
        DescribeNetworkAttributeResponseBodyCloudResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CloudResources"]));
        cloudResources = make_shared<DescribeNetworkAttributeResponseBodyCloudResources>(model1);
      }
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("GatewayRouteTableId") != m.end() && !m["GatewayRouteTableId"].empty()) {
      gatewayRouteTableId = make_shared<string>(boost::any_cast<string>(m["GatewayRouteTableId"]));
    }
    if (m.find("HaVipIds") != m.end() && !m["HaVipIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["HaVipIds"].type()) {
        DescribeNetworkAttributeResponseBodyHaVipIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HaVipIds"]));
        haVipIds = make_shared<DescribeNetworkAttributeResponseBodyHaVipIds>(model1);
      }
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceIds"].type()) {
        DescribeNetworkAttributeResponseBodyInstanceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceIds"]));
        instanceIds = make_shared<DescribeNetworkAttributeResponseBodyInstanceIds>(model1);
      }
    }
    if (m.find("LoadBalancerIds") != m.end() && !m["LoadBalancerIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["LoadBalancerIds"].type()) {
        DescribeNetworkAttributeResponseBodyLoadBalancerIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LoadBalancerIds"]));
        loadBalancerIds = make_shared<DescribeNetworkAttributeResponseBodyLoadBalancerIds>(model1);
      }
    }
    if (m.find("NatGatewayIds") != m.end() && !m["NatGatewayIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NatGatewayIds"].type()) {
        DescribeNetworkAttributeResponseBodyNatGatewayIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NatGatewayIds"]));
        natGatewayIds = make_shared<DescribeNetworkAttributeResponseBodyNatGatewayIds>(model1);
      }
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("NetworkInterfaceIds") != m.end() && !m["NetworkInterfaceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkInterfaceIds"].type()) {
        DescribeNetworkAttributeResponseBodyNetworkInterfaceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkInterfaceIds"]));
        networkInterfaceIds = make_shared<DescribeNetworkAttributeResponseBodyNetworkInterfaceIds>(model1);
      }
    }
    if (m.find("NetworkName") != m.end() && !m["NetworkName"].empty()) {
      networkName = make_shared<string>(boost::any_cast<string>(m["NetworkName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("RouteTableIds") != m.end() && !m["RouteTableIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteTableIds"].type()) {
        DescribeNetworkAttributeResponseBodyRouteTableIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteTableIds"]));
        routeTableIds = make_shared<DescribeNetworkAttributeResponseBodyRouteTableIds>(model1);
      }
    }
    if (m.find("RouterTableId") != m.end() && !m["RouterTableId"].empty()) {
      routerTableId = make_shared<string>(boost::any_cast<string>(m["RouterTableId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["VSwitchIds"].type()) {
        DescribeNetworkAttributeResponseBodyVSwitchIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VSwitchIds"]));
        vSwitchIds = make_shared<DescribeNetworkAttributeResponseBodyVSwitchIds>(model1);
      }
    }
  }


  virtual ~DescribeNetworkAttributeResponseBody() = default;
};
class DescribeNetworkAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNetworkAttributeResponseBody> body{};

  DescribeNetworkAttributeResponse() {}

  explicit DescribeNetworkAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworkAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworkAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworkAttributeResponse() = default;
};
class DescribeNetworkInterfacesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<vector<string>> ensRegionIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> ipv6Address{};
  shared_ptr<string> networkId{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<vector<string>> networkInterfaceIds{};
  shared_ptr<string> networkInterfaceName{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> primaryIpAddress{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> vSwitchId{};

  DescribeNetworkInterfacesRequest() {}

  explicit DescribeNetworkInterfacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = boost::any(*ensRegionIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (networkInterfaceIds) {
      res["NetworkInterfaceIds"] = boost::any(*networkInterfaceIds);
    }
    if (networkInterfaceName) {
      res["NetworkInterfaceName"] = boost::any(*networkInterfaceName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (primaryIpAddress) {
      res["PrimaryIpAddress"] = boost::any(*primaryIpAddress);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnsRegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnsRegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ensRegionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ipv6Address"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ipv6Address"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipv6Address = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("NetworkInterfaceIds") != m.end() && !m["NetworkInterfaceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NetworkInterfaceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NetworkInterfaceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      networkInterfaceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NetworkInterfaceName") != m.end() && !m["NetworkInterfaceName"].empty()) {
      networkInterfaceName = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("PrimaryIpAddress") != m.end() && !m["PrimaryIpAddress"].empty()) {
      primaryIpAddress = make_shared<string>(boost::any_cast<string>(m["PrimaryIpAddress"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeNetworkInterfacesRequest() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set : public Darabonba::Model {
public:
  shared_ptr<string> ipv6Address{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      ipv6Address = make_shared<string>(boost::any_cast<string>(m["Ipv6Address"]));
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set>> ipv6Set{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Set) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6Set){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6Set"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Set") != m.end() && !m["Ipv6Set"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6Set"].type()) {
        vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6Set"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6Set = make_shared<vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet : public Darabonba::Model {
public:
  shared_ptr<bool> primary{};
  shared_ptr<string> privateIpAddress{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (primary) {
      res["Primary"] = boost::any(*primary);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Primary") != m.end() && !m["Primary"].empty()) {
      primary = make_shared<bool>(boost::any_cast<bool>(m["Primary"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet>> privateIpSet{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateIpSet) {
      vector<boost::any> temp1;
      for(auto item1:*privateIpSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrivateIpSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateIpSet") != m.end() && !m["PrivateIpSet"].empty()) {
      if (typeid(vector<boost::any>) == m["PrivateIpSet"].type()) {
        vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrivateIpSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        privateIpSet = make_shared<vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> securityGroup{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroup) {
      res["SecurityGroup"] = boost::any(*securityGroup);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroup") != m.end() && !m["SecurityGroup"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroup"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroup"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroup = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets> ipv6Sets{};
  shared_ptr<string> macAddress{};
  shared_ptr<string> networkId{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> networkInterfaceName{};
  shared_ptr<string> primaryIp{};
  shared_ptr<string> primaryIpType{};
  shared_ptr<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets> privateIpSets{};
  shared_ptr<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds> securityGroupIds{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> vSwitchId{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipv6Sets) {
      res["Ipv6Sets"] = ipv6Sets ? boost::any(ipv6Sets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (macAddress) {
      res["MacAddress"] = boost::any(*macAddress);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (networkInterfaceName) {
      res["NetworkInterfaceName"] = boost::any(*networkInterfaceName);
    }
    if (primaryIp) {
      res["PrimaryIp"] = boost::any(*primaryIp);
    }
    if (primaryIpType) {
      res["PrimaryIpType"] = boost::any(*primaryIpType);
    }
    if (privateIpSets) {
      res["PrivateIpSets"] = privateIpSets ? boost::any(privateIpSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = securityGroupIds ? boost::any(securityGroupIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ipv6Sets") != m.end() && !m["Ipv6Sets"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6Sets"].type()) {
        DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6Sets"]));
        ipv6Sets = make_shared<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets>(model1);
      }
    }
    if (m.find("MacAddress") != m.end() && !m["MacAddress"].empty()) {
      macAddress = make_shared<string>(boost::any_cast<string>(m["MacAddress"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("NetworkInterfaceName") != m.end() && !m["NetworkInterfaceName"].empty()) {
      networkInterfaceName = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceName"]));
    }
    if (m.find("PrimaryIp") != m.end() && !m["PrimaryIp"].empty()) {
      primaryIp = make_shared<string>(boost::any_cast<string>(m["PrimaryIp"]));
    }
    if (m.find("PrimaryIpType") != m.end() && !m["PrimaryIpType"].empty()) {
      primaryIpType = make_shared<string>(boost::any_cast<string>(m["PrimaryIpType"]));
    }
    if (m.find("PrivateIpSets") != m.end() && !m["PrivateIpSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivateIpSets"].type()) {
        DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivateIpSets"]));
        privateIpSets = make_shared<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets>(model1);
      }
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroupIds"].type()) {
        DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroupIds"]));
        securityGroupIds = make_shared<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet>> networkInterfaceSet{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceSet) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterfaceSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterfaceSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceSet") != m.end() && !m["NetworkInterfaceSet"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterfaceSet"].type()) {
        vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterfaceSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterfaceSet = make_shared<vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets() = default;
};
class DescribeNetworkInterfacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets> networkInterfaceSets{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeNetworkInterfacesResponseBody() {}

  explicit DescribeNetworkInterfacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceSets) {
      res["NetworkInterfaceSets"] = networkInterfaceSets ? boost::any(networkInterfaceSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceSets") != m.end() && !m["NetworkInterfaceSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkInterfaceSets"].type()) {
        DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkInterfaceSets"]));
        networkInterfaceSets = make_shared<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBody() = default;
};
class DescribeNetworkInterfacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNetworkInterfacesResponseBody> body{};

  DescribeNetworkInterfacesResponse() {}

  explicit DescribeNetworkInterfacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworkInterfacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworkInterfacesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworkInterfacesResponse() = default;
};
class DescribeNetworksRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<vector<string>> ensRegionIds{};
  shared_ptr<string> networkId{};
  shared_ptr<vector<string>> networkIds{};
  shared_ptr<string> networkName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeNetworksRequest() {}

  explicit DescribeNetworksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = boost::any(*ensRegionIds);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (networkIds) {
      res["NetworkIds"] = boost::any(*networkIds);
    }
    if (networkName) {
      res["NetworkName"] = boost::any(*networkName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnsRegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnsRegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ensRegionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("NetworkIds") != m.end() && !m["NetworkIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NetworkIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NetworkIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      networkIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NetworkName") != m.end() && !m["NetworkName"].empty()) {
      networkName = make_shared<string>(boost::any_cast<string>(m["NetworkName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeNetworksRequest() = default;
};
class DescribeNetworksResponseBodyNetworksNetworkRouteTableIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> routeTableId{};

  DescribeNetworksResponseBodyNetworksNetworkRouteTableIds() {}

  explicit DescribeNetworksResponseBodyNetworksNetworkRouteTableIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RouteTableId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RouteTableId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      routeTableId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworksResponseBodyNetworksNetworkRouteTableIds() = default;
};
class DescribeNetworksResponseBodyNetworksNetworkTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};
  shared_ptr<string> value{};

  DescribeNetworksResponseBodyNetworksNetworkTagsTag() {}

  explicit DescribeNetworksResponseBodyNetworksNetworkTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeNetworksResponseBodyNetworksNetworkTagsTag() = default;
};
class DescribeNetworksResponseBodyNetworksNetworkTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworksResponseBodyNetworksNetworkTagsTag>> tag{};

  DescribeNetworksResponseBodyNetworksNetworkTags() {}

  explicit DescribeNetworksResponseBodyNetworksNetworkTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeNetworksResponseBodyNetworksNetworkTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworksResponseBodyNetworksNetworkTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeNetworksResponseBodyNetworksNetworkTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworksResponseBodyNetworksNetworkTags() = default;
};
class DescribeNetworksResponseBodyNetworksNetworkVSwitchIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> vSwitchId{};

  DescribeNetworksResponseBodyNetworksNetworkVSwitchIds() {}

  explicit DescribeNetworksResponseBodyNetworksNetworkVSwitchIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworksResponseBodyNetworksNetworkVSwitchIds() = default;
};
class DescribeNetworksResponseBodyNetworksNetwork : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> gatewayRouteTableId{};
  shared_ptr<string> networkAclId{};
  shared_ptr<string> networkId{};
  shared_ptr<string> networkName{};
  shared_ptr<string> routeTableId{};
  shared_ptr<DescribeNetworksResponseBodyNetworksNetworkRouteTableIds> routeTableIds{};
  shared_ptr<string> routerTableId{};
  shared_ptr<string> status{};
  shared_ptr<DescribeNetworksResponseBodyNetworksNetworkTags> tags{};
  shared_ptr<DescribeNetworksResponseBodyNetworksNetworkVSwitchIds> vSwitchIds{};

  DescribeNetworksResponseBodyNetworksNetwork() {}

  explicit DescribeNetworksResponseBodyNetworksNetwork(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (gatewayRouteTableId) {
      res["GatewayRouteTableId"] = boost::any(*gatewayRouteTableId);
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (networkName) {
      res["NetworkName"] = boost::any(*networkName);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (routeTableIds) {
      res["RouteTableIds"] = routeTableIds ? boost::any(routeTableIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (routerTableId) {
      res["RouterTableId"] = boost::any(*routerTableId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = vSwitchIds ? boost::any(vSwitchIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("GatewayRouteTableId") != m.end() && !m["GatewayRouteTableId"].empty()) {
      gatewayRouteTableId = make_shared<string>(boost::any_cast<string>(m["GatewayRouteTableId"]));
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("NetworkName") != m.end() && !m["NetworkName"].empty()) {
      networkName = make_shared<string>(boost::any_cast<string>(m["NetworkName"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("RouteTableIds") != m.end() && !m["RouteTableIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteTableIds"].type()) {
        DescribeNetworksResponseBodyNetworksNetworkRouteTableIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteTableIds"]));
        routeTableIds = make_shared<DescribeNetworksResponseBodyNetworksNetworkRouteTableIds>(model1);
      }
    }
    if (m.find("RouterTableId") != m.end() && !m["RouterTableId"].empty()) {
      routerTableId = make_shared<string>(boost::any_cast<string>(m["RouterTableId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeNetworksResponseBodyNetworksNetworkTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeNetworksResponseBodyNetworksNetworkTags>(model1);
      }
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["VSwitchIds"].type()) {
        DescribeNetworksResponseBodyNetworksNetworkVSwitchIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VSwitchIds"]));
        vSwitchIds = make_shared<DescribeNetworksResponseBodyNetworksNetworkVSwitchIds>(model1);
      }
    }
  }


  virtual ~DescribeNetworksResponseBodyNetworksNetwork() = default;
};
class DescribeNetworksResponseBodyNetworks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworksResponseBodyNetworksNetwork>> network{};

  DescribeNetworksResponseBodyNetworks() {}

  explicit DescribeNetworksResponseBodyNetworks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (network) {
      vector<boost::any> temp1;
      for(auto item1:*network){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Network"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Network") != m.end() && !m["Network"].empty()) {
      if (typeid(vector<boost::any>) == m["Network"].type()) {
        vector<DescribeNetworksResponseBodyNetworksNetwork> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Network"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworksResponseBodyNetworksNetwork model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        network = make_shared<vector<DescribeNetworksResponseBodyNetworksNetwork>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworksResponseBodyNetworks() = default;
};
class DescribeNetworksResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeNetworksResponseBodyNetworks> networks{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeNetworksResponseBody() {}

  explicit DescribeNetworksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networks) {
      res["Networks"] = networks ? boost::any(networks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Networks") != m.end() && !m["Networks"].empty()) {
      if (typeid(map<string, boost::any>) == m["Networks"].type()) {
        DescribeNetworksResponseBodyNetworks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Networks"]));
        networks = make_shared<DescribeNetworksResponseBodyNetworks>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeNetworksResponseBody() = default;
};
class DescribeNetworksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNetworksResponseBody> body{};

  DescribeNetworksResponse() {}

  explicit DescribeNetworksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworksResponse() = default;
};
class DescribePrePaidInstanceStockRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataDiskSize{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceSpec{};
  shared_ptr<long> systemDiskSize{};

  DescribePrePaidInstanceStockRequest() {}

  explicit DescribePrePaidInstanceStockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceSpec) {
      res["InstanceSpec"] = boost::any(*instanceSpec);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<long>(boost::any_cast<long>(m["DataDiskSize"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceSpec") != m.end() && !m["InstanceSpec"].empty()) {
      instanceSpec = make_shared<string>(boost::any_cast<string>(m["InstanceSpec"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskSize"]));
    }
  }


  virtual ~DescribePrePaidInstanceStockRequest() = default;
};
class DescribePrePaidInstanceStockResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> avaliableCount{};
  shared_ptr<long> cores{};
  shared_ptr<long> dataDiskSize{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceSpec{};
  shared_ptr<long> memory{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGap{};
  shared_ptr<long> systemDiskSize{};

  DescribePrePaidInstanceStockResponseBody() {}

  explicit DescribePrePaidInstanceStockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avaliableCount) {
      res["AvaliableCount"] = boost::any(*avaliableCount);
    }
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceSpec) {
      res["InstanceSpec"] = boost::any(*instanceSpec);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGap) {
      res["ResourceGap"] = boost::any(*resourceGap);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvaliableCount") != m.end() && !m["AvaliableCount"].empty()) {
      avaliableCount = make_shared<long>(boost::any_cast<long>(m["AvaliableCount"]));
    }
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<long>(boost::any_cast<long>(m["DataDiskSize"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceSpec") != m.end() && !m["InstanceSpec"].empty()) {
      instanceSpec = make_shared<string>(boost::any_cast<string>(m["InstanceSpec"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGap") != m.end() && !m["ResourceGap"].empty()) {
      resourceGap = make_shared<string>(boost::any_cast<string>(m["ResourceGap"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskSize"]));
    }
  }


  virtual ~DescribePrePaidInstanceStockResponseBody() = default;
};
class DescribePrePaidInstanceStockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePrePaidInstanceStockResponseBody> body{};

  DescribePrePaidInstanceStockResponse() {}

  explicit DescribePrePaidInstanceStockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePrePaidInstanceStockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePrePaidInstanceStockResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePrePaidInstanceStockResponse() = default;
};
class DescribePriceRequestDataDisk : public Darabonba::Model {
public:
  shared_ptr<long> size{};

  DescribePriceRequestDataDisk() {}

  explicit DescribePriceRequestDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribePriceRequestDataDisk() = default;
};
class DescribePriceRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<long> size{};

  DescribePriceRequestSystemDisk() {}

  explicit DescribePriceRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribePriceRequestSystemDisk() = default;
};
class DescribePriceRequestDataDisks : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> size{};

  DescribePriceRequestDataDisks() {}

  explicit DescribePriceRequestDataDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribePriceRequestDataDisks() = default;
};
class DescribePriceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePriceRequestDataDisk>> dataDisk{};
  shared_ptr<DescribePriceRequestSystemDisk> systemDisk{};
  shared_ptr<vector<DescribePriceRequestDataDisks>> dataDisks{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<long> quantity{};

  DescribePriceRequest() {}

  explicit DescribePriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataDisks) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisks"] = boost::any(temp1);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<DescribePriceRequestDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePriceRequestDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<DescribePriceRequestDataDisk>>(expect1);
      }
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        DescribePriceRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<DescribePriceRequestSystemDisk>(model1);
      }
    }
    if (m.find("DataDisks") != m.end() && !m["DataDisks"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisks"].type()) {
        vector<DescribePriceRequestDataDisks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePriceRequestDataDisks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisks = make_shared<vector<DescribePriceRequestDataDisks>>(expect1);
      }
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
  }


  virtual ~DescribePriceRequest() = default;
};
class DescribePriceShrinkRequestDataDisk : public Darabonba::Model {
public:
  shared_ptr<long> size{};

  DescribePriceShrinkRequestDataDisk() {}

  explicit DescribePriceShrinkRequestDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribePriceShrinkRequestDataDisk() = default;
};
class DescribePriceShrinkRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<long> size{};

  DescribePriceShrinkRequestSystemDisk() {}

  explicit DescribePriceShrinkRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribePriceShrinkRequestSystemDisk() = default;
};
class DescribePriceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePriceShrinkRequestDataDisk>> dataDisk{};
  shared_ptr<DescribePriceShrinkRequestSystemDisk> systemDisk{};
  shared_ptr<string> dataDisksShrink{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<long> quantity{};

  DescribePriceShrinkRequest() {}

  explicit DescribePriceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataDisksShrink) {
      res["DataDisks"] = boost::any(*dataDisksShrink);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<DescribePriceShrinkRequestDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePriceShrinkRequestDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<DescribePriceShrinkRequestDataDisk>>(expect1);
      }
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        DescribePriceShrinkRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<DescribePriceShrinkRequestSystemDisk>(model1);
      }
    }
    if (m.find("DataDisks") != m.end() && !m["DataDisks"].empty()) {
      dataDisksShrink = make_shared<string>(boost::any_cast<string>(m["DataDisks"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
  }


  virtual ~DescribePriceShrinkRequest() = default;
};
class DescribePriceResponseBodyPriceInfoPrice : public Darabonba::Model {
public:
  shared_ptr<string> currency{};
  shared_ptr<double> discountPrice{};
  shared_ptr<double> originalPrice{};
  shared_ptr<double> tradePrice{};

  DescribePriceResponseBodyPriceInfoPrice() {}

  explicit DescribePriceResponseBodyPriceInfoPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoPrice() = default;
};
class DescribePriceResponseBodyPriceInfo : public Darabonba::Model {
public:
  shared_ptr<DescribePriceResponseBodyPriceInfoPrice> price{};

  DescribePriceResponseBodyPriceInfo() {}

  explicit DescribePriceResponseBodyPriceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (price) {
      res["Price"] = price ? boost::any(price->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      if (typeid(map<string, boost::any>) == m["Price"].type()) {
        DescribePriceResponseBodyPriceInfoPrice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Price"]));
        price = make_shared<DescribePriceResponseBodyPriceInfoPrice>(model1);
      }
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfo() = default;
};
class DescribePriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePriceResponseBodyPriceInfo> priceInfo{};
  shared_ptr<string> requestId{};

  DescribePriceResponseBody() {}

  explicit DescribePriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (priceInfo) {
      res["PriceInfo"] = priceInfo ? boost::any(priceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PriceInfo") != m.end() && !m["PriceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PriceInfo"].type()) {
        DescribePriceResponseBodyPriceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PriceInfo"]));
        priceInfo = make_shared<DescribePriceResponseBodyPriceInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePriceResponseBody() = default;
};
class DescribePriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePriceResponseBody> body{};

  DescribePriceResponse() {}

  explicit DescribePriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePriceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePriceResponse() = default;
};
class DescribeRegionIspsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};

  DescribeRegionIspsRequest() {}

  explicit DescribeRegionIspsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
  }


  virtual ~DescribeRegionIspsRequest() = default;
};
class DescribeRegionIspsResponseBodyIsps : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};

  DescribeRegionIspsResponseBodyIsps() {}

  explicit DescribeRegionIspsResponseBodyIsps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeRegionIspsResponseBodyIsps() = default;
};
class DescribeRegionIspsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRegionIspsResponseBodyIsps>> isps{};
  shared_ptr<string> requestId{};

  DescribeRegionIspsResponseBody() {}

  explicit DescribeRegionIspsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isps) {
      vector<boost::any> temp1;
      for(auto item1:*isps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Isps"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Isps") != m.end() && !m["Isps"].empty()) {
      if (typeid(vector<boost::any>) == m["Isps"].type()) {
        vector<DescribeRegionIspsResponseBodyIsps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Isps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionIspsResponseBodyIsps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        isps = make_shared<vector<DescribeRegionIspsResponseBodyIsps>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRegionIspsResponseBody() = default;
};
class DescribeRegionIspsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRegionIspsResponseBody> body{};

  DescribeRegionIspsResponse() {}

  explicit DescribeRegionIspsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionIspsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionIspsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionIspsResponse() = default;
};
class DescribeRegionResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> ispType{};

  DescribeRegionResourceRequest() {}

  explicit DescribeRegionResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ispType) {
      res["IspType"] = boost::any(*ispType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("IspType") != m.end() && !m["IspType"].empty()) {
      ispType = make_shared<string>(boost::any_cast<string>(m["IspType"]));
    }
  }


  virtual ~DescribeRegionResourceRequest() = default;
};
class DescribeRegionResourceResponseBodyDataArmCard : public Darabonba::Model {
public:
  shared_ptr<bool> display{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};

  DescribeRegionResourceResponseBodyDataArmCard() {}

  explicit DescribeRegionResourceResponseBodyDataArmCard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
  }


  virtual ~DescribeRegionResourceResponseBodyDataArmCard() = default;
};
class DescribeRegionResourceResponseBodyDataBandwidth : public Darabonba::Model {
public:
  shared_ptr<bool> display{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};

  DescribeRegionResourceResponseBodyDataBandwidth() {}

  explicit DescribeRegionResourceResponseBodyDataBandwidth(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
  }


  virtual ~DescribeRegionResourceResponseBodyDataBandwidth() = default;
};
class DescribeRegionResourceResponseBodyDataBlockStorage : public Darabonba::Model {
public:
  shared_ptr<bool> display{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};

  DescribeRegionResourceResponseBodyDataBlockStorage() {}

  explicit DescribeRegionResourceResponseBodyDataBlockStorage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
  }


  virtual ~DescribeRegionResourceResponseBodyDataBlockStorage() = default;
};
class DescribeRegionResourceResponseBodyDataCpu : public Darabonba::Model {
public:
  shared_ptr<bool> display{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};

  DescribeRegionResourceResponseBodyDataCpu() {}

  explicit DescribeRegionResourceResponseBodyDataCpu(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
  }


  virtual ~DescribeRegionResourceResponseBodyDataCpu() = default;
};
class DescribeRegionResourceResponseBodyDataGpu : public Darabonba::Model {
public:
  shared_ptr<bool> display{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};

  DescribeRegionResourceResponseBodyDataGpu() {}

  explicit DescribeRegionResourceResponseBodyDataGpu(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
  }


  virtual ~DescribeRegionResourceResponseBodyDataGpu() = default;
};
class DescribeRegionResourceResponseBodyDataHdd : public Darabonba::Model {
public:
  shared_ptr<bool> display{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};

  DescribeRegionResourceResponseBodyDataHdd() {}

  explicit DescribeRegionResourceResponseBodyDataHdd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
  }


  virtual ~DescribeRegionResourceResponseBodyDataHdd() = default;
};
class DescribeRegionResourceResponseBodyDataIpv4s : public Darabonba::Model {
public:
  shared_ptr<string> display{};
  shared_ptr<string> isp{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};
  shared_ptr<string> vlan{};

  DescribeRegionResourceResponseBodyDataIpv4s() {}

  explicit DescribeRegionResourceResponseBodyDataIpv4s(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    if (vlan) {
      res["Vlan"] = boost::any(*vlan);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<string>(boost::any_cast<string>(m["Display"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
    if (m.find("Vlan") != m.end() && !m["Vlan"].empty()) {
      vlan = make_shared<string>(boost::any_cast<string>(m["Vlan"]));
    }
  }


  virtual ~DescribeRegionResourceResponseBodyDataIpv4s() = default;
};
class DescribeRegionResourceResponseBodyDataIpv6s : public Darabonba::Model {
public:
  shared_ptr<string> display{};
  shared_ptr<string> isp{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};
  shared_ptr<string> vlan{};

  DescribeRegionResourceResponseBodyDataIpv6s() {}

  explicit DescribeRegionResourceResponseBodyDataIpv6s(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    if (vlan) {
      res["Vlan"] = boost::any(*vlan);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<string>(boost::any_cast<string>(m["Display"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
    if (m.find("Vlan") != m.end() && !m["Vlan"].empty()) {
      vlan = make_shared<string>(boost::any_cast<string>(m["Vlan"]));
    }
  }


  virtual ~DescribeRegionResourceResponseBodyDataIpv6s() = default;
};
class DescribeRegionResourceResponseBodyDataMemory : public Darabonba::Model {
public:
  shared_ptr<bool> display{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};

  DescribeRegionResourceResponseBodyDataMemory() {}

  explicit DescribeRegionResourceResponseBodyDataMemory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
  }


  virtual ~DescribeRegionResourceResponseBodyDataMemory() = default;
};
class DescribeRegionResourceResponseBodyDataNvme : public Darabonba::Model {
public:
  shared_ptr<bool> display{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};

  DescribeRegionResourceResponseBodyDataNvme() {}

  explicit DescribeRegionResourceResponseBodyDataNvme(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
  }


  virtual ~DescribeRegionResourceResponseBodyDataNvme() = default;
};
class DescribeRegionResourceResponseBodyDataOssStorage : public Darabonba::Model {
public:
  shared_ptr<bool> display{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};

  DescribeRegionResourceResponseBodyDataOssStorage() {}

  explicit DescribeRegionResourceResponseBodyDataOssStorage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
  }


  virtual ~DescribeRegionResourceResponseBodyDataOssStorage() = default;
};
class DescribeRegionResourceResponseBodyDataPangu : public Darabonba::Model {
public:
  shared_ptr<bool> display{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};

  DescribeRegionResourceResponseBodyDataPangu() {}

  explicit DescribeRegionResourceResponseBodyDataPangu(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
  }


  virtual ~DescribeRegionResourceResponseBodyDataPangu() = default;
};
class DescribeRegionResourceResponseBodyDataPcfarmNum : public Darabonba::Model {
public:
  shared_ptr<bool> display{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};

  DescribeRegionResourceResponseBodyDataPcfarmNum() {}

  explicit DescribeRegionResourceResponseBodyDataPcfarmNum(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
  }


  virtual ~DescribeRegionResourceResponseBodyDataPcfarmNum() = default;
};
class DescribeRegionResourceResponseBodyDataSsd : public Darabonba::Model {
public:
  shared_ptr<bool> display{};
  shared_ptr<long> oversellRatio{};
  shared_ptr<long> remain{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<long> reserveDisableTotal{};
  shared_ptr<long> reserved{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<long> statusDisableTotal{};
  shared_ptr<long> total{};
  shared_ptr<string> type{};
  shared_ptr<long> used{};
  shared_ptr<long> usedRatio{};

  DescribeRegionResourceResponseBodyDataSsd() {}

  explicit DescribeRegionResourceResponseBodyDataSsd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (oversellRatio) {
      res["OversellRatio"] = boost::any(*oversellRatio);
    }
    if (remain) {
      res["Remain"] = boost::any(*remain);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (reserveDisableTotal) {
      res["ReserveDisableTotal"] = boost::any(*reserveDisableTotal);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (statusDisableTotal) {
      res["StatusDisableTotal"] = boost::any(*statusDisableTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (usedRatio) {
      res["UsedRatio"] = boost::any(*usedRatio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("OversellRatio") != m.end() && !m["OversellRatio"].empty()) {
      oversellRatio = make_shared<long>(boost::any_cast<long>(m["OversellRatio"]));
    }
    if (m.find("Remain") != m.end() && !m["Remain"].empty()) {
      remain = make_shared<long>(boost::any_cast<long>(m["Remain"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("ReserveDisableTotal") != m.end() && !m["ReserveDisableTotal"].empty()) {
      reserveDisableTotal = make_shared<long>(boost::any_cast<long>(m["ReserveDisableTotal"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("StatusDisableTotal") != m.end() && !m["StatusDisableTotal"].empty()) {
      statusDisableTotal = make_shared<long>(boost::any_cast<long>(m["StatusDisableTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UsedRatio") != m.end() && !m["UsedRatio"].empty()) {
      usedRatio = make_shared<long>(boost::any_cast<long>(m["UsedRatio"]));
    }
  }


  virtual ~DescribeRegionResourceResponseBodyDataSsd() = default;
};
class DescribeRegionResourceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> areaCode{};
  shared_ptr<string> areaName{};
  shared_ptr<DescribeRegionResourceResponseBodyDataArmCard> armCard{};
  shared_ptr<vector<string>> attributes{};
  shared_ptr<DescribeRegionResourceResponseBodyDataBandwidth> bandwidth{};
  shared_ptr<DescribeRegionResourceResponseBodyDataBlockStorage> blockStorage{};
  shared_ptr<string> countryCode{};
  shared_ptr<string> countryName{};
  shared_ptr<DescribeRegionResourceResponseBodyDataCpu> cpu{};
  shared_ptr<DescribeRegionResourceResponseBodyDataGpu> gpu{};
  shared_ptr<DescribeRegionResourceResponseBodyDataHdd> hdd{};
  shared_ptr<string> houseId{};
  shared_ptr<vector<DescribeRegionResourceResponseBodyDataIpv4s>> ipv4s{};
  shared_ptr<vector<DescribeRegionResourceResponseBodyDataIpv6s>> ipv6s{};
  shared_ptr<vector<string>> ispTypes{};
  shared_ptr<DescribeRegionResourceResponseBodyDataMemory> memory{};
  shared_ptr<string> name{};
  shared_ptr<DescribeRegionResourceResponseBodyDataNvme> nvme{};
  shared_ptr<DescribeRegionResourceResponseBodyDataOssStorage> ossStorage{};
  shared_ptr<DescribeRegionResourceResponseBodyDataPangu> pangu{};
  shared_ptr<DescribeRegionResourceResponseBodyDataPcfarmNum> pcfarmNum{};
  shared_ptr<bool> poc{};
  shared_ptr<string> provinceCode{};
  shared_ptr<string> provinceName{};
  shared_ptr<bool> reserveDisable{};
  shared_ptr<DescribeRegionResourceResponseBodyDataSsd> ssd{};
  shared_ptr<bool> statusDisable{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};
  shared_ptr<string> virtual_{};

  DescribeRegionResourceResponseBodyData() {}

  explicit DescribeRegionResourceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (areaCode) {
      res["AreaCode"] = boost::any(*areaCode);
    }
    if (areaName) {
      res["AreaName"] = boost::any(*areaName);
    }
    if (armCard) {
      res["ArmCard"] = armCard ? boost::any(armCard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (attributes) {
      res["Attributes"] = boost::any(*attributes);
    }
    if (bandwidth) {
      res["Bandwidth"] = bandwidth ? boost::any(bandwidth->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (blockStorage) {
      res["BlockStorage"] = blockStorage ? boost::any(blockStorage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (countryCode) {
      res["CountryCode"] = boost::any(*countryCode);
    }
    if (countryName) {
      res["CountryName"] = boost::any(*countryName);
    }
    if (cpu) {
      res["Cpu"] = cpu ? boost::any(cpu->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gpu) {
      res["Gpu"] = gpu ? boost::any(gpu->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hdd) {
      res["Hdd"] = hdd ? boost::any(hdd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (houseId) {
      res["HouseId"] = boost::any(*houseId);
    }
    if (ipv4s) {
      vector<boost::any> temp1;
      for(auto item1:*ipv4s){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv4s"] = boost::any(temp1);
    }
    if (ipv6s) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6s){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6s"] = boost::any(temp1);
    }
    if (ispTypes) {
      res["IspTypes"] = boost::any(*ispTypes);
    }
    if (memory) {
      res["Memory"] = memory ? boost::any(memory->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nvme) {
      res["Nvme"] = nvme ? boost::any(nvme->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ossStorage) {
      res["OssStorage"] = ossStorage ? boost::any(ossStorage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pangu) {
      res["Pangu"] = pangu ? boost::any(pangu->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pcfarmNum) {
      res["PcfarmNum"] = pcfarmNum ? boost::any(pcfarmNum->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (poc) {
      res["Poc"] = boost::any(*poc);
    }
    if (provinceCode) {
      res["ProvinceCode"] = boost::any(*provinceCode);
    }
    if (provinceName) {
      res["ProvinceName"] = boost::any(*provinceName);
    }
    if (reserveDisable) {
      res["ReserveDisable"] = boost::any(*reserveDisable);
    }
    if (ssd) {
      res["Ssd"] = ssd ? boost::any(ssd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (statusDisable) {
      res["StatusDisable"] = boost::any(*statusDisable);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (virtual_) {
      res["Virtual"] = boost::any(*virtual_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AreaCode") != m.end() && !m["AreaCode"].empty()) {
      areaCode = make_shared<string>(boost::any_cast<string>(m["AreaCode"]));
    }
    if (m.find("AreaName") != m.end() && !m["AreaName"].empty()) {
      areaName = make_shared<string>(boost::any_cast<string>(m["AreaName"]));
    }
    if (m.find("ArmCard") != m.end() && !m["ArmCard"].empty()) {
      if (typeid(map<string, boost::any>) == m["ArmCard"].type()) {
        DescribeRegionResourceResponseBodyDataArmCard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ArmCard"]));
        armCard = make_shared<DescribeRegionResourceResponseBodyDataArmCard>(model1);
      }
    }
    if (m.find("Attributes") != m.end() && !m["Attributes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Attributes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Attributes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      attributes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      if (typeid(map<string, boost::any>) == m["Bandwidth"].type()) {
        DescribeRegionResourceResponseBodyDataBandwidth model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Bandwidth"]));
        bandwidth = make_shared<DescribeRegionResourceResponseBodyDataBandwidth>(model1);
      }
    }
    if (m.find("BlockStorage") != m.end() && !m["BlockStorage"].empty()) {
      if (typeid(map<string, boost::any>) == m["BlockStorage"].type()) {
        DescribeRegionResourceResponseBodyDataBlockStorage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BlockStorage"]));
        blockStorage = make_shared<DescribeRegionResourceResponseBodyDataBlockStorage>(model1);
      }
    }
    if (m.find("CountryCode") != m.end() && !m["CountryCode"].empty()) {
      countryCode = make_shared<string>(boost::any_cast<string>(m["CountryCode"]));
    }
    if (m.find("CountryName") != m.end() && !m["CountryName"].empty()) {
      countryName = make_shared<string>(boost::any_cast<string>(m["CountryName"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cpu"].type()) {
        DescribeRegionResourceResponseBodyDataCpu model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cpu"]));
        cpu = make_shared<DescribeRegionResourceResponseBodyDataCpu>(model1);
      }
    }
    if (m.find("Gpu") != m.end() && !m["Gpu"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gpu"].type()) {
        DescribeRegionResourceResponseBodyDataGpu model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gpu"]));
        gpu = make_shared<DescribeRegionResourceResponseBodyDataGpu>(model1);
      }
    }
    if (m.find("Hdd") != m.end() && !m["Hdd"].empty()) {
      if (typeid(map<string, boost::any>) == m["Hdd"].type()) {
        DescribeRegionResourceResponseBodyDataHdd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Hdd"]));
        hdd = make_shared<DescribeRegionResourceResponseBodyDataHdd>(model1);
      }
    }
    if (m.find("HouseId") != m.end() && !m["HouseId"].empty()) {
      houseId = make_shared<string>(boost::any_cast<string>(m["HouseId"]));
    }
    if (m.find("Ipv4s") != m.end() && !m["Ipv4s"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv4s"].type()) {
        vector<DescribeRegionResourceResponseBodyDataIpv4s> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv4s"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionResourceResponseBodyDataIpv4s model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv4s = make_shared<vector<DescribeRegionResourceResponseBodyDataIpv4s>>(expect1);
      }
    }
    if (m.find("Ipv6s") != m.end() && !m["Ipv6s"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6s"].type()) {
        vector<DescribeRegionResourceResponseBodyDataIpv6s> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6s"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionResourceResponseBodyDataIpv6s model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6s = make_shared<vector<DescribeRegionResourceResponseBodyDataIpv6s>>(expect1);
      }
    }
    if (m.find("IspTypes") != m.end() && !m["IspTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IspTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IspTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ispTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      if (typeid(map<string, boost::any>) == m["Memory"].type()) {
        DescribeRegionResourceResponseBodyDataMemory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Memory"]));
        memory = make_shared<DescribeRegionResourceResponseBodyDataMemory>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Nvme") != m.end() && !m["Nvme"].empty()) {
      if (typeid(map<string, boost::any>) == m["Nvme"].type()) {
        DescribeRegionResourceResponseBodyDataNvme model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Nvme"]));
        nvme = make_shared<DescribeRegionResourceResponseBodyDataNvme>(model1);
      }
    }
    if (m.find("OssStorage") != m.end() && !m["OssStorage"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssStorage"].type()) {
        DescribeRegionResourceResponseBodyDataOssStorage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssStorage"]));
        ossStorage = make_shared<DescribeRegionResourceResponseBodyDataOssStorage>(model1);
      }
    }
    if (m.find("Pangu") != m.end() && !m["Pangu"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pangu"].type()) {
        DescribeRegionResourceResponseBodyDataPangu model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pangu"]));
        pangu = make_shared<DescribeRegionResourceResponseBodyDataPangu>(model1);
      }
    }
    if (m.find("PcfarmNum") != m.end() && !m["PcfarmNum"].empty()) {
      if (typeid(map<string, boost::any>) == m["PcfarmNum"].type()) {
        DescribeRegionResourceResponseBodyDataPcfarmNum model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PcfarmNum"]));
        pcfarmNum = make_shared<DescribeRegionResourceResponseBodyDataPcfarmNum>(model1);
      }
    }
    if (m.find("Poc") != m.end() && !m["Poc"].empty()) {
      poc = make_shared<bool>(boost::any_cast<bool>(m["Poc"]));
    }
    if (m.find("ProvinceCode") != m.end() && !m["ProvinceCode"].empty()) {
      provinceCode = make_shared<string>(boost::any_cast<string>(m["ProvinceCode"]));
    }
    if (m.find("ProvinceName") != m.end() && !m["ProvinceName"].empty()) {
      provinceName = make_shared<string>(boost::any_cast<string>(m["ProvinceName"]));
    }
    if (m.find("ReserveDisable") != m.end() && !m["ReserveDisable"].empty()) {
      reserveDisable = make_shared<bool>(boost::any_cast<bool>(m["ReserveDisable"]));
    }
    if (m.find("Ssd") != m.end() && !m["Ssd"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ssd"].type()) {
        DescribeRegionResourceResponseBodyDataSsd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ssd"]));
        ssd = make_shared<DescribeRegionResourceResponseBodyDataSsd>(model1);
      }
    }
    if (m.find("StatusDisable") != m.end() && !m["StatusDisable"].empty()) {
      statusDisable = make_shared<bool>(boost::any_cast<bool>(m["StatusDisable"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Virtual") != m.end() && !m["Virtual"].empty()) {
      virtual_ = make_shared<string>(boost::any_cast<string>(m["Virtual"]));
    }
  }


  virtual ~DescribeRegionResourceResponseBodyData() = default;
};
class DescribeRegionResourceResponseBodyPager : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  DescribeRegionResourceResponseBodyPager() {}

  explicit DescribeRegionResourceResponseBodyPager(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeRegionResourceResponseBodyPager() = default;
};
class DescribeRegionResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRegionResourceResponseBodyData>> data{};
  shared_ptr<string> desc{};
  shared_ptr<string> msg{};
  shared_ptr<DescribeRegionResourceResponseBodyPager> pager{};
  shared_ptr<string> requestId{};

  DescribeRegionResourceResponseBody() {}

  explicit DescribeRegionResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (pager) {
      res["Pager"] = pager ? boost::any(pager->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeRegionResourceResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionResourceResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeRegionResourceResponseBodyData>>(expect1);
      }
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Pager") != m.end() && !m["Pager"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pager"].type()) {
        DescribeRegionResourceResponseBodyPager model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pager"]));
        pager = make_shared<DescribeRegionResourceResponseBodyPager>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRegionResourceResponseBody() = default;
};
class DescribeRegionResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRegionResourceResponseBody> body{};

  DescribeRegionResourceResponse() {}

  explicit DescribeRegionResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionResourceResponse() = default;
};
class DescribeReservedResourceResponseBodyImagesImage : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};

  DescribeReservedResourceResponseBodyImagesImage() {}

  explicit DescribeReservedResourceResponseBodyImagesImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
  }


  virtual ~DescribeReservedResourceResponseBodyImagesImage() = default;
};
class DescribeReservedResourceResponseBodyImages : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeReservedResourceResponseBodyImagesImage>> image{};

  DescribeReservedResourceResponseBodyImages() {}

  explicit DescribeReservedResourceResponseBodyImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      vector<boost::any> temp1;
      for(auto item1:*image){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Image"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      if (typeid(vector<boost::any>) == m["Image"].type()) {
        vector<DescribeReservedResourceResponseBodyImagesImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Image"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservedResourceResponseBodyImagesImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        image = make_shared<vector<DescribeReservedResourceResponseBodyImagesImage>>(expect1);
      }
    }
  }


  virtual ~DescribeReservedResourceResponseBodyImages() = default;
};
class DescribeReservedResourceResponseBodySupportResourcesSupportResourceDataDiskSizes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dataDiskSize{};

  DescribeReservedResourceResponseBodySupportResourcesSupportResourceDataDiskSizes() {}

  explicit DescribeReservedResourceResponseBodySupportResourcesSupportResourceDataDiskSizes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DataDiskSize"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataDiskSize"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dataDiskSize = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeReservedResourceResponseBodySupportResourcesSupportResourceDataDiskSizes() = default;
};
class DescribeReservedResourceResponseBodySupportResourcesSupportResourceSystemDiskSizes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> systemDiskSize{};

  DescribeReservedResourceResponseBodySupportResourcesSupportResourceSystemDiskSizes() {}

  explicit DescribeReservedResourceResponseBodySupportResourcesSupportResourceSystemDiskSizes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SystemDiskSize"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SystemDiskSize"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      systemDiskSize = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeReservedResourceResponseBodySupportResourcesSupportResourceSystemDiskSizes() = default;
};
class DescribeReservedResourceResponseBodySupportResourcesSupportResource : public Darabonba::Model {
public:
  shared_ptr<DescribeReservedResourceResponseBodySupportResourcesSupportResourceDataDiskSizes> dataDiskSizes{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceSpec{};
  shared_ptr<string> supportResourcesCount{};
  shared_ptr<DescribeReservedResourceResponseBodySupportResourcesSupportResourceSystemDiskSizes> systemDiskSizes{};

  DescribeReservedResourceResponseBodySupportResourcesSupportResource() {}

  explicit DescribeReservedResourceResponseBodySupportResourcesSupportResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDiskSizes) {
      res["DataDiskSizes"] = dataDiskSizes ? boost::any(dataDiskSizes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceSpec) {
      res["InstanceSpec"] = boost::any(*instanceSpec);
    }
    if (supportResourcesCount) {
      res["SupportResourcesCount"] = boost::any(*supportResourcesCount);
    }
    if (systemDiskSizes) {
      res["SystemDiskSizes"] = systemDiskSizes ? boost::any(systemDiskSizes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDiskSizes") != m.end() && !m["DataDiskSizes"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataDiskSizes"].type()) {
        DescribeReservedResourceResponseBodySupportResourcesSupportResourceDataDiskSizes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataDiskSizes"]));
        dataDiskSizes = make_shared<DescribeReservedResourceResponseBodySupportResourcesSupportResourceDataDiskSizes>(model1);
      }
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceSpec") != m.end() && !m["InstanceSpec"].empty()) {
      instanceSpec = make_shared<string>(boost::any_cast<string>(m["InstanceSpec"]));
    }
    if (m.find("SupportResourcesCount") != m.end() && !m["SupportResourcesCount"].empty()) {
      supportResourcesCount = make_shared<string>(boost::any_cast<string>(m["SupportResourcesCount"]));
    }
    if (m.find("SystemDiskSizes") != m.end() && !m["SystemDiskSizes"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDiskSizes"].type()) {
        DescribeReservedResourceResponseBodySupportResourcesSupportResourceSystemDiskSizes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDiskSizes"]));
        systemDiskSizes = make_shared<DescribeReservedResourceResponseBodySupportResourcesSupportResourceSystemDiskSizes>(model1);
      }
    }
  }


  virtual ~DescribeReservedResourceResponseBodySupportResourcesSupportResource() = default;
};
class DescribeReservedResourceResponseBodySupportResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeReservedResourceResponseBodySupportResourcesSupportResource>> supportResource{};

  DescribeReservedResourceResponseBodySupportResources() {}

  explicit DescribeReservedResourceResponseBodySupportResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportResource) {
      vector<boost::any> temp1;
      for(auto item1:*supportResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportResource") != m.end() && !m["SupportResource"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportResource"].type()) {
        vector<DescribeReservedResourceResponseBodySupportResourcesSupportResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservedResourceResponseBodySupportResourcesSupportResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportResource = make_shared<vector<DescribeReservedResourceResponseBodySupportResourcesSupportResource>>(expect1);
      }
    }
  }


  virtual ~DescribeReservedResourceResponseBodySupportResources() = default;
};
class DescribeReservedResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeReservedResourceResponseBodyImages> images{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeReservedResourceResponseBodySupportResources> supportResources{};

  DescribeReservedResourceResponseBody() {}

  explicit DescribeReservedResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (images) {
      res["Images"] = images ? boost::any(images->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (supportResources) {
      res["SupportResources"] = supportResources ? boost::any(supportResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(map<string, boost::any>) == m["Images"].type()) {
        DescribeReservedResourceResponseBodyImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Images"]));
        images = make_shared<DescribeReservedResourceResponseBodyImages>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SupportResources") != m.end() && !m["SupportResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportResources"].type()) {
        DescribeReservedResourceResponseBodySupportResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportResources"]));
        supportResources = make_shared<DescribeReservedResourceResponseBodySupportResources>(model1);
      }
    }
  }


  virtual ~DescribeReservedResourceResponseBody() = default;
};
class DescribeReservedResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeReservedResourceResponseBody> body{};

  DescribeReservedResourceResponse() {}

  explicit DescribeReservedResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeReservedResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeReservedResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeReservedResourceResponse() = default;
};
class DescribeResourceTimelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> beginTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> uuid{};

  DescribeResourceTimelineRequest() {}

  explicit DescribeResourceTimelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeResourceTimelineRequest() = default;
};
class DescribeResourceTimelineResponseBodyAvailableEvents : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> occurrenceTime{};
  shared_ptr<string> reason{};
  shared_ptr<string> type{};

  DescribeResourceTimelineResponseBodyAvailableEvents() {}

  explicit DescribeResourceTimelineResponseBodyAvailableEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (occurrenceTime) {
      res["OccurrenceTime"] = boost::any(*occurrenceTime);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OccurrenceTime") != m.end() && !m["OccurrenceTime"].empty()) {
      occurrenceTime = make_shared<string>(boost::any_cast<string>(m["OccurrenceTime"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeResourceTimelineResponseBodyAvailableEvents() = default;
};
class DescribeResourceTimelineResponseBodyBizEvents : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> occurrenceTime{};
  shared_ptr<string> reason{};
  shared_ptr<string> type{};

  DescribeResourceTimelineResponseBodyBizEvents() {}

  explicit DescribeResourceTimelineResponseBodyBizEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (occurrenceTime) {
      res["OccurrenceTime"] = boost::any(*occurrenceTime);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OccurrenceTime") != m.end() && !m["OccurrenceTime"].empty()) {
      occurrenceTime = make_shared<string>(boost::any_cast<string>(m["OccurrenceTime"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeResourceTimelineResponseBodyBizEvents() = default;
};
class DescribeResourceTimelineResponseBodyInventoryEvents : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> occurrenceTime{};
  shared_ptr<string> reason{};
  shared_ptr<string> type{};

  DescribeResourceTimelineResponseBodyInventoryEvents() {}

  explicit DescribeResourceTimelineResponseBodyInventoryEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (occurrenceTime) {
      res["OccurrenceTime"] = boost::any(*occurrenceTime);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OccurrenceTime") != m.end() && !m["OccurrenceTime"].empty()) {
      occurrenceTime = make_shared<string>(boost::any_cast<string>(m["OccurrenceTime"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeResourceTimelineResponseBodyInventoryEvents() = default;
};
class DescribeResourceTimelineResponseBodyReserveEvents : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> occurrenceTime{};
  shared_ptr<string> reason{};
  shared_ptr<string> type{};

  DescribeResourceTimelineResponseBodyReserveEvents() {}

  explicit DescribeResourceTimelineResponseBodyReserveEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (occurrenceTime) {
      res["OccurrenceTime"] = boost::any(*occurrenceTime);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OccurrenceTime") != m.end() && !m["OccurrenceTime"].empty()) {
      occurrenceTime = make_shared<string>(boost::any_cast<string>(m["OccurrenceTime"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeResourceTimelineResponseBodyReserveEvents() = default;
};
class DescribeResourceTimelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourceTimelineResponseBodyAvailableEvents>> availableEvents{};
  shared_ptr<vector<DescribeResourceTimelineResponseBodyBizEvents>> bizEvents{};
  shared_ptr<string> desc{};
  shared_ptr<vector<DescribeResourceTimelineResponseBodyInventoryEvents>> inventoryEvents{};
  shared_ptr<string> msg{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeResourceTimelineResponseBodyReserveEvents>> reserveEvents{};

  DescribeResourceTimelineResponseBody() {}

  explicit DescribeResourceTimelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableEvents) {
      vector<boost::any> temp1;
      for(auto item1:*availableEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableEvents"] = boost::any(temp1);
    }
    if (bizEvents) {
      vector<boost::any> temp1;
      for(auto item1:*bizEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BizEvents"] = boost::any(temp1);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (inventoryEvents) {
      vector<boost::any> temp1;
      for(auto item1:*inventoryEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InventoryEvents"] = boost::any(temp1);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (reserveEvents) {
      vector<boost::any> temp1;
      for(auto item1:*reserveEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReserveEvents"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableEvents") != m.end() && !m["AvailableEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableEvents"].type()) {
        vector<DescribeResourceTimelineResponseBodyAvailableEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceTimelineResponseBodyAvailableEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableEvents = make_shared<vector<DescribeResourceTimelineResponseBodyAvailableEvents>>(expect1);
      }
    }
    if (m.find("BizEvents") != m.end() && !m["BizEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["BizEvents"].type()) {
        vector<DescribeResourceTimelineResponseBodyBizEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BizEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceTimelineResponseBodyBizEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bizEvents = make_shared<vector<DescribeResourceTimelineResponseBodyBizEvents>>(expect1);
      }
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("InventoryEvents") != m.end() && !m["InventoryEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["InventoryEvents"].type()) {
        vector<DescribeResourceTimelineResponseBodyInventoryEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InventoryEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceTimelineResponseBodyInventoryEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inventoryEvents = make_shared<vector<DescribeResourceTimelineResponseBodyInventoryEvents>>(expect1);
      }
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ReserveEvents") != m.end() && !m["ReserveEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["ReserveEvents"].type()) {
        vector<DescribeResourceTimelineResponseBodyReserveEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReserveEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceTimelineResponseBodyReserveEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reserveEvents = make_shared<vector<DescribeResourceTimelineResponseBodyReserveEvents>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceTimelineResponseBody() = default;
};
class DescribeResourceTimelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeResourceTimelineResponseBody> body{};

  DescribeResourceTimelineResponse() {}

  explicit DescribeResourceTimelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResourceTimelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResourceTimelineResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResourceTimelineResponse() = default;
};
class DescribeSDGRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> SDGIds{};

  DescribeSDGRequest() {}

  explicit DescribeSDGRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (SDGIds) {
      res["SDGIds"] = boost::any(*SDGIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SDGIds") != m.end() && !m["SDGIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SDGIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SDGIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      SDGIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSDGRequest() = default;
};
class DescribeSDGShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> SDGIdsShrink{};

  DescribeSDGShrinkRequest() {}

  explicit DescribeSDGShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (SDGIdsShrink) {
      res["SDGIds"] = boost::any(*SDGIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SDGIds") != m.end() && !m["SDGIds"].empty()) {
      SDGIdsShrink = make_shared<string>(boost::any_cast<string>(m["SDGIds"]));
    }
  }


  virtual ~DescribeSDGShrinkRequest() = default;
};
class DescribeSDGResponseBodySDGsAvaliableRegionIds : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> status{};

  DescribeSDGResponseBodySDGsAvaliableRegionIds() {}

  explicit DescribeSDGResponseBodySDGsAvaliableRegionIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSDGResponseBodySDGsAvaliableRegionIds() = default;
};
class DescribeSDGResponseBodySDGsPreloadInfos : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> redundantNum{};
  shared_ptr<string> regionId{};
  shared_ptr<string> updateTime{};

  DescribeSDGResponseBodySDGsPreloadInfos() {}

  explicit DescribeSDGResponseBodySDGsPreloadInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (redundantNum) {
      res["RedundantNum"] = boost::any(*redundantNum);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RedundantNum") != m.end() && !m["RedundantNum"].empty()) {
      redundantNum = make_shared<long>(boost::any_cast<long>(m["RedundantNum"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeSDGResponseBodySDGsPreloadInfos() = default;
};
class DescribeSDGResponseBodySDGs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSDGResponseBodySDGsAvaliableRegionIds>> avaliableRegionIds{};
  shared_ptr<string> creationInstanceId{};
  shared_ptr<string> creationRegionId{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> parentSDGId{};
  shared_ptr<vector<DescribeSDGResponseBodySDGsPreloadInfos>> preloadInfos{};
  shared_ptr<string> SDGId{};
  shared_ptr<long> size{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};

  DescribeSDGResponseBodySDGs() {}

  explicit DescribeSDGResponseBodySDGs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avaliableRegionIds) {
      vector<boost::any> temp1;
      for(auto item1:*avaliableRegionIds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvaliableRegionIds"] = boost::any(temp1);
    }
    if (creationInstanceId) {
      res["CreationInstanceId"] = boost::any(*creationInstanceId);
    }
    if (creationRegionId) {
      res["CreationRegionId"] = boost::any(*creationRegionId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (parentSDGId) {
      res["ParentSDGId"] = boost::any(*parentSDGId);
    }
    if (preloadInfos) {
      vector<boost::any> temp1;
      for(auto item1:*preloadInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PreloadInfos"] = boost::any(temp1);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvaliableRegionIds") != m.end() && !m["AvaliableRegionIds"].empty()) {
      if (typeid(vector<boost::any>) == m["AvaliableRegionIds"].type()) {
        vector<DescribeSDGResponseBodySDGsAvaliableRegionIds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvaliableRegionIds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSDGResponseBodySDGsAvaliableRegionIds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        avaliableRegionIds = make_shared<vector<DescribeSDGResponseBodySDGsAvaliableRegionIds>>(expect1);
      }
    }
    if (m.find("CreationInstanceId") != m.end() && !m["CreationInstanceId"].empty()) {
      creationInstanceId = make_shared<string>(boost::any_cast<string>(m["CreationInstanceId"]));
    }
    if (m.find("CreationRegionId") != m.end() && !m["CreationRegionId"].empty()) {
      creationRegionId = make_shared<string>(boost::any_cast<string>(m["CreationRegionId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ParentSDGId") != m.end() && !m["ParentSDGId"].empty()) {
      parentSDGId = make_shared<string>(boost::any_cast<string>(m["ParentSDGId"]));
    }
    if (m.find("PreloadInfos") != m.end() && !m["PreloadInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["PreloadInfos"].type()) {
        vector<DescribeSDGResponseBodySDGsPreloadInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PreloadInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSDGResponseBodySDGsPreloadInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        preloadInfos = make_shared<vector<DescribeSDGResponseBodySDGsPreloadInfos>>(expect1);
      }
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeSDGResponseBodySDGs() = default;
};
class DescribeSDGResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSDGResponseBodySDGs>> SDGs{};
  shared_ptr<long> totalCount{};

  DescribeSDGResponseBody() {}

  explicit DescribeSDGResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (SDGs) {
      vector<boost::any> temp1;
      for(auto item1:*SDGs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SDGs"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SDGs") != m.end() && !m["SDGs"].empty()) {
      if (typeid(vector<boost::any>) == m["SDGs"].type()) {
        vector<DescribeSDGResponseBodySDGs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SDGs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSDGResponseBodySDGs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        SDGs = make_shared<vector<DescribeSDGResponseBodySDGs>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSDGResponseBody() = default;
};
class DescribeSDGResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSDGResponseBody> body{};

  DescribeSDGResponse() {}

  explicit DescribeSDGResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSDGResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSDGResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSDGResponse() = default;
};
class DescribeSDGDeploymentStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> deploymentType{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> regionIds{};
  shared_ptr<string> SDGId{};
  shared_ptr<string> status{};

  DescribeSDGDeploymentStatusRequest() {}

  explicit DescribeSDGDeploymentStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deploymentType) {
      res["DeploymentType"] = boost::any(*deploymentType);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionIds) {
      res["RegionIds"] = boost::any(*regionIds);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeploymentType") != m.end() && !m["DeploymentType"].empty()) {
      deploymentType = make_shared<string>(boost::any_cast<string>(m["DeploymentType"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionIds") != m.end() && !m["RegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      regionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSDGDeploymentStatusRequest() = default;
};
class DescribeSDGDeploymentStatusShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> deploymentType{};
  shared_ptr<string> instanceIdsShrink{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionIdsShrink{};
  shared_ptr<string> SDGId{};
  shared_ptr<string> status{};

  DescribeSDGDeploymentStatusShrinkRequest() {}

  explicit DescribeSDGDeploymentStatusShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deploymentType) {
      res["DeploymentType"] = boost::any(*deploymentType);
    }
    if (instanceIdsShrink) {
      res["InstanceIds"] = boost::any(*instanceIdsShrink);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionIdsShrink) {
      res["RegionIds"] = boost::any(*regionIdsShrink);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeploymentType") != m.end() && !m["DeploymentType"].empty()) {
      deploymentType = make_shared<string>(boost::any_cast<string>(m["DeploymentType"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionIds") != m.end() && !m["RegionIds"].empty()) {
      regionIdsShrink = make_shared<string>(boost::any_cast<string>(m["RegionIds"]));
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSDGDeploymentStatusShrinkRequest() = default;
};
class DescribeSDGDeploymentStatusResponseBodyDeploymentStatus : public Darabonba::Model {
public:
  shared_ptr<long> blockRwSplitSize{};
  shared_ptr<long> cacheSize{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mountType{};
  shared_ptr<string> phase{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};

  DescribeSDGDeploymentStatusResponseBodyDeploymentStatus() {}

  explicit DescribeSDGDeploymentStatusResponseBodyDeploymentStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockRwSplitSize) {
      res["BlockRwSplitSize"] = boost::any(*blockRwSplitSize);
    }
    if (cacheSize) {
      res["CacheSize"] = boost::any(*cacheSize);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mountType) {
      res["MountType"] = boost::any(*mountType);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockRwSplitSize") != m.end() && !m["BlockRwSplitSize"].empty()) {
      blockRwSplitSize = make_shared<long>(boost::any_cast<long>(m["BlockRwSplitSize"]));
    }
    if (m.find("CacheSize") != m.end() && !m["CacheSize"].empty()) {
      cacheSize = make_shared<long>(boost::any_cast<long>(m["CacheSize"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MountType") != m.end() && !m["MountType"].empty()) {
      mountType = make_shared<string>(boost::any_cast<string>(m["MountType"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeSDGDeploymentStatusResponseBodyDeploymentStatus() = default;
};
class DescribeSDGDeploymentStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSDGDeploymentStatusResponseBodyDeploymentStatus>> deploymentStatus{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeSDGDeploymentStatusResponseBody() {}

  explicit DescribeSDGDeploymentStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deploymentStatus) {
      vector<boost::any> temp1;
      for(auto item1:*deploymentStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeploymentStatus"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeploymentStatus") != m.end() && !m["DeploymentStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["DeploymentStatus"].type()) {
        vector<DescribeSDGDeploymentStatusResponseBodyDeploymentStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeploymentStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSDGDeploymentStatusResponseBodyDeploymentStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deploymentStatus = make_shared<vector<DescribeSDGDeploymentStatusResponseBodyDeploymentStatus>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSDGDeploymentStatusResponseBody() = default;
};
class DescribeSDGDeploymentStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSDGDeploymentStatusResponseBody> body{};

  DescribeSDGDeploymentStatusResponse() {}

  explicit DescribeSDGDeploymentStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSDGDeploymentStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSDGDeploymentStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSDGDeploymentStatusResponse() = default;
};
class DescribeSDGsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<vector<string>> SDGIds{};

  DescribeSDGsRequest() {}

  explicit DescribeSDGsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (SDGIds) {
      res["SDGIds"] = boost::any(*SDGIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SDGIds") != m.end() && !m["SDGIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SDGIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SDGIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      SDGIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSDGsRequest() = default;
};
class DescribeSDGsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIdsShrink{};
  shared_ptr<string> SDGIdsShrink{};

  DescribeSDGsShrinkRequest() {}

  explicit DescribeSDGsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIdsShrink) {
      res["InstanceIds"] = boost::any(*instanceIdsShrink);
    }
    if (SDGIdsShrink) {
      res["SDGIds"] = boost::any(*SDGIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("SDGIds") != m.end() && !m["SDGIds"].empty()) {
      SDGIdsShrink = make_shared<string>(boost::any_cast<string>(m["SDGIds"]));
    }
  }


  virtual ~DescribeSDGsShrinkRequest() = default;
};
class DescribeSDGsResponseBodySDGsAvaliableRegionIds : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> status{};

  DescribeSDGsResponseBodySDGsAvaliableRegionIds() {}

  explicit DescribeSDGsResponseBodySDGsAvaliableRegionIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSDGsResponseBodySDGsAvaliableRegionIds() = default;
};
class DescribeSDGsResponseBodySDGsDeployedInstanceIds : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> deploymentType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> status{};

  DescribeSDGsResponseBodySDGsDeployedInstanceIds() {}

  explicit DescribeSDGsResponseBodySDGsDeployedInstanceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (deploymentType) {
      res["DeploymentType"] = boost::any(*deploymentType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DeploymentType") != m.end() && !m["DeploymentType"].empty()) {
      deploymentType = make_shared<string>(boost::any_cast<string>(m["DeploymentType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSDGsResponseBodySDGsDeployedInstanceIds() = default;
};
class DescribeSDGsResponseBodySDGs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSDGsResponseBodySDGsAvaliableRegionIds>> avaliableRegionIds{};
  shared_ptr<string> creationInstanceId{};
  shared_ptr<string> creationRegionId{};
  shared_ptr<string> creationTime{};
  shared_ptr<vector<DescribeSDGsResponseBodySDGsDeployedInstanceIds>> deployedInstanceIds{};
  shared_ptr<string> description{};
  shared_ptr<string> parentSDGId{};
  shared_ptr<string> SDGId{};
  shared_ptr<long> size{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};

  DescribeSDGsResponseBodySDGs() {}

  explicit DescribeSDGsResponseBodySDGs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avaliableRegionIds) {
      vector<boost::any> temp1;
      for(auto item1:*avaliableRegionIds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvaliableRegionIds"] = boost::any(temp1);
    }
    if (creationInstanceId) {
      res["CreationInstanceId"] = boost::any(*creationInstanceId);
    }
    if (creationRegionId) {
      res["CreationRegionId"] = boost::any(*creationRegionId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (deployedInstanceIds) {
      vector<boost::any> temp1;
      for(auto item1:*deployedInstanceIds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeployedInstanceIds"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (parentSDGId) {
      res["ParentSDGId"] = boost::any(*parentSDGId);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvaliableRegionIds") != m.end() && !m["AvaliableRegionIds"].empty()) {
      if (typeid(vector<boost::any>) == m["AvaliableRegionIds"].type()) {
        vector<DescribeSDGsResponseBodySDGsAvaliableRegionIds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvaliableRegionIds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSDGsResponseBodySDGsAvaliableRegionIds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        avaliableRegionIds = make_shared<vector<DescribeSDGsResponseBodySDGsAvaliableRegionIds>>(expect1);
      }
    }
    if (m.find("CreationInstanceId") != m.end() && !m["CreationInstanceId"].empty()) {
      creationInstanceId = make_shared<string>(boost::any_cast<string>(m["CreationInstanceId"]));
    }
    if (m.find("CreationRegionId") != m.end() && !m["CreationRegionId"].empty()) {
      creationRegionId = make_shared<string>(boost::any_cast<string>(m["CreationRegionId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DeployedInstanceIds") != m.end() && !m["DeployedInstanceIds"].empty()) {
      if (typeid(vector<boost::any>) == m["DeployedInstanceIds"].type()) {
        vector<DescribeSDGsResponseBodySDGsDeployedInstanceIds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeployedInstanceIds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSDGsResponseBodySDGsDeployedInstanceIds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployedInstanceIds = make_shared<vector<DescribeSDGsResponseBodySDGsDeployedInstanceIds>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ParentSDGId") != m.end() && !m["ParentSDGId"].empty()) {
      parentSDGId = make_shared<string>(boost::any_cast<string>(m["ParentSDGId"]));
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeSDGsResponseBodySDGs() = default;
};
class DescribeSDGsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSDGsResponseBodySDGs>> SDGs{};

  DescribeSDGsResponseBody() {}

  explicit DescribeSDGsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (SDGs) {
      vector<boost::any> temp1;
      for(auto item1:*SDGs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SDGs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SDGs") != m.end() && !m["SDGs"].empty()) {
      if (typeid(vector<boost::any>) == m["SDGs"].type()) {
        vector<DescribeSDGsResponseBodySDGs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SDGs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSDGsResponseBodySDGs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        SDGs = make_shared<vector<DescribeSDGsResponseBodySDGs>>(expect1);
      }
    }
  }


  virtual ~DescribeSDGsResponseBody() = default;
};
class DescribeSDGsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSDGsResponseBody> body{};

  DescribeSDGsResponse() {}

  explicit DescribeSDGsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSDGsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSDGsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSDGsResponse() = default;
};
class DescribeSecondaryPublicIpAddressesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<vector<string>> ensRegionIds{};
  shared_ptr<string> isp{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> secondaryPublicIpAddress{};
  shared_ptr<string> secondaryPublicIpId{};

  DescribeSecondaryPublicIpAddressesRequest() {}

  explicit DescribeSecondaryPublicIpAddressesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = boost::any(*ensRegionIds);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (secondaryPublicIpAddress) {
      res["SecondaryPublicIpAddress"] = boost::any(*secondaryPublicIpAddress);
    }
    if (secondaryPublicIpId) {
      res["SecondaryPublicIpId"] = boost::any(*secondaryPublicIpId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnsRegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnsRegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ensRegionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecondaryPublicIpAddress") != m.end() && !m["SecondaryPublicIpAddress"].empty()) {
      secondaryPublicIpAddress = make_shared<string>(boost::any_cast<string>(m["SecondaryPublicIpAddress"]));
    }
    if (m.find("SecondaryPublicIpId") != m.end() && !m["SecondaryPublicIpId"].empty()) {
      secondaryPublicIpId = make_shared<string>(boost::any_cast<string>(m["SecondaryPublicIpId"]));
    }
  }


  virtual ~DescribeSecondaryPublicIpAddressesRequest() = default;
};
class DescribeSecondaryPublicIpAddressesResponseBodySecondaryPublicIpAddresses : public Darabonba::Model {
public:
  shared_ptr<long> cidrMask{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> gateway{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> isp{};
  shared_ptr<string> secondaryPublicIpAddress{};
  shared_ptr<string> secondaryPublicIpId{};

  DescribeSecondaryPublicIpAddressesResponseBodySecondaryPublicIpAddresses() {}

  explicit DescribeSecondaryPublicIpAddressesResponseBodySecondaryPublicIpAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrMask) {
      res["CidrMask"] = boost::any(*cidrMask);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (secondaryPublicIpAddress) {
      res["SecondaryPublicIpAddress"] = boost::any(*secondaryPublicIpAddress);
    }
    if (secondaryPublicIpId) {
      res["SecondaryPublicIpId"] = boost::any(*secondaryPublicIpId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrMask") != m.end() && !m["CidrMask"].empty()) {
      cidrMask = make_shared<long>(boost::any_cast<long>(m["CidrMask"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("SecondaryPublicIpAddress") != m.end() && !m["SecondaryPublicIpAddress"].empty()) {
      secondaryPublicIpAddress = make_shared<string>(boost::any_cast<string>(m["SecondaryPublicIpAddress"]));
    }
    if (m.find("SecondaryPublicIpId") != m.end() && !m["SecondaryPublicIpId"].empty()) {
      secondaryPublicIpId = make_shared<string>(boost::any_cast<string>(m["SecondaryPublicIpId"]));
    }
  }


  virtual ~DescribeSecondaryPublicIpAddressesResponseBodySecondaryPublicIpAddresses() = default;
};
class DescribeSecondaryPublicIpAddressesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSecondaryPublicIpAddressesResponseBodySecondaryPublicIpAddresses>> secondaryPublicIpAddresses{};
  shared_ptr<long> totalCount{};

  DescribeSecondaryPublicIpAddressesResponseBody() {}

  explicit DescribeSecondaryPublicIpAddressesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (secondaryPublicIpAddresses) {
      vector<boost::any> temp1;
      for(auto item1:*secondaryPublicIpAddresses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecondaryPublicIpAddresses"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecondaryPublicIpAddresses") != m.end() && !m["SecondaryPublicIpAddresses"].empty()) {
      if (typeid(vector<boost::any>) == m["SecondaryPublicIpAddresses"].type()) {
        vector<DescribeSecondaryPublicIpAddressesResponseBodySecondaryPublicIpAddresses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecondaryPublicIpAddresses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecondaryPublicIpAddressesResponseBodySecondaryPublicIpAddresses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        secondaryPublicIpAddresses = make_shared<vector<DescribeSecondaryPublicIpAddressesResponseBodySecondaryPublicIpAddresses>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSecondaryPublicIpAddressesResponseBody() = default;
};
class DescribeSecondaryPublicIpAddressesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSecondaryPublicIpAddressesResponseBody> body{};

  DescribeSecondaryPublicIpAddressesResponse() {}

  explicit DescribeSecondaryPublicIpAddressesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecondaryPublicIpAddressesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecondaryPublicIpAddressesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecondaryPublicIpAddressesResponse() = default;
};
class DescribeSecurityGroupAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityGroupId{};

  DescribeSecurityGroupAttributeRequest() {}

  explicit DescribeSecurityGroupAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~DescribeSecurityGroupAttributeRequest() = default;
};
class DescribeSecurityGroupAttributeResponseBodyPermissionsPermission : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> direction{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> sourcePortRange{};

  DescribeSecurityGroupAttributeResponseBodyPermissionsPermission() {}

  explicit DescribeSecurityGroupAttributeResponseBodyPermissionsPermission(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
  }


  virtual ~DescribeSecurityGroupAttributeResponseBodyPermissionsPermission() = default;
};
class DescribeSecurityGroupAttributeResponseBodyPermissions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSecurityGroupAttributeResponseBodyPermissionsPermission>> permission{};

  DescribeSecurityGroupAttributeResponseBodyPermissions() {}

  explicit DescribeSecurityGroupAttributeResponseBodyPermissions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (permission) {
      vector<boost::any> temp1;
      for(auto item1:*permission){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Permission"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Permission") != m.end() && !m["Permission"].empty()) {
      if (typeid(vector<boost::any>) == m["Permission"].type()) {
        vector<DescribeSecurityGroupAttributeResponseBodyPermissionsPermission> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Permission"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityGroupAttributeResponseBodyPermissionsPermission model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        permission = make_shared<vector<DescribeSecurityGroupAttributeResponseBodyPermissionsPermission>>(expect1);
      }
    }
  }


  virtual ~DescribeSecurityGroupAttributeResponseBodyPermissions() = default;
};
class DescribeSecurityGroupAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<DescribeSecurityGroupAttributeResponseBodyPermissions> permissions{};
  shared_ptr<string> requestId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupName{};

  DescribeSecurityGroupAttributeResponseBody() {}

  explicit DescribeSecurityGroupAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (permissions) {
      res["Permissions"] = permissions ? boost::any(permissions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Permissions") != m.end() && !m["Permissions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Permissions"].type()) {
        DescribeSecurityGroupAttributeResponseBodyPermissions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Permissions"]));
        permissions = make_shared<DescribeSecurityGroupAttributeResponseBodyPermissions>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
  }


  virtual ~DescribeSecurityGroupAttributeResponseBody() = default;
};
class DescribeSecurityGroupAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSecurityGroupAttributeResponseBody> body{};

  DescribeSecurityGroupAttributeResponse() {}

  explicit DescribeSecurityGroupAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityGroupAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityGroupAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityGroupAttributeResponse() = default;
};
class DescribeSecurityGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupName{};

  DescribeSecurityGroupsRequest() {}

  explicit DescribeSecurityGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
  }


  virtual ~DescribeSecurityGroupsRequest() = default;
};
class DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupInstanceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceId{};

  DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupInstanceIds() {}

  explicit DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupInstanceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupInstanceIds() = default;
};
class DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupNetworkInterfaceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> networkInterfaceId{};

  DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupNetworkInterfaceIds() {}

  explicit DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupNetworkInterfaceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NetworkInterfaceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NetworkInterfaceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      networkInterfaceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupNetworkInterfaceIds() = default;
};
class DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<long> instanceCount{};
  shared_ptr<DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupInstanceIds> instanceIds{};
  shared_ptr<DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupNetworkInterfaceIds> networkInterfaceIds{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupName{};

  DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup() {}

  explicit DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (instanceIds) {
      res["InstanceIds"] = instanceIds ? boost::any(instanceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkInterfaceIds) {
      res["NetworkInterfaceIds"] = networkInterfaceIds ? boost::any(networkInterfaceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceIds"].type()) {
        DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupInstanceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceIds"]));
        instanceIds = make_shared<DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupInstanceIds>(model1);
      }
    }
    if (m.find("NetworkInterfaceIds") != m.end() && !m["NetworkInterfaceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkInterfaceIds"].type()) {
        DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupNetworkInterfaceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkInterfaceIds"]));
        networkInterfaceIds = make_shared<DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupNetworkInterfaceIds>(model1);
      }
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
  }


  virtual ~DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup() = default;
};
class DescribeSecurityGroupsResponseBodySecurityGroups : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup>> securityGroup{};

  DescribeSecurityGroupsResponseBodySecurityGroups() {}

  explicit DescribeSecurityGroupsResponseBodySecurityGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroup) {
      vector<boost::any> temp1;
      for(auto item1:*securityGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroup") != m.end() && !m["SecurityGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityGroup"].type()) {
        vector<DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityGroup = make_shared<vector<DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeSecurityGroupsResponseBodySecurityGroups() = default;
};
class DescribeSecurityGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSecurityGroupsResponseBodySecurityGroups> securityGroups{};
  shared_ptr<long> totalCount{};

  DescribeSecurityGroupsResponseBody() {}

  explicit DescribeSecurityGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityGroups) {
      res["SecurityGroups"] = securityGroups ? boost::any(securityGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityGroups") != m.end() && !m["SecurityGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroups"].type()) {
        DescribeSecurityGroupsResponseBodySecurityGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroups"]));
        securityGroups = make_shared<DescribeSecurityGroupsResponseBodySecurityGroups>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSecurityGroupsResponseBody() = default;
};
class DescribeSecurityGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSecurityGroupsResponseBody> body{};

  DescribeSecurityGroupsResponse() {}

  explicit DescribeSecurityGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityGroupsResponse() = default;
};
class DescribeSelfImagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> snapshotId{};

  DescribeSelfImagesRequest() {}

  explicit DescribeSelfImagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
  }


  virtual ~DescribeSelfImagesRequest() = default;
};
class DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping : public Darabonba::Model {
public:
  shared_ptr<string> format{};
  shared_ptr<string> size{};
  shared_ptr<string> type{};
  shared_ptr<string> imageId{};

  DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping() {}

  explicit DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (imageId) {
      res["imageId"] = boost::any(*imageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("imageId") != m.end() && !m["imageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["imageId"]));
    }
  }


  virtual ~DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping() = default;
};
class DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappings : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping>> diskDeviceMapping{};

  DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappings() {}

  explicit DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskDeviceMapping) {
      vector<boost::any> temp1;
      for(auto item1:*diskDeviceMapping){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiskDeviceMapping"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskDeviceMapping") != m.end() && !m["DiskDeviceMapping"].empty()) {
      if (typeid(vector<boost::any>) == m["DiskDeviceMapping"].type()) {
        vector<DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiskDeviceMapping"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diskDeviceMapping = make_shared<vector<DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping>>(expect1);
      }
    }
  }


  virtual ~DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappings() = default;
};
class DescribeSelfImagesResponseBodyImagesImage : public Darabonba::Model {
public:
  shared_ptr<string> architecture{};
  shared_ptr<string> computeType{};
  shared_ptr<string> creationTime{};
  shared_ptr<DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappings> diskDeviceMappings{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> imageOwnerAlias{};
  shared_ptr<string> imageSize{};
  shared_ptr<string> imageStorageSize{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> osVersion{};
  shared_ptr<string> platform{};
  shared_ptr<string> regionId{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> status{};

  DescribeSelfImagesResponseBodyImagesImage() {}

  explicit DescribeSelfImagesResponseBodyImagesImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (computeType) {
      res["ComputeType"] = boost::any(*computeType);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (diskDeviceMappings) {
      res["DiskDeviceMappings"] = diskDeviceMappings ? boost::any(diskDeviceMappings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (imageOwnerAlias) {
      res["ImageOwnerAlias"] = boost::any(*imageOwnerAlias);
    }
    if (imageSize) {
      res["ImageSize"] = boost::any(*imageSize);
    }
    if (imageStorageSize) {
      res["ImageStorageSize"] = boost::any(*imageStorageSize);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (osVersion) {
      res["OsVersion"] = boost::any(*osVersion);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("ComputeType") != m.end() && !m["ComputeType"].empty()) {
      computeType = make_shared<string>(boost::any_cast<string>(m["ComputeType"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DiskDeviceMappings") != m.end() && !m["DiskDeviceMappings"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskDeviceMappings"].type()) {
        DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskDeviceMappings"]));
        diskDeviceMappings = make_shared<DescribeSelfImagesResponseBodyImagesImageDiskDeviceMappings>(model1);
      }
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("ImageOwnerAlias") != m.end() && !m["ImageOwnerAlias"].empty()) {
      imageOwnerAlias = make_shared<string>(boost::any_cast<string>(m["ImageOwnerAlias"]));
    }
    if (m.find("ImageSize") != m.end() && !m["ImageSize"].empty()) {
      imageSize = make_shared<string>(boost::any_cast<string>(m["ImageSize"]));
    }
    if (m.find("ImageStorageSize") != m.end() && !m["ImageStorageSize"].empty()) {
      imageStorageSize = make_shared<string>(boost::any_cast<string>(m["ImageStorageSize"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OsVersion") != m.end() && !m["OsVersion"].empty()) {
      osVersion = make_shared<string>(boost::any_cast<string>(m["OsVersion"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSelfImagesResponseBodyImagesImage() = default;
};
class DescribeSelfImagesResponseBodyImages : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSelfImagesResponseBodyImagesImage>> image{};

  DescribeSelfImagesResponseBodyImages() {}

  explicit DescribeSelfImagesResponseBodyImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      vector<boost::any> temp1;
      for(auto item1:*image){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Image"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      if (typeid(vector<boost::any>) == m["Image"].type()) {
        vector<DescribeSelfImagesResponseBodyImagesImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Image"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSelfImagesResponseBodyImagesImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        image = make_shared<vector<DescribeSelfImagesResponseBodyImagesImage>>(expect1);
      }
    }
  }


  virtual ~DescribeSelfImagesResponseBodyImages() = default;
};
class DescribeSelfImagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeSelfImagesResponseBodyImages> images{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};

  DescribeSelfImagesResponseBody() {}

  explicit DescribeSelfImagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (images) {
      res["Images"] = images ? boost::any(images->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(map<string, boost::any>) == m["Images"].type()) {
        DescribeSelfImagesResponseBodyImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Images"]));
        images = make_shared<DescribeSelfImagesResponseBodyImages>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSelfImagesResponseBody() = default;
};
class DescribeSelfImagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSelfImagesResponseBody> body{};

  DescribeSelfImagesResponse() {}

  explicit DescribeSelfImagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSelfImagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSelfImagesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSelfImagesResponse() = default;
};
class DescribeServcieScheduleRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> podConfigName{};
  shared_ptr<string> uuid{};

  DescribeServcieScheduleRequest() {}

  explicit DescribeServcieScheduleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (podConfigName) {
      res["PodConfigName"] = boost::any(*podConfigName);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("PodConfigName") != m.end() && !m["PodConfigName"].empty()) {
      podConfigName = make_shared<string>(boost::any_cast<string>(m["PodConfigName"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeServcieScheduleRequest() = default;
};
class DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatusesContainerStatus : public Darabonba::Model {
public:
  shared_ptr<string> containerId{};
  shared_ptr<string> name{};

  DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatusesContainerStatus() {}

  explicit DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatusesContainerStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatusesContainerStatus() = default;
};
class DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatuses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatusesContainerStatus>> containerStatus{};

  DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatuses() {}

  explicit DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatuses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerStatus) {
      vector<boost::any> temp1;
      for(auto item1:*containerStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContainerStatus"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerStatus") != m.end() && !m["ContainerStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["ContainerStatus"].type()) {
        vector<DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatusesContainerStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContainerStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatusesContainerStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        containerStatus = make_shared<vector<DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatusesContainerStatus>>(expect1);
      }
    }
  }


  virtual ~DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatuses() = default;
};
class DescribeServcieScheduleResponseBodyPodAbstractInfo : public Darabonba::Model {
public:
  shared_ptr<bool> containerService{};
  shared_ptr<DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatuses> containerStatuses{};
  shared_ptr<bool> name{};
  shared_ptr<bool> namespace_{};
  shared_ptr<bool> resourceScope{};
  shared_ptr<bool> status{};

  DescribeServcieScheduleResponseBodyPodAbstractInfo() {}

  explicit DescribeServcieScheduleResponseBodyPodAbstractInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerService) {
      res["ContainerService"] = boost::any(*containerService);
    }
    if (containerStatuses) {
      res["ContainerStatuses"] = containerStatuses ? boost::any(containerStatuses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (resourceScope) {
      res["ResourceScope"] = boost::any(*resourceScope);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerService") != m.end() && !m["ContainerService"].empty()) {
      containerService = make_shared<bool>(boost::any_cast<bool>(m["ContainerService"]));
    }
    if (m.find("ContainerStatuses") != m.end() && !m["ContainerStatuses"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContainerStatuses"].type()) {
        DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatuses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContainerStatuses"]));
        containerStatuses = make_shared<DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatuses>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<bool>(boost::any_cast<bool>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<bool>(boost::any_cast<bool>(m["Namespace"]));
    }
    if (m.find("ResourceScope") != m.end() && !m["ResourceScope"].empty()) {
      resourceScope = make_shared<bool>(boost::any_cast<bool>(m["ResourceScope"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
  }


  virtual ~DescribeServcieScheduleResponseBodyPodAbstractInfo() = default;
};
class DescribeServcieScheduleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> index{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceIp{};
  shared_ptr<long> instancePort{};
  shared_ptr<DescribeServcieScheduleResponseBodyPodAbstractInfo> podAbstractInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> requestRepeated{};
  shared_ptr<string> tcpPorts{};

  DescribeServcieScheduleResponseBody() {}

  explicit DescribeServcieScheduleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceIp) {
      res["InstanceIp"] = boost::any(*instanceIp);
    }
    if (instancePort) {
      res["InstancePort"] = boost::any(*instancePort);
    }
    if (podAbstractInfo) {
      res["PodAbstractInfo"] = podAbstractInfo ? boost::any(podAbstractInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestRepeated) {
      res["RequestRepeated"] = boost::any(*requestRepeated);
    }
    if (tcpPorts) {
      res["TcpPorts"] = boost::any(*tcpPorts);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceIp") != m.end() && !m["InstanceIp"].empty()) {
      instanceIp = make_shared<string>(boost::any_cast<string>(m["InstanceIp"]));
    }
    if (m.find("InstancePort") != m.end() && !m["InstancePort"].empty()) {
      instancePort = make_shared<long>(boost::any_cast<long>(m["InstancePort"]));
    }
    if (m.find("PodAbstractInfo") != m.end() && !m["PodAbstractInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PodAbstractInfo"].type()) {
        DescribeServcieScheduleResponseBodyPodAbstractInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PodAbstractInfo"]));
        podAbstractInfo = make_shared<DescribeServcieScheduleResponseBodyPodAbstractInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestRepeated") != m.end() && !m["RequestRepeated"].empty()) {
      requestRepeated = make_shared<bool>(boost::any_cast<bool>(m["RequestRepeated"]));
    }
    if (m.find("TcpPorts") != m.end() && !m["TcpPorts"].empty()) {
      tcpPorts = make_shared<string>(boost::any_cast<string>(m["TcpPorts"]));
    }
  }


  virtual ~DescribeServcieScheduleResponseBody() = default;
};
class DescribeServcieScheduleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeServcieScheduleResponseBody> body{};

  DescribeServcieScheduleResponse() {}

  explicit DescribeServcieScheduleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeServcieScheduleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeServcieScheduleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeServcieScheduleResponse() = default;
};
class DescribeServerLoadBalancerListenMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> proto{};
  shared_ptr<string> startTime{};
  shared_ptr<string> VPort{};

  DescribeServerLoadBalancerListenMonitorRequest() {}

  explicit DescribeServerLoadBalancerListenMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (proto) {
      res["Proto"] = boost::any(*proto);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (VPort) {
      res["VPort"] = boost::any(*VPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("Proto") != m.end() && !m["Proto"].empty()) {
      proto = make_shared<string>(boost::any_cast<string>(m["Proto"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("VPort") != m.end() && !m["VPort"].empty()) {
      VPort = make_shared<string>(boost::any_cast<string>(m["VPort"]));
    }
  }


  virtual ~DescribeServerLoadBalancerListenMonitorRequest() = default;
};
class DescribeServerLoadBalancerListenMonitorResponseBodyServerLoadBalancerMonitorData : public Darabonba::Model {
public:
  shared_ptr<long> acc{};
  shared_ptr<string> bizTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> loadBalancerName{};
  shared_ptr<string> loadBalancerSpec{};
  shared_ptr<string> proto{};
  shared_ptr<long> reqs2xx{};
  shared_ptr<long> reqs3xx{};
  shared_ptr<long> reqs4xx{};
  shared_ptr<long> reqs5xx{};
  shared_ptr<long> rtAvg{};
  shared_ptr<string> vip{};
  shared_ptr<long> vni{};
  shared_ptr<long> vport{};

  DescribeServerLoadBalancerListenMonitorResponseBodyServerLoadBalancerMonitorData() {}

  explicit DescribeServerLoadBalancerListenMonitorResponseBodyServerLoadBalancerMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acc) {
      res["Acc"] = boost::any(*acc);
    }
    if (bizTime) {
      res["BizTime"] = boost::any(*bizTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (loadBalancerName) {
      res["LoadBalancerName"] = boost::any(*loadBalancerName);
    }
    if (loadBalancerSpec) {
      res["LoadBalancerSpec"] = boost::any(*loadBalancerSpec);
    }
    if (proto) {
      res["Proto"] = boost::any(*proto);
    }
    if (reqs2xx) {
      res["Reqs2xx"] = boost::any(*reqs2xx);
    }
    if (reqs3xx) {
      res["Reqs3xx"] = boost::any(*reqs3xx);
    }
    if (reqs4xx) {
      res["Reqs4xx"] = boost::any(*reqs4xx);
    }
    if (reqs5xx) {
      res["Reqs5xx"] = boost::any(*reqs5xx);
    }
    if (rtAvg) {
      res["RtAvg"] = boost::any(*rtAvg);
    }
    if (vip) {
      res["Vip"] = boost::any(*vip);
    }
    if (vni) {
      res["Vni"] = boost::any(*vni);
    }
    if (vport) {
      res["Vport"] = boost::any(*vport);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Acc") != m.end() && !m["Acc"].empty()) {
      acc = make_shared<long>(boost::any_cast<long>(m["Acc"]));
    }
    if (m.find("BizTime") != m.end() && !m["BizTime"].empty()) {
      bizTime = make_shared<string>(boost::any_cast<string>(m["BizTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("LoadBalancerName") != m.end() && !m["LoadBalancerName"].empty()) {
      loadBalancerName = make_shared<string>(boost::any_cast<string>(m["LoadBalancerName"]));
    }
    if (m.find("LoadBalancerSpec") != m.end() && !m["LoadBalancerSpec"].empty()) {
      loadBalancerSpec = make_shared<string>(boost::any_cast<string>(m["LoadBalancerSpec"]));
    }
    if (m.find("Proto") != m.end() && !m["Proto"].empty()) {
      proto = make_shared<string>(boost::any_cast<string>(m["Proto"]));
    }
    if (m.find("Reqs2xx") != m.end() && !m["Reqs2xx"].empty()) {
      reqs2xx = make_shared<long>(boost::any_cast<long>(m["Reqs2xx"]));
    }
    if (m.find("Reqs3xx") != m.end() && !m["Reqs3xx"].empty()) {
      reqs3xx = make_shared<long>(boost::any_cast<long>(m["Reqs3xx"]));
    }
    if (m.find("Reqs4xx") != m.end() && !m["Reqs4xx"].empty()) {
      reqs4xx = make_shared<long>(boost::any_cast<long>(m["Reqs4xx"]));
    }
    if (m.find("Reqs5xx") != m.end() && !m["Reqs5xx"].empty()) {
      reqs5xx = make_shared<long>(boost::any_cast<long>(m["Reqs5xx"]));
    }
    if (m.find("RtAvg") != m.end() && !m["RtAvg"].empty()) {
      rtAvg = make_shared<long>(boost::any_cast<long>(m["RtAvg"]));
    }
    if (m.find("Vip") != m.end() && !m["Vip"].empty()) {
      vip = make_shared<string>(boost::any_cast<string>(m["Vip"]));
    }
    if (m.find("Vni") != m.end() && !m["Vni"].empty()) {
      vni = make_shared<long>(boost::any_cast<long>(m["Vni"]));
    }
    if (m.find("Vport") != m.end() && !m["Vport"].empty()) {
      vport = make_shared<long>(boost::any_cast<long>(m["Vport"]));
    }
  }


  virtual ~DescribeServerLoadBalancerListenMonitorResponseBodyServerLoadBalancerMonitorData() = default;
};
class DescribeServerLoadBalancerListenMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeServerLoadBalancerListenMonitorResponseBodyServerLoadBalancerMonitorData>> serverLoadBalancerMonitorData{};

  DescribeServerLoadBalancerListenMonitorResponseBody() {}

  explicit DescribeServerLoadBalancerListenMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (serverLoadBalancerMonitorData) {
      vector<boost::any> temp1;
      for(auto item1:*serverLoadBalancerMonitorData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServerLoadBalancerMonitorData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ServerLoadBalancerMonitorData") != m.end() && !m["ServerLoadBalancerMonitorData"].empty()) {
      if (typeid(vector<boost::any>) == m["ServerLoadBalancerMonitorData"].type()) {
        vector<DescribeServerLoadBalancerListenMonitorResponseBodyServerLoadBalancerMonitorData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServerLoadBalancerMonitorData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeServerLoadBalancerListenMonitorResponseBodyServerLoadBalancerMonitorData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serverLoadBalancerMonitorData = make_shared<vector<DescribeServerLoadBalancerListenMonitorResponseBodyServerLoadBalancerMonitorData>>(expect1);
      }
    }
  }


  virtual ~DescribeServerLoadBalancerListenMonitorResponseBody() = default;
};
class DescribeServerLoadBalancerListenMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeServerLoadBalancerListenMonitorResponseBody> body{};

  DescribeServerLoadBalancerListenMonitorResponse() {}

  explicit DescribeServerLoadBalancerListenMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeServerLoadBalancerListenMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeServerLoadBalancerListenMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeServerLoadBalancerListenMonitorResponse() = default;
};
class DescribeServerLoadBalancerMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> startTime{};

  DescribeServerLoadBalancerMonitorRequest() {}

  explicit DescribeServerLoadBalancerMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeServerLoadBalancerMonitorRequest() = default;
};
class DescribeServerLoadBalancerMonitorResponseBodyServerLoadBalancerMonitorData : public Darabonba::Model {
public:
  shared_ptr<long> acc{};
  shared_ptr<string> bizTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> loadBalancerName{};
  shared_ptr<string> loadBalancerSpec{};
  shared_ptr<long> reqs2xx{};
  shared_ptr<long> reqs3xx{};
  shared_ptr<long> reqs4xx{};
  shared_ptr<long> reqs5xx{};
  shared_ptr<long> rtAvg{};
  shared_ptr<string> vip{};
  shared_ptr<long> vni{};

  DescribeServerLoadBalancerMonitorResponseBodyServerLoadBalancerMonitorData() {}

  explicit DescribeServerLoadBalancerMonitorResponseBodyServerLoadBalancerMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acc) {
      res["Acc"] = boost::any(*acc);
    }
    if (bizTime) {
      res["BizTime"] = boost::any(*bizTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (loadBalancerName) {
      res["LoadBalancerName"] = boost::any(*loadBalancerName);
    }
    if (loadBalancerSpec) {
      res["LoadBalancerSpec"] = boost::any(*loadBalancerSpec);
    }
    if (reqs2xx) {
      res["Reqs2xx"] = boost::any(*reqs2xx);
    }
    if (reqs3xx) {
      res["Reqs3xx"] = boost::any(*reqs3xx);
    }
    if (reqs4xx) {
      res["Reqs4xx"] = boost::any(*reqs4xx);
    }
    if (reqs5xx) {
      res["Reqs5xx"] = boost::any(*reqs5xx);
    }
    if (rtAvg) {
      res["RtAvg"] = boost::any(*rtAvg);
    }
    if (vip) {
      res["Vip"] = boost::any(*vip);
    }
    if (vni) {
      res["Vni"] = boost::any(*vni);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Acc") != m.end() && !m["Acc"].empty()) {
      acc = make_shared<long>(boost::any_cast<long>(m["Acc"]));
    }
    if (m.find("BizTime") != m.end() && !m["BizTime"].empty()) {
      bizTime = make_shared<string>(boost::any_cast<string>(m["BizTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("LoadBalancerName") != m.end() && !m["LoadBalancerName"].empty()) {
      loadBalancerName = make_shared<string>(boost::any_cast<string>(m["LoadBalancerName"]));
    }
    if (m.find("LoadBalancerSpec") != m.end() && !m["LoadBalancerSpec"].empty()) {
      loadBalancerSpec = make_shared<string>(boost::any_cast<string>(m["LoadBalancerSpec"]));
    }
    if (m.find("Reqs2xx") != m.end() && !m["Reqs2xx"].empty()) {
      reqs2xx = make_shared<long>(boost::any_cast<long>(m["Reqs2xx"]));
    }
    if (m.find("Reqs3xx") != m.end() && !m["Reqs3xx"].empty()) {
      reqs3xx = make_shared<long>(boost::any_cast<long>(m["Reqs3xx"]));
    }
    if (m.find("Reqs4xx") != m.end() && !m["Reqs4xx"].empty()) {
      reqs4xx = make_shared<long>(boost::any_cast<long>(m["Reqs4xx"]));
    }
    if (m.find("Reqs5xx") != m.end() && !m["Reqs5xx"].empty()) {
      reqs5xx = make_shared<long>(boost::any_cast<long>(m["Reqs5xx"]));
    }
    if (m.find("RtAvg") != m.end() && !m["RtAvg"].empty()) {
      rtAvg = make_shared<long>(boost::any_cast<long>(m["RtAvg"]));
    }
    if (m.find("Vip") != m.end() && !m["Vip"].empty()) {
      vip = make_shared<string>(boost::any_cast<string>(m["Vip"]));
    }
    if (m.find("Vni") != m.end() && !m["Vni"].empty()) {
      vni = make_shared<long>(boost::any_cast<long>(m["Vni"]));
    }
  }


  virtual ~DescribeServerLoadBalancerMonitorResponseBodyServerLoadBalancerMonitorData() = default;
};
class DescribeServerLoadBalancerMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeServerLoadBalancerMonitorResponseBodyServerLoadBalancerMonitorData>> serverLoadBalancerMonitorData{};

  DescribeServerLoadBalancerMonitorResponseBody() {}

  explicit DescribeServerLoadBalancerMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (serverLoadBalancerMonitorData) {
      vector<boost::any> temp1;
      for(auto item1:*serverLoadBalancerMonitorData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServerLoadBalancerMonitorData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ServerLoadBalancerMonitorData") != m.end() && !m["ServerLoadBalancerMonitorData"].empty()) {
      if (typeid(vector<boost::any>) == m["ServerLoadBalancerMonitorData"].type()) {
        vector<DescribeServerLoadBalancerMonitorResponseBodyServerLoadBalancerMonitorData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServerLoadBalancerMonitorData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeServerLoadBalancerMonitorResponseBodyServerLoadBalancerMonitorData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serverLoadBalancerMonitorData = make_shared<vector<DescribeServerLoadBalancerMonitorResponseBodyServerLoadBalancerMonitorData>>(expect1);
      }
    }
  }


  virtual ~DescribeServerLoadBalancerMonitorResponseBody() = default;
};
class DescribeServerLoadBalancerMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeServerLoadBalancerMonitorResponseBody> body{};

  DescribeServerLoadBalancerMonitorResponse() {}

  explicit DescribeServerLoadBalancerMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeServerLoadBalancerMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeServerLoadBalancerMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeServerLoadBalancerMonitorResponse() = default;
};
class DescribeSnapshotsRequest : public Darabonba::Model {
public:
  shared_ptr<string> diskId{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> ensRegionIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> snapshotName{};

  DescribeSnapshotsRequest() {}

  explicit DescribeSnapshotsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = boost::any(*ensRegionIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (snapshotName) {
      res["SnapshotName"] = boost::any(*snapshotName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      ensRegionIds = make_shared<string>(boost::any_cast<string>(m["EnsRegionIds"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("SnapshotName") != m.end() && !m["SnapshotName"].empty()) {
      snapshotName = make_shared<string>(boost::any_cast<string>(m["SnapshotName"]));
    }
  }


  virtual ~DescribeSnapshotsRequest() = default;
};
class DescribeSnapshotsResponseBodySnapshots : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> size{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> snapshotName{};
  shared_ptr<string> sourceDiskCategory{};
  shared_ptr<string> sourceDiskId{};
  shared_ptr<string> sourceDiskType{};
  shared_ptr<string> sourceEnsRegionId{};
  shared_ptr<string> sourceSnapshotId{};
  shared_ptr<string> status{};

  DescribeSnapshotsResponseBodySnapshots() {}

  explicit DescribeSnapshotsResponseBodySnapshots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (snapshotName) {
      res["SnapshotName"] = boost::any(*snapshotName);
    }
    if (sourceDiskCategory) {
      res["SourceDiskCategory"] = boost::any(*sourceDiskCategory);
    }
    if (sourceDiskId) {
      res["SourceDiskId"] = boost::any(*sourceDiskId);
    }
    if (sourceDiskType) {
      res["SourceDiskType"] = boost::any(*sourceDiskType);
    }
    if (sourceEnsRegionId) {
      res["SourceEnsRegionId"] = boost::any(*sourceEnsRegionId);
    }
    if (sourceSnapshotId) {
      res["SourceSnapshotId"] = boost::any(*sourceSnapshotId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("SnapshotName") != m.end() && !m["SnapshotName"].empty()) {
      snapshotName = make_shared<string>(boost::any_cast<string>(m["SnapshotName"]));
    }
    if (m.find("SourceDiskCategory") != m.end() && !m["SourceDiskCategory"].empty()) {
      sourceDiskCategory = make_shared<string>(boost::any_cast<string>(m["SourceDiskCategory"]));
    }
    if (m.find("SourceDiskId") != m.end() && !m["SourceDiskId"].empty()) {
      sourceDiskId = make_shared<string>(boost::any_cast<string>(m["SourceDiskId"]));
    }
    if (m.find("SourceDiskType") != m.end() && !m["SourceDiskType"].empty()) {
      sourceDiskType = make_shared<string>(boost::any_cast<string>(m["SourceDiskType"]));
    }
    if (m.find("SourceEnsRegionId") != m.end() && !m["SourceEnsRegionId"].empty()) {
      sourceEnsRegionId = make_shared<string>(boost::any_cast<string>(m["SourceEnsRegionId"]));
    }
    if (m.find("SourceSnapshotId") != m.end() && !m["SourceSnapshotId"].empty()) {
      sourceSnapshotId = make_shared<string>(boost::any_cast<string>(m["SourceSnapshotId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSnapshotsResponseBodySnapshots() = default;
};
class DescribeSnapshotsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSnapshotsResponseBodySnapshots>> snapshots{};
  shared_ptr<long> totalCount{};

  DescribeSnapshotsResponseBody() {}

  explicit DescribeSnapshotsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshots) {
      vector<boost::any> temp1;
      for(auto item1:*snapshots){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Snapshots"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      if (typeid(vector<boost::any>) == m["Snapshots"].type()) {
        vector<DescribeSnapshotsResponseBodySnapshots> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Snapshots"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSnapshotsResponseBodySnapshots model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshots = make_shared<vector<DescribeSnapshotsResponseBodySnapshots>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSnapshotsResponseBody() = default;
};
class DescribeSnapshotsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSnapshotsResponseBody> body{};

  DescribeSnapshotsResponse() {}

  explicit DescribeSnapshotsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSnapshotsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSnapshotsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSnapshotsResponse() = default;
};
class DescribeSnatAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> snatEntryId{};

  DescribeSnatAttributeRequest() {}

  explicit DescribeSnatAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snatEntryId) {
      res["SnatEntryId"] = boost::any(*snatEntryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnatEntryId") != m.end() && !m["SnatEntryId"].empty()) {
      snatEntryId = make_shared<string>(boost::any_cast<string>(m["SnatEntryId"]));
    }
  }


  virtual ~DescribeSnatAttributeRequest() = default;
};
class DescribeSnatAttributeResponseBodySnatIps : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> ip{};
  shared_ptr<string> status{};

  DescribeSnatAttributeResponseBodySnatIps() {}

  explicit DescribeSnatAttributeResponseBodySnatIps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSnatAttributeResponseBodySnatIps() = default;
};
class DescribeSnatAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> destCIDR{};
  shared_ptr<bool> eipAffinity{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<bool> ispAffinity{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> snatEntryId{};
  shared_ptr<string> snatEntryName{};
  shared_ptr<string> snatIp{};
  shared_ptr<vector<DescribeSnatAttributeResponseBodySnatIps>> snatIps{};
  shared_ptr<string> sourceCIDR{};
  shared_ptr<string> standbySnatIp{};
  shared_ptr<string> standbyStatus{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeSnatAttributeResponseBody() {}

  explicit DescribeSnatAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (destCIDR) {
      res["DestCIDR"] = boost::any(*destCIDR);
    }
    if (eipAffinity) {
      res["EipAffinity"] = boost::any(*eipAffinity);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (ispAffinity) {
      res["IspAffinity"] = boost::any(*ispAffinity);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snatEntryId) {
      res["SnatEntryId"] = boost::any(*snatEntryId);
    }
    if (snatEntryName) {
      res["SnatEntryName"] = boost::any(*snatEntryName);
    }
    if (snatIp) {
      res["SnatIp"] = boost::any(*snatIp);
    }
    if (snatIps) {
      vector<boost::any> temp1;
      for(auto item1:*snatIps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SnatIps"] = boost::any(temp1);
    }
    if (sourceCIDR) {
      res["SourceCIDR"] = boost::any(*sourceCIDR);
    }
    if (standbySnatIp) {
      res["StandbySnatIp"] = boost::any(*standbySnatIp);
    }
    if (standbyStatus) {
      res["StandbyStatus"] = boost::any(*standbyStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DestCIDR") != m.end() && !m["DestCIDR"].empty()) {
      destCIDR = make_shared<string>(boost::any_cast<string>(m["DestCIDR"]));
    }
    if (m.find("EipAffinity") != m.end() && !m["EipAffinity"].empty()) {
      eipAffinity = make_shared<bool>(boost::any_cast<bool>(m["EipAffinity"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("IspAffinity") != m.end() && !m["IspAffinity"].empty()) {
      ispAffinity = make_shared<bool>(boost::any_cast<bool>(m["IspAffinity"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnatEntryId") != m.end() && !m["SnatEntryId"].empty()) {
      snatEntryId = make_shared<string>(boost::any_cast<string>(m["SnatEntryId"]));
    }
    if (m.find("SnatEntryName") != m.end() && !m["SnatEntryName"].empty()) {
      snatEntryName = make_shared<string>(boost::any_cast<string>(m["SnatEntryName"]));
    }
    if (m.find("SnatIp") != m.end() && !m["SnatIp"].empty()) {
      snatIp = make_shared<string>(boost::any_cast<string>(m["SnatIp"]));
    }
    if (m.find("SnatIps") != m.end() && !m["SnatIps"].empty()) {
      if (typeid(vector<boost::any>) == m["SnatIps"].type()) {
        vector<DescribeSnatAttributeResponseBodySnatIps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SnatIps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSnatAttributeResponseBodySnatIps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snatIps = make_shared<vector<DescribeSnatAttributeResponseBodySnatIps>>(expect1);
      }
    }
    if (m.find("SourceCIDR") != m.end() && !m["SourceCIDR"].empty()) {
      sourceCIDR = make_shared<string>(boost::any_cast<string>(m["SourceCIDR"]));
    }
    if (m.find("StandbySnatIp") != m.end() && !m["StandbySnatIp"].empty()) {
      standbySnatIp = make_shared<string>(boost::any_cast<string>(m["StandbySnatIp"]));
    }
    if (m.find("StandbyStatus") != m.end() && !m["StandbyStatus"].empty()) {
      standbyStatus = make_shared<string>(boost::any_cast<string>(m["StandbyStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeSnatAttributeResponseBody() = default;
};
class DescribeSnatAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSnatAttributeResponseBody> body{};

  DescribeSnatAttributeResponse() {}

  explicit DescribeSnatAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSnatAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSnatAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSnatAttributeResponse() = default;
};
class DescribeSnatTableEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> natGatewayId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> snatEntryId{};
  shared_ptr<string> snatEntryName{};
  shared_ptr<string> snatIp{};
  shared_ptr<vector<string>> snatIps{};
  shared_ptr<string> sourceCIDR{};

  DescribeSnatTableEntriesRequest() {}

  explicit DescribeSnatTableEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (snatEntryId) {
      res["SnatEntryId"] = boost::any(*snatEntryId);
    }
    if (snatEntryName) {
      res["SnatEntryName"] = boost::any(*snatEntryName);
    }
    if (snatIp) {
      res["SnatIp"] = boost::any(*snatIp);
    }
    if (snatIps) {
      res["SnatIps"] = boost::any(*snatIps);
    }
    if (sourceCIDR) {
      res["SourceCIDR"] = boost::any(*sourceCIDR);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SnatEntryId") != m.end() && !m["SnatEntryId"].empty()) {
      snatEntryId = make_shared<string>(boost::any_cast<string>(m["SnatEntryId"]));
    }
    if (m.find("SnatEntryName") != m.end() && !m["SnatEntryName"].empty()) {
      snatEntryName = make_shared<string>(boost::any_cast<string>(m["SnatEntryName"]));
    }
    if (m.find("SnatIp") != m.end() && !m["SnatIp"].empty()) {
      snatIp = make_shared<string>(boost::any_cast<string>(m["SnatIp"]));
    }
    if (m.find("SnatIps") != m.end() && !m["SnatIps"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SnatIps"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SnatIps"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      snatIps = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SourceCIDR") != m.end() && !m["SourceCIDR"].empty()) {
      sourceCIDR = make_shared<string>(boost::any_cast<string>(m["SourceCIDR"]));
    }
  }


  virtual ~DescribeSnatTableEntriesRequest() = default;
};
class DescribeSnatTableEntriesResponseBodySnatTableEntries : public Darabonba::Model {
public:
  shared_ptr<bool> eipAffinity{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<bool> ispAffinity{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> snatEntryId{};
  shared_ptr<string> snatEntryName{};
  shared_ptr<string> snatIp{};
  shared_ptr<string> sourceCIDR{};
  shared_ptr<string> standbySnatIp{};
  shared_ptr<string> standbyStatus{};
  shared_ptr<string> status{};

  DescribeSnatTableEntriesResponseBodySnatTableEntries() {}

  explicit DescribeSnatTableEntriesResponseBodySnatTableEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipAffinity) {
      res["EipAffinity"] = boost::any(*eipAffinity);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (ispAffinity) {
      res["IspAffinity"] = boost::any(*ispAffinity);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (snatEntryId) {
      res["SnatEntryId"] = boost::any(*snatEntryId);
    }
    if (snatEntryName) {
      res["SnatEntryName"] = boost::any(*snatEntryName);
    }
    if (snatIp) {
      res["SnatIp"] = boost::any(*snatIp);
    }
    if (sourceCIDR) {
      res["SourceCIDR"] = boost::any(*sourceCIDR);
    }
    if (standbySnatIp) {
      res["StandbySnatIp"] = boost::any(*standbySnatIp);
    }
    if (standbyStatus) {
      res["StandbyStatus"] = boost::any(*standbyStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipAffinity") != m.end() && !m["EipAffinity"].empty()) {
      eipAffinity = make_shared<bool>(boost::any_cast<bool>(m["EipAffinity"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("IspAffinity") != m.end() && !m["IspAffinity"].empty()) {
      ispAffinity = make_shared<bool>(boost::any_cast<bool>(m["IspAffinity"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("SnatEntryId") != m.end() && !m["SnatEntryId"].empty()) {
      snatEntryId = make_shared<string>(boost::any_cast<string>(m["SnatEntryId"]));
    }
    if (m.find("SnatEntryName") != m.end() && !m["SnatEntryName"].empty()) {
      snatEntryName = make_shared<string>(boost::any_cast<string>(m["SnatEntryName"]));
    }
    if (m.find("SnatIp") != m.end() && !m["SnatIp"].empty()) {
      snatIp = make_shared<string>(boost::any_cast<string>(m["SnatIp"]));
    }
    if (m.find("SourceCIDR") != m.end() && !m["SourceCIDR"].empty()) {
      sourceCIDR = make_shared<string>(boost::any_cast<string>(m["SourceCIDR"]));
    }
    if (m.find("StandbySnatIp") != m.end() && !m["StandbySnatIp"].empty()) {
      standbySnatIp = make_shared<string>(boost::any_cast<string>(m["StandbySnatIp"]));
    }
    if (m.find("StandbyStatus") != m.end() && !m["StandbyStatus"].empty()) {
      standbyStatus = make_shared<string>(boost::any_cast<string>(m["StandbyStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSnatTableEntriesResponseBodySnatTableEntries() = default;
};
class DescribeSnatTableEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSnatTableEntriesResponseBodySnatTableEntries>> snatTableEntries{};
  shared_ptr<long> totalCount{};

  DescribeSnatTableEntriesResponseBody() {}

  explicit DescribeSnatTableEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snatTableEntries) {
      vector<boost::any> temp1;
      for(auto item1:*snatTableEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SnatTableEntries"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnatTableEntries") != m.end() && !m["SnatTableEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["SnatTableEntries"].type()) {
        vector<DescribeSnatTableEntriesResponseBodySnatTableEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SnatTableEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSnatTableEntriesResponseBodySnatTableEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snatTableEntries = make_shared<vector<DescribeSnatTableEntriesResponseBodySnatTableEntries>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSnatTableEntriesResponseBody() = default;
};
class DescribeSnatTableEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSnatTableEntriesResponseBody> body{};

  DescribeSnatTableEntriesResponse() {}

  explicit DescribeSnatTableEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSnatTableEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSnatTableEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSnatTableEntriesResponse() = default;
};
class DescribeStorageGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> gatewayId{};
  shared_ptr<string> gatewayType{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> vpcId{};

  DescribeStorageGatewayRequest() {}

  explicit DescribeStorageGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayType) {
      res["GatewayType"] = boost::any(*gatewayType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<string>(boost::any_cast<string>(m["GatewayId"]));
    }
    if (m.find("GatewayType") != m.end() && !m["GatewayType"].empty()) {
      gatewayType = make_shared<string>(boost::any_cast<string>(m["GatewayType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeStorageGatewayRequest() = default;
};
class DescribeStorageGatewayResponseBodyStorageGateways : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> serviceIp{};
  shared_ptr<string> status{};
  shared_ptr<string> storageGatewayId{};
  shared_ptr<string> storageGatewayName{};
  shared_ptr<long> storageGatewayType{};
  shared_ptr<string> vpcId{};

  DescribeStorageGatewayResponseBodyStorageGateways() {}

  explicit DescribeStorageGatewayResponseBodyStorageGateways(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (serviceIp) {
      res["ServiceIp"] = boost::any(*serviceIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageGatewayId) {
      res["StorageGatewayId"] = boost::any(*storageGatewayId);
    }
    if (storageGatewayName) {
      res["StorageGatewayName"] = boost::any(*storageGatewayName);
    }
    if (storageGatewayType) {
      res["StorageGatewayType"] = boost::any(*storageGatewayType);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("ServiceIp") != m.end() && !m["ServiceIp"].empty()) {
      serviceIp = make_shared<string>(boost::any_cast<string>(m["ServiceIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageGatewayId") != m.end() && !m["StorageGatewayId"].empty()) {
      storageGatewayId = make_shared<string>(boost::any_cast<string>(m["StorageGatewayId"]));
    }
    if (m.find("StorageGatewayName") != m.end() && !m["StorageGatewayName"].empty()) {
      storageGatewayName = make_shared<string>(boost::any_cast<string>(m["StorageGatewayName"]));
    }
    if (m.find("StorageGatewayType") != m.end() && !m["StorageGatewayType"].empty()) {
      storageGatewayType = make_shared<long>(boost::any_cast<long>(m["StorageGatewayType"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeStorageGatewayResponseBodyStorageGateways() = default;
};
class DescribeStorageGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeStorageGatewayResponseBodyStorageGateways>> storageGateways{};
  shared_ptr<long> totalCount{};

  DescribeStorageGatewayResponseBody() {}

  explicit DescribeStorageGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (storageGateways) {
      vector<boost::any> temp1;
      for(auto item1:*storageGateways){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StorageGateways"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StorageGateways") != m.end() && !m["StorageGateways"].empty()) {
      if (typeid(vector<boost::any>) == m["StorageGateways"].type()) {
        vector<DescribeStorageGatewayResponseBodyStorageGateways> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StorageGateways"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStorageGatewayResponseBodyStorageGateways model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        storageGateways = make_shared<vector<DescribeStorageGatewayResponseBodyStorageGateways>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeStorageGatewayResponseBody() = default;
};
class DescribeStorageGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeStorageGatewayResponseBody> body{};

  DescribeStorageGatewayResponse() {}

  explicit DescribeStorageGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStorageGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStorageGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStorageGatewayResponse() = default;
};
class DescribeStorageVolumeRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> gatewayId{};
  shared_ptr<long> isEnable{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> storageId{};
  shared_ptr<string> volumeId{};

  DescribeStorageVolumeRequest() {}

  explicit DescribeStorageVolumeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (isEnable) {
      res["IsEnable"] = boost::any(*isEnable);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (storageId) {
      res["StorageId"] = boost::any(*storageId);
    }
    if (volumeId) {
      res["VolumeId"] = boost::any(*volumeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<string>(boost::any_cast<string>(m["GatewayId"]));
    }
    if (m.find("IsEnable") != m.end() && !m["IsEnable"].empty()) {
      isEnable = make_shared<long>(boost::any_cast<long>(m["IsEnable"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StorageId") != m.end() && !m["StorageId"].empty()) {
      storageId = make_shared<string>(boost::any_cast<string>(m["StorageId"]));
    }
    if (m.find("VolumeId") != m.end() && !m["VolumeId"].empty()) {
      volumeId = make_shared<string>(boost::any_cast<string>(m["VolumeId"]));
    }
  }


  virtual ~DescribeStorageVolumeRequest() = default;
};
class DescribeStorageVolumeResponseBodyStorageVolumes : public Darabonba::Model {
public:
  shared_ptr<string> authProtocol{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<long> isAuth{};
  shared_ptr<long> isEnable{};
  shared_ptr<string> status{};
  shared_ptr<string> storageGatewayId{};
  shared_ptr<string> storageId{};
  shared_ptr<string> storageVolumeId{};
  shared_ptr<string> storageVolumeName{};
  shared_ptr<string> targetName{};

  DescribeStorageVolumeResponseBodyStorageVolumes() {}

  explicit DescribeStorageVolumeResponseBodyStorageVolumes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authProtocol) {
      res["AuthProtocol"] = boost::any(*authProtocol);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (isAuth) {
      res["IsAuth"] = boost::any(*isAuth);
    }
    if (isEnable) {
      res["IsEnable"] = boost::any(*isEnable);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageGatewayId) {
      res["StorageGatewayId"] = boost::any(*storageGatewayId);
    }
    if (storageId) {
      res["StorageId"] = boost::any(*storageId);
    }
    if (storageVolumeId) {
      res["StorageVolumeId"] = boost::any(*storageVolumeId);
    }
    if (storageVolumeName) {
      res["StorageVolumeName"] = boost::any(*storageVolumeName);
    }
    if (targetName) {
      res["TargetName"] = boost::any(*targetName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthProtocol") != m.end() && !m["AuthProtocol"].empty()) {
      authProtocol = make_shared<string>(boost::any_cast<string>(m["AuthProtocol"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("IsAuth") != m.end() && !m["IsAuth"].empty()) {
      isAuth = make_shared<long>(boost::any_cast<long>(m["IsAuth"]));
    }
    if (m.find("IsEnable") != m.end() && !m["IsEnable"].empty()) {
      isEnable = make_shared<long>(boost::any_cast<long>(m["IsEnable"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageGatewayId") != m.end() && !m["StorageGatewayId"].empty()) {
      storageGatewayId = make_shared<string>(boost::any_cast<string>(m["StorageGatewayId"]));
    }
    if (m.find("StorageId") != m.end() && !m["StorageId"].empty()) {
      storageId = make_shared<string>(boost::any_cast<string>(m["StorageId"]));
    }
    if (m.find("StorageVolumeId") != m.end() && !m["StorageVolumeId"].empty()) {
      storageVolumeId = make_shared<string>(boost::any_cast<string>(m["StorageVolumeId"]));
    }
    if (m.find("StorageVolumeName") != m.end() && !m["StorageVolumeName"].empty()) {
      storageVolumeName = make_shared<string>(boost::any_cast<string>(m["StorageVolumeName"]));
    }
    if (m.find("TargetName") != m.end() && !m["TargetName"].empty()) {
      targetName = make_shared<string>(boost::any_cast<string>(m["TargetName"]));
    }
  }


  virtual ~DescribeStorageVolumeResponseBodyStorageVolumes() = default;
};
class DescribeStorageVolumeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeStorageVolumeResponseBodyStorageVolumes>> storageVolumes{};
  shared_ptr<string> totalCount{};

  DescribeStorageVolumeResponseBody() {}

  explicit DescribeStorageVolumeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (storageVolumes) {
      vector<boost::any> temp1;
      for(auto item1:*storageVolumes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StorageVolumes"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StorageVolumes") != m.end() && !m["StorageVolumes"].empty()) {
      if (typeid(vector<boost::any>) == m["StorageVolumes"].type()) {
        vector<DescribeStorageVolumeResponseBodyStorageVolumes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StorageVolumes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStorageVolumeResponseBodyStorageVolumes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        storageVolumes = make_shared<vector<DescribeStorageVolumeResponseBodyStorageVolumes>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~DescribeStorageVolumeResponseBody() = default;
};
class DescribeStorageVolumeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeStorageVolumeResponseBody> body{};

  DescribeStorageVolumeResponse() {}

  explicit DescribeStorageVolumeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStorageVolumeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStorageVolumeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStorageVolumeResponse() = default;
};
class DescribeUserBandWidthDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> isp{};
  shared_ptr<string> period{};
  shared_ptr<string> startTime{};

  DescribeUserBandWidthDataRequest() {}

  explicit DescribeUserBandWidthDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeUserBandWidthDataRequest() = default;
};
class DescribeUserBandWidthDataResponseBodyMonitorDataBandWidthMonitorData : public Darabonba::Model {
public:
  shared_ptr<long> downBandWidth{};
  shared_ptr<long> internetRX{};
  shared_ptr<long> internetTX{};
  shared_ptr<string> timeStamp{};
  shared_ptr<long> upBandWidth{};

  DescribeUserBandWidthDataResponseBodyMonitorDataBandWidthMonitorData() {}

  explicit DescribeUserBandWidthDataResponseBodyMonitorDataBandWidthMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downBandWidth) {
      res["DownBandWidth"] = boost::any(*downBandWidth);
    }
    if (internetRX) {
      res["InternetRX"] = boost::any(*internetRX);
    }
    if (internetTX) {
      res["InternetTX"] = boost::any(*internetTX);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (upBandWidth) {
      res["UpBandWidth"] = boost::any(*upBandWidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownBandWidth") != m.end() && !m["DownBandWidth"].empty()) {
      downBandWidth = make_shared<long>(boost::any_cast<long>(m["DownBandWidth"]));
    }
    if (m.find("InternetRX") != m.end() && !m["InternetRX"].empty()) {
      internetRX = make_shared<long>(boost::any_cast<long>(m["InternetRX"]));
    }
    if (m.find("InternetTX") != m.end() && !m["InternetTX"].empty()) {
      internetTX = make_shared<long>(boost::any_cast<long>(m["InternetTX"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("UpBandWidth") != m.end() && !m["UpBandWidth"].empty()) {
      upBandWidth = make_shared<long>(boost::any_cast<long>(m["UpBandWidth"]));
    }
  }


  virtual ~DescribeUserBandWidthDataResponseBodyMonitorDataBandWidthMonitorData() = default;
};
class DescribeUserBandWidthDataResponseBodyMonitorData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUserBandWidthDataResponseBodyMonitorDataBandWidthMonitorData>> bandWidthMonitorData{};
  shared_ptr<string> maxDownBandWidth{};
  shared_ptr<string> maxUpBandWidth{};

  DescribeUserBandWidthDataResponseBodyMonitorData() {}

  explicit DescribeUserBandWidthDataResponseBodyMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidthMonitorData) {
      vector<boost::any> temp1;
      for(auto item1:*bandWidthMonitorData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BandWidthMonitorData"] = boost::any(temp1);
    }
    if (maxDownBandWidth) {
      res["MaxDownBandWidth"] = boost::any(*maxDownBandWidth);
    }
    if (maxUpBandWidth) {
      res["MaxUpBandWidth"] = boost::any(*maxUpBandWidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidthMonitorData") != m.end() && !m["BandWidthMonitorData"].empty()) {
      if (typeid(vector<boost::any>) == m["BandWidthMonitorData"].type()) {
        vector<DescribeUserBandWidthDataResponseBodyMonitorDataBandWidthMonitorData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BandWidthMonitorData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserBandWidthDataResponseBodyMonitorDataBandWidthMonitorData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bandWidthMonitorData = make_shared<vector<DescribeUserBandWidthDataResponseBodyMonitorDataBandWidthMonitorData>>(expect1);
      }
    }
    if (m.find("MaxDownBandWidth") != m.end() && !m["MaxDownBandWidth"].empty()) {
      maxDownBandWidth = make_shared<string>(boost::any_cast<string>(m["MaxDownBandWidth"]));
    }
    if (m.find("MaxUpBandWidth") != m.end() && !m["MaxUpBandWidth"].empty()) {
      maxUpBandWidth = make_shared<string>(boost::any_cast<string>(m["MaxUpBandWidth"]));
    }
  }


  virtual ~DescribeUserBandWidthDataResponseBodyMonitorData() = default;
};
class DescribeUserBandWidthDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeUserBandWidthDataResponseBodyMonitorData> monitorData{};
  shared_ptr<string> requestId{};

  DescribeUserBandWidthDataResponseBody() {}

  explicit DescribeUserBandWidthDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (monitorData) {
      res["MonitorData"] = monitorData ? boost::any(monitorData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("MonitorData") != m.end() && !m["MonitorData"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonitorData"].type()) {
        DescribeUserBandWidthDataResponseBodyMonitorData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonitorData"]));
        monitorData = make_shared<DescribeUserBandWidthDataResponseBodyMonitorData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserBandWidthDataResponseBody() = default;
};
class DescribeUserBandWidthDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserBandWidthDataResponseBody> body{};

  DescribeUserBandWidthDataResponse() {}

  explicit DescribeUserBandWidthDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserBandWidthDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserBandWidthDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserBandWidthDataResponse() = default;
};
class DescribeVSwitchAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<string> vSwitchId{};

  DescribeVSwitchAttributesRequest() {}

  explicit DescribeVSwitchAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeVSwitchAttributesRequest() = default;
};
class DescribeVSwitchAttributesResponseBodyHaVipIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> haVipId{};

  DescribeVSwitchAttributesResponseBodyHaVipIds() {}

  explicit DescribeVSwitchAttributesResponseBodyHaVipIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (haVipId) {
      res["HaVipId"] = boost::any(*haVipId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HaVipId") != m.end() && !m["HaVipId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HaVipId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HaVipId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      haVipId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVSwitchAttributesResponseBodyHaVipIds() = default;
};
class DescribeVSwitchAttributesResponseBodyInstanceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceId{};

  DescribeVSwitchAttributesResponseBodyInstanceIds() {}

  explicit DescribeVSwitchAttributesResponseBodyInstanceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVSwitchAttributesResponseBodyInstanceIds() = default;
};
class DescribeVSwitchAttributesResponseBodyLoadBalancerIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> loadBalancerId{};

  DescribeVSwitchAttributesResponseBodyLoadBalancerIds() {}

  explicit DescribeVSwitchAttributesResponseBodyLoadBalancerIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LoadBalancerId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LoadBalancerId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      loadBalancerId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVSwitchAttributesResponseBodyLoadBalancerIds() = default;
};
class DescribeVSwitchAttributesResponseBodyNatGatewayIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> natGatewayId{};

  DescribeVSwitchAttributesResponseBodyNatGatewayIds() {}

  explicit DescribeVSwitchAttributesResponseBodyNatGatewayIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NatGatewayId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NatGatewayId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      natGatewayId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVSwitchAttributesResponseBodyNatGatewayIds() = default;
};
class DescribeVSwitchAttributesResponseBodyNetworkInterfaceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> networkInterfaceId{};

  DescribeVSwitchAttributesResponseBodyNetworkInterfaceIds() {}

  explicit DescribeVSwitchAttributesResponseBodyNetworkInterfaceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NetworkInterfaceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NetworkInterfaceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      networkInterfaceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVSwitchAttributesResponseBodyNetworkInterfaceIds() = default;
};
class DescribeVSwitchAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> availableIpAddressCount{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<DescribeVSwitchAttributesResponseBodyHaVipIds> haVipIds{};
  shared_ptr<DescribeVSwitchAttributesResponseBodyInstanceIds> instanceIds{};
  shared_ptr<DescribeVSwitchAttributesResponseBodyLoadBalancerIds> loadBalancerIds{};
  shared_ptr<DescribeVSwitchAttributesResponseBodyNatGatewayIds> natGatewayIds{};
  shared_ptr<string> networkId{};
  shared_ptr<DescribeVSwitchAttributesResponseBodyNetworkInterfaceIds> networkInterfaceIds{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vSwitchName{};

  DescribeVSwitchAttributesResponseBody() {}

  explicit DescribeVSwitchAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableIpAddressCount) {
      res["AvailableIpAddressCount"] = boost::any(*availableIpAddressCount);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (haVipIds) {
      res["HaVipIds"] = haVipIds ? boost::any(haVipIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceIds) {
      res["InstanceIds"] = instanceIds ? boost::any(instanceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (loadBalancerIds) {
      res["LoadBalancerIds"] = loadBalancerIds ? boost::any(loadBalancerIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (natGatewayIds) {
      res["NatGatewayIds"] = natGatewayIds ? boost::any(natGatewayIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (networkInterfaceIds) {
      res["NetworkInterfaceIds"] = networkInterfaceIds ? boost::any(networkInterfaceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableIpAddressCount") != m.end() && !m["AvailableIpAddressCount"].empty()) {
      availableIpAddressCount = make_shared<long>(boost::any_cast<long>(m["AvailableIpAddressCount"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("HaVipIds") != m.end() && !m["HaVipIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["HaVipIds"].type()) {
        DescribeVSwitchAttributesResponseBodyHaVipIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HaVipIds"]));
        haVipIds = make_shared<DescribeVSwitchAttributesResponseBodyHaVipIds>(model1);
      }
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceIds"].type()) {
        DescribeVSwitchAttributesResponseBodyInstanceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceIds"]));
        instanceIds = make_shared<DescribeVSwitchAttributesResponseBodyInstanceIds>(model1);
      }
    }
    if (m.find("LoadBalancerIds") != m.end() && !m["LoadBalancerIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["LoadBalancerIds"].type()) {
        DescribeVSwitchAttributesResponseBodyLoadBalancerIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LoadBalancerIds"]));
        loadBalancerIds = make_shared<DescribeVSwitchAttributesResponseBodyLoadBalancerIds>(model1);
      }
    }
    if (m.find("NatGatewayIds") != m.end() && !m["NatGatewayIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NatGatewayIds"].type()) {
        DescribeVSwitchAttributesResponseBodyNatGatewayIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NatGatewayIds"]));
        natGatewayIds = make_shared<DescribeVSwitchAttributesResponseBodyNatGatewayIds>(model1);
      }
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("NetworkInterfaceIds") != m.end() && !m["NetworkInterfaceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkInterfaceIds"].type()) {
        DescribeVSwitchAttributesResponseBodyNetworkInterfaceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkInterfaceIds"]));
        networkInterfaceIds = make_shared<DescribeVSwitchAttributesResponseBodyNetworkInterfaceIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
  }


  virtual ~DescribeVSwitchAttributesResponseBody() = default;
};
class DescribeVSwitchAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVSwitchAttributesResponseBody> body{};

  DescribeVSwitchAttributesResponse() {}

  explicit DescribeVSwitchAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVSwitchAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVSwitchAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVSwitchAttributesResponse() = default;
};
class DescribeVSwitchesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<vector<string>> ensRegionIds{};
  shared_ptr<string> networkId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<vector<string>> vSwitchIds{};
  shared_ptr<string> vSwitchName{};

  DescribeVSwitchesRequest() {}

  explicit DescribeVSwitchesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = boost::any(*ensRegionIds);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnsRegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnsRegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ensRegionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
  }


  virtual ~DescribeVSwitchesRequest() = default;
};
class DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};
  shared_ptr<string> value{};

  DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag() {}

  explicit DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag() = default;
};
class DescribeVSwitchesResponseBodyVSwitchesVSwitchTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag>> tag{};

  DescribeVSwitchesResponseBodyVSwitchesVSwitchTags() {}

  explicit DescribeVSwitchesResponseBodyVSwitchesVSwitchTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeVSwitchesResponseBodyVSwitchesVSwitchTags() = default;
};
class DescribeVSwitchesResponseBodyVSwitchesVSwitch : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<long> freeIpCount{};
  shared_ptr<string> networkId{};
  shared_ptr<string> status{};
  shared_ptr<DescribeVSwitchesResponseBodyVSwitchesVSwitchTags> tags{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vSwitchName{};

  DescribeVSwitchesResponseBodyVSwitchesVSwitch() {}

  explicit DescribeVSwitchesResponseBodyVSwitchesVSwitch(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (freeIpCount) {
      res["FreeIpCount"] = boost::any(*freeIpCount);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("FreeIpCount") != m.end() && !m["FreeIpCount"].empty()) {
      freeIpCount = make_shared<long>(boost::any_cast<long>(m["FreeIpCount"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeVSwitchesResponseBodyVSwitchesVSwitchTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeVSwitchesResponseBodyVSwitchesVSwitchTags>(model1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
  }


  virtual ~DescribeVSwitchesResponseBodyVSwitchesVSwitch() = default;
};
class DescribeVSwitchesResponseBodyVSwitches : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVSwitchesResponseBodyVSwitchesVSwitch>> vSwitch{};

  DescribeVSwitchesResponseBodyVSwitches() {}

  explicit DescribeVSwitchesResponseBodyVSwitches(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitch) {
      vector<boost::any> temp1;
      for(auto item1:*vSwitch){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VSwitch"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitch") != m.end() && !m["VSwitch"].empty()) {
      if (typeid(vector<boost::any>) == m["VSwitch"].type()) {
        vector<DescribeVSwitchesResponseBodyVSwitchesVSwitch> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VSwitch"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVSwitchesResponseBodyVSwitchesVSwitch model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vSwitch = make_shared<vector<DescribeVSwitchesResponseBodyVSwitchesVSwitch>>(expect1);
      }
    }
  }


  virtual ~DescribeVSwitchesResponseBodyVSwitches() = default;
};
class DescribeVSwitchesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeVSwitchesResponseBodyVSwitches> vSwitches{};

  DescribeVSwitchesResponseBody() {}

  explicit DescribeVSwitchesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vSwitches) {
      res["VSwitches"] = vSwitches ? boost::any(vSwitches->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VSwitches") != m.end() && !m["VSwitches"].empty()) {
      if (typeid(map<string, boost::any>) == m["VSwitches"].type()) {
        DescribeVSwitchesResponseBodyVSwitches model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VSwitches"]));
        vSwitches = make_shared<DescribeVSwitchesResponseBodyVSwitches>(model1);
      }
    }
  }


  virtual ~DescribeVSwitchesResponseBody() = default;
};
class DescribeVSwitchesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVSwitchesResponseBody> body{};

  DescribeVSwitchesResponse() {}

  explicit DescribeVSwitchesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVSwitchesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVSwitchesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVSwitchesResponse() = default;
};
class DetachDiskRequest : public Darabonba::Model {
public:
  shared_ptr<string> diskId{};
  shared_ptr<string> instanceId{};

  DetachDiskRequest() {}

  explicit DetachDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DetachDiskRequest() = default;
};
class DetachDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  DetachDiskResponseBody() {}

  explicit DetachDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachDiskResponseBody() = default;
};
class DetachDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachDiskResponseBody> body{};

  DetachDiskResponse() {}

  explicit DetachDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachDiskResponseBody>(model1);
      }
    }
  }


  virtual ~DetachDiskResponse() = default;
};
class DetachInstanceSDGRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> SDGId{};

  DetachInstanceSDGRequest() {}

  explicit DetachInstanceSDGRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~DetachInstanceSDGRequest() = default;
};
class DetachInstanceSDGShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIdsShrink{};
  shared_ptr<string> SDGId{};

  DetachInstanceSDGShrinkRequest() {}

  explicit DetachInstanceSDGShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIdsShrink) {
      res["InstanceIds"] = boost::any(*instanceIdsShrink);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~DetachInstanceSDGShrinkRequest() = default;
};
class DetachInstanceSDGResponseBodyDataResultFailedItems : public Darabonba::Model {
public:
  shared_ptr<string> errMessage{};
  shared_ptr<string> instanceId{};

  DetachInstanceSDGResponseBodyDataResultFailedItems() {}

  explicit DetachInstanceSDGResponseBodyDataResultFailedItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DetachInstanceSDGResponseBodyDataResultFailedItems() = default;
};
class DetachInstanceSDGResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<long> failedCount{};
  shared_ptr<vector<DetachInstanceSDGResponseBodyDataResultFailedItems>> failedItems{};
  shared_ptr<string> successCount{};

  DetachInstanceSDGResponseBodyDataResult() {}

  explicit DetachInstanceSDGResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedCount) {
      res["FailedCount"] = boost::any(*failedCount);
    }
    if (failedItems) {
      vector<boost::any> temp1;
      for(auto item1:*failedItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedItems"] = boost::any(temp1);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedCount") != m.end() && !m["FailedCount"].empty()) {
      failedCount = make_shared<long>(boost::any_cast<long>(m["FailedCount"]));
    }
    if (m.find("FailedItems") != m.end() && !m["FailedItems"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedItems"].type()) {
        vector<DetachInstanceSDGResponseBodyDataResultFailedItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachInstanceSDGResponseBodyDataResultFailedItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedItems = make_shared<vector<DetachInstanceSDGResponseBodyDataResultFailedItems>>(expect1);
      }
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<string>(boost::any_cast<string>(m["SuccessCount"]));
    }
  }


  virtual ~DetachInstanceSDGResponseBodyDataResult() = default;
};
class DetachInstanceSDGResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<DetachInstanceSDGResponseBodyDataResult> result{};
  shared_ptr<bool> success{};

  DetachInstanceSDGResponseBodyData() {}

  explicit DetachInstanceSDGResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DetachInstanceSDGResponseBodyDataResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DetachInstanceSDGResponseBodyDataResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DetachInstanceSDGResponseBodyData() = default;
};
class DetachInstanceSDGResponseBody : public Darabonba::Model {
public:
  shared_ptr<DetachInstanceSDGResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DetachInstanceSDGResponseBody() {}

  explicit DetachInstanceSDGResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DetachInstanceSDGResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DetachInstanceSDGResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachInstanceSDGResponseBody() = default;
};
class DetachInstanceSDGResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachInstanceSDGResponseBody> body{};

  DetachInstanceSDGResponse() {}

  explicit DetachInstanceSDGResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachInstanceSDGResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachInstanceSDGResponseBody>(model1);
      }
    }
  }


  virtual ~DetachInstanceSDGResponse() = default;
};
class DetachNetworkInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkInterfaceId{};

  DetachNetworkInterfaceRequest() {}

  explicit DetachNetworkInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
  }


  virtual ~DetachNetworkInterfaceRequest() = default;
};
class DetachNetworkInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DetachNetworkInterfaceResponseBody() {}

  explicit DetachNetworkInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachNetworkInterfaceResponseBody() = default;
};
class DetachNetworkInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachNetworkInterfaceResponseBody> body{};

  DetachNetworkInterfaceResponse() {}

  explicit DetachNetworkInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachNetworkInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachNetworkInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~DetachNetworkInterfaceResponse() = default;
};
class DistApplicationDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> data{};
  shared_ptr<string> distStrategy{};

  DistApplicationDataRequest() {}

  explicit DistApplicationDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (distStrategy) {
      res["DistStrategy"] = boost::any(*distStrategy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("DistStrategy") != m.end() && !m["DistStrategy"].empty()) {
      distStrategy = make_shared<string>(boost::any_cast<string>(m["DistStrategy"]));
    }
  }


  virtual ~DistApplicationDataRequest() = default;
};
class DistApplicationDataResponseBodyDistInstanceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distInstanceId{};

  DistApplicationDataResponseBodyDistInstanceIds() {}

  explicit DistApplicationDataResponseBodyDistInstanceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distInstanceId) {
      res["DistInstanceId"] = boost::any(*distInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistInstanceId") != m.end() && !m["DistInstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistInstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistInstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distInstanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DistApplicationDataResponseBodyDistInstanceIds() = default;
};
class DistApplicationDataResponseBodyDistResultsDistResult : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> resultCode{};
  shared_ptr<string> resultDescrip{};
  shared_ptr<string> version{};

  DistApplicationDataResponseBodyDistResultsDistResult() {}

  explicit DistApplicationDataResponseBodyDistResultsDistResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultDescrip) {
      res["ResultDescrip"] = boost::any(*resultDescrip);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<long>(boost::any_cast<long>(m["ResultCode"]));
    }
    if (m.find("ResultDescrip") != m.end() && !m["ResultDescrip"].empty()) {
      resultDescrip = make_shared<string>(boost::any_cast<string>(m["ResultDescrip"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DistApplicationDataResponseBodyDistResultsDistResult() = default;
};
class DistApplicationDataResponseBodyDistResults : public Darabonba::Model {
public:
  shared_ptr<vector<DistApplicationDataResponseBodyDistResultsDistResult>> distResult{};

  DistApplicationDataResponseBodyDistResults() {}

  explicit DistApplicationDataResponseBodyDistResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distResult) {
      vector<boost::any> temp1;
      for(auto item1:*distResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DistResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistResult") != m.end() && !m["DistResult"].empty()) {
      if (typeid(vector<boost::any>) == m["DistResult"].type()) {
        vector<DistApplicationDataResponseBodyDistResultsDistResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DistResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DistApplicationDataResponseBodyDistResultsDistResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        distResult = make_shared<vector<DistApplicationDataResponseBodyDistResultsDistResult>>(expect1);
      }
    }
  }


  virtual ~DistApplicationDataResponseBodyDistResults() = default;
};
class DistApplicationDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DistApplicationDataResponseBodyDistInstanceIds> distInstanceIds{};
  shared_ptr<long> distInstanceTotalCount{};
  shared_ptr<DistApplicationDataResponseBodyDistResults> distResults{};
  shared_ptr<string> requestId{};

  DistApplicationDataResponseBody() {}

  explicit DistApplicationDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distInstanceIds) {
      res["DistInstanceIds"] = distInstanceIds ? boost::any(distInstanceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (distInstanceTotalCount) {
      res["DistInstanceTotalCount"] = boost::any(*distInstanceTotalCount);
    }
    if (distResults) {
      res["DistResults"] = distResults ? boost::any(distResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistInstanceIds") != m.end() && !m["DistInstanceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DistInstanceIds"].type()) {
        DistApplicationDataResponseBodyDistInstanceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DistInstanceIds"]));
        distInstanceIds = make_shared<DistApplicationDataResponseBodyDistInstanceIds>(model1);
      }
    }
    if (m.find("DistInstanceTotalCount") != m.end() && !m["DistInstanceTotalCount"].empty()) {
      distInstanceTotalCount = make_shared<long>(boost::any_cast<long>(m["DistInstanceTotalCount"]));
    }
    if (m.find("DistResults") != m.end() && !m["DistResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["DistResults"].type()) {
        DistApplicationDataResponseBodyDistResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DistResults"]));
        distResults = make_shared<DistApplicationDataResponseBodyDistResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DistApplicationDataResponseBody() = default;
};
class DistApplicationDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DistApplicationDataResponseBody> body{};

  DistApplicationDataResponse() {}

  explicit DistApplicationDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DistApplicationDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DistApplicationDataResponseBody>(model1);
      }
    }
  }


  virtual ~DistApplicationDataResponse() = default;
};
class ExportBillDetailDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<string> startDate{};

  ExportBillDetailDataRequest() {}

  explicit ExportBillDetailDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
  }


  virtual ~ExportBillDetailDataRequest() = default;
};
class ExportBillDetailDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> filePath{};
  shared_ptr<string> requestId{};

  ExportBillDetailDataResponseBody() {}

  explicit ExportBillDetailDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExportBillDetailDataResponseBody() = default;
};
class ExportBillDetailDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportBillDetailDataResponseBody> body{};

  ExportBillDetailDataResponse() {}

  explicit ExportBillDetailDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportBillDetailDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportBillDetailDataResponseBody>(model1);
      }
    }
  }


  virtual ~ExportBillDetailDataResponse() = default;
};
class ExportImageRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> OSSBucket{};
  shared_ptr<string> OSSPrefix{};
  shared_ptr<string> OSSRegionId{};
  shared_ptr<string> roleName{};

  ExportImageRequest() {}

  explicit ExportImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (OSSBucket) {
      res["OSSBucket"] = boost::any(*OSSBucket);
    }
    if (OSSPrefix) {
      res["OSSPrefix"] = boost::any(*OSSPrefix);
    }
    if (OSSRegionId) {
      res["OSSRegionId"] = boost::any(*OSSRegionId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("OSSBucket") != m.end() && !m["OSSBucket"].empty()) {
      OSSBucket = make_shared<string>(boost::any_cast<string>(m["OSSBucket"]));
    }
    if (m.find("OSSPrefix") != m.end() && !m["OSSPrefix"].empty()) {
      OSSPrefix = make_shared<string>(boost::any_cast<string>(m["OSSPrefix"]));
    }
    if (m.find("OSSRegionId") != m.end() && !m["OSSRegionId"].empty()) {
      OSSRegionId = make_shared<string>(boost::any_cast<string>(m["OSSRegionId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
  }


  virtual ~ExportImageRequest() = default;
};
class ExportImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> exportedImageURL{};
  shared_ptr<string> requestId{};

  ExportImageResponseBody() {}

  explicit ExportImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exportedImageURL) {
      res["ExportedImageURL"] = boost::any(*exportedImageURL);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExportedImageURL") != m.end() && !m["ExportedImageURL"].empty()) {
      exportedImageURL = make_shared<string>(boost::any_cast<string>(m["ExportedImageURL"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExportImageResponseBody() = default;
};
class ExportImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportImageResponseBody> body{};

  ExportImageResponse() {}

  explicit ExportImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportImageResponseBody>(model1);
      }
    }
  }


  virtual ~ExportImageResponse() = default;
};
class ExportMeasurementDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<string> startDate{};

  ExportMeasurementDataRequest() {}

  explicit ExportMeasurementDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
  }


  virtual ~ExportMeasurementDataRequest() = default;
};
class ExportMeasurementDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> filePath{};
  shared_ptr<string> requestId{};

  ExportMeasurementDataResponseBody() {}

  explicit ExportMeasurementDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExportMeasurementDataResponseBody() = default;
};
class ExportMeasurementDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportMeasurementDataResponseBody> body{};

  ExportMeasurementDataResponse() {}

  explicit ExportMeasurementDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportMeasurementDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportMeasurementDataResponseBody>(model1);
      }
    }
  }


  virtual ~ExportMeasurementDataResponse() = default;
};
class GetBucketAclRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucketName{};

  GetBucketAclRequest() {}

  explicit GetBucketAclRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
  }


  virtual ~GetBucketAclRequest() = default;
};
class GetBucketAclResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bucketAcl{};
  shared_ptr<string> requestId{};

  GetBucketAclResponseBody() {}

  explicit GetBucketAclResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketAcl) {
      res["BucketAcl"] = boost::any(*bucketAcl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketAcl") != m.end() && !m["BucketAcl"].empty()) {
      bucketAcl = make_shared<string>(boost::any_cast<string>(m["BucketAcl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetBucketAclResponseBody() = default;
};
class GetBucketAclResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBucketAclResponseBody> body{};

  GetBucketAclResponse() {}

  explicit GetBucketAclResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBucketAclResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBucketAclResponseBody>(model1);
      }
    }
  }


  virtual ~GetBucketAclResponse() = default;
};
class GetBucketInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucketName{};

  GetBucketInfoRequest() {}

  explicit GetBucketInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
  }


  virtual ~GetBucketInfoRequest() = default;
};
class GetBucketInfoResponseBodyBucketInfo : public Darabonba::Model {
public:
  shared_ptr<string> bucketAcl{};
  shared_ptr<string> bucketName{};
  shared_ptr<string> comment{};
  shared_ptr<string> createTime{};
  shared_ptr<string> logicalBucketType{};
  shared_ptr<string> modifyTime{};

  GetBucketInfoResponseBodyBucketInfo() {}

  explicit GetBucketInfoResponseBodyBucketInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketAcl) {
      res["BucketAcl"] = boost::any(*bucketAcl);
    }
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (logicalBucketType) {
      res["LogicalBucketType"] = boost::any(*logicalBucketType);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketAcl") != m.end() && !m["BucketAcl"].empty()) {
      bucketAcl = make_shared<string>(boost::any_cast<string>(m["BucketAcl"]));
    }
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("LogicalBucketType") != m.end() && !m["LogicalBucketType"].empty()) {
      logicalBucketType = make_shared<string>(boost::any_cast<string>(m["LogicalBucketType"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
  }


  virtual ~GetBucketInfoResponseBodyBucketInfo() = default;
};
class GetBucketInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetBucketInfoResponseBodyBucketInfo> bucketInfo{};
  shared_ptr<string> requestId{};

  GetBucketInfoResponseBody() {}

  explicit GetBucketInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketInfo) {
      res["BucketInfo"] = bucketInfo ? boost::any(bucketInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketInfo") != m.end() && !m["BucketInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["BucketInfo"].type()) {
        GetBucketInfoResponseBodyBucketInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BucketInfo"]));
        bucketInfo = make_shared<GetBucketInfoResponseBodyBucketInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetBucketInfoResponseBody() = default;
};
class GetBucketInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBucketInfoResponseBody> body{};

  GetBucketInfoResponse() {}

  explicit GetBucketInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBucketInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBucketInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetBucketInfoResponse() = default;
};
class GetBucketLifecycleRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucketName{};
  shared_ptr<string> ruleId{};

  GetBucketLifecycleRequest() {}

  explicit GetBucketLifecycleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~GetBucketLifecycleRequest() = default;
};
class GetBucketLifecycleResponseBodyRuleExpiration : public Darabonba::Model {
public:
  shared_ptr<string> createdBeforeDate{};
  shared_ptr<string> days{};

  GetBucketLifecycleResponseBodyRuleExpiration() {}

  explicit GetBucketLifecycleResponseBodyRuleExpiration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdBeforeDate) {
      res["CreatedBeforeDate"] = boost::any(*createdBeforeDate);
    }
    if (days) {
      res["Days"] = boost::any(*days);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedBeforeDate") != m.end() && !m["CreatedBeforeDate"].empty()) {
      createdBeforeDate = make_shared<string>(boost::any_cast<string>(m["CreatedBeforeDate"]));
    }
    if (m.find("Days") != m.end() && !m["Days"].empty()) {
      days = make_shared<string>(boost::any_cast<string>(m["Days"]));
    }
  }


  virtual ~GetBucketLifecycleResponseBodyRuleExpiration() = default;
};
class GetBucketLifecycleResponseBodyRule : public Darabonba::Model {
public:
  shared_ptr<GetBucketLifecycleResponseBodyRuleExpiration> expiration{};
  shared_ptr<string> ID{};
  shared_ptr<string> prefix{};
  shared_ptr<string> status{};

  GetBucketLifecycleResponseBodyRule() {}

  explicit GetBucketLifecycleResponseBodyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expiration) {
      res["Expiration"] = expiration ? boost::any(expiration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ID) {
      res["ID"] = boost::any(*ID);
    }
    if (prefix) {
      res["Prefix"] = boost::any(*prefix);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expiration") != m.end() && !m["Expiration"].empty()) {
      if (typeid(map<string, boost::any>) == m["Expiration"].type()) {
        GetBucketLifecycleResponseBodyRuleExpiration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Expiration"]));
        expiration = make_shared<GetBucketLifecycleResponseBodyRuleExpiration>(model1);
      }
    }
    if (m.find("ID") != m.end() && !m["ID"].empty()) {
      ID = make_shared<string>(boost::any_cast<string>(m["ID"]));
    }
    if (m.find("Prefix") != m.end() && !m["Prefix"].empty()) {
      prefix = make_shared<string>(boost::any_cast<string>(m["Prefix"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetBucketLifecycleResponseBodyRule() = default;
};
class GetBucketLifecycleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetBucketLifecycleResponseBodyRule>> rule{};

  GetBucketLifecycleResponseBody() {}

  explicit GetBucketLifecycleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rule) {
      vector<boost::any> temp1;
      for(auto item1:*rule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(vector<boost::any>) == m["Rule"].type()) {
        vector<GetBucketLifecycleResponseBodyRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBucketLifecycleResponseBodyRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rule = make_shared<vector<GetBucketLifecycleResponseBodyRule>>(expect1);
      }
    }
  }


  virtual ~GetBucketLifecycleResponseBody() = default;
};
class GetBucketLifecycleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBucketLifecycleResponseBody> body{};

  GetBucketLifecycleResponse() {}

  explicit GetBucketLifecycleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBucketLifecycleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBucketLifecycleResponseBody>(model1);
      }
    }
  }


  virtual ~GetBucketLifecycleResponse() = default;
};
class GetOssStorageAndAccByBucketsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucketList{};

  GetOssStorageAndAccByBucketsRequest() {}

  explicit GetOssStorageAndAccByBucketsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketList) {
      res["BucketList"] = boost::any(*bucketList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketList") != m.end() && !m["BucketList"].empty()) {
      bucketList = make_shared<string>(boost::any_cast<string>(m["BucketList"]));
    }
  }


  virtual ~GetOssStorageAndAccByBucketsRequest() = default;
};
class GetOssStorageAndAccByBucketsResponseBodyBucketList : public Darabonba::Model {
public:
  shared_ptr<long> acc{};
  shared_ptr<string> bucket{};
  shared_ptr<long> storageUsageByte{};

  GetOssStorageAndAccByBucketsResponseBodyBucketList() {}

  explicit GetOssStorageAndAccByBucketsResponseBodyBucketList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acc) {
      res["Acc"] = boost::any(*acc);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (storageUsageByte) {
      res["StorageUsageByte"] = boost::any(*storageUsageByte);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Acc") != m.end() && !m["Acc"].empty()) {
      acc = make_shared<long>(boost::any_cast<long>(m["Acc"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("StorageUsageByte") != m.end() && !m["StorageUsageByte"].empty()) {
      storageUsageByte = make_shared<long>(boost::any_cast<long>(m["StorageUsageByte"]));
    }
  }


  virtual ~GetOssStorageAndAccByBucketsResponseBodyBucketList() = default;
};
class GetOssStorageAndAccByBucketsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetOssStorageAndAccByBucketsResponseBodyBucketList>> bucketList{};
  shared_ptr<string> requestId{};

  GetOssStorageAndAccByBucketsResponseBody() {}

  explicit GetOssStorageAndAccByBucketsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketList) {
      vector<boost::any> temp1;
      for(auto item1:*bucketList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BucketList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketList") != m.end() && !m["BucketList"].empty()) {
      if (typeid(vector<boost::any>) == m["BucketList"].type()) {
        vector<GetOssStorageAndAccByBucketsResponseBodyBucketList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BucketList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetOssStorageAndAccByBucketsResponseBodyBucketList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bucketList = make_shared<vector<GetOssStorageAndAccByBucketsResponseBodyBucketList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetOssStorageAndAccByBucketsResponseBody() = default;
};
class GetOssStorageAndAccByBucketsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOssStorageAndAccByBucketsResponseBody> body{};

  GetOssStorageAndAccByBucketsResponse() {}

  explicit GetOssStorageAndAccByBucketsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOssStorageAndAccByBucketsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOssStorageAndAccByBucketsResponseBody>(model1);
      }
    }
  }


  virtual ~GetOssStorageAndAccByBucketsResponse() = default;
};
class GetOssUsageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> endTime{};
  shared_ptr<string> period{};
  shared_ptr<string> startTime{};

  GetOssUsageDataRequest() {}

  explicit GetOssUsageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~GetOssUsageDataRequest() = default;
};
class GetOssUsageDataResponseBodyUsageList : public Darabonba::Model {
public:
  shared_ptr<long> lanRxBw{};
  shared_ptr<long> lanTxBw{};
  shared_ptr<long> point{};
  shared_ptr<string> pointTs{};
  shared_ptr<long> storageUsageByte{};
  shared_ptr<long> wanRxBw{};
  shared_ptr<long> wanTxBw{};

  GetOssUsageDataResponseBodyUsageList() {}

  explicit GetOssUsageDataResponseBodyUsageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lanRxBw) {
      res["LanRxBw"] = boost::any(*lanRxBw);
    }
    if (lanTxBw) {
      res["LanTxBw"] = boost::any(*lanTxBw);
    }
    if (point) {
      res["Point"] = boost::any(*point);
    }
    if (pointTs) {
      res["PointTs"] = boost::any(*pointTs);
    }
    if (storageUsageByte) {
      res["StorageUsageByte"] = boost::any(*storageUsageByte);
    }
    if (wanRxBw) {
      res["WanRxBw"] = boost::any(*wanRxBw);
    }
    if (wanTxBw) {
      res["WanTxBw"] = boost::any(*wanTxBw);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LanRxBw") != m.end() && !m["LanRxBw"].empty()) {
      lanRxBw = make_shared<long>(boost::any_cast<long>(m["LanRxBw"]));
    }
    if (m.find("LanTxBw") != m.end() && !m["LanTxBw"].empty()) {
      lanTxBw = make_shared<long>(boost::any_cast<long>(m["LanTxBw"]));
    }
    if (m.find("Point") != m.end() && !m["Point"].empty()) {
      point = make_shared<long>(boost::any_cast<long>(m["Point"]));
    }
    if (m.find("PointTs") != m.end() && !m["PointTs"].empty()) {
      pointTs = make_shared<string>(boost::any_cast<string>(m["PointTs"]));
    }
    if (m.find("StorageUsageByte") != m.end() && !m["StorageUsageByte"].empty()) {
      storageUsageByte = make_shared<long>(boost::any_cast<long>(m["StorageUsageByte"]));
    }
    if (m.find("WanRxBw") != m.end() && !m["WanRxBw"].empty()) {
      wanRxBw = make_shared<long>(boost::any_cast<long>(m["WanRxBw"]));
    }
    if (m.find("WanTxBw") != m.end() && !m["WanTxBw"].empty()) {
      wanTxBw = make_shared<long>(boost::any_cast<long>(m["WanTxBw"]));
    }
  }


  virtual ~GetOssUsageDataResponseBodyUsageList() = default;
};
class GetOssUsageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetOssUsageDataResponseBodyUsageList>> usageList{};

  GetOssUsageDataResponseBody() {}

  explicit GetOssUsageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (usageList) {
      vector<boost::any> temp1;
      for(auto item1:*usageList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UsageList") != m.end() && !m["UsageList"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageList"].type()) {
        vector<GetOssUsageDataResponseBodyUsageList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetOssUsageDataResponseBodyUsageList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageList = make_shared<vector<GetOssUsageDataResponseBodyUsageList>>(expect1);
      }
    }
  }


  virtual ~GetOssUsageDataResponseBody() = default;
};
class GetOssUsageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOssUsageDataResponseBody> body{};

  GetOssUsageDataResponse() {}

  explicit GetOssUsageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOssUsageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOssUsageDataResponseBody>(model1);
      }
    }
  }


  virtual ~GetOssUsageDataResponse() = default;
};
class ImportImageRequestDiskDeviceMapping : public Darabonba::Model {
public:
  shared_ptr<string> OSSBucket{};
  shared_ptr<string> OSSObject{};
  shared_ptr<string> OSSRegion{};

  ImportImageRequestDiskDeviceMapping() {}

  explicit ImportImageRequestDiskDeviceMapping(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (OSSBucket) {
      res["OSSBucket"] = boost::any(*OSSBucket);
    }
    if (OSSObject) {
      res["OSSObject"] = boost::any(*OSSObject);
    }
    if (OSSRegion) {
      res["OSSRegion"] = boost::any(*OSSRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OSSBucket") != m.end() && !m["OSSBucket"].empty()) {
      OSSBucket = make_shared<string>(boost::any_cast<string>(m["OSSBucket"]));
    }
    if (m.find("OSSObject") != m.end() && !m["OSSObject"].empty()) {
      OSSObject = make_shared<string>(boost::any_cast<string>(m["OSSObject"]));
    }
    if (m.find("OSSRegion") != m.end() && !m["OSSRegion"].empty()) {
      OSSRegion = make_shared<string>(boost::any_cast<string>(m["OSSRegion"]));
    }
  }


  virtual ~ImportImageRequestDiskDeviceMapping() = default;
};
class ImportImageRequest : public Darabonba::Model {
public:
  shared_ptr<string> architecture{};
  shared_ptr<string> computeType{};
  shared_ptr<vector<ImportImageRequestDiskDeviceMapping>> diskDeviceMapping{};
  shared_ptr<string> imageFormat{};
  shared_ptr<string> imageName{};
  shared_ptr<string> OSSBucket{};
  shared_ptr<string> OSSObject{};
  shared_ptr<string> OSSRegion{};
  shared_ptr<string> OSType{};
  shared_ptr<string> OSVersion{};
  shared_ptr<string> platform{};
  shared_ptr<string> targetOSSRegionId{};

  ImportImageRequest() {}

  explicit ImportImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (computeType) {
      res["ComputeType"] = boost::any(*computeType);
    }
    if (diskDeviceMapping) {
      vector<boost::any> temp1;
      for(auto item1:*diskDeviceMapping){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiskDeviceMapping"] = boost::any(temp1);
    }
    if (imageFormat) {
      res["ImageFormat"] = boost::any(*imageFormat);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (OSSBucket) {
      res["OSSBucket"] = boost::any(*OSSBucket);
    }
    if (OSSObject) {
      res["OSSObject"] = boost::any(*OSSObject);
    }
    if (OSSRegion) {
      res["OSSRegion"] = boost::any(*OSSRegion);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (OSVersion) {
      res["OSVersion"] = boost::any(*OSVersion);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (targetOSSRegionId) {
      res["TargetOSSRegionId"] = boost::any(*targetOSSRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("ComputeType") != m.end() && !m["ComputeType"].empty()) {
      computeType = make_shared<string>(boost::any_cast<string>(m["ComputeType"]));
    }
    if (m.find("DiskDeviceMapping") != m.end() && !m["DiskDeviceMapping"].empty()) {
      if (typeid(vector<boost::any>) == m["DiskDeviceMapping"].type()) {
        vector<ImportImageRequestDiskDeviceMapping> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiskDeviceMapping"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportImageRequestDiskDeviceMapping model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diskDeviceMapping = make_shared<vector<ImportImageRequestDiskDeviceMapping>>(expect1);
      }
    }
    if (m.find("ImageFormat") != m.end() && !m["ImageFormat"].empty()) {
      imageFormat = make_shared<string>(boost::any_cast<string>(m["ImageFormat"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("OSSBucket") != m.end() && !m["OSSBucket"].empty()) {
      OSSBucket = make_shared<string>(boost::any_cast<string>(m["OSSBucket"]));
    }
    if (m.find("OSSObject") != m.end() && !m["OSSObject"].empty()) {
      OSSObject = make_shared<string>(boost::any_cast<string>(m["OSSObject"]));
    }
    if (m.find("OSSRegion") != m.end() && !m["OSSRegion"].empty()) {
      OSSRegion = make_shared<string>(boost::any_cast<string>(m["OSSRegion"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("OSVersion") != m.end() && !m["OSVersion"].empty()) {
      OSVersion = make_shared<string>(boost::any_cast<string>(m["OSVersion"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("TargetOSSRegionId") != m.end() && !m["TargetOSSRegionId"].empty()) {
      targetOSSRegionId = make_shared<string>(boost::any_cast<string>(m["TargetOSSRegionId"]));
    }
  }


  virtual ~ImportImageRequest() = default;
};
class ImportImageShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> architecture{};
  shared_ptr<string> computeType{};
  shared_ptr<string> diskDeviceMappingShrink{};
  shared_ptr<string> imageFormat{};
  shared_ptr<string> imageName{};
  shared_ptr<string> OSSBucket{};
  shared_ptr<string> OSSObject{};
  shared_ptr<string> OSSRegion{};
  shared_ptr<string> OSType{};
  shared_ptr<string> OSVersion{};
  shared_ptr<string> platform{};
  shared_ptr<string> targetOSSRegionId{};

  ImportImageShrinkRequest() {}

  explicit ImportImageShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (computeType) {
      res["ComputeType"] = boost::any(*computeType);
    }
    if (diskDeviceMappingShrink) {
      res["DiskDeviceMapping"] = boost::any(*diskDeviceMappingShrink);
    }
    if (imageFormat) {
      res["ImageFormat"] = boost::any(*imageFormat);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (OSSBucket) {
      res["OSSBucket"] = boost::any(*OSSBucket);
    }
    if (OSSObject) {
      res["OSSObject"] = boost::any(*OSSObject);
    }
    if (OSSRegion) {
      res["OSSRegion"] = boost::any(*OSSRegion);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (OSVersion) {
      res["OSVersion"] = boost::any(*OSVersion);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (targetOSSRegionId) {
      res["TargetOSSRegionId"] = boost::any(*targetOSSRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("ComputeType") != m.end() && !m["ComputeType"].empty()) {
      computeType = make_shared<string>(boost::any_cast<string>(m["ComputeType"]));
    }
    if (m.find("DiskDeviceMapping") != m.end() && !m["DiskDeviceMapping"].empty()) {
      diskDeviceMappingShrink = make_shared<string>(boost::any_cast<string>(m["DiskDeviceMapping"]));
    }
    if (m.find("ImageFormat") != m.end() && !m["ImageFormat"].empty()) {
      imageFormat = make_shared<string>(boost::any_cast<string>(m["ImageFormat"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("OSSBucket") != m.end() && !m["OSSBucket"].empty()) {
      OSSBucket = make_shared<string>(boost::any_cast<string>(m["OSSBucket"]));
    }
    if (m.find("OSSObject") != m.end() && !m["OSSObject"].empty()) {
      OSSObject = make_shared<string>(boost::any_cast<string>(m["OSSObject"]));
    }
    if (m.find("OSSRegion") != m.end() && !m["OSSRegion"].empty()) {
      OSSRegion = make_shared<string>(boost::any_cast<string>(m["OSSRegion"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("OSVersion") != m.end() && !m["OSVersion"].empty()) {
      OSVersion = make_shared<string>(boost::any_cast<string>(m["OSVersion"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("TargetOSSRegionId") != m.end() && !m["TargetOSSRegionId"].empty()) {
      targetOSSRegionId = make_shared<string>(boost::any_cast<string>(m["TargetOSSRegionId"]));
    }
  }


  virtual ~ImportImageShrinkRequest() = default;
};
class ImportImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> requestId{};

  ImportImageResponseBody() {}

  explicit ImportImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ImportImageResponseBody() = default;
};
class ImportImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportImageResponseBody> body{};

  ImportImageResponse() {}

  explicit ImportImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportImageResponseBody>(model1);
      }
    }
  }


  virtual ~ImportImageResponse() = default;
};
class ImportKeyPairRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyPairName{};
  shared_ptr<string> publicKeyBody{};

  ImportKeyPairRequest() {}

  explicit ImportKeyPairRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (publicKeyBody) {
      res["PublicKeyBody"] = boost::any(*publicKeyBody);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("PublicKeyBody") != m.end() && !m["PublicKeyBody"].empty()) {
      publicKeyBody = make_shared<string>(boost::any_cast<string>(m["PublicKeyBody"]));
    }
  }


  virtual ~ImportKeyPairRequest() = default;
};
class ImportKeyPairResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> keyPairFingerPrint{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> requestId{};

  ImportKeyPairResponseBody() {}

  explicit ImportKeyPairResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPairFingerPrint) {
      res["KeyPairFingerPrint"] = boost::any(*keyPairFingerPrint);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPairFingerPrint") != m.end() && !m["KeyPairFingerPrint"].empty()) {
      keyPairFingerPrint = make_shared<string>(boost::any_cast<string>(m["KeyPairFingerPrint"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ImportKeyPairResponseBody() = default;
};
class ImportKeyPairResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportKeyPairResponseBody> body{};

  ImportKeyPairResponse() {}

  explicit ImportKeyPairResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportKeyPairResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportKeyPairResponseBody>(model1);
      }
    }
  }


  virtual ~ImportKeyPairResponse() = default;
};
class JoinPublicIpsToEpnInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> instanceInfos{};

  JoinPublicIpsToEpnInstanceRequest() {}

  explicit JoinPublicIpsToEpnInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (instanceInfos) {
      res["InstanceInfos"] = boost::any(*instanceInfos);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("InstanceInfos") != m.end() && !m["InstanceInfos"].empty()) {
      instanceInfos = make_shared<string>(boost::any_cast<string>(m["InstanceInfos"]));
    }
  }


  virtual ~JoinPublicIpsToEpnInstanceRequest() = default;
};
class JoinPublicIpsToEpnInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  JoinPublicIpsToEpnInstanceResponseBody() {}

  explicit JoinPublicIpsToEpnInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~JoinPublicIpsToEpnInstanceResponseBody() = default;
};
class JoinPublicIpsToEpnInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<JoinPublicIpsToEpnInstanceResponseBody> body{};

  JoinPublicIpsToEpnInstanceResponse() {}

  explicit JoinPublicIpsToEpnInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        JoinPublicIpsToEpnInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<JoinPublicIpsToEpnInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~JoinPublicIpsToEpnInstanceResponse() = default;
};
class JoinSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> securityGroupId{};

  JoinSecurityGroupRequest() {}

  explicit JoinSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~JoinSecurityGroupRequest() = default;
};
class JoinSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  JoinSecurityGroupResponseBody() {}

  explicit JoinSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~JoinSecurityGroupResponseBody() = default;
};
class JoinSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<JoinSecurityGroupResponseBody> body{};

  JoinSecurityGroupResponse() {}

  explicit JoinSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        JoinSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<JoinSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~JoinSecurityGroupResponse() = default;
};
class JoinVSwitchesToEpnInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> vSwitchesInfo{};

  JoinVSwitchesToEpnInstanceRequest() {}

  explicit JoinVSwitchesToEpnInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (vSwitchesInfo) {
      res["VSwitchesInfo"] = boost::any(*vSwitchesInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("VSwitchesInfo") != m.end() && !m["VSwitchesInfo"].empty()) {
      vSwitchesInfo = make_shared<string>(boost::any_cast<string>(m["VSwitchesInfo"]));
    }
  }


  virtual ~JoinVSwitchesToEpnInstanceRequest() = default;
};
class JoinVSwitchesToEpnInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  JoinVSwitchesToEpnInstanceResponseBody() {}

  explicit JoinVSwitchesToEpnInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~JoinVSwitchesToEpnInstanceResponseBody() = default;
};
class JoinVSwitchesToEpnInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<JoinVSwitchesToEpnInstanceResponseBody> body{};

  JoinVSwitchesToEpnInstanceResponse() {}

  explicit JoinVSwitchesToEpnInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        JoinVSwitchesToEpnInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<JoinVSwitchesToEpnInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~JoinVSwitchesToEpnInstanceResponse() = default;
};
class LeaveSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> securityGroupId{};

  LeaveSecurityGroupRequest() {}

  explicit LeaveSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~LeaveSecurityGroupRequest() = default;
};
class LeaveSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  LeaveSecurityGroupResponseBody() {}

  explicit LeaveSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~LeaveSecurityGroupResponseBody() = default;
};
class LeaveSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<LeaveSecurityGroupResponseBody> body{};

  LeaveSecurityGroupResponse() {}

  explicit LeaveSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LeaveSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LeaveSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~LeaveSecurityGroupResponse() = default;
};
class ListApplicationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appVersions{};
  shared_ptr<string> clusterNames{};
  shared_ptr<string> level{};
  shared_ptr<string> maxDate{};
  shared_ptr<string> minDate{};
  shared_ptr<string> outAppInfoParams{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListApplicationsRequest() {}

  explicit ListApplicationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appVersions) {
      res["AppVersions"] = boost::any(*appVersions);
    }
    if (clusterNames) {
      res["ClusterNames"] = boost::any(*clusterNames);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (maxDate) {
      res["MaxDate"] = boost::any(*maxDate);
    }
    if (minDate) {
      res["MinDate"] = boost::any(*minDate);
    }
    if (outAppInfoParams) {
      res["OutAppInfoParams"] = boost::any(*outAppInfoParams);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppVersions") != m.end() && !m["AppVersions"].empty()) {
      appVersions = make_shared<string>(boost::any_cast<string>(m["AppVersions"]));
    }
    if (m.find("ClusterNames") != m.end() && !m["ClusterNames"].empty()) {
      clusterNames = make_shared<string>(boost::any_cast<string>(m["ClusterNames"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("MaxDate") != m.end() && !m["MaxDate"].empty()) {
      maxDate = make_shared<string>(boost::any_cast<string>(m["MaxDate"]));
    }
    if (m.find("MinDate") != m.end() && !m["MinDate"].empty()) {
      minDate = make_shared<string>(boost::any_cast<string>(m["MinDate"]));
    }
    if (m.find("OutAppInfoParams") != m.end() && !m["OutAppInfoParams"].empty()) {
      outAppInfoParams = make_shared<string>(boost::any_cast<string>(m["OutAppInfoParams"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListApplicationsRequest() = default;
};
class ListApplicationsResponseBodyApplicationsApplicationAppListApp : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appInfo{};

  ListApplicationsResponseBodyApplicationsApplicationAppListApp() {}

  explicit ListApplicationsResponseBodyApplicationsApplicationAppListApp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appInfo) {
      res["AppInfo"] = boost::any(*appInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppInfo") != m.end() && !m["AppInfo"].empty()) {
      appInfo = make_shared<string>(boost::any_cast<string>(m["AppInfo"]));
    }
  }


  virtual ~ListApplicationsResponseBodyApplicationsApplicationAppListApp() = default;
};
class ListApplicationsResponseBodyApplicationsApplicationAppList : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationsResponseBodyApplicationsApplicationAppListApp>> app{};

  ListApplicationsResponseBodyApplicationsApplicationAppList() {}

  explicit ListApplicationsResponseBodyApplicationsApplicationAppList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      vector<boost::any> temp1;
      for(auto item1:*app){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["App"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      if (typeid(vector<boost::any>) == m["App"].type()) {
        vector<ListApplicationsResponseBodyApplicationsApplicationAppListApp> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["App"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsResponseBodyApplicationsApplicationAppListApp model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        app = make_shared<vector<ListApplicationsResponseBodyApplicationsApplicationAppListApp>>(expect1);
      }
    }
  }


  virtual ~ListApplicationsResponseBodyApplicationsApplicationAppList() = default;
};
class ListApplicationsResponseBodyApplicationsApplication : public Darabonba::Model {
public:
  shared_ptr<ListApplicationsResponseBodyApplicationsApplicationAppList> appList{};
  shared_ptr<string> clusterName{};

  ListApplicationsResponseBodyApplicationsApplication() {}

  explicit ListApplicationsResponseBodyApplicationsApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appList) {
      res["AppList"] = appList ? boost::any(appList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppList") != m.end() && !m["AppList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppList"].type()) {
        ListApplicationsResponseBodyApplicationsApplicationAppList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppList"]));
        appList = make_shared<ListApplicationsResponseBodyApplicationsApplicationAppList>(model1);
      }
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
  }


  virtual ~ListApplicationsResponseBodyApplicationsApplication() = default;
};
class ListApplicationsResponseBodyApplications : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationsResponseBodyApplicationsApplication>> application{};

  ListApplicationsResponseBodyApplications() {}

  explicit ListApplicationsResponseBodyApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (application) {
      vector<boost::any> temp1;
      for(auto item1:*application){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Application"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      if (typeid(vector<boost::any>) == m["Application"].type()) {
        vector<ListApplicationsResponseBodyApplicationsApplication> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Application"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsResponseBodyApplicationsApplication model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        application = make_shared<vector<ListApplicationsResponseBodyApplicationsApplication>>(expect1);
      }
    }
  }


  virtual ~ListApplicationsResponseBodyApplications() = default;
};
class ListApplicationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListApplicationsResponseBodyApplications> applications{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListApplicationsResponseBody() {}

  explicit ListApplicationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applications) {
      res["Applications"] = applications ? boost::any(applications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Applications") != m.end() && !m["Applications"].empty()) {
      if (typeid(map<string, boost::any>) == m["Applications"].type()) {
        ListApplicationsResponseBodyApplications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Applications"]));
        applications = make_shared<ListApplicationsResponseBodyApplications>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListApplicationsResponseBody() = default;
};
class ListApplicationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApplicationsResponseBody> body{};

  ListApplicationsResponse() {}

  explicit ListApplicationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationsResponse() = default;
};
class ListBucketsRequest : public Darabonba::Model {
public:
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> prefix{};

  ListBucketsRequest() {}

  explicit ListBucketsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prefix) {
      res["Prefix"] = boost::any(*prefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Prefix") != m.end() && !m["Prefix"].empty()) {
      prefix = make_shared<string>(boost::any_cast<string>(m["Prefix"]));
    }
  }


  virtual ~ListBucketsRequest() = default;
};
class ListBucketsResponseBodyBucketInfos : public Darabonba::Model {
public:
  shared_ptr<string> bucketAcl{};
  shared_ptr<string> bucketName{};
  shared_ptr<string> comment{};
  shared_ptr<string> createTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> logicalBucketType{};
  shared_ptr<string> modifyTime{};

  ListBucketsResponseBodyBucketInfos() {}

  explicit ListBucketsResponseBodyBucketInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketAcl) {
      res["BucketAcl"] = boost::any(*bucketAcl);
    }
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (logicalBucketType) {
      res["LogicalBucketType"] = boost::any(*logicalBucketType);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketAcl") != m.end() && !m["BucketAcl"].empty()) {
      bucketAcl = make_shared<string>(boost::any_cast<string>(m["BucketAcl"]));
    }
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("LogicalBucketType") != m.end() && !m["LogicalBucketType"].empty()) {
      logicalBucketType = make_shared<string>(boost::any_cast<string>(m["LogicalBucketType"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
  }


  virtual ~ListBucketsResponseBodyBucketInfos() = default;
};
class ListBucketsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListBucketsResponseBodyBucketInfos>> bucketInfos{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListBucketsResponseBody() {}

  explicit ListBucketsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketInfos) {
      vector<boost::any> temp1;
      for(auto item1:*bucketInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BucketInfos"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketInfos") != m.end() && !m["BucketInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["BucketInfos"].type()) {
        vector<ListBucketsResponseBodyBucketInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BucketInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBucketsResponseBodyBucketInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bucketInfos = make_shared<vector<ListBucketsResponseBodyBucketInfos>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListBucketsResponseBody() = default;
};
class ListBucketsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBucketsResponseBody> body{};

  ListBucketsResponse() {}

  explicit ListBucketsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBucketsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBucketsResponseBody>(model1);
      }
    }
  }


  virtual ~ListBucketsResponse() = default;
};
class ListObjectsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucketName{};
  shared_ptr<string> continuationToken{};
  shared_ptr<string> encodingType{};
  shared_ptr<string> marker{};
  shared_ptr<long> maxKeys{};
  shared_ptr<string> prefix{};
  shared_ptr<string> startAfter{};

  ListObjectsRequest() {}

  explicit ListObjectsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (continuationToken) {
      res["ContinuationToken"] = boost::any(*continuationToken);
    }
    if (encodingType) {
      res["EncodingType"] = boost::any(*encodingType);
    }
    if (marker) {
      res["Marker"] = boost::any(*marker);
    }
    if (maxKeys) {
      res["MaxKeys"] = boost::any(*maxKeys);
    }
    if (prefix) {
      res["Prefix"] = boost::any(*prefix);
    }
    if (startAfter) {
      res["StartAfter"] = boost::any(*startAfter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("ContinuationToken") != m.end() && !m["ContinuationToken"].empty()) {
      continuationToken = make_shared<string>(boost::any_cast<string>(m["ContinuationToken"]));
    }
    if (m.find("EncodingType") != m.end() && !m["EncodingType"].empty()) {
      encodingType = make_shared<string>(boost::any_cast<string>(m["EncodingType"]));
    }
    if (m.find("Marker") != m.end() && !m["Marker"].empty()) {
      marker = make_shared<string>(boost::any_cast<string>(m["Marker"]));
    }
    if (m.find("MaxKeys") != m.end() && !m["MaxKeys"].empty()) {
      maxKeys = make_shared<long>(boost::any_cast<long>(m["MaxKeys"]));
    }
    if (m.find("Prefix") != m.end() && !m["Prefix"].empty()) {
      prefix = make_shared<string>(boost::any_cast<string>(m["Prefix"]));
    }
    if (m.find("StartAfter") != m.end() && !m["StartAfter"].empty()) {
      startAfter = make_shared<string>(boost::any_cast<string>(m["StartAfter"]));
    }
  }


  virtual ~ListObjectsRequest() = default;
};
class ListObjectsResponseBodyContents : public Darabonba::Model {
public:
  shared_ptr<string> ETag{};
  shared_ptr<string> key{};
  shared_ptr<string> lastModified{};
  shared_ptr<long> size{};

  ListObjectsResponseBodyContents() {}

  explicit ListObjectsResponseBodyContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ETag) {
      res["ETag"] = boost::any(*ETag);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ETag") != m.end() && !m["ETag"].empty()) {
      ETag = make_shared<string>(boost::any_cast<string>(m["ETag"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~ListObjectsResponseBodyContents() = default;
};
class ListObjectsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bucketName{};
  shared_ptr<vector<string>> commonPrefixes{};
  shared_ptr<vector<ListObjectsResponseBodyContents>> contents{};
  shared_ptr<string> continuationToken{};
  shared_ptr<string> delimiter{};
  shared_ptr<string> encodingType{};
  shared_ptr<bool> isTruncated{};
  shared_ptr<long> keyCount{};
  shared_ptr<string> marker{};
  shared_ptr<long> maxKeys{};
  shared_ptr<string> nextContinuationToken{};
  shared_ptr<string> nextMarker{};
  shared_ptr<string> prefix{};
  shared_ptr<string> requestId{};

  ListObjectsResponseBody() {}

  explicit ListObjectsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (commonPrefixes) {
      res["CommonPrefixes"] = boost::any(*commonPrefixes);
    }
    if (contents) {
      vector<boost::any> temp1;
      for(auto item1:*contents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contents"] = boost::any(temp1);
    }
    if (continuationToken) {
      res["ContinuationToken"] = boost::any(*continuationToken);
    }
    if (delimiter) {
      res["Delimiter"] = boost::any(*delimiter);
    }
    if (encodingType) {
      res["EncodingType"] = boost::any(*encodingType);
    }
    if (isTruncated) {
      res["IsTruncated"] = boost::any(*isTruncated);
    }
    if (keyCount) {
      res["KeyCount"] = boost::any(*keyCount);
    }
    if (marker) {
      res["Marker"] = boost::any(*marker);
    }
    if (maxKeys) {
      res["MaxKeys"] = boost::any(*maxKeys);
    }
    if (nextContinuationToken) {
      res["NextContinuationToken"] = boost::any(*nextContinuationToken);
    }
    if (nextMarker) {
      res["NextMarker"] = boost::any(*nextMarker);
    }
    if (prefix) {
      res["Prefix"] = boost::any(*prefix);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("CommonPrefixes") != m.end() && !m["CommonPrefixes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CommonPrefixes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CommonPrefixes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      commonPrefixes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      if (typeid(vector<boost::any>) == m["Contents"].type()) {
        vector<ListObjectsResponseBodyContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListObjectsResponseBodyContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contents = make_shared<vector<ListObjectsResponseBodyContents>>(expect1);
      }
    }
    if (m.find("ContinuationToken") != m.end() && !m["ContinuationToken"].empty()) {
      continuationToken = make_shared<string>(boost::any_cast<string>(m["ContinuationToken"]));
    }
    if (m.find("Delimiter") != m.end() && !m["Delimiter"].empty()) {
      delimiter = make_shared<string>(boost::any_cast<string>(m["Delimiter"]));
    }
    if (m.find("EncodingType") != m.end() && !m["EncodingType"].empty()) {
      encodingType = make_shared<string>(boost::any_cast<string>(m["EncodingType"]));
    }
    if (m.find("IsTruncated") != m.end() && !m["IsTruncated"].empty()) {
      isTruncated = make_shared<bool>(boost::any_cast<bool>(m["IsTruncated"]));
    }
    if (m.find("KeyCount") != m.end() && !m["KeyCount"].empty()) {
      keyCount = make_shared<long>(boost::any_cast<long>(m["KeyCount"]));
    }
    if (m.find("Marker") != m.end() && !m["Marker"].empty()) {
      marker = make_shared<string>(boost::any_cast<string>(m["Marker"]));
    }
    if (m.find("MaxKeys") != m.end() && !m["MaxKeys"].empty()) {
      maxKeys = make_shared<long>(boost::any_cast<long>(m["MaxKeys"]));
    }
    if (m.find("NextContinuationToken") != m.end() && !m["NextContinuationToken"].empty()) {
      nextContinuationToken = make_shared<string>(boost::any_cast<string>(m["NextContinuationToken"]));
    }
    if (m.find("NextMarker") != m.end() && !m["NextMarker"].empty()) {
      nextMarker = make_shared<string>(boost::any_cast<string>(m["NextMarker"]));
    }
    if (m.find("Prefix") != m.end() && !m["Prefix"].empty()) {
      prefix = make_shared<string>(boost::any_cast<string>(m["Prefix"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListObjectsResponseBody() = default;
};
class ListObjectsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListObjectsResponseBody> body{};

  ListObjectsResponse() {}

  explicit ListObjectsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListObjectsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListObjectsResponseBody>(model1);
      }
    }
  }


  virtual ~ListObjectsResponse() = default;
};
class ListProductAbilitiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> productAbilities{};
  shared_ptr<string> requestId{};

  ListProductAbilitiesResponseBody() {}

  explicit ListProductAbilitiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productAbilities) {
      res["ProductAbilities"] = boost::any(*productAbilities);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductAbilities") != m.end() && !m["ProductAbilities"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProductAbilities"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProductAbilities"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      productAbilities = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListProductAbilitiesResponseBody() = default;
};
class ListProductAbilitiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProductAbilitiesResponseBody> body{};

  ListProductAbilitiesResponse() {}

  explicit ListProductAbilitiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProductAbilitiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProductAbilitiesResponseBody>(model1);
      }
    }
  }


  virtual ~ListProductAbilitiesResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListTagResourcesResponseBodyTagResources>> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<ListTagResourcesResponseBodyTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<ListTagResourcesResponseBodyTagResources>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ModifyEnsEipAddressAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};

  ModifyEnsEipAddressAttributeRequest() {}

  explicit ModifyEnsEipAddressAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ModifyEnsEipAddressAttributeRequest() = default;
};
class ModifyEnsEipAddressAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyEnsEipAddressAttributeResponseBody() {}

  explicit ModifyEnsEipAddressAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyEnsEipAddressAttributeResponseBody() = default;
};
class ModifyEnsEipAddressAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyEnsEipAddressAttributeResponseBody> body{};

  ModifyEnsEipAddressAttributeResponse() {}

  explicit ModifyEnsEipAddressAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyEnsEipAddressAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyEnsEipAddressAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyEnsEipAddressAttributeResponse() = default;
};
class ModifyEnsRouteEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> routeEntryId{};
  shared_ptr<string> routeEntryName{};

  ModifyEnsRouteEntryRequest() {}

  explicit ModifyEnsRouteEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (routeEntryId) {
      res["RouteEntryId"] = boost::any(*routeEntryId);
    }
    if (routeEntryName) {
      res["RouteEntryName"] = boost::any(*routeEntryName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RouteEntryId") != m.end() && !m["RouteEntryId"].empty()) {
      routeEntryId = make_shared<string>(boost::any_cast<string>(m["RouteEntryId"]));
    }
    if (m.find("RouteEntryName") != m.end() && !m["RouteEntryName"].empty()) {
      routeEntryName = make_shared<string>(boost::any_cast<string>(m["RouteEntryName"]));
    }
  }


  virtual ~ModifyEnsRouteEntryRequest() = default;
};
class ModifyEnsRouteEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyEnsRouteEntryResponseBody() {}

  explicit ModifyEnsRouteEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyEnsRouteEntryResponseBody() = default;
};
class ModifyEnsRouteEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyEnsRouteEntryResponseBody> body{};

  ModifyEnsRouteEntryResponse() {}

  explicit ModifyEnsRouteEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyEnsRouteEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyEnsRouteEntryResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyEnsRouteEntryResponse() = default;
};
class ModifyEpnInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> EPNInstanceName{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> networkingModel{};

  ModifyEpnInstanceRequest() {}

  explicit ModifyEpnInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (EPNInstanceName) {
      res["EPNInstanceName"] = boost::any(*EPNInstanceName);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (networkingModel) {
      res["NetworkingModel"] = boost::any(*networkingModel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("EPNInstanceName") != m.end() && !m["EPNInstanceName"].empty()) {
      EPNInstanceName = make_shared<string>(boost::any_cast<string>(m["EPNInstanceName"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("NetworkingModel") != m.end() && !m["NetworkingModel"].empty()) {
      networkingModel = make_shared<string>(boost::any_cast<string>(m["NetworkingModel"]));
    }
  }


  virtual ~ModifyEpnInstanceRequest() = default;
};
class ModifyEpnInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyEpnInstanceResponseBody() {}

  explicit ModifyEpnInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyEpnInstanceResponseBody() = default;
};
class ModifyEpnInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyEpnInstanceResponseBody> body{};

  ModifyEpnInstanceResponse() {}

  explicit ModifyEpnInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyEpnInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyEpnInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyEpnInstanceResponse() = default;
};
class ModifyFileSystemRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> fileSystemId{};

  ModifyFileSystemRequest() {}

  explicit ModifyFileSystemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (fileSystemId) {
      res["FileSystemId"] = boost::any(*fileSystemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("FileSystemId") != m.end() && !m["FileSystemId"].empty()) {
      fileSystemId = make_shared<string>(boost::any_cast<string>(m["FileSystemId"]));
    }
  }


  virtual ~ModifyFileSystemRequest() = default;
};
class ModifyFileSystemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyFileSystemResponseBody() {}

  explicit ModifyFileSystemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyFileSystemResponseBody() = default;
};
class ModifyFileSystemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyFileSystemResponseBody> body{};

  ModifyFileSystemResponse() {}

  explicit ModifyFileSystemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyFileSystemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyFileSystemResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyFileSystemResponse() = default;
};
class ModifyForwardEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> externalIp{};
  shared_ptr<string> externalPort{};
  shared_ptr<string> forwardEntryId{};
  shared_ptr<string> forwardEntryName{};
  shared_ptr<long> healthCheckPort{};
  shared_ptr<string> internalIp{};
  shared_ptr<string> internalPort{};
  shared_ptr<string> ipProtocol{};

  ModifyForwardEntryRequest() {}

  explicit ModifyForwardEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (externalIp) {
      res["ExternalIp"] = boost::any(*externalIp);
    }
    if (externalPort) {
      res["ExternalPort"] = boost::any(*externalPort);
    }
    if (forwardEntryId) {
      res["ForwardEntryId"] = boost::any(*forwardEntryId);
    }
    if (forwardEntryName) {
      res["ForwardEntryName"] = boost::any(*forwardEntryName);
    }
    if (healthCheckPort) {
      res["HealthCheckPort"] = boost::any(*healthCheckPort);
    }
    if (internalIp) {
      res["InternalIp"] = boost::any(*internalIp);
    }
    if (internalPort) {
      res["InternalPort"] = boost::any(*internalPort);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExternalIp") != m.end() && !m["ExternalIp"].empty()) {
      externalIp = make_shared<string>(boost::any_cast<string>(m["ExternalIp"]));
    }
    if (m.find("ExternalPort") != m.end() && !m["ExternalPort"].empty()) {
      externalPort = make_shared<string>(boost::any_cast<string>(m["ExternalPort"]));
    }
    if (m.find("ForwardEntryId") != m.end() && !m["ForwardEntryId"].empty()) {
      forwardEntryId = make_shared<string>(boost::any_cast<string>(m["ForwardEntryId"]));
    }
    if (m.find("ForwardEntryName") != m.end() && !m["ForwardEntryName"].empty()) {
      forwardEntryName = make_shared<string>(boost::any_cast<string>(m["ForwardEntryName"]));
    }
    if (m.find("HealthCheckPort") != m.end() && !m["HealthCheckPort"].empty()) {
      healthCheckPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckPort"]));
    }
    if (m.find("InternalIp") != m.end() && !m["InternalIp"].empty()) {
      internalIp = make_shared<string>(boost::any_cast<string>(m["InternalIp"]));
    }
    if (m.find("InternalPort") != m.end() && !m["InternalPort"].empty()) {
      internalPort = make_shared<string>(boost::any_cast<string>(m["InternalPort"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
  }


  virtual ~ModifyForwardEntryRequest() = default;
};
class ModifyForwardEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyForwardEntryResponseBody() {}

  explicit ModifyForwardEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyForwardEntryResponseBody() = default;
};
class ModifyForwardEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyForwardEntryResponseBody> body{};

  ModifyForwardEntryResponse() {}

  explicit ModifyForwardEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyForwardEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyForwardEntryResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyForwardEntryResponse() = default;
};
class ModifyHaVipAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> haVipId{};
  shared_ptr<string> name{};

  ModifyHaVipAttributeRequest() {}

  explicit ModifyHaVipAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (haVipId) {
      res["HaVipId"] = boost::any(*haVipId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HaVipId") != m.end() && !m["HaVipId"].empty()) {
      haVipId = make_shared<string>(boost::any_cast<string>(m["HaVipId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ModifyHaVipAttributeRequest() = default;
};
class ModifyHaVipAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHaVipAttributeResponseBody() {}

  explicit ModifyHaVipAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHaVipAttributeResponseBody() = default;
};
class ModifyHaVipAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHaVipAttributeResponseBody> body{};

  ModifyHaVipAttributeResponse() {}

  explicit ModifyHaVipAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHaVipAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHaVipAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHaVipAttributeResponse() = default;
};
class ModifyImageAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};

  ModifyImageAttributeRequest() {}

  explicit ModifyImageAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
  }


  virtual ~ModifyImageAttributeRequest() = default;
};
class ModifyImageAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  ModifyImageAttributeResponseBody() {}

  explicit ModifyImageAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyImageAttributeResponseBody() = default;
};
class ModifyImageAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyImageAttributeResponseBody> body{};

  ModifyImageAttributeResponse() {}

  explicit ModifyImageAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyImageAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyImageAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyImageAttributeResponse() = default;
};
class ModifyImageSharePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> addAccounts{};
  shared_ptr<string> imageId{};
  shared_ptr<string> removeAccounts{};

  ModifyImageSharePermissionRequest() {}

  explicit ModifyImageSharePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addAccounts) {
      res["AddAccounts"] = boost::any(*addAccounts);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (removeAccounts) {
      res["RemoveAccounts"] = boost::any(*removeAccounts);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddAccounts") != m.end() && !m["AddAccounts"].empty()) {
      addAccounts = make_shared<string>(boost::any_cast<string>(m["AddAccounts"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("RemoveAccounts") != m.end() && !m["RemoveAccounts"].empty()) {
      removeAccounts = make_shared<string>(boost::any_cast<string>(m["RemoveAccounts"]));
    }
  }


  virtual ~ModifyImageSharePermissionRequest() = default;
};
class ModifyImageSharePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyImageSharePermissionResponseBody() {}

  explicit ModifyImageSharePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyImageSharePermissionResponseBody() = default;
};
class ModifyImageSharePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyImageSharePermissionResponseBody> body{};

  ModifyImageSharePermissionResponse() {}

  explicit ModifyImageSharePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyImageSharePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyImageSharePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyImageSharePermissionResponse() = default;
};
class ModifyInstanceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> password{};
  shared_ptr<string> userData{};

  ModifyInstanceAttributeRequest() {}

  explicit ModifyInstanceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~ModifyInstanceAttributeRequest() = default;
};
class ModifyInstanceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  ModifyInstanceAttributeResponseBody() {}

  explicit ModifyInstanceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceAttributeResponseBody() = default;
};
class ModifyInstanceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceAttributeResponseBody> body{};

  ModifyInstanceAttributeResponse() {}

  explicit ModifyInstanceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceAttributeResponse() = default;
};
class ModifyInstanceAutoRenewAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> autoRenew{};
  shared_ptr<string> duration{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> renewalStatus{};

  ModifyInstanceAutoRenewAttributeRequest() {}

  explicit ModifyInstanceAutoRenewAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (renewalStatus) {
      res["RenewalStatus"] = boost::any(*renewalStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<string>(boost::any_cast<string>(m["AutoRenew"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RenewalStatus") != m.end() && !m["RenewalStatus"].empty()) {
      renewalStatus = make_shared<string>(boost::any_cast<string>(m["RenewalStatus"]));
    }
  }


  virtual ~ModifyInstanceAutoRenewAttributeRequest() = default;
};
class ModifyInstanceAutoRenewAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  ModifyInstanceAutoRenewAttributeResponseBody() {}

  explicit ModifyInstanceAutoRenewAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceAutoRenewAttributeResponseBody() = default;
};
class ModifyInstanceAutoRenewAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceAutoRenewAttributeResponseBody> body{};

  ModifyInstanceAutoRenewAttributeResponse() {}

  explicit ModifyInstanceAutoRenewAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceAutoRenewAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceAutoRenewAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceAutoRenewAttributeResponse() = default;
};
class ModifyInstanceBootConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> bootSet{};
  shared_ptr<string> bootType{};
  shared_ptr<string> diskSet{};
  shared_ptr<string> instanceId{};

  ModifyInstanceBootConfigurationRequest() {}

  explicit ModifyInstanceBootConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bootSet) {
      res["BootSet"] = boost::any(*bootSet);
    }
    if (bootType) {
      res["BootType"] = boost::any(*bootType);
    }
    if (diskSet) {
      res["DiskSet"] = boost::any(*diskSet);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BootSet") != m.end() && !m["BootSet"].empty()) {
      bootSet = make_shared<string>(boost::any_cast<string>(m["BootSet"]));
    }
    if (m.find("BootType") != m.end() && !m["BootType"].empty()) {
      bootType = make_shared<string>(boost::any_cast<string>(m["BootType"]));
    }
    if (m.find("DiskSet") != m.end() && !m["DiskSet"].empty()) {
      diskSet = make_shared<string>(boost::any_cast<string>(m["DiskSet"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ModifyInstanceBootConfigurationRequest() = default;
};
class ModifyInstanceBootConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceBootConfigurationResponseBody() {}

  explicit ModifyInstanceBootConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceBootConfigurationResponseBody() = default;
};
class ModifyInstanceBootConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceBootConfigurationResponseBody> body{};

  ModifyInstanceBootConfigurationResponse() {}

  explicit ModifyInstanceBootConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceBootConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceBootConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceBootConfigurationResponse() = default;
};
class ModifyInstanceChargeTypeRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> billingCycle{};
  shared_ptr<bool> includeDataDisks{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> period{};
  shared_ptr<string> periodUnit{};

  ModifyInstanceChargeTypeRequest() {}

  explicit ModifyInstanceChargeTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (billingCycle) {
      res["BillingCycle"] = boost::any(*billingCycle);
    }
    if (includeDataDisks) {
      res["IncludeDataDisks"] = boost::any(*includeDataDisks);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("BillingCycle") != m.end() && !m["BillingCycle"].empty()) {
      billingCycle = make_shared<string>(boost::any_cast<string>(m["BillingCycle"]));
    }
    if (m.find("IncludeDataDisks") != m.end() && !m["IncludeDataDisks"].empty()) {
      includeDataDisks = make_shared<bool>(boost::any_cast<bool>(m["IncludeDataDisks"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
  }


  virtual ~ModifyInstanceChargeTypeRequest() = default;
};
class ModifyInstanceChargeTypeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> billingCycle{};
  shared_ptr<bool> includeDataDisks{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceIdsShrink{};
  shared_ptr<string> period{};
  shared_ptr<string> periodUnit{};

  ModifyInstanceChargeTypeShrinkRequest() {}

  explicit ModifyInstanceChargeTypeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (billingCycle) {
      res["BillingCycle"] = boost::any(*billingCycle);
    }
    if (includeDataDisks) {
      res["IncludeDataDisks"] = boost::any(*includeDataDisks);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceIdsShrink) {
      res["InstanceIds"] = boost::any(*instanceIdsShrink);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("BillingCycle") != m.end() && !m["BillingCycle"].empty()) {
      billingCycle = make_shared<string>(boost::any_cast<string>(m["BillingCycle"]));
    }
    if (m.find("IncludeDataDisks") != m.end() && !m["IncludeDataDisks"].empty()) {
      includeDataDisks = make_shared<bool>(boost::any_cast<bool>(m["IncludeDataDisks"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
  }


  virtual ~ModifyInstanceChargeTypeShrinkRequest() = default;
};
class ModifyInstanceChargeTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<long> orderId{};
  shared_ptr<string> requestId{};

  ModifyInstanceChargeTypeResponseBody() {}

  explicit ModifyInstanceChargeTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceChargeTypeResponseBody() = default;
};
class ModifyInstanceChargeTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceChargeTypeResponseBody> body{};

  ModifyInstanceChargeTypeResponse() {}

  explicit ModifyInstanceChargeTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceChargeTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceChargeTypeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceChargeTypeResponse() = default;
};
class ModifyLoadBalancerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> loadBalancerName{};

  ModifyLoadBalancerAttributeRequest() {}

  explicit ModifyLoadBalancerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (loadBalancerName) {
      res["LoadBalancerName"] = boost::any(*loadBalancerName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("LoadBalancerName") != m.end() && !m["LoadBalancerName"].empty()) {
      loadBalancerName = make_shared<string>(boost::any_cast<string>(m["LoadBalancerName"]));
    }
  }


  virtual ~ModifyLoadBalancerAttributeRequest() = default;
};
class ModifyLoadBalancerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyLoadBalancerAttributeResponseBody() {}

  explicit ModifyLoadBalancerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLoadBalancerAttributeResponseBody() = default;
};
class ModifyLoadBalancerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyLoadBalancerAttributeResponseBody> body{};

  ModifyLoadBalancerAttributeResponse() {}

  explicit ModifyLoadBalancerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLoadBalancerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLoadBalancerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLoadBalancerAttributeResponse() = default;
};
class ModifyNetworkAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> networkId{};
  shared_ptr<string> networkName{};

  ModifyNetworkAttributeRequest() {}

  explicit ModifyNetworkAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (networkName) {
      res["NetworkName"] = boost::any(*networkName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("NetworkName") != m.end() && !m["NetworkName"].empty()) {
      networkName = make_shared<string>(boost::any_cast<string>(m["NetworkName"]));
    }
  }


  virtual ~ModifyNetworkAttributeRequest() = default;
};
class ModifyNetworkAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyNetworkAttributeResponseBody() {}

  explicit ModifyNetworkAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyNetworkAttributeResponseBody() = default;
};
class ModifyNetworkAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyNetworkAttributeResponseBody> body{};

  ModifyNetworkAttributeResponse() {}

  explicit ModifyNetworkAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyNetworkAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyNetworkAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyNetworkAttributeResponse() = default;
};
class ModifyNetworkInterfaceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> networkInterfaceName{};

  ModifyNetworkInterfaceAttributeRequest() {}

  explicit ModifyNetworkInterfaceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (networkInterfaceName) {
      res["NetworkInterfaceName"] = boost::any(*networkInterfaceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("NetworkInterfaceName") != m.end() && !m["NetworkInterfaceName"].empty()) {
      networkInterfaceName = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceName"]));
    }
  }


  virtual ~ModifyNetworkInterfaceAttributeRequest() = default;
};
class ModifyNetworkInterfaceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyNetworkInterfaceAttributeResponseBody() {}

  explicit ModifyNetworkInterfaceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyNetworkInterfaceAttributeResponseBody() = default;
};
class ModifyNetworkInterfaceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyNetworkInterfaceAttributeResponseBody> body{};

  ModifyNetworkInterfaceAttributeResponse() {}

  explicit ModifyNetworkInterfaceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyNetworkInterfaceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyNetworkInterfaceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyNetworkInterfaceAttributeResponse() = default;
};
class ModifyPrepayInstanceSpecRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};

  ModifyPrepayInstanceSpecRequest() {}

  explicit ModifyPrepayInstanceSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~ModifyPrepayInstanceSpecRequest() = default;
};
class ModifyPrepayInstanceSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyPrepayInstanceSpecResponseBody() {}

  explicit ModifyPrepayInstanceSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyPrepayInstanceSpecResponseBody() = default;
};
class ModifyPrepayInstanceSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyPrepayInstanceSpecResponseBody> body{};

  ModifyPrepayInstanceSpecResponse() {}

  explicit ModifyPrepayInstanceSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPrepayInstanceSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPrepayInstanceSpecResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPrepayInstanceSpecResponse() = default;
};
class ModifySecurityGroupAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupName{};

  ModifySecurityGroupAttributeRequest() {}

  explicit ModifySecurityGroupAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
  }


  virtual ~ModifySecurityGroupAttributeRequest() = default;
};
class ModifySecurityGroupAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySecurityGroupAttributeResponseBody() {}

  explicit ModifySecurityGroupAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySecurityGroupAttributeResponseBody() = default;
};
class ModifySecurityGroupAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySecurityGroupAttributeResponseBody> body{};

  ModifySecurityGroupAttributeResponse() {}

  explicit ModifySecurityGroupAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySecurityGroupAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySecurityGroupAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySecurityGroupAttributeResponse() = default;
};
class ModifySnapshotAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> snapshotName{};

  ModifySnapshotAttributeRequest() {}

  explicit ModifySnapshotAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (snapshotName) {
      res["SnapshotName"] = boost::any(*snapshotName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("SnapshotName") != m.end() && !m["SnapshotName"].empty()) {
      snapshotName = make_shared<string>(boost::any_cast<string>(m["SnapshotName"]));
    }
  }


  virtual ~ModifySnapshotAttributeRequest() = default;
};
class ModifySnapshotAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySnapshotAttributeResponseBody() {}

  explicit ModifySnapshotAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySnapshotAttributeResponseBody() = default;
};
class ModifySnapshotAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySnapshotAttributeResponseBody> body{};

  ModifySnapshotAttributeResponse() {}

  explicit ModifySnapshotAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySnapshotAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySnapshotAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySnapshotAttributeResponse() = default;
};
class ModifySnatEntryRequest : public Darabonba::Model {
public:
  shared_ptr<bool> eipAffinity{};
  shared_ptr<bool> ispAffinity{};
  shared_ptr<string> snatEntryId{};
  shared_ptr<string> snatEntryName{};
  shared_ptr<string> snatIp{};

  ModifySnatEntryRequest() {}

  explicit ModifySnatEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipAffinity) {
      res["EipAffinity"] = boost::any(*eipAffinity);
    }
    if (ispAffinity) {
      res["IspAffinity"] = boost::any(*ispAffinity);
    }
    if (snatEntryId) {
      res["SnatEntryId"] = boost::any(*snatEntryId);
    }
    if (snatEntryName) {
      res["SnatEntryName"] = boost::any(*snatEntryName);
    }
    if (snatIp) {
      res["SnatIp"] = boost::any(*snatIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipAffinity") != m.end() && !m["EipAffinity"].empty()) {
      eipAffinity = make_shared<bool>(boost::any_cast<bool>(m["EipAffinity"]));
    }
    if (m.find("IspAffinity") != m.end() && !m["IspAffinity"].empty()) {
      ispAffinity = make_shared<bool>(boost::any_cast<bool>(m["IspAffinity"]));
    }
    if (m.find("SnatEntryId") != m.end() && !m["SnatEntryId"].empty()) {
      snatEntryId = make_shared<string>(boost::any_cast<string>(m["SnatEntryId"]));
    }
    if (m.find("SnatEntryName") != m.end() && !m["SnatEntryName"].empty()) {
      snatEntryName = make_shared<string>(boost::any_cast<string>(m["SnatEntryName"]));
    }
    if (m.find("SnatIp") != m.end() && !m["SnatIp"].empty()) {
      snatIp = make_shared<string>(boost::any_cast<string>(m["SnatIp"]));
    }
  }


  virtual ~ModifySnatEntryRequest() = default;
};
class ModifySnatEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySnatEntryResponseBody() {}

  explicit ModifySnatEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySnatEntryResponseBody() = default;
};
class ModifySnatEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySnatEntryResponseBody> body{};

  ModifySnatEntryResponse() {}

  explicit ModifySnatEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySnatEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySnatEntryResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySnatEntryResponse() = default;
};
class ModifyVSwitchAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vSwitchName{};

  ModifyVSwitchAttributeRequest() {}

  explicit ModifyVSwitchAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
  }


  virtual ~ModifyVSwitchAttributeRequest() = default;
};
class ModifyVSwitchAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVSwitchAttributeResponseBody() {}

  explicit ModifyVSwitchAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVSwitchAttributeResponseBody() = default;
};
class ModifyVSwitchAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVSwitchAttributeResponseBody> body{};

  ModifyVSwitchAttributeResponse() {}

  explicit ModifyVSwitchAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVSwitchAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVSwitchAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVSwitchAttributeResponse() = default;
};
class MountInstanceSDGRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> SDGId{};

  MountInstanceSDGRequest() {}

  explicit MountInstanceSDGRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~MountInstanceSDGRequest() = default;
};
class MountInstanceSDGShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIdsShrink{};
  shared_ptr<string> SDGId{};

  MountInstanceSDGShrinkRequest() {}

  explicit MountInstanceSDGShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIdsShrink) {
      res["InstanceIds"] = boost::any(*instanceIdsShrink);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~MountInstanceSDGShrinkRequest() = default;
};
class MountInstanceSDGResponseBodyDataResultFailedItems : public Darabonba::Model {
public:
  shared_ptr<string> errMessage{};
  shared_ptr<string> instanceId{};

  MountInstanceSDGResponseBodyDataResultFailedItems() {}

  explicit MountInstanceSDGResponseBodyDataResultFailedItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~MountInstanceSDGResponseBodyDataResultFailedItems() = default;
};
class MountInstanceSDGResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<long> failedCount{};
  shared_ptr<vector<MountInstanceSDGResponseBodyDataResultFailedItems>> failedItems{};
  shared_ptr<long> successCount{};

  MountInstanceSDGResponseBodyDataResult() {}

  explicit MountInstanceSDGResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedCount) {
      res["FailedCount"] = boost::any(*failedCount);
    }
    if (failedItems) {
      vector<boost::any> temp1;
      for(auto item1:*failedItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedItems"] = boost::any(temp1);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedCount") != m.end() && !m["FailedCount"].empty()) {
      failedCount = make_shared<long>(boost::any_cast<long>(m["FailedCount"]));
    }
    if (m.find("FailedItems") != m.end() && !m["FailedItems"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedItems"].type()) {
        vector<MountInstanceSDGResponseBodyDataResultFailedItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MountInstanceSDGResponseBodyDataResultFailedItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedItems = make_shared<vector<MountInstanceSDGResponseBodyDataResultFailedItems>>(expect1);
      }
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
  }


  virtual ~MountInstanceSDGResponseBodyDataResult() = default;
};
class MountInstanceSDGResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<MountInstanceSDGResponseBodyDataResult> result{};
  shared_ptr<bool> success{};

  MountInstanceSDGResponseBodyData() {}

  explicit MountInstanceSDGResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        MountInstanceSDGResponseBodyDataResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<MountInstanceSDGResponseBodyDataResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~MountInstanceSDGResponseBodyData() = default;
};
class MountInstanceSDGResponseBody : public Darabonba::Model {
public:
  shared_ptr<MountInstanceSDGResponseBodyData> data{};
  shared_ptr<string> requestId{};

  MountInstanceSDGResponseBody() {}

  explicit MountInstanceSDGResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        MountInstanceSDGResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<MountInstanceSDGResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MountInstanceSDGResponseBody() = default;
};
class MountInstanceSDGResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MountInstanceSDGResponseBody> body{};

  MountInstanceSDGResponse() {}

  explicit MountInstanceSDGResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MountInstanceSDGResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MountInstanceSDGResponseBody>(model1);
      }
    }
  }


  virtual ~MountInstanceSDGResponse() = default;
};
class PreloadRegionSDGRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> destinationRegionIds{};
  shared_ptr<vector<string>> namespaces{};
  shared_ptr<long> redundantNum{};
  shared_ptr<string> SDGId{};

  PreloadRegionSDGRequest() {}

  explicit PreloadRegionSDGRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationRegionIds) {
      res["DestinationRegionIds"] = boost::any(*destinationRegionIds);
    }
    if (namespaces) {
      res["Namespaces"] = boost::any(*namespaces);
    }
    if (redundantNum) {
      res["RedundantNum"] = boost::any(*redundantNum);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationRegionIds") != m.end() && !m["DestinationRegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DestinationRegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DestinationRegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      destinationRegionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Namespaces") != m.end() && !m["Namespaces"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Namespaces"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Namespaces"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      namespaces = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RedundantNum") != m.end() && !m["RedundantNum"].empty()) {
      redundantNum = make_shared<long>(boost::any_cast<long>(m["RedundantNum"]));
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~PreloadRegionSDGRequest() = default;
};
class PreloadRegionSDGShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> destinationRegionIdsShrink{};
  shared_ptr<string> namespacesShrink{};
  shared_ptr<long> redundantNum{};
  shared_ptr<string> SDGId{};

  PreloadRegionSDGShrinkRequest() {}

  explicit PreloadRegionSDGShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationRegionIdsShrink) {
      res["DestinationRegionIds"] = boost::any(*destinationRegionIdsShrink);
    }
    if (namespacesShrink) {
      res["Namespaces"] = boost::any(*namespacesShrink);
    }
    if (redundantNum) {
      res["RedundantNum"] = boost::any(*redundantNum);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationRegionIds") != m.end() && !m["DestinationRegionIds"].empty()) {
      destinationRegionIdsShrink = make_shared<string>(boost::any_cast<string>(m["DestinationRegionIds"]));
    }
    if (m.find("Namespaces") != m.end() && !m["Namespaces"].empty()) {
      namespacesShrink = make_shared<string>(boost::any_cast<string>(m["Namespaces"]));
    }
    if (m.find("RedundantNum") != m.end() && !m["RedundantNum"].empty()) {
      redundantNum = make_shared<long>(boost::any_cast<long>(m["RedundantNum"]));
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~PreloadRegionSDGShrinkRequest() = default;
};
class PreloadRegionSDGResponseBodyDataResultFailedItems : public Darabonba::Model {
public:
  shared_ptr<string> destinationRegionId{};
  shared_ptr<string> errorMessage{};

  PreloadRegionSDGResponseBodyDataResultFailedItems() {}

  explicit PreloadRegionSDGResponseBodyDataResultFailedItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationRegionId) {
      res["DestinationRegionId"] = boost::any(*destinationRegionId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationRegionId") != m.end() && !m["DestinationRegionId"].empty()) {
      destinationRegionId = make_shared<string>(boost::any_cast<string>(m["DestinationRegionId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~PreloadRegionSDGResponseBodyDataResultFailedItems() = default;
};
class PreloadRegionSDGResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<long> failedCount{};
  shared_ptr<vector<PreloadRegionSDGResponseBodyDataResultFailedItems>> failedItems{};
  shared_ptr<long> successCount{};

  PreloadRegionSDGResponseBodyDataResult() {}

  explicit PreloadRegionSDGResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedCount) {
      res["FailedCount"] = boost::any(*failedCount);
    }
    if (failedItems) {
      vector<boost::any> temp1;
      for(auto item1:*failedItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedItems"] = boost::any(temp1);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedCount") != m.end() && !m["FailedCount"].empty()) {
      failedCount = make_shared<long>(boost::any_cast<long>(m["FailedCount"]));
    }
    if (m.find("FailedItems") != m.end() && !m["FailedItems"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedItems"].type()) {
        vector<PreloadRegionSDGResponseBodyDataResultFailedItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PreloadRegionSDGResponseBodyDataResultFailedItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedItems = make_shared<vector<PreloadRegionSDGResponseBodyDataResultFailedItems>>(expect1);
      }
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
  }


  virtual ~PreloadRegionSDGResponseBodyDataResult() = default;
};
class PreloadRegionSDGResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<PreloadRegionSDGResponseBodyDataResult> result{};
  shared_ptr<bool> success{};

  PreloadRegionSDGResponseBodyData() {}

  explicit PreloadRegionSDGResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        PreloadRegionSDGResponseBodyDataResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<PreloadRegionSDGResponseBodyDataResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PreloadRegionSDGResponseBodyData() = default;
};
class PreloadRegionSDGResponseBody : public Darabonba::Model {
public:
  shared_ptr<PreloadRegionSDGResponseBodyData> data{};
  shared_ptr<string> requestId{};

  PreloadRegionSDGResponseBody() {}

  explicit PreloadRegionSDGResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        PreloadRegionSDGResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<PreloadRegionSDGResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PreloadRegionSDGResponseBody() = default;
};
class PreloadRegionSDGResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PreloadRegionSDGResponseBody> body{};

  PreloadRegionSDGResponse() {}

  explicit PreloadRegionSDGResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PreloadRegionSDGResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PreloadRegionSDGResponseBody>(model1);
      }
    }
  }


  virtual ~PreloadRegionSDGResponse() = default;
};
class PrepareUploadRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucketName{};
  shared_ptr<string> clientIp{};

  PrepareUploadRequest() {}

  explicit PrepareUploadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
  }


  virtual ~PrepareUploadRequest() = default;
};
class PrepareUploadResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bucketName{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> requestId{};

  PrepareUploadResponseBody() {}

  explicit PrepareUploadResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PrepareUploadResponseBody() = default;
};
class PrepareUploadResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PrepareUploadResponseBody> body{};

  PrepareUploadResponse() {}

  explicit PrepareUploadResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PrepareUploadResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PrepareUploadResponseBody>(model1);
      }
    }
  }


  virtual ~PrepareUploadResponse() = default;
};
class PushApplicationDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> data{};
  shared_ptr<string> pushStrategy{};
  shared_ptr<long> timeout{};

  PushApplicationDataRequest() {}

  explicit PushApplicationDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (pushStrategy) {
      res["PushStrategy"] = boost::any(*pushStrategy);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("PushStrategy") != m.end() && !m["PushStrategy"].empty()) {
      pushStrategy = make_shared<string>(boost::any_cast<string>(m["PushStrategy"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~PushApplicationDataRequest() = default;
};
class PushApplicationDataResponseBodyPushResultsPushResult : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> resultCode{};
  shared_ptr<string> resultDescrip{};
  shared_ptr<string> version{};

  PushApplicationDataResponseBodyPushResultsPushResult() {}

  explicit PushApplicationDataResponseBodyPushResultsPushResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultDescrip) {
      res["ResultDescrip"] = boost::any(*resultDescrip);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<long>(boost::any_cast<long>(m["ResultCode"]));
    }
    if (m.find("ResultDescrip") != m.end() && !m["ResultDescrip"].empty()) {
      resultDescrip = make_shared<string>(boost::any_cast<string>(m["ResultDescrip"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~PushApplicationDataResponseBodyPushResultsPushResult() = default;
};
class PushApplicationDataResponseBodyPushResults : public Darabonba::Model {
public:
  shared_ptr<vector<PushApplicationDataResponseBodyPushResultsPushResult>> pushResult{};

  PushApplicationDataResponseBodyPushResults() {}

  explicit PushApplicationDataResponseBodyPushResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushResult) {
      vector<boost::any> temp1;
      for(auto item1:*pushResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PushResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushResult") != m.end() && !m["PushResult"].empty()) {
      if (typeid(vector<boost::any>) == m["PushResult"].type()) {
        vector<PushApplicationDataResponseBodyPushResultsPushResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PushResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PushApplicationDataResponseBodyPushResultsPushResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pushResult = make_shared<vector<PushApplicationDataResponseBodyPushResultsPushResult>>(expect1);
      }
    }
  }


  virtual ~PushApplicationDataResponseBodyPushResults() = default;
};
class PushApplicationDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<PushApplicationDataResponseBodyPushResults> pushResults{};
  shared_ptr<string> requestId{};

  PushApplicationDataResponseBody() {}

  explicit PushApplicationDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushResults) {
      res["PushResults"] = pushResults ? boost::any(pushResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushResults") != m.end() && !m["PushResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["PushResults"].type()) {
        PushApplicationDataResponseBodyPushResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PushResults"]));
        pushResults = make_shared<PushApplicationDataResponseBodyPushResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PushApplicationDataResponseBody() = default;
};
class PushApplicationDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PushApplicationDataResponseBody> body{};

  PushApplicationDataResponse() {}

  explicit PushApplicationDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PushApplicationDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PushApplicationDataResponseBody>(model1);
      }
    }
  }


  virtual ~PushApplicationDataResponse() = default;
};
class PutBucketRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucketAcl{};
  shared_ptr<string> bucketName{};
  shared_ptr<string> comment{};
  shared_ptr<string> dispatchScope{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> logicalBucketType{};

  PutBucketRequest() {}

  explicit PutBucketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketAcl) {
      res["BucketAcl"] = boost::any(*bucketAcl);
    }
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (dispatchScope) {
      res["DispatchScope"] = boost::any(*dispatchScope);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (logicalBucketType) {
      res["LogicalBucketType"] = boost::any(*logicalBucketType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketAcl") != m.end() && !m["BucketAcl"].empty()) {
      bucketAcl = make_shared<string>(boost::any_cast<string>(m["BucketAcl"]));
    }
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("DispatchScope") != m.end() && !m["DispatchScope"].empty()) {
      dispatchScope = make_shared<string>(boost::any_cast<string>(m["DispatchScope"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("LogicalBucketType") != m.end() && !m["LogicalBucketType"].empty()) {
      logicalBucketType = make_shared<string>(boost::any_cast<string>(m["LogicalBucketType"]));
    }
  }


  virtual ~PutBucketRequest() = default;
};
class PutBucketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  PutBucketResponseBody() {}

  explicit PutBucketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PutBucketResponseBody() = default;
};
class PutBucketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutBucketResponseBody> body{};

  PutBucketResponse() {}

  explicit PutBucketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutBucketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutBucketResponseBody>(model1);
      }
    }
  }


  virtual ~PutBucketResponse() = default;
};
class PutBucketAclRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucketAcl{};
  shared_ptr<string> bucketName{};

  PutBucketAclRequest() {}

  explicit PutBucketAclRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketAcl) {
      res["BucketAcl"] = boost::any(*bucketAcl);
    }
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketAcl") != m.end() && !m["BucketAcl"].empty()) {
      bucketAcl = make_shared<string>(boost::any_cast<string>(m["BucketAcl"]));
    }
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
  }


  virtual ~PutBucketAclRequest() = default;
};
class PutBucketAclResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  PutBucketAclResponseBody() {}

  explicit PutBucketAclResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PutBucketAclResponseBody() = default;
};
class PutBucketAclResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutBucketAclResponseBody> body{};

  PutBucketAclResponse() {}

  explicit PutBucketAclResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutBucketAclResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutBucketAclResponseBody>(model1);
      }
    }
  }


  virtual ~PutBucketAclResponse() = default;
};
class PutBucketLifecycleRequest : public Darabonba::Model {
public:
  shared_ptr<string> allowSameActionOverlap{};
  shared_ptr<string> bucketName{};
  shared_ptr<string> createdBeforeDate{};
  shared_ptr<long> expirationDays{};
  shared_ptr<string> prefix{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> status{};

  PutBucketLifecycleRequest() {}

  explicit PutBucketLifecycleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowSameActionOverlap) {
      res["AllowSameActionOverlap"] = boost::any(*allowSameActionOverlap);
    }
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (createdBeforeDate) {
      res["CreatedBeforeDate"] = boost::any(*createdBeforeDate);
    }
    if (expirationDays) {
      res["ExpirationDays"] = boost::any(*expirationDays);
    }
    if (prefix) {
      res["Prefix"] = boost::any(*prefix);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowSameActionOverlap") != m.end() && !m["AllowSameActionOverlap"].empty()) {
      allowSameActionOverlap = make_shared<string>(boost::any_cast<string>(m["AllowSameActionOverlap"]));
    }
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("CreatedBeforeDate") != m.end() && !m["CreatedBeforeDate"].empty()) {
      createdBeforeDate = make_shared<string>(boost::any_cast<string>(m["CreatedBeforeDate"]));
    }
    if (m.find("ExpirationDays") != m.end() && !m["ExpirationDays"].empty()) {
      expirationDays = make_shared<long>(boost::any_cast<long>(m["ExpirationDays"]));
    }
    if (m.find("Prefix") != m.end() && !m["Prefix"].empty()) {
      prefix = make_shared<string>(boost::any_cast<string>(m["Prefix"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~PutBucketLifecycleRequest() = default;
};
class PutBucketLifecycleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> ruleId{};

  PutBucketLifecycleResponseBody() {}

  explicit PutBucketLifecycleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~PutBucketLifecycleResponseBody() = default;
};
class PutBucketLifecycleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutBucketLifecycleResponseBody> body{};

  PutBucketLifecycleResponse() {}

  explicit PutBucketLifecycleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutBucketLifecycleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutBucketLifecycleResponseBody>(model1);
      }
    }
  }


  virtual ~PutBucketLifecycleResponse() = default;
};
class ReInitDiskRequest : public Darabonba::Model {
public:
  shared_ptr<string> diskId{};
  shared_ptr<string> imageId{};

  ReInitDiskRequest() {}

  explicit ReInitDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
  }


  virtual ~ReInitDiskRequest() = default;
};
class ReInitDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  ReInitDiskResponseBody() {}

  explicit ReInitDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReInitDiskResponseBody() = default;
};
class ReInitDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReInitDiskResponseBody> body{};

  ReInitDiskResponse() {}

  explicit ReInitDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReInitDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReInitDiskResponseBody>(model1);
      }
    }
  }


  virtual ~ReInitDiskResponse() = default;
};
class RebootAICInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> serverId{};

  RebootAICInstanceRequest() {}

  explicit RebootAICInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
  }


  virtual ~RebootAICInstanceRequest() = default;
};
class RebootAICInstanceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceIdsShrink{};
  shared_ptr<string> serverId{};

  RebootAICInstanceShrinkRequest() {}

  explicit RebootAICInstanceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceIdsShrink) {
      res["InstanceIds"] = boost::any(*instanceIdsShrink);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
  }


  virtual ~RebootAICInstanceShrinkRequest() = default;
};
class RebootAICInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RebootAICInstanceResponseBody() {}

  explicit RebootAICInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RebootAICInstanceResponseBody() = default;
};
class RebootAICInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RebootAICInstanceResponseBody> body{};

  RebootAICInstanceResponse() {}

  explicit RebootAICInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RebootAICInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RebootAICInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RebootAICInstanceResponse() = default;
};
class RebootARMServerInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> serverId{};

  RebootARMServerInstanceRequest() {}

  explicit RebootARMServerInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
  }


  virtual ~RebootARMServerInstanceRequest() = default;
};
class RebootARMServerInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RebootARMServerInstanceResponseBody() {}

  explicit RebootARMServerInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RebootARMServerInstanceResponseBody() = default;
};
class RebootARMServerInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RebootARMServerInstanceResponseBody> body{};

  RebootARMServerInstanceResponse() {}

  explicit RebootARMServerInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RebootARMServerInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RebootARMServerInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RebootARMServerInstanceResponse() = default;
};
class RebootInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> forceStop{};
  shared_ptr<string> instanceId{};

  RebootInstanceRequest() {}

  explicit RebootInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forceStop) {
      res["ForceStop"] = boost::any(*forceStop);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForceStop") != m.end() && !m["ForceStop"].empty()) {
      forceStop = make_shared<string>(boost::any_cast<string>(m["ForceStop"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~RebootInstanceRequest() = default;
};
class RebootInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  RebootInstanceResponseBody() {}

  explicit RebootInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RebootInstanceResponseBody() = default;
};
class RebootInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RebootInstanceResponseBody> body{};

  RebootInstanceResponse() {}

  explicit RebootInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RebootInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RebootInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RebootInstanceResponse() = default;
};
class RebootInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};

  RebootInstancesRequest() {}

  explicit RebootInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RebootInstancesRequest() = default;
};
class RebootInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIdsShrink{};

  RebootInstancesShrinkRequest() {}

  explicit RebootInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIdsShrink) {
      res["InstanceIds"] = boost::any(*instanceIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
  }


  virtual ~RebootInstancesShrinkRequest() = default;
};
class RebootInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<InstanceOperateResponse>> instanceResponses{};
  shared_ptr<string> requestId{};

  RebootInstancesResponseBody() {}

  explicit RebootInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceResponses) {
      vector<boost::any> temp1;
      for(auto item1:*instanceResponses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceResponses"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceResponses") != m.end() && !m["InstanceResponses"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceResponses"].type()) {
        vector<InstanceOperateResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceResponses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InstanceOperateResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceResponses = make_shared<vector<InstanceOperateResponse>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RebootInstancesResponseBody() = default;
};
class RebootInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RebootInstancesResponseBody> body{};

  RebootInstancesResponse() {}

  explicit RebootInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RebootInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RebootInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~RebootInstancesResponse() = default;
};
class RecoverAICInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> serverId{};

  RecoverAICInstanceRequest() {}

  explicit RecoverAICInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
  }


  virtual ~RecoverAICInstanceRequest() = default;
};
class RecoverAICInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RecoverAICInstanceResponseBody() {}

  explicit RecoverAICInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RecoverAICInstanceResponseBody() = default;
};
class RecoverAICInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RecoverAICInstanceResponseBody> body{};

  RecoverAICInstanceResponse() {}

  explicit RecoverAICInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RecoverAICInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RecoverAICInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RecoverAICInstanceResponse() = default;
};
class ReinitInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> password{};

  ReinitInstanceRequest() {}

  explicit ReinitInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
  }


  virtual ~ReinitInstanceRequest() = default;
};
class ReinitInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReinitInstanceResponseBody() {}

  explicit ReinitInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReinitInstanceResponseBody() = default;
};
class ReinitInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReinitInstanceResponseBody> body{};

  ReinitInstanceResponse() {}

  explicit ReinitInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReinitInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReinitInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ReinitInstanceResponse() = default;
};
class ReinitInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> password{};

  ReinitInstancesRequest() {}

  explicit ReinitInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
  }


  virtual ~ReinitInstancesRequest() = default;
};
class ReinitInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceIdsShrink{};
  shared_ptr<string> password{};

  ReinitInstancesShrinkRequest() {}

  explicit ReinitInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceIdsShrink) {
      res["InstanceIds"] = boost::any(*instanceIdsShrink);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
  }


  virtual ~ReinitInstancesShrinkRequest() = default;
};
class ReinitInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<InstanceOperateResponse>> instanceResponses{};
  shared_ptr<string> requestId{};

  ReinitInstancesResponseBody() {}

  explicit ReinitInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceResponses) {
      vector<boost::any> temp1;
      for(auto item1:*instanceResponses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceResponses"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceResponses") != m.end() && !m["InstanceResponses"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceResponses"].type()) {
        vector<InstanceOperateResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceResponses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InstanceOperateResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceResponses = make_shared<vector<InstanceOperateResponse>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReinitInstancesResponseBody() = default;
};
class ReinitInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReinitInstancesResponseBody> body{};

  ReinitInstancesResponse() {}

  explicit ReinitInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReinitInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReinitInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ReinitInstancesResponse() = default;
};
class ReleaseAICInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> serverId{};

  ReleaseAICInstanceRequest() {}

  explicit ReleaseAICInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
  }


  virtual ~ReleaseAICInstanceRequest() = default;
};
class ReleaseAICInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseAICInstanceResponseBody() {}

  explicit ReleaseAICInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseAICInstanceResponseBody() = default;
};
class ReleaseAICInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseAICInstanceResponseBody> body{};

  ReleaseAICInstanceResponse() {}

  explicit ReleaseAICInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseAICInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseAICInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseAICInstanceResponse() = default;
};
class ReleaseARMServerInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ReleaseARMServerInstanceRequest() {}

  explicit ReleaseARMServerInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ReleaseARMServerInstanceRequest() = default;
};
class ReleaseARMServerInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseARMServerInstanceResponseBody() {}

  explicit ReleaseARMServerInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseARMServerInstanceResponseBody() = default;
};
class ReleaseARMServerInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseARMServerInstanceResponseBody> body{};

  ReleaseARMServerInstanceResponse() {}

  explicit ReleaseARMServerInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseARMServerInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseARMServerInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseARMServerInstanceResponse() = default;
};
class ReleaseInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ReleaseInstanceRequest() {}

  explicit ReleaseInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ReleaseInstanceRequest() = default;
};
class ReleaseInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceType{};

  ReleaseInstanceResponseBody() {}

  explicit ReleaseInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ReleaseInstanceResponseBody() = default;
};
class ReleaseInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseInstanceResponseBody> body{};

  ReleaseInstanceResponse() {}

  explicit ReleaseInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseInstanceResponse() = default;
};
class ReleasePostPaidInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ReleasePostPaidInstanceRequest() {}

  explicit ReleasePostPaidInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ReleasePostPaidInstanceRequest() = default;
};
class ReleasePostPaidInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleasePostPaidInstanceResponseBody() {}

  explicit ReleasePostPaidInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleasePostPaidInstanceResponseBody() = default;
};
class ReleasePostPaidInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleasePostPaidInstanceResponseBody> body{};

  ReleasePostPaidInstanceResponse() {}

  explicit ReleasePostPaidInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleasePostPaidInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleasePostPaidInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ReleasePostPaidInstanceResponse() = default;
};
class ReleasePrePaidInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ReleasePrePaidInstanceRequest() {}

  explicit ReleasePrePaidInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ReleasePrePaidInstanceRequest() = default;
};
class ReleasePrePaidInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleasePrePaidInstanceResponseBody() {}

  explicit ReleasePrePaidInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleasePrePaidInstanceResponseBody() = default;
};
class ReleasePrePaidInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleasePrePaidInstanceResponseBody> body{};

  ReleasePrePaidInstanceResponse() {}

  explicit ReleasePrePaidInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleasePrePaidInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleasePrePaidInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ReleasePrePaidInstanceResponse() = default;
};
class RemoveBackendServersRequestBackendServers : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<long> port{};
  shared_ptr<string> serverId{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  RemoveBackendServersRequestBackendServers() {}

  explicit RemoveBackendServersRequestBackendServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~RemoveBackendServersRequestBackendServers() = default;
};
class RemoveBackendServersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<RemoveBackendServersRequestBackendServers>> backendServers{};
  shared_ptr<string> loadBalancerId{};

  RemoveBackendServersRequest() {}

  explicit RemoveBackendServersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServers) {
      vector<boost::any> temp1;
      for(auto item1:*backendServers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendServers"] = boost::any(temp1);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendServers"].type()) {
        vector<RemoveBackendServersRequestBackendServers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendServers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RemoveBackendServersRequestBackendServers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendServers = make_shared<vector<RemoveBackendServersRequestBackendServers>>(expect1);
      }
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~RemoveBackendServersRequest() = default;
};
class RemoveBackendServersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> backendServersShrink{};
  shared_ptr<string> loadBalancerId{};

  RemoveBackendServersShrinkRequest() {}

  explicit RemoveBackendServersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServersShrink) {
      res["BackendServers"] = boost::any(*backendServersShrink);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      backendServersShrink = make_shared<string>(boost::any_cast<string>(m["BackendServers"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~RemoveBackendServersShrinkRequest() = default;
};
class RemoveBackendServersResponseBodyBackendServersBackendServer : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<long> port{};
  shared_ptr<string> serverId{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  RemoveBackendServersResponseBodyBackendServersBackendServer() {}

  explicit RemoveBackendServersResponseBodyBackendServersBackendServer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~RemoveBackendServersResponseBodyBackendServersBackendServer() = default;
};
class RemoveBackendServersResponseBodyBackendServers : public Darabonba::Model {
public:
  shared_ptr<vector<RemoveBackendServersResponseBodyBackendServersBackendServer>> backendServer{};

  RemoveBackendServersResponseBodyBackendServers() {}

  explicit RemoveBackendServersResponseBodyBackendServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServer) {
      vector<boost::any> temp1;
      for(auto item1:*backendServer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendServer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServer") != m.end() && !m["BackendServer"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendServer"].type()) {
        vector<RemoveBackendServersResponseBodyBackendServersBackendServer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendServer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RemoveBackendServersResponseBodyBackendServersBackendServer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendServer = make_shared<vector<RemoveBackendServersResponseBodyBackendServersBackendServer>>(expect1);
      }
    }
  }


  virtual ~RemoveBackendServersResponseBodyBackendServers() = default;
};
class RemoveBackendServersResponseBody : public Darabonba::Model {
public:
  shared_ptr<RemoveBackendServersResponseBodyBackendServers> backendServers{};
  shared_ptr<string> requestId{};

  RemoveBackendServersResponseBody() {}

  explicit RemoveBackendServersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServers) {
      res["BackendServers"] = backendServers ? boost::any(backendServers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackendServers"].type()) {
        RemoveBackendServersResponseBodyBackendServers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackendServers"]));
        backendServers = make_shared<RemoveBackendServersResponseBodyBackendServers>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveBackendServersResponseBody() = default;
};
class RemoveBackendServersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveBackendServersResponseBody> body{};

  RemoveBackendServersResponse() {}

  explicit RemoveBackendServersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveBackendServersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveBackendServersResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveBackendServersResponse() = default;
};
class RemoveInstanceSDGRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};

  RemoveInstanceSDGRequest() {}

  explicit RemoveInstanceSDGRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RemoveInstanceSDGRequest() = default;
};
class RemoveInstanceSDGShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIdsShrink{};

  RemoveInstanceSDGShrinkRequest() {}

  explicit RemoveInstanceSDGShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIdsShrink) {
      res["InstanceIds"] = boost::any(*instanceIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
  }


  virtual ~RemoveInstanceSDGShrinkRequest() = default;
};
class RemoveInstanceSDGResponseBodyDataResultFailedItems : public Darabonba::Model {
public:
  shared_ptr<string> errMessage{};
  shared_ptr<string> instanceId{};

  RemoveInstanceSDGResponseBodyDataResultFailedItems() {}

  explicit RemoveInstanceSDGResponseBodyDataResultFailedItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~RemoveInstanceSDGResponseBodyDataResultFailedItems() = default;
};
class RemoveInstanceSDGResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<long> failedCount{};
  shared_ptr<vector<RemoveInstanceSDGResponseBodyDataResultFailedItems>> failedItems{};
  shared_ptr<long> successCount{};

  RemoveInstanceSDGResponseBodyDataResult() {}

  explicit RemoveInstanceSDGResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedCount) {
      res["FailedCount"] = boost::any(*failedCount);
    }
    if (failedItems) {
      vector<boost::any> temp1;
      for(auto item1:*failedItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedItems"] = boost::any(temp1);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedCount") != m.end() && !m["FailedCount"].empty()) {
      failedCount = make_shared<long>(boost::any_cast<long>(m["FailedCount"]));
    }
    if (m.find("FailedItems") != m.end() && !m["FailedItems"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedItems"].type()) {
        vector<RemoveInstanceSDGResponseBodyDataResultFailedItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RemoveInstanceSDGResponseBodyDataResultFailedItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedItems = make_shared<vector<RemoveInstanceSDGResponseBodyDataResultFailedItems>>(expect1);
      }
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
  }


  virtual ~RemoveInstanceSDGResponseBodyDataResult() = default;
};
class RemoveInstanceSDGResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<RemoveInstanceSDGResponseBodyDataResult> result{};
  shared_ptr<bool> success{};

  RemoveInstanceSDGResponseBodyData() {}

  explicit RemoveInstanceSDGResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        RemoveInstanceSDGResponseBodyDataResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<RemoveInstanceSDGResponseBodyDataResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemoveInstanceSDGResponseBodyData() = default;
};
class RemoveInstanceSDGResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<RemoveInstanceSDGResponseBodyData> data{};
  shared_ptr<string> requestId{};

  RemoveInstanceSDGResponseBody() {}

  explicit RemoveInstanceSDGResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RemoveInstanceSDGResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RemoveInstanceSDGResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveInstanceSDGResponseBody() = default;
};
class RemoveInstanceSDGResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveInstanceSDGResponseBody> body{};

  RemoveInstanceSDGResponse() {}

  explicit RemoveInstanceSDGResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveInstanceSDGResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveInstanceSDGResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveInstanceSDGResponse() = default;
};
class RemovePublicIpsFromEpnInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> instanceInfos{};

  RemovePublicIpsFromEpnInstanceRequest() {}

  explicit RemovePublicIpsFromEpnInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (instanceInfos) {
      res["InstanceInfos"] = boost::any(*instanceInfos);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("InstanceInfos") != m.end() && !m["InstanceInfos"].empty()) {
      instanceInfos = make_shared<string>(boost::any_cast<string>(m["InstanceInfos"]));
    }
  }


  virtual ~RemovePublicIpsFromEpnInstanceRequest() = default;
};
class RemovePublicIpsFromEpnInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemovePublicIpsFromEpnInstanceResponseBody() {}

  explicit RemovePublicIpsFromEpnInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemovePublicIpsFromEpnInstanceResponseBody() = default;
};
class RemovePublicIpsFromEpnInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemovePublicIpsFromEpnInstanceResponseBody> body{};

  RemovePublicIpsFromEpnInstanceResponse() {}

  explicit RemovePublicIpsFromEpnInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemovePublicIpsFromEpnInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemovePublicIpsFromEpnInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RemovePublicIpsFromEpnInstanceResponse() = default;
};
class RemoveSDGRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};

  RemoveSDGRequest() {}

  explicit RemoveSDGRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RemoveSDGRequest() = default;
};
class RemoveSDGShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIdsShrink{};

  RemoveSDGShrinkRequest() {}

  explicit RemoveSDGShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIdsShrink) {
      res["InstanceIds"] = boost::any(*instanceIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
  }


  virtual ~RemoveSDGShrinkRequest() = default;
};
class RemoveSDGResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveSDGResponseBody() {}

  explicit RemoveSDGResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveSDGResponseBody() = default;
};
class RemoveSDGResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveSDGResponseBody> body{};

  RemoveSDGResponse() {}

  explicit RemoveSDGResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveSDGResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveSDGResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveSDGResponse() = default;
};
class RemoveVSwitchesFromEpnInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> vSwitchesInfo{};

  RemoveVSwitchesFromEpnInstanceRequest() {}

  explicit RemoveVSwitchesFromEpnInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (vSwitchesInfo) {
      res["VSwitchesInfo"] = boost::any(*vSwitchesInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("VSwitchesInfo") != m.end() && !m["VSwitchesInfo"].empty()) {
      vSwitchesInfo = make_shared<string>(boost::any_cast<string>(m["VSwitchesInfo"]));
    }
  }


  virtual ~RemoveVSwitchesFromEpnInstanceRequest() = default;
};
class RemoveVSwitchesFromEpnInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveVSwitchesFromEpnInstanceResponseBody() {}

  explicit RemoveVSwitchesFromEpnInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveVSwitchesFromEpnInstanceResponseBody() = default;
};
class RemoveVSwitchesFromEpnInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveVSwitchesFromEpnInstanceResponseBody> body{};

  RemoveVSwitchesFromEpnInstanceResponse() {}

  explicit RemoveVSwitchesFromEpnInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveVSwitchesFromEpnInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveVSwitchesFromEpnInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveVSwitchesFromEpnInstanceResponse() = default;
};
class RenewARMServerInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};

  RenewARMServerInstanceRequest() {}

  explicit RenewARMServerInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
  }


  virtual ~RenewARMServerInstanceRequest() = default;
};
class RenewARMServerInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RenewARMServerInstanceResponseBody() {}

  explicit RenewARMServerInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RenewARMServerInstanceResponseBody() = default;
};
class RenewARMServerInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenewARMServerInstanceResponseBody> body{};

  RenewARMServerInstanceResponse() {}

  explicit RenewARMServerInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenewARMServerInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenewARMServerInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RenewARMServerInstanceResponse() = default;
};
class RenewInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> period{};

  RenewInstanceRequest() {}

  explicit RenewInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
  }


  virtual ~RenewInstanceRequest() = default;
};
class RenewInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RenewInstanceResponseBody() {}

  explicit RenewInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RenewInstanceResponseBody() = default;
};
class RenewInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenewInstanceResponseBody> body{};

  RenewInstanceResponse() {}

  explicit RenewInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenewInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenewInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RenewInstanceResponse() = default;
};
class RescaleApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> rescaleLevel{};
  shared_ptr<string> rescaleType{};
  shared_ptr<string> resourceSelector{};
  shared_ptr<long> timeout{};
  shared_ptr<string> toAppVersion{};

  RescaleApplicationRequest() {}

  explicit RescaleApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (rescaleLevel) {
      res["RescaleLevel"] = boost::any(*rescaleLevel);
    }
    if (rescaleType) {
      res["RescaleType"] = boost::any(*rescaleType);
    }
    if (resourceSelector) {
      res["ResourceSelector"] = boost::any(*resourceSelector);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (toAppVersion) {
      res["ToAppVersion"] = boost::any(*toAppVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RescaleLevel") != m.end() && !m["RescaleLevel"].empty()) {
      rescaleLevel = make_shared<string>(boost::any_cast<string>(m["RescaleLevel"]));
    }
    if (m.find("RescaleType") != m.end() && !m["RescaleType"].empty()) {
      rescaleType = make_shared<string>(boost::any_cast<string>(m["RescaleType"]));
    }
    if (m.find("ResourceSelector") != m.end() && !m["ResourceSelector"].empty()) {
      resourceSelector = make_shared<string>(boost::any_cast<string>(m["ResourceSelector"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("ToAppVersion") != m.end() && !m["ToAppVersion"].empty()) {
      toAppVersion = make_shared<string>(boost::any_cast<string>(m["ToAppVersion"]));
    }
  }


  virtual ~RescaleApplicationRequest() = default;
};
class RescaleApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RescaleApplicationResponseBody() {}

  explicit RescaleApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RescaleApplicationResponseBody() = default;
};
class RescaleApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RescaleApplicationResponseBody> body{};

  RescaleApplicationResponse() {}

  explicit RescaleApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RescaleApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RescaleApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~RescaleApplicationResponse() = default;
};
class RescaleDeviceServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> imageId{};
  shared_ptr<long> ipType{};
  shared_ptr<string> rescaleLevel{};
  shared_ptr<string> rescaleType{};
  shared_ptr<string> resourceInfo{};
  shared_ptr<string> resourceSelector{};
  shared_ptr<string> resourceSpec{};
  shared_ptr<string> serviceId{};
  shared_ptr<long> timeout{};

  RescaleDeviceServiceRequest() {}

  explicit RescaleDeviceServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (rescaleLevel) {
      res["RescaleLevel"] = boost::any(*rescaleLevel);
    }
    if (rescaleType) {
      res["RescaleType"] = boost::any(*rescaleType);
    }
    if (resourceInfo) {
      res["ResourceInfo"] = boost::any(*resourceInfo);
    }
    if (resourceSelector) {
      res["ResourceSelector"] = boost::any(*resourceSelector);
    }
    if (resourceSpec) {
      res["ResourceSpec"] = boost::any(*resourceSpec);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<long>(boost::any_cast<long>(m["IpType"]));
    }
    if (m.find("RescaleLevel") != m.end() && !m["RescaleLevel"].empty()) {
      rescaleLevel = make_shared<string>(boost::any_cast<string>(m["RescaleLevel"]));
    }
    if (m.find("RescaleType") != m.end() && !m["RescaleType"].empty()) {
      rescaleType = make_shared<string>(boost::any_cast<string>(m["RescaleType"]));
    }
    if (m.find("ResourceInfo") != m.end() && !m["ResourceInfo"].empty()) {
      resourceInfo = make_shared<string>(boost::any_cast<string>(m["ResourceInfo"]));
    }
    if (m.find("ResourceSelector") != m.end() && !m["ResourceSelector"].empty()) {
      resourceSelector = make_shared<string>(boost::any_cast<string>(m["ResourceSelector"]));
    }
    if (m.find("ResourceSpec") != m.end() && !m["ResourceSpec"].empty()) {
      resourceSpec = make_shared<string>(boost::any_cast<string>(m["ResourceSpec"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["ServiceId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~RescaleDeviceServiceRequest() = default;
};
class RescaleDeviceServiceResponseBodyResourceDetailInfos : public Darabonba::Model {
public:
  shared_ptr<string> ID{};
  shared_ptr<string> IP{};
  shared_ptr<string> ISP{};
  shared_ptr<string> mac{};
  shared_ptr<string> regionID{};
  shared_ptr<string> server{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  RescaleDeviceServiceResponseBodyResourceDetailInfos() {}

  explicit RescaleDeviceServiceResponseBodyResourceDetailInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ID) {
      res["ID"] = boost::any(*ID);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (mac) {
      res["Mac"] = boost::any(*mac);
    }
    if (regionID) {
      res["RegionID"] = boost::any(*regionID);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ID") != m.end() && !m["ID"].empty()) {
      ID = make_shared<string>(boost::any_cast<string>(m["ID"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("Mac") != m.end() && !m["Mac"].empty()) {
      mac = make_shared<string>(boost::any_cast<string>(m["Mac"]));
    }
    if (m.find("RegionID") != m.end() && !m["RegionID"].empty()) {
      regionID = make_shared<string>(boost::any_cast<string>(m["RegionID"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~RescaleDeviceServiceResponseBodyResourceDetailInfos() = default;
};
class RescaleDeviceServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceIds{};
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<RescaleDeviceServiceResponseBodyResourceDetailInfos>> resourceDetailInfos{};

  RescaleDeviceServiceResponseBody() {}

  explicit RescaleDeviceServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceIds) {
      res["DeviceIds"] = boost::any(*deviceIds);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceDetailInfos) {
      vector<boost::any> temp1;
      for(auto item1:*resourceDetailInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceDetailInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceIds") != m.end() && !m["DeviceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceDetailInfos") != m.end() && !m["ResourceDetailInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceDetailInfos"].type()) {
        vector<RescaleDeviceServiceResponseBodyResourceDetailInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceDetailInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RescaleDeviceServiceResponseBodyResourceDetailInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceDetailInfos = make_shared<vector<RescaleDeviceServiceResponseBodyResourceDetailInfos>>(expect1);
      }
    }
  }


  virtual ~RescaleDeviceServiceResponseBody() = default;
};
class RescaleDeviceServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RescaleDeviceServiceResponseBody> body{};

  RescaleDeviceServiceResponse() {}

  explicit RescaleDeviceServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RescaleDeviceServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RescaleDeviceServiceResponseBody>(model1);
      }
    }
  }


  virtual ~RescaleDeviceServiceResponse() = default;
};
class ResetAICInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> serverId{};

  ResetAICInstanceRequest() {}

  explicit ResetAICInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
  }


  virtual ~ResetAICInstanceRequest() = default;
};
class ResetAICInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResetAICInstanceResponseBody() {}

  explicit ResetAICInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetAICInstanceResponseBody() = default;
};
class ResetAICInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetAICInstanceResponseBody> body{};

  ResetAICInstanceResponse() {}

  explicit ResetAICInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetAICInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetAICInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ResetAICInstanceResponse() = default;
};
class ResetDiskRequest : public Darabonba::Model {
public:
  shared_ptr<string> diskId{};
  shared_ptr<string> snapshotId{};

  ResetDiskRequest() {}

  explicit ResetDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
  }


  virtual ~ResetDiskRequest() = default;
};
class ResetDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResetDiskResponseBody() {}

  explicit ResetDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetDiskResponseBody() = default;
};
class ResetDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetDiskResponseBody> body{};

  ResetDiskResponse() {}

  explicit ResetDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetDiskResponseBody>(model1);
      }
    }
  }


  virtual ~ResetDiskResponse() = default;
};
class ResizeDiskRequest : public Darabonba::Model {
public:
  shared_ptr<string> diskId{};
  shared_ptr<string> newSize{};

  ResizeDiskRequest() {}

  explicit ResizeDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (newSize) {
      res["NewSize"] = boost::any(*newSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("NewSize") != m.end() && !m["NewSize"].empty()) {
      newSize = make_shared<string>(boost::any_cast<string>(m["NewSize"]));
    }
  }


  virtual ~ResizeDiskRequest() = default;
};
class ResizeDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  ResizeDiskResponseBody() {}

  explicit ResizeDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResizeDiskResponseBody() = default;
};
class ResizeDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResizeDiskResponseBody> body{};

  ResizeDiskResponse() {}

  explicit ResizeDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResizeDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResizeDiskResponseBody>(model1);
      }
    }
  }


  virtual ~ResizeDiskResponse() = default;
};
class RevokeSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> sourcePortRange{};

  RevokeSecurityGroupRequest() {}

  explicit RevokeSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
  }


  virtual ~RevokeSecurityGroupRequest() = default;
};
class RevokeSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeSecurityGroupResponseBody() {}

  explicit RevokeSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeSecurityGroupResponseBody() = default;
};
class RevokeSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevokeSecurityGroupResponseBody> body{};

  RevokeSecurityGroupResponse() {}

  explicit RevokeSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeSecurityGroupResponse() = default;
};
class RevokeSecurityGroupEgressRequest : public Darabonba::Model {
public:
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> sourcePortRange{};

  RevokeSecurityGroupEgressRequest() {}

  explicit RevokeSecurityGroupEgressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
  }


  virtual ~RevokeSecurityGroupEgressRequest() = default;
};
class RevokeSecurityGroupEgressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeSecurityGroupEgressResponseBody() {}

  explicit RevokeSecurityGroupEgressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeSecurityGroupEgressResponseBody() = default;
};
class RevokeSecurityGroupEgressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevokeSecurityGroupEgressResponseBody> body{};

  RevokeSecurityGroupEgressResponse() {}

  explicit RevokeSecurityGroupEgressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeSecurityGroupEgressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeSecurityGroupEgressResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeSecurityGroupEgressResponse() = default;
};
class RollbackApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> fromAppVersion{};
  shared_ptr<long> timeout{};
  shared_ptr<string> toAppVersion{};

  RollbackApplicationRequest() {}

  explicit RollbackApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (fromAppVersion) {
      res["FromAppVersion"] = boost::any(*fromAppVersion);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (toAppVersion) {
      res["ToAppVersion"] = boost::any(*toAppVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("FromAppVersion") != m.end() && !m["FromAppVersion"].empty()) {
      fromAppVersion = make_shared<string>(boost::any_cast<string>(m["FromAppVersion"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("ToAppVersion") != m.end() && !m["ToAppVersion"].empty()) {
      toAppVersion = make_shared<string>(boost::any_cast<string>(m["ToAppVersion"]));
    }
  }


  virtual ~RollbackApplicationRequest() = default;
};
class RollbackApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RollbackApplicationResponseBody() {}

  explicit RollbackApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RollbackApplicationResponseBody() = default;
};
class RollbackApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RollbackApplicationResponseBody> body{};

  RollbackApplicationResponse() {}

  explicit RollbackApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RollbackApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RollbackApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~RollbackApplicationResponse() = default;
};
class RunInstancesRequestDataDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<bool> encrypted{};
  shared_ptr<string> KMSKeyId{};
  shared_ptr<long> size{};

  RunInstancesRequestDataDisk() {}

  explicit RunInstancesRequestDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (encrypted) {
      res["Encrypted"] = boost::any(*encrypted);
    }
    if (KMSKeyId) {
      res["KMSKeyId"] = boost::any(*KMSKeyId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Encrypted") != m.end() && !m["Encrypted"].empty()) {
      encrypted = make_shared<bool>(boost::any_cast<bool>(m["Encrypted"]));
    }
    if (m.find("KMSKeyId") != m.end() && !m["KMSKeyId"].empty()) {
      KMSKeyId = make_shared<string>(boost::any_cast<string>(m["KMSKeyId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~RunInstancesRequestDataDisk() = default;
};
class RunInstancesRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> size{};

  RunInstancesRequestSystemDisk() {}

  explicit RunInstancesRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~RunInstancesRequestSystemDisk() = default;
};
class RunInstancesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  RunInstancesRequestTag() {}

  explicit RunInstancesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~RunInstancesRequestTag() = default;
};
class RunInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> autoReleaseTime{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> autoUseCoupon{};
  shared_ptr<string> billingCycle{};
  shared_ptr<string> carrier{};
  shared_ptr<vector<RunInstancesRequestDataDisk>> dataDisk{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceChargeStrategy{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> ipType{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> netDistrictCode{};
  shared_ptr<string> netWorkId{};
  shared_ptr<string> password{};
  shared_ptr<bool> passwordInherit{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<bool> publicIpIdentification{};
  shared_ptr<string> scheduleAreaLevel{};
  shared_ptr<string> schedulingPriceStrategy{};
  shared_ptr<string> schedulingStrategy{};
  shared_ptr<string> securityId{};
  shared_ptr<long> spotDuration{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<RunInstancesRequestSystemDisk> systemDisk{};
  shared_ptr<vector<RunInstancesRequestTag>> tag{};
  shared_ptr<bool> uniqueSuffix{};
  shared_ptr<string> userData{};
  shared_ptr<string> vSwitchId{};

  RunInstancesRequest() {}

  explicit RunInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (autoReleaseTime) {
      res["AutoReleaseTime"] = boost::any(*autoReleaseTime);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoUseCoupon) {
      res["AutoUseCoupon"] = boost::any(*autoUseCoupon);
    }
    if (billingCycle) {
      res["BillingCycle"] = boost::any(*billingCycle);
    }
    if (carrier) {
      res["Carrier"] = boost::any(*carrier);
    }
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceChargeStrategy) {
      res["InstanceChargeStrategy"] = boost::any(*instanceChargeStrategy);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (netDistrictCode) {
      res["NetDistrictCode"] = boost::any(*netDistrictCode);
    }
    if (netWorkId) {
      res["NetWorkId"] = boost::any(*netWorkId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (passwordInherit) {
      res["PasswordInherit"] = boost::any(*passwordInherit);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (publicIpIdentification) {
      res["PublicIpIdentification"] = boost::any(*publicIpIdentification);
    }
    if (scheduleAreaLevel) {
      res["ScheduleAreaLevel"] = boost::any(*scheduleAreaLevel);
    }
    if (schedulingPriceStrategy) {
      res["SchedulingPriceStrategy"] = boost::any(*schedulingPriceStrategy);
    }
    if (schedulingStrategy) {
      res["SchedulingStrategy"] = boost::any(*schedulingStrategy);
    }
    if (securityId) {
      res["SecurityId"] = boost::any(*securityId);
    }
    if (spotDuration) {
      res["SpotDuration"] = boost::any(*spotDuration);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (uniqueSuffix) {
      res["UniqueSuffix"] = boost::any(*uniqueSuffix);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("AutoReleaseTime") != m.end() && !m["AutoReleaseTime"].empty()) {
      autoReleaseTime = make_shared<string>(boost::any_cast<string>(m["AutoReleaseTime"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoUseCoupon") != m.end() && !m["AutoUseCoupon"].empty()) {
      autoUseCoupon = make_shared<string>(boost::any_cast<string>(m["AutoUseCoupon"]));
    }
    if (m.find("BillingCycle") != m.end() && !m["BillingCycle"].empty()) {
      billingCycle = make_shared<string>(boost::any_cast<string>(m["BillingCycle"]));
    }
    if (m.find("Carrier") != m.end() && !m["Carrier"].empty()) {
      carrier = make_shared<string>(boost::any_cast<string>(m["Carrier"]));
    }
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<RunInstancesRequestDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunInstancesRequestDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<RunInstancesRequestDataDisk>>(expect1);
      }
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceChargeStrategy") != m.end() && !m["InstanceChargeStrategy"].empty()) {
      instanceChargeStrategy = make_shared<string>(boost::any_cast<string>(m["InstanceChargeStrategy"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<string>(boost::any_cast<string>(m["IpType"]));
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("NetDistrictCode") != m.end() && !m["NetDistrictCode"].empty()) {
      netDistrictCode = make_shared<string>(boost::any_cast<string>(m["NetDistrictCode"]));
    }
    if (m.find("NetWorkId") != m.end() && !m["NetWorkId"].empty()) {
      netWorkId = make_shared<string>(boost::any_cast<string>(m["NetWorkId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PasswordInherit") != m.end() && !m["PasswordInherit"].empty()) {
      passwordInherit = make_shared<bool>(boost::any_cast<bool>(m["PasswordInherit"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("PublicIpIdentification") != m.end() && !m["PublicIpIdentification"].empty()) {
      publicIpIdentification = make_shared<bool>(boost::any_cast<bool>(m["PublicIpIdentification"]));
    }
    if (m.find("ScheduleAreaLevel") != m.end() && !m["ScheduleAreaLevel"].empty()) {
      scheduleAreaLevel = make_shared<string>(boost::any_cast<string>(m["ScheduleAreaLevel"]));
    }
    if (m.find("SchedulingPriceStrategy") != m.end() && !m["SchedulingPriceStrategy"].empty()) {
      schedulingPriceStrategy = make_shared<string>(boost::any_cast<string>(m["SchedulingPriceStrategy"]));
    }
    if (m.find("SchedulingStrategy") != m.end() && !m["SchedulingStrategy"].empty()) {
      schedulingStrategy = make_shared<string>(boost::any_cast<string>(m["SchedulingStrategy"]));
    }
    if (m.find("SecurityId") != m.end() && !m["SecurityId"].empty()) {
      securityId = make_shared<string>(boost::any_cast<string>(m["SecurityId"]));
    }
    if (m.find("SpotDuration") != m.end() && !m["SpotDuration"].empty()) {
      spotDuration = make_shared<long>(boost::any_cast<long>(m["SpotDuration"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        RunInstancesRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<RunInstancesRequestSystemDisk>(model1);
      }
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<RunInstancesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunInstancesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<RunInstancesRequestTag>>(expect1);
      }
    }
    if (m.find("UniqueSuffix") != m.end() && !m["UniqueSuffix"].empty()) {
      uniqueSuffix = make_shared<bool>(boost::any_cast<bool>(m["UniqueSuffix"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~RunInstancesRequest() = default;
};
class RunInstancesShrinkRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  RunInstancesShrinkRequestTag() {}

  explicit RunInstancesShrinkRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~RunInstancesShrinkRequestTag() = default;
};
class RunInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> autoReleaseTime{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> autoUseCoupon{};
  shared_ptr<string> billingCycle{};
  shared_ptr<string> carrier{};
  shared_ptr<string> dataDiskShrink{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceChargeStrategy{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> ipType{};
  shared_ptr<long> ipv6AddressCount{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> netDistrictCode{};
  shared_ptr<string> netWorkId{};
  shared_ptr<string> password{};
  shared_ptr<bool> passwordInherit{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<bool> publicIpIdentification{};
  shared_ptr<string> scheduleAreaLevel{};
  shared_ptr<string> schedulingPriceStrategy{};
  shared_ptr<string> schedulingStrategy{};
  shared_ptr<string> securityId{};
  shared_ptr<long> spotDuration{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> systemDiskShrink{};
  shared_ptr<vector<RunInstancesShrinkRequestTag>> tag{};
  shared_ptr<bool> uniqueSuffix{};
  shared_ptr<string> userData{};
  shared_ptr<string> vSwitchId{};

  RunInstancesShrinkRequest() {}

  explicit RunInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (autoReleaseTime) {
      res["AutoReleaseTime"] = boost::any(*autoReleaseTime);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoUseCoupon) {
      res["AutoUseCoupon"] = boost::any(*autoUseCoupon);
    }
    if (billingCycle) {
      res["BillingCycle"] = boost::any(*billingCycle);
    }
    if (carrier) {
      res["Carrier"] = boost::any(*carrier);
    }
    if (dataDiskShrink) {
      res["DataDisk"] = boost::any(*dataDiskShrink);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceChargeStrategy) {
      res["InstanceChargeStrategy"] = boost::any(*instanceChargeStrategy);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (ipv6AddressCount) {
      res["Ipv6AddressCount"] = boost::any(*ipv6AddressCount);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (netDistrictCode) {
      res["NetDistrictCode"] = boost::any(*netDistrictCode);
    }
    if (netWorkId) {
      res["NetWorkId"] = boost::any(*netWorkId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (passwordInherit) {
      res["PasswordInherit"] = boost::any(*passwordInherit);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (publicIpIdentification) {
      res["PublicIpIdentification"] = boost::any(*publicIpIdentification);
    }
    if (scheduleAreaLevel) {
      res["ScheduleAreaLevel"] = boost::any(*scheduleAreaLevel);
    }
    if (schedulingPriceStrategy) {
      res["SchedulingPriceStrategy"] = boost::any(*schedulingPriceStrategy);
    }
    if (schedulingStrategy) {
      res["SchedulingStrategy"] = boost::any(*schedulingStrategy);
    }
    if (securityId) {
      res["SecurityId"] = boost::any(*securityId);
    }
    if (spotDuration) {
      res["SpotDuration"] = boost::any(*spotDuration);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (systemDiskShrink) {
      res["SystemDisk"] = boost::any(*systemDiskShrink);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (uniqueSuffix) {
      res["UniqueSuffix"] = boost::any(*uniqueSuffix);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("AutoReleaseTime") != m.end() && !m["AutoReleaseTime"].empty()) {
      autoReleaseTime = make_shared<string>(boost::any_cast<string>(m["AutoReleaseTime"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoUseCoupon") != m.end() && !m["AutoUseCoupon"].empty()) {
      autoUseCoupon = make_shared<string>(boost::any_cast<string>(m["AutoUseCoupon"]));
    }
    if (m.find("BillingCycle") != m.end() && !m["BillingCycle"].empty()) {
      billingCycle = make_shared<string>(boost::any_cast<string>(m["BillingCycle"]));
    }
    if (m.find("Carrier") != m.end() && !m["Carrier"].empty()) {
      carrier = make_shared<string>(boost::any_cast<string>(m["Carrier"]));
    }
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      dataDiskShrink = make_shared<string>(boost::any_cast<string>(m["DataDisk"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceChargeStrategy") != m.end() && !m["InstanceChargeStrategy"].empty()) {
      instanceChargeStrategy = make_shared<string>(boost::any_cast<string>(m["InstanceChargeStrategy"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<string>(boost::any_cast<string>(m["IpType"]));
    }
    if (m.find("Ipv6AddressCount") != m.end() && !m["Ipv6AddressCount"].empty()) {
      ipv6AddressCount = make_shared<long>(boost::any_cast<long>(m["Ipv6AddressCount"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("NetDistrictCode") != m.end() && !m["NetDistrictCode"].empty()) {
      netDistrictCode = make_shared<string>(boost::any_cast<string>(m["NetDistrictCode"]));
    }
    if (m.find("NetWorkId") != m.end() && !m["NetWorkId"].empty()) {
      netWorkId = make_shared<string>(boost::any_cast<string>(m["NetWorkId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PasswordInherit") != m.end() && !m["PasswordInherit"].empty()) {
      passwordInherit = make_shared<bool>(boost::any_cast<bool>(m["PasswordInherit"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("PublicIpIdentification") != m.end() && !m["PublicIpIdentification"].empty()) {
      publicIpIdentification = make_shared<bool>(boost::any_cast<bool>(m["PublicIpIdentification"]));
    }
    if (m.find("ScheduleAreaLevel") != m.end() && !m["ScheduleAreaLevel"].empty()) {
      scheduleAreaLevel = make_shared<string>(boost::any_cast<string>(m["ScheduleAreaLevel"]));
    }
    if (m.find("SchedulingPriceStrategy") != m.end() && !m["SchedulingPriceStrategy"].empty()) {
      schedulingPriceStrategy = make_shared<string>(boost::any_cast<string>(m["SchedulingPriceStrategy"]));
    }
    if (m.find("SchedulingStrategy") != m.end() && !m["SchedulingStrategy"].empty()) {
      schedulingStrategy = make_shared<string>(boost::any_cast<string>(m["SchedulingStrategy"]));
    }
    if (m.find("SecurityId") != m.end() && !m["SecurityId"].empty()) {
      securityId = make_shared<string>(boost::any_cast<string>(m["SecurityId"]));
    }
    if (m.find("SpotDuration") != m.end() && !m["SpotDuration"].empty()) {
      spotDuration = make_shared<long>(boost::any_cast<long>(m["SpotDuration"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      systemDiskShrink = make_shared<string>(boost::any_cast<string>(m["SystemDisk"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<RunInstancesShrinkRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunInstancesShrinkRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<RunInstancesShrinkRequestTag>>(expect1);
      }
    }
    if (m.find("UniqueSuffix") != m.end() && !m["UniqueSuffix"].empty()) {
      uniqueSuffix = make_shared<bool>(boost::any_cast<bool>(m["UniqueSuffix"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~RunInstancesShrinkRequest() = default;
};
class RunInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  RunInstancesResponseBody() {}

  explicit RunInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunInstancesResponseBody() = default;
};
class RunInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunInstancesResponseBody> body{};

  RunInstancesResponse() {}

  explicit RunInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~RunInstancesResponse() = default;
};
class RunServiceScheduleRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> directorys{};
  shared_ptr<string> podConfigName{};
  shared_ptr<long> preLockedTimeout{};
  shared_ptr<string> scheduleStrategy{};
  shared_ptr<string> serviceAction{};
  shared_ptr<string> serviceCommands{};
  shared_ptr<string> uuid{};

  RunServiceScheduleRequest() {}

  explicit RunServiceScheduleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (directorys) {
      res["Directorys"] = boost::any(*directorys);
    }
    if (podConfigName) {
      res["PodConfigName"] = boost::any(*podConfigName);
    }
    if (preLockedTimeout) {
      res["PreLockedTimeout"] = boost::any(*preLockedTimeout);
    }
    if (scheduleStrategy) {
      res["ScheduleStrategy"] = boost::any(*scheduleStrategy);
    }
    if (serviceAction) {
      res["ServiceAction"] = boost::any(*serviceAction);
    }
    if (serviceCommands) {
      res["ServiceCommands"] = boost::any(*serviceCommands);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("Directorys") != m.end() && !m["Directorys"].empty()) {
      directorys = make_shared<string>(boost::any_cast<string>(m["Directorys"]));
    }
    if (m.find("PodConfigName") != m.end() && !m["PodConfigName"].empty()) {
      podConfigName = make_shared<string>(boost::any_cast<string>(m["PodConfigName"]));
    }
    if (m.find("PreLockedTimeout") != m.end() && !m["PreLockedTimeout"].empty()) {
      preLockedTimeout = make_shared<long>(boost::any_cast<long>(m["PreLockedTimeout"]));
    }
    if (m.find("ScheduleStrategy") != m.end() && !m["ScheduleStrategy"].empty()) {
      scheduleStrategy = make_shared<string>(boost::any_cast<string>(m["ScheduleStrategy"]));
    }
    if (m.find("ServiceAction") != m.end() && !m["ServiceAction"].empty()) {
      serviceAction = make_shared<string>(boost::any_cast<string>(m["ServiceAction"]));
    }
    if (m.find("ServiceCommands") != m.end() && !m["ServiceCommands"].empty()) {
      serviceCommands = make_shared<string>(boost::any_cast<string>(m["ServiceCommands"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~RunServiceScheduleRequest() = default;
};
class RunServiceScheduleResponseBodyCommandResultsCommandResult : public Darabonba::Model {
public:
  shared_ptr<string> command{};
  shared_ptr<string> containerName{};
  shared_ptr<string> resultMsg{};

  RunServiceScheduleResponseBodyCommandResultsCommandResult() {}

  explicit RunServiceScheduleResponseBodyCommandResultsCommandResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (containerName) {
      res["ContainerName"] = boost::any(*containerName);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("ContainerName") != m.end() && !m["ContainerName"].empty()) {
      containerName = make_shared<string>(boost::any_cast<string>(m["ContainerName"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
  }


  virtual ~RunServiceScheduleResponseBodyCommandResultsCommandResult() = default;
};
class RunServiceScheduleResponseBodyCommandResults : public Darabonba::Model {
public:
  shared_ptr<vector<RunServiceScheduleResponseBodyCommandResultsCommandResult>> commandResult{};

  RunServiceScheduleResponseBodyCommandResults() {}

  explicit RunServiceScheduleResponseBodyCommandResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commandResult) {
      vector<boost::any> temp1;
      for(auto item1:*commandResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CommandResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommandResult") != m.end() && !m["CommandResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CommandResult"].type()) {
        vector<RunServiceScheduleResponseBodyCommandResultsCommandResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CommandResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunServiceScheduleResponseBodyCommandResultsCommandResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        commandResult = make_shared<vector<RunServiceScheduleResponseBodyCommandResultsCommandResult>>(expect1);
      }
    }
  }


  virtual ~RunServiceScheduleResponseBodyCommandResults() = default;
};
class RunServiceScheduleResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunServiceScheduleResponseBodyCommandResults> commandResults{};
  shared_ptr<long> index{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceIp{};
  shared_ptr<long> instancePort{};
  shared_ptr<string> requestId{};
  shared_ptr<string> requestRepeated{};
  shared_ptr<bool> tcpPorts{};

  RunServiceScheduleResponseBody() {}

  explicit RunServiceScheduleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commandResults) {
      res["CommandResults"] = commandResults ? boost::any(commandResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceIp) {
      res["InstanceIp"] = boost::any(*instanceIp);
    }
    if (instancePort) {
      res["InstancePort"] = boost::any(*instancePort);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestRepeated) {
      res["RequestRepeated"] = boost::any(*requestRepeated);
    }
    if (tcpPorts) {
      res["TcpPorts"] = boost::any(*tcpPorts);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommandResults") != m.end() && !m["CommandResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommandResults"].type()) {
        RunServiceScheduleResponseBodyCommandResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommandResults"]));
        commandResults = make_shared<RunServiceScheduleResponseBodyCommandResults>(model1);
      }
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceIp") != m.end() && !m["InstanceIp"].empty()) {
      instanceIp = make_shared<string>(boost::any_cast<string>(m["InstanceIp"]));
    }
    if (m.find("InstancePort") != m.end() && !m["InstancePort"].empty()) {
      instancePort = make_shared<long>(boost::any_cast<long>(m["InstancePort"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestRepeated") != m.end() && !m["RequestRepeated"].empty()) {
      requestRepeated = make_shared<string>(boost::any_cast<string>(m["RequestRepeated"]));
    }
    if (m.find("TcpPorts") != m.end() && !m["TcpPorts"].empty()) {
      tcpPorts = make_shared<bool>(boost::any_cast<bool>(m["TcpPorts"]));
    }
  }


  virtual ~RunServiceScheduleResponseBody() = default;
};
class RunServiceScheduleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunServiceScheduleResponseBody> body{};

  RunServiceScheduleResponse() {}

  explicit RunServiceScheduleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunServiceScheduleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunServiceScheduleResponseBody>(model1);
      }
    }
  }


  virtual ~RunServiceScheduleResponse() = default;
};
class SaveSDGRequest : public Darabonba::Model {
public:
  shared_ptr<string> SDGId{};

  SaveSDGRequest() {}

  explicit SaveSDGRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~SaveSDGRequest() = default;
};
class SaveSDGResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SaveSDGResponseBody() {}

  explicit SaveSDGResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SaveSDGResponseBody() = default;
};
class SaveSDGResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveSDGResponseBody> body{};

  SaveSDGResponse() {}

  explicit SaveSDGResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveSDGResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveSDGResponseBody>(model1);
      }
    }
  }


  virtual ~SaveSDGResponse() = default;
};
class SetBackendServersRequestBackendServers : public Darabonba::Model {
public:
  shared_ptr<string> serverId{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  SetBackendServersRequestBackendServers() {}

  explicit SetBackendServersRequestBackendServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~SetBackendServersRequestBackendServers() = default;
};
class SetBackendServersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<SetBackendServersRequestBackendServers>> backendServers{};
  shared_ptr<string> loadBalancerId{};

  SetBackendServersRequest() {}

  explicit SetBackendServersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServers) {
      vector<boost::any> temp1;
      for(auto item1:*backendServers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendServers"] = boost::any(temp1);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendServers"].type()) {
        vector<SetBackendServersRequestBackendServers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendServers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetBackendServersRequestBackendServers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendServers = make_shared<vector<SetBackendServersRequestBackendServers>>(expect1);
      }
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~SetBackendServersRequest() = default;
};
class SetBackendServersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> backendServersShrink{};
  shared_ptr<string> loadBalancerId{};

  SetBackendServersShrinkRequest() {}

  explicit SetBackendServersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServersShrink) {
      res["BackendServers"] = boost::any(*backendServersShrink);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      backendServersShrink = make_shared<string>(boost::any_cast<string>(m["BackendServers"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~SetBackendServersShrinkRequest() = default;
};
class SetBackendServersResponseBodyBackendServersBackendServer : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<long> port{};
  shared_ptr<string> serverId{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  SetBackendServersResponseBodyBackendServersBackendServer() {}

  explicit SetBackendServersResponseBodyBackendServersBackendServer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~SetBackendServersResponseBodyBackendServersBackendServer() = default;
};
class SetBackendServersResponseBodyBackendServers : public Darabonba::Model {
public:
  shared_ptr<vector<SetBackendServersResponseBodyBackendServersBackendServer>> backendServer{};

  SetBackendServersResponseBodyBackendServers() {}

  explicit SetBackendServersResponseBodyBackendServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServer) {
      vector<boost::any> temp1;
      for(auto item1:*backendServer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendServer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServer") != m.end() && !m["BackendServer"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendServer"].type()) {
        vector<SetBackendServersResponseBodyBackendServersBackendServer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendServer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetBackendServersResponseBodyBackendServersBackendServer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendServer = make_shared<vector<SetBackendServersResponseBodyBackendServersBackendServer>>(expect1);
      }
    }
  }


  virtual ~SetBackendServersResponseBodyBackendServers() = default;
};
class SetBackendServersResponseBody : public Darabonba::Model {
public:
  shared_ptr<SetBackendServersResponseBodyBackendServers> backendServers{};
  shared_ptr<string> requestId{};

  SetBackendServersResponseBody() {}

  explicit SetBackendServersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServers) {
      res["BackendServers"] = backendServers ? boost::any(backendServers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackendServers"].type()) {
        SetBackendServersResponseBodyBackendServers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackendServers"]));
        backendServers = make_shared<SetBackendServersResponseBodyBackendServers>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetBackendServersResponseBody() = default;
};
class SetBackendServersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetBackendServersResponseBody> body{};

  SetBackendServersResponse() {}

  explicit SetBackendServersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetBackendServersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetBackendServersResponseBody>(model1);
      }
    }
  }


  virtual ~SetBackendServersResponse() = default;
};
class SetLoadBalancerHTTPListenerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> healthCheck{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckMethod{};
  shared_ptr<long> healthCheckTimeout{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<long> requestTimeout{};
  shared_ptr<string> scheduler{};
  shared_ptr<long> unhealthyThreshold{};
  shared_ptr<string> XForwardedFor{};

  SetLoadBalancerHTTPListenerAttributeRequest() {}

  explicit SetLoadBalancerHTTPListenerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckMethod) {
      res["HealthCheckMethod"] = boost::any(*healthCheckMethod);
    }
    if (healthCheckTimeout) {
      res["HealthCheckTimeout"] = boost::any(*healthCheckTimeout);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (requestTimeout) {
      res["RequestTimeout"] = boost::any(*requestTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    if (XForwardedFor) {
      res["XForwardedFor"] = boost::any(*XForwardedFor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckMethod") != m.end() && !m["HealthCheckMethod"].empty()) {
      healthCheckMethod = make_shared<string>(boost::any_cast<string>(m["HealthCheckMethod"]));
    }
    if (m.find("HealthCheckTimeout") != m.end() && !m["HealthCheckTimeout"].empty()) {
      healthCheckTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckTimeout"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("RequestTimeout") != m.end() && !m["RequestTimeout"].empty()) {
      requestTimeout = make_shared<long>(boost::any_cast<long>(m["RequestTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
    if (m.find("XForwardedFor") != m.end() && !m["XForwardedFor"].empty()) {
      XForwardedFor = make_shared<string>(boost::any_cast<string>(m["XForwardedFor"]));
    }
  }


  virtual ~SetLoadBalancerHTTPListenerAttributeRequest() = default;
};
class SetLoadBalancerHTTPListenerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLoadBalancerHTTPListenerAttributeResponseBody() {}

  explicit SetLoadBalancerHTTPListenerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLoadBalancerHTTPListenerAttributeResponseBody() = default;
};
class SetLoadBalancerHTTPListenerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLoadBalancerHTTPListenerAttributeResponseBody> body{};

  SetLoadBalancerHTTPListenerAttributeResponse() {}

  explicit SetLoadBalancerHTTPListenerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLoadBalancerHTTPListenerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLoadBalancerHTTPListenerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~SetLoadBalancerHTTPListenerAttributeResponse() = default;
};
class SetLoadBalancerHTTPSListenerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> healthCheck{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckMethod{};
  shared_ptr<long> healthCheckTimeout{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<long> requestTimeout{};
  shared_ptr<string> scheduler{};
  shared_ptr<string> serverCertificateId{};
  shared_ptr<long> unhealthyThreshold{};

  SetLoadBalancerHTTPSListenerAttributeRequest() {}

  explicit SetLoadBalancerHTTPSListenerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckMethod) {
      res["HealthCheckMethod"] = boost::any(*healthCheckMethod);
    }
    if (healthCheckTimeout) {
      res["HealthCheckTimeout"] = boost::any(*healthCheckTimeout);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (requestTimeout) {
      res["RequestTimeout"] = boost::any(*requestTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (serverCertificateId) {
      res["ServerCertificateId"] = boost::any(*serverCertificateId);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckMethod") != m.end() && !m["HealthCheckMethod"].empty()) {
      healthCheckMethod = make_shared<string>(boost::any_cast<string>(m["HealthCheckMethod"]));
    }
    if (m.find("HealthCheckTimeout") != m.end() && !m["HealthCheckTimeout"].empty()) {
      healthCheckTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckTimeout"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("RequestTimeout") != m.end() && !m["RequestTimeout"].empty()) {
      requestTimeout = make_shared<long>(boost::any_cast<long>(m["RequestTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("ServerCertificateId") != m.end() && !m["ServerCertificateId"].empty()) {
      serverCertificateId = make_shared<string>(boost::any_cast<string>(m["ServerCertificateId"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~SetLoadBalancerHTTPSListenerAttributeRequest() = default;
};
class SetLoadBalancerHTTPSListenerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLoadBalancerHTTPSListenerAttributeResponseBody() {}

  explicit SetLoadBalancerHTTPSListenerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLoadBalancerHTTPSListenerAttributeResponseBody() = default;
};
class SetLoadBalancerHTTPSListenerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLoadBalancerHTTPSListenerAttributeResponseBody> body{};

  SetLoadBalancerHTTPSListenerAttributeResponse() {}

  explicit SetLoadBalancerHTTPSListenerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLoadBalancerHTTPSListenerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLoadBalancerHTTPSListenerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~SetLoadBalancerHTTPSListenerAttributeResponse() = default;
};
class SetLoadBalancerStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> loadBalancerStatus{};

  SetLoadBalancerStatusRequest() {}

  explicit SetLoadBalancerStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (loadBalancerStatus) {
      res["LoadBalancerStatus"] = boost::any(*loadBalancerStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("LoadBalancerStatus") != m.end() && !m["LoadBalancerStatus"].empty()) {
      loadBalancerStatus = make_shared<string>(boost::any_cast<string>(m["LoadBalancerStatus"]));
    }
  }


  virtual ~SetLoadBalancerStatusRequest() = default;
};
class SetLoadBalancerStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLoadBalancerStatusResponseBody() {}

  explicit SetLoadBalancerStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLoadBalancerStatusResponseBody() = default;
};
class SetLoadBalancerStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLoadBalancerStatusResponseBody> body{};

  SetLoadBalancerStatusResponse() {}

  explicit SetLoadBalancerStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLoadBalancerStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLoadBalancerStatusResponseBody>(model1);
      }
    }
  }


  virtual ~SetLoadBalancerStatusResponse() = default;
};
class SetLoadBalancerTCPListenerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> eipTransmit{};
  shared_ptr<long> establishedTimeout{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<long> healthCheckConnectTimeout{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckType{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<long> persistenceTimeout{};
  shared_ptr<string> scheduler{};
  shared_ptr<long> unhealthyThreshold{};

  SetLoadBalancerTCPListenerAttributeRequest() {}

  explicit SetLoadBalancerTCPListenerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eipTransmit) {
      res["EipTransmit"] = boost::any(*eipTransmit);
    }
    if (establishedTimeout) {
      res["EstablishedTimeout"] = boost::any(*establishedTimeout);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckConnectTimeout) {
      res["HealthCheckConnectTimeout"] = boost::any(*healthCheckConnectTimeout);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckType) {
      res["HealthCheckType"] = boost::any(*healthCheckType);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (persistenceTimeout) {
      res["PersistenceTimeout"] = boost::any(*persistenceTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EipTransmit") != m.end() && !m["EipTransmit"].empty()) {
      eipTransmit = make_shared<string>(boost::any_cast<string>(m["EipTransmit"]));
    }
    if (m.find("EstablishedTimeout") != m.end() && !m["EstablishedTimeout"].empty()) {
      establishedTimeout = make_shared<long>(boost::any_cast<long>(m["EstablishedTimeout"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckConnectTimeout") != m.end() && !m["HealthCheckConnectTimeout"].empty()) {
      healthCheckConnectTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectTimeout"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckType") != m.end() && !m["HealthCheckType"].empty()) {
      healthCheckType = make_shared<string>(boost::any_cast<string>(m["HealthCheckType"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("PersistenceTimeout") != m.end() && !m["PersistenceTimeout"].empty()) {
      persistenceTimeout = make_shared<long>(boost::any_cast<long>(m["PersistenceTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~SetLoadBalancerTCPListenerAttributeRequest() = default;
};
class SetLoadBalancerTCPListenerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLoadBalancerTCPListenerAttributeResponseBody() {}

  explicit SetLoadBalancerTCPListenerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLoadBalancerTCPListenerAttributeResponseBody() = default;
};
class SetLoadBalancerTCPListenerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLoadBalancerTCPListenerAttributeResponseBody> body{};

  SetLoadBalancerTCPListenerAttributeResponse() {}

  explicit SetLoadBalancerTCPListenerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLoadBalancerTCPListenerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLoadBalancerTCPListenerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~SetLoadBalancerTCPListenerAttributeResponse() = default;
};
class SetLoadBalancerUDPListenerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> eipTransmit{};
  shared_ptr<long> establishedTimeout{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<long> healthCheckConnectTimeout{};
  shared_ptr<string> healthCheckExp{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckReq{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> scheduler{};
  shared_ptr<long> unhealthyThreshold{};

  SetLoadBalancerUDPListenerAttributeRequest() {}

  explicit SetLoadBalancerUDPListenerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eipTransmit) {
      res["EipTransmit"] = boost::any(*eipTransmit);
    }
    if (establishedTimeout) {
      res["EstablishedTimeout"] = boost::any(*establishedTimeout);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckConnectTimeout) {
      res["HealthCheckConnectTimeout"] = boost::any(*healthCheckConnectTimeout);
    }
    if (healthCheckExp) {
      res["HealthCheckExp"] = boost::any(*healthCheckExp);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckReq) {
      res["HealthCheckReq"] = boost::any(*healthCheckReq);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EipTransmit") != m.end() && !m["EipTransmit"].empty()) {
      eipTransmit = make_shared<string>(boost::any_cast<string>(m["EipTransmit"]));
    }
    if (m.find("EstablishedTimeout") != m.end() && !m["EstablishedTimeout"].empty()) {
      establishedTimeout = make_shared<long>(boost::any_cast<long>(m["EstablishedTimeout"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckConnectTimeout") != m.end() && !m["HealthCheckConnectTimeout"].empty()) {
      healthCheckConnectTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectTimeout"]));
    }
    if (m.find("HealthCheckExp") != m.end() && !m["HealthCheckExp"].empty()) {
      healthCheckExp = make_shared<string>(boost::any_cast<string>(m["HealthCheckExp"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckReq") != m.end() && !m["HealthCheckReq"].empty()) {
      healthCheckReq = make_shared<string>(boost::any_cast<string>(m["HealthCheckReq"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~SetLoadBalancerUDPListenerAttributeRequest() = default;
};
class SetLoadBalancerUDPListenerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLoadBalancerUDPListenerAttributeResponseBody() {}

  explicit SetLoadBalancerUDPListenerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLoadBalancerUDPListenerAttributeResponseBody() = default;
};
class SetLoadBalancerUDPListenerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLoadBalancerUDPListenerAttributeResponseBody> body{};

  SetLoadBalancerUDPListenerAttributeResponse() {}

  explicit SetLoadBalancerUDPListenerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLoadBalancerUDPListenerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLoadBalancerUDPListenerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~SetLoadBalancerUDPListenerAttributeResponse() = default;
};
class StartEpnInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};

  StartEpnInstanceRequest() {}

  explicit StartEpnInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
  }


  virtual ~StartEpnInstanceRequest() = default;
};
class StartEpnInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartEpnInstanceResponseBody() {}

  explicit StartEpnInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartEpnInstanceResponseBody() = default;
};
class StartEpnInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartEpnInstanceResponseBody> body{};

  StartEpnInstanceResponse() {}

  explicit StartEpnInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartEpnInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartEpnInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StartEpnInstanceResponse() = default;
};
class StartInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  StartInstanceRequest() {}

  explicit StartInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~StartInstanceRequest() = default;
};
class StartInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  StartInstanceResponseBody() {}

  explicit StartInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartInstanceResponseBody() = default;
};
class StartInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartInstanceResponseBody> body{};

  StartInstanceResponse() {}

  explicit StartInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StartInstanceResponse() = default;
};
class StartInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};

  StartInstancesRequest() {}

  explicit StartInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~StartInstancesRequest() = default;
};
class StartInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIdsShrink{};

  StartInstancesShrinkRequest() {}

  explicit StartInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIdsShrink) {
      res["InstanceIds"] = boost::any(*instanceIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
  }


  virtual ~StartInstancesShrinkRequest() = default;
};
class StartInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<InstanceOperateResponse>> instanceResponses{};
  shared_ptr<string> requestId{};

  StartInstancesResponseBody() {}

  explicit StartInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceResponses) {
      vector<boost::any> temp1;
      for(auto item1:*instanceResponses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceResponses"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceResponses") != m.end() && !m["InstanceResponses"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceResponses"].type()) {
        vector<InstanceOperateResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceResponses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InstanceOperateResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceResponses = make_shared<vector<InstanceOperateResponse>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartInstancesResponseBody() = default;
};
class StartInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartInstancesResponseBody> body{};

  StartInstancesResponse() {}

  explicit StartInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~StartInstancesResponse() = default;
};
class StartLoadBalancerListenerRequest : public Darabonba::Model {
public:
  shared_ptr<long> listenerPort{};
  shared_ptr<string> listenerProtocol{};
  shared_ptr<string> loadBalancerId{};

  StartLoadBalancerListenerRequest() {}

  explicit StartLoadBalancerListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (listenerProtocol) {
      res["ListenerProtocol"] = boost::any(*listenerProtocol);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("ListenerProtocol") != m.end() && !m["ListenerProtocol"].empty()) {
      listenerProtocol = make_shared<string>(boost::any_cast<string>(m["ListenerProtocol"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~StartLoadBalancerListenerRequest() = default;
};
class StartLoadBalancerListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartLoadBalancerListenerResponseBody() {}

  explicit StartLoadBalancerListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartLoadBalancerListenerResponseBody() = default;
};
class StartLoadBalancerListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartLoadBalancerListenerResponseBody> body{};

  StartLoadBalancerListenerResponse() {}

  explicit StartLoadBalancerListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartLoadBalancerListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartLoadBalancerListenerResponseBody>(model1);
      }
    }
  }


  virtual ~StartLoadBalancerListenerResponse() = default;
};
class StartSnatIpForSnatEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> snatEntryId{};
  shared_ptr<string> snatIp{};

  StartSnatIpForSnatEntryRequest() {}

  explicit StartSnatIpForSnatEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snatEntryId) {
      res["SnatEntryId"] = boost::any(*snatEntryId);
    }
    if (snatIp) {
      res["SnatIp"] = boost::any(*snatIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnatEntryId") != m.end() && !m["SnatEntryId"].empty()) {
      snatEntryId = make_shared<string>(boost::any_cast<string>(m["SnatEntryId"]));
    }
    if (m.find("SnatIp") != m.end() && !m["SnatIp"].empty()) {
      snatIp = make_shared<string>(boost::any_cast<string>(m["SnatIp"]));
    }
  }


  virtual ~StartSnatIpForSnatEntryRequest() = default;
};
class StartSnatIpForSnatEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartSnatIpForSnatEntryResponseBody() {}

  explicit StartSnatIpForSnatEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartSnatIpForSnatEntryResponseBody() = default;
};
class StartSnatIpForSnatEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartSnatIpForSnatEntryResponseBody> body{};

  StartSnatIpForSnatEntryResponse() {}

  explicit StartSnatIpForSnatEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartSnatIpForSnatEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartSnatIpForSnatEntryResponseBody>(model1);
      }
    }
  }


  virtual ~StartSnatIpForSnatEntryResponse() = default;
};
class StopEpnInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};

  StopEpnInstanceRequest() {}

  explicit StopEpnInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
  }


  virtual ~StopEpnInstanceRequest() = default;
};
class StopEpnInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopEpnInstanceResponseBody() {}

  explicit StopEpnInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopEpnInstanceResponseBody() = default;
};
class StopEpnInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopEpnInstanceResponseBody> body{};

  StopEpnInstanceResponse() {}

  explicit StopEpnInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopEpnInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopEpnInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StopEpnInstanceResponse() = default;
};
class StopInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> forceStop{};
  shared_ptr<string> instanceId{};

  StopInstanceRequest() {}

  explicit StopInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forceStop) {
      res["ForceStop"] = boost::any(*forceStop);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForceStop") != m.end() && !m["ForceStop"].empty()) {
      forceStop = make_shared<string>(boost::any_cast<string>(m["ForceStop"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~StopInstanceRequest() = default;
};
class StopInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  StopInstanceResponseBody() {}

  explicit StopInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopInstanceResponseBody() = default;
};
class StopInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopInstanceResponseBody> body{};

  StopInstanceResponse() {}

  explicit StopInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StopInstanceResponse() = default;
};
class StopInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};

  StopInstancesRequest() {}

  explicit StopInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~StopInstancesRequest() = default;
};
class StopInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIdsShrink{};

  StopInstancesShrinkRequest() {}

  explicit StopInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIdsShrink) {
      res["InstanceIds"] = boost::any(*instanceIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
  }


  virtual ~StopInstancesShrinkRequest() = default;
};
class StopInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<InstanceOperateResponse>> instanceResponses{};
  shared_ptr<string> requestId{};

  StopInstancesResponseBody() {}

  explicit StopInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceResponses) {
      vector<boost::any> temp1;
      for(auto item1:*instanceResponses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceResponses"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceResponses") != m.end() && !m["InstanceResponses"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceResponses"].type()) {
        vector<InstanceOperateResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceResponses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InstanceOperateResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceResponses = make_shared<vector<InstanceOperateResponse>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopInstancesResponseBody() = default;
};
class StopInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopInstancesResponseBody> body{};

  StopInstancesResponse() {}

  explicit StopInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~StopInstancesResponse() = default;
};
class StopLoadBalancerListenerRequest : public Darabonba::Model {
public:
  shared_ptr<long> listenerPort{};
  shared_ptr<string> listenerProtocol{};
  shared_ptr<string> loadBalancerId{};

  StopLoadBalancerListenerRequest() {}

  explicit StopLoadBalancerListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (listenerProtocol) {
      res["ListenerProtocol"] = boost::any(*listenerProtocol);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("ListenerProtocol") != m.end() && !m["ListenerProtocol"].empty()) {
      listenerProtocol = make_shared<string>(boost::any_cast<string>(m["ListenerProtocol"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~StopLoadBalancerListenerRequest() = default;
};
class StopLoadBalancerListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopLoadBalancerListenerResponseBody() {}

  explicit StopLoadBalancerListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopLoadBalancerListenerResponseBody() = default;
};
class StopLoadBalancerListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopLoadBalancerListenerResponseBody> body{};

  StopLoadBalancerListenerResponse() {}

  explicit StopLoadBalancerListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopLoadBalancerListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopLoadBalancerListenerResponseBody>(model1);
      }
    }
  }


  virtual ~StopLoadBalancerListenerResponse() = default;
};
class StopSnatIpForSnatEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> snatEntryId{};
  shared_ptr<string> snatIp{};

  StopSnatIpForSnatEntryRequest() {}

  explicit StopSnatIpForSnatEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snatEntryId) {
      res["SnatEntryId"] = boost::any(*snatEntryId);
    }
    if (snatIp) {
      res["SnatIp"] = boost::any(*snatIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnatEntryId") != m.end() && !m["SnatEntryId"].empty()) {
      snatEntryId = make_shared<string>(boost::any_cast<string>(m["SnatEntryId"]));
    }
    if (m.find("SnatIp") != m.end() && !m["SnatIp"].empty()) {
      snatIp = make_shared<string>(boost::any_cast<string>(m["SnatIp"]));
    }
  }


  virtual ~StopSnatIpForSnatEntryRequest() = default;
};
class StopSnatIpForSnatEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopSnatIpForSnatEntryResponseBody() {}

  explicit StopSnatIpForSnatEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopSnatIpForSnatEntryResponseBody() = default;
};
class StopSnatIpForSnatEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopSnatIpForSnatEntryResponseBody> body{};

  StopSnatIpForSnatEntryResponse() {}

  explicit StopSnatIpForSnatEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopSnatIpForSnatEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopSnatIpForSnatEntryResponseBody>(model1);
      }
    }
  }


  virtual ~StopSnatIpForSnatEntryResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class UnAssociateEnsEipAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<bool> force{};

  UnAssociateEnsEipAddressRequest() {}

  explicit UnAssociateEnsEipAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
  }


  virtual ~UnAssociateEnsEipAddressRequest() = default;
};
class UnAssociateEnsEipAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnAssociateEnsEipAddressResponseBody() {}

  explicit UnAssociateEnsEipAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnAssociateEnsEipAddressResponseBody() = default;
};
class UnAssociateEnsEipAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnAssociateEnsEipAddressResponseBody> body{};

  UnAssociateEnsEipAddressResponse() {}

  explicit UnAssociateEnsEipAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnAssociateEnsEipAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnAssociateEnsEipAddressResponseBody>(model1);
      }
    }
  }


  virtual ~UnAssociateEnsEipAddressResponse() = default;
};
class UnassignPrivateIpAddressesRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<vector<string>> privateIpAddress{};

  UnassignPrivateIpAddressesRequest() {}

  explicit UnassignPrivateIpAddressesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrivateIpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrivateIpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      privateIpAddress = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UnassignPrivateIpAddressesRequest() = default;
};
class UnassignPrivateIpAddressesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnassignPrivateIpAddressesResponseBody() {}

  explicit UnassignPrivateIpAddressesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnassignPrivateIpAddressesResponseBody() = default;
};
class UnassignPrivateIpAddressesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnassignPrivateIpAddressesResponseBody> body{};

  UnassignPrivateIpAddressesResponse() {}

  explicit UnassignPrivateIpAddressesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnassignPrivateIpAddressesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnassignPrivateIpAddressesResponseBody>(model1);
      }
    }
  }


  virtual ~UnassignPrivateIpAddressesResponse() = default;
};
class UnassociateHaVipRequest : public Darabonba::Model {
public:
  shared_ptr<string> haVipId{};
  shared_ptr<string> instanceId{};

  UnassociateHaVipRequest() {}

  explicit UnassociateHaVipRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (haVipId) {
      res["HaVipId"] = boost::any(*haVipId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HaVipId") != m.end() && !m["HaVipId"].empty()) {
      haVipId = make_shared<string>(boost::any_cast<string>(m["HaVipId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UnassociateHaVipRequest() = default;
};
class UnassociateHaVipResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnassociateHaVipResponseBody() {}

  explicit UnassociateHaVipResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnassociateHaVipResponseBody() = default;
};
class UnassociateHaVipResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnassociateHaVipResponseBody> body{};

  UnassociateHaVipResponse() {}

  explicit UnassociateHaVipResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnassociateHaVipResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnassociateHaVipResponseBody>(model1);
      }
    }
  }


  virtual ~UnassociateHaVipResponse() = default;
};
class UnassociateNetworkAclRequestResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  UnassociateNetworkAclRequestResource() {}

  explicit UnassociateNetworkAclRequestResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~UnassociateNetworkAclRequestResource() = default;
};
class UnassociateNetworkAclRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkAclId{};
  shared_ptr<vector<UnassociateNetworkAclRequestResource>> resource{};

  UnassociateNetworkAclRequest() {}

  explicit UnassociateNetworkAclRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<UnassociateNetworkAclRequestResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UnassociateNetworkAclRequestResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<UnassociateNetworkAclRequestResource>>(expect1);
      }
    }
  }


  virtual ~UnassociateNetworkAclRequest() = default;
};
class UnassociateNetworkAclResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnassociateNetworkAclResponseBody() {}

  explicit UnassociateNetworkAclResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnassociateNetworkAclResponseBody() = default;
};
class UnassociateNetworkAclResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnassociateNetworkAclResponseBody> body{};

  UnassociateNetworkAclResponse() {}

  explicit UnassociateNetworkAclResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnassociateNetworkAclResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnassociateNetworkAclResponseBody>(model1);
      }
    }
  }


  virtual ~UnassociateNetworkAclResponse() = default;
};
class UnloadRegionSDGRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> destinationRegionIds{};
  shared_ptr<vector<string>> namespaces{};
  shared_ptr<string> SDGId{};

  UnloadRegionSDGRequest() {}

  explicit UnloadRegionSDGRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationRegionIds) {
      res["DestinationRegionIds"] = boost::any(*destinationRegionIds);
    }
    if (namespaces) {
      res["Namespaces"] = boost::any(*namespaces);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationRegionIds") != m.end() && !m["DestinationRegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DestinationRegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DestinationRegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      destinationRegionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Namespaces") != m.end() && !m["Namespaces"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Namespaces"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Namespaces"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      namespaces = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~UnloadRegionSDGRequest() = default;
};
class UnloadRegionSDGShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> destinationRegionIdsShrink{};
  shared_ptr<string> namespacesShrink{};
  shared_ptr<string> SDGId{};

  UnloadRegionSDGShrinkRequest() {}

  explicit UnloadRegionSDGShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationRegionIdsShrink) {
      res["DestinationRegionIds"] = boost::any(*destinationRegionIdsShrink);
    }
    if (namespacesShrink) {
      res["Namespaces"] = boost::any(*namespacesShrink);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationRegionIds") != m.end() && !m["DestinationRegionIds"].empty()) {
      destinationRegionIdsShrink = make_shared<string>(boost::any_cast<string>(m["DestinationRegionIds"]));
    }
    if (m.find("Namespaces") != m.end() && !m["Namespaces"].empty()) {
      namespacesShrink = make_shared<string>(boost::any_cast<string>(m["Namespaces"]));
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~UnloadRegionSDGShrinkRequest() = default;
};
class UnloadRegionSDGResponseBodyDataResultFailedItems : public Darabonba::Model {
public:
  shared_ptr<string> destinationRegionId{};
  shared_ptr<string> errorMessage{};

  UnloadRegionSDGResponseBodyDataResultFailedItems() {}

  explicit UnloadRegionSDGResponseBodyDataResultFailedItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationRegionId) {
      res["DestinationRegionId"] = boost::any(*destinationRegionId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationRegionId") != m.end() && !m["DestinationRegionId"].empty()) {
      destinationRegionId = make_shared<string>(boost::any_cast<string>(m["DestinationRegionId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
  }


  virtual ~UnloadRegionSDGResponseBodyDataResultFailedItems() = default;
};
class UnloadRegionSDGResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<long> failedCount{};
  shared_ptr<vector<UnloadRegionSDGResponseBodyDataResultFailedItems>> failedItems{};
  shared_ptr<long> successCount{};

  UnloadRegionSDGResponseBodyDataResult() {}

  explicit UnloadRegionSDGResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedCount) {
      res["FailedCount"] = boost::any(*failedCount);
    }
    if (failedItems) {
      vector<boost::any> temp1;
      for(auto item1:*failedItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedItems"] = boost::any(temp1);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedCount") != m.end() && !m["FailedCount"].empty()) {
      failedCount = make_shared<long>(boost::any_cast<long>(m["FailedCount"]));
    }
    if (m.find("FailedItems") != m.end() && !m["FailedItems"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedItems"].type()) {
        vector<UnloadRegionSDGResponseBodyDataResultFailedItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UnloadRegionSDGResponseBodyDataResultFailedItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedItems = make_shared<vector<UnloadRegionSDGResponseBodyDataResultFailedItems>>(expect1);
      }
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
  }


  virtual ~UnloadRegionSDGResponseBodyDataResult() = default;
};
class UnloadRegionSDGResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<UnloadRegionSDGResponseBodyDataResult> result{};
  shared_ptr<bool> success{};

  UnloadRegionSDGResponseBodyData() {}

  explicit UnloadRegionSDGResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UnloadRegionSDGResponseBodyDataResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UnloadRegionSDGResponseBodyDataResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UnloadRegionSDGResponseBodyData() = default;
};
class UnloadRegionSDGResponseBody : public Darabonba::Model {
public:
  shared_ptr<UnloadRegionSDGResponseBodyData> data{};
  shared_ptr<string> requestId{};

  UnloadRegionSDGResponseBody() {}

  explicit UnloadRegionSDGResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UnloadRegionSDGResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UnloadRegionSDGResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnloadRegionSDGResponseBody() = default;
};
class UnloadRegionSDGResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnloadRegionSDGResponseBody> body{};

  UnloadRegionSDGResponse() {}

  explicit UnloadRegionSDGResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnloadRegionSDGResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnloadRegionSDGResponseBody>(model1);
      }
    }
  }


  virtual ~UnloadRegionSDGResponse() = default;
};
class UnmountInstanceSDGRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> SDGId{};

  UnmountInstanceSDGRequest() {}

  explicit UnmountInstanceSDGRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~UnmountInstanceSDGRequest() = default;
};
class UnmountInstanceSDGShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIdsShrink{};
  shared_ptr<string> SDGId{};

  UnmountInstanceSDGShrinkRequest() {}

  explicit UnmountInstanceSDGShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIdsShrink) {
      res["InstanceIds"] = boost::any(*instanceIdsShrink);
    }
    if (SDGId) {
      res["SDGId"] = boost::any(*SDGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("SDGId") != m.end() && !m["SDGId"].empty()) {
      SDGId = make_shared<string>(boost::any_cast<string>(m["SDGId"]));
    }
  }


  virtual ~UnmountInstanceSDGShrinkRequest() = default;
};
class UnmountInstanceSDGResponseBodyDataResultFailedItems : public Darabonba::Model {
public:
  shared_ptr<string> errMessage{};
  shared_ptr<string> instanceId{};

  UnmountInstanceSDGResponseBodyDataResultFailedItems() {}

  explicit UnmountInstanceSDGResponseBodyDataResultFailedItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UnmountInstanceSDGResponseBodyDataResultFailedItems() = default;
};
class UnmountInstanceSDGResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<long> failedCount{};
  shared_ptr<vector<UnmountInstanceSDGResponseBodyDataResultFailedItems>> failedItems{};
  shared_ptr<long> successCount{};

  UnmountInstanceSDGResponseBodyDataResult() {}

  explicit UnmountInstanceSDGResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedCount) {
      res["FailedCount"] = boost::any(*failedCount);
    }
    if (failedItems) {
      vector<boost::any> temp1;
      for(auto item1:*failedItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedItems"] = boost::any(temp1);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedCount") != m.end() && !m["FailedCount"].empty()) {
      failedCount = make_shared<long>(boost::any_cast<long>(m["FailedCount"]));
    }
    if (m.find("FailedItems") != m.end() && !m["FailedItems"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedItems"].type()) {
        vector<UnmountInstanceSDGResponseBodyDataResultFailedItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UnmountInstanceSDGResponseBodyDataResultFailedItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedItems = make_shared<vector<UnmountInstanceSDGResponseBodyDataResultFailedItems>>(expect1);
      }
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
  }


  virtual ~UnmountInstanceSDGResponseBodyDataResult() = default;
};
class UnmountInstanceSDGResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<UnmountInstanceSDGResponseBodyDataResult> result{};
  shared_ptr<bool> success{};

  UnmountInstanceSDGResponseBodyData() {}

  explicit UnmountInstanceSDGResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UnmountInstanceSDGResponseBodyDataResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UnmountInstanceSDGResponseBodyDataResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UnmountInstanceSDGResponseBodyData() = default;
};
class UnmountInstanceSDGResponseBody : public Darabonba::Model {
public:
  shared_ptr<UnmountInstanceSDGResponseBodyData> data{};
  shared_ptr<string> requestId{};

  UnmountInstanceSDGResponseBody() {}

  explicit UnmountInstanceSDGResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UnmountInstanceSDGResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UnmountInstanceSDGResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnmountInstanceSDGResponseBody() = default;
};
class UnmountInstanceSDGResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnmountInstanceSDGResponseBody> body{};

  UnmountInstanceSDGResponse() {}

  explicit UnmountInstanceSDGResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnmountInstanceSDGResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnmountInstanceSDGResponseBody>(model1);
      }
    }
  }


  virtual ~UnmountInstanceSDGResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpdateEnsSaleControlRequestSaleControlsConditionControls : public Darabonba::Model {
public:
  shared_ptr<string> conditionControlModuleCode{};
  shared_ptr<string> conditionControlModuleValue{};

  UpdateEnsSaleControlRequestSaleControlsConditionControls() {}

  explicit UpdateEnsSaleControlRequestSaleControlsConditionControls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionControlModuleCode) {
      res["ConditionControlModuleCode"] = boost::any(*conditionControlModuleCode);
    }
    if (conditionControlModuleValue) {
      res["ConditionControlModuleValue"] = boost::any(*conditionControlModuleValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionControlModuleCode") != m.end() && !m["ConditionControlModuleCode"].empty()) {
      conditionControlModuleCode = make_shared<string>(boost::any_cast<string>(m["ConditionControlModuleCode"]));
    }
    if (m.find("ConditionControlModuleValue") != m.end() && !m["ConditionControlModuleValue"].empty()) {
      conditionControlModuleValue = make_shared<string>(boost::any_cast<string>(m["ConditionControlModuleValue"]));
    }
  }


  virtual ~UpdateEnsSaleControlRequestSaleControlsConditionControls() = default;
};
class UpdateEnsSaleControlRequestSaleControlsModuleValue : public Darabonba::Model {
public:
  shared_ptr<string> moduleMaxValue{};
  shared_ptr<string> moduleMinValue{};
  shared_ptr<vector<string>> moduleValue{};

  UpdateEnsSaleControlRequestSaleControlsModuleValue() {}

  explicit UpdateEnsSaleControlRequestSaleControlsModuleValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moduleMaxValue) {
      res["ModuleMaxValue"] = boost::any(*moduleMaxValue);
    }
    if (moduleMinValue) {
      res["ModuleMinValue"] = boost::any(*moduleMinValue);
    }
    if (moduleValue) {
      res["ModuleValue"] = boost::any(*moduleValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModuleMaxValue") != m.end() && !m["ModuleMaxValue"].empty()) {
      moduleMaxValue = make_shared<string>(boost::any_cast<string>(m["ModuleMaxValue"]));
    }
    if (m.find("ModuleMinValue") != m.end() && !m["ModuleMinValue"].empty()) {
      moduleMinValue = make_shared<string>(boost::any_cast<string>(m["ModuleMinValue"]));
    }
    if (m.find("ModuleValue") != m.end() && !m["ModuleValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ModuleValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ModuleValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      moduleValue = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateEnsSaleControlRequestSaleControlsModuleValue() = default;
};
class UpdateEnsSaleControlRequestSaleControls : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateEnsSaleControlRequestSaleControlsConditionControls>> conditionControls{};
  shared_ptr<string> description{};
  shared_ptr<string> moduleCode{};
  shared_ptr<UpdateEnsSaleControlRequestSaleControlsModuleValue> moduleValue{};
  shared_ptr<string> operator_{};
  shared_ptr<string> orderType{};

  UpdateEnsSaleControlRequestSaleControls() {}

  explicit UpdateEnsSaleControlRequestSaleControls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionControls) {
      vector<boost::any> temp1;
      for(auto item1:*conditionControls){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConditionControls"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (moduleCode) {
      res["ModuleCode"] = boost::any(*moduleCode);
    }
    if (moduleValue) {
      res["ModuleValue"] = moduleValue ? boost::any(moduleValue->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionControls") != m.end() && !m["ConditionControls"].empty()) {
      if (typeid(vector<boost::any>) == m["ConditionControls"].type()) {
        vector<UpdateEnsSaleControlRequestSaleControlsConditionControls> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConditionControls"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateEnsSaleControlRequestSaleControlsConditionControls model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditionControls = make_shared<vector<UpdateEnsSaleControlRequestSaleControlsConditionControls>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModuleCode") != m.end() && !m["ModuleCode"].empty()) {
      moduleCode = make_shared<string>(boost::any_cast<string>(m["ModuleCode"]));
    }
    if (m.find("ModuleValue") != m.end() && !m["ModuleValue"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModuleValue"].type()) {
        UpdateEnsSaleControlRequestSaleControlsModuleValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModuleValue"]));
        moduleValue = make_shared<UpdateEnsSaleControlRequestSaleControlsModuleValue>(model1);
      }
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
  }


  virtual ~UpdateEnsSaleControlRequestSaleControls() = default;
};
class UpdateEnsSaleControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliUidAccount{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> customAccount{};
  shared_ptr<vector<UpdateEnsSaleControlRequestSaleControls>> saleControls{};

  UpdateEnsSaleControlRequest() {}

  explicit UpdateEnsSaleControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUidAccount) {
      res["AliUidAccount"] = boost::any(*aliUidAccount);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (customAccount) {
      res["CustomAccount"] = boost::any(*customAccount);
    }
    if (saleControls) {
      vector<boost::any> temp1;
      for(auto item1:*saleControls){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SaleControls"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUidAccount") != m.end() && !m["AliUidAccount"].empty()) {
      aliUidAccount = make_shared<string>(boost::any_cast<string>(m["AliUidAccount"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CustomAccount") != m.end() && !m["CustomAccount"].empty()) {
      customAccount = make_shared<string>(boost::any_cast<string>(m["CustomAccount"]));
    }
    if (m.find("SaleControls") != m.end() && !m["SaleControls"].empty()) {
      if (typeid(vector<boost::any>) == m["SaleControls"].type()) {
        vector<UpdateEnsSaleControlRequestSaleControls> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SaleControls"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateEnsSaleControlRequestSaleControls model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        saleControls = make_shared<vector<UpdateEnsSaleControlRequestSaleControls>>(expect1);
      }
    }
  }


  virtual ~UpdateEnsSaleControlRequest() = default;
};
class UpdateEnsSaleControlShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliUidAccount{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> customAccount{};
  shared_ptr<string> saleControlsShrink{};

  UpdateEnsSaleControlShrinkRequest() {}

  explicit UpdateEnsSaleControlShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUidAccount) {
      res["AliUidAccount"] = boost::any(*aliUidAccount);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (customAccount) {
      res["CustomAccount"] = boost::any(*customAccount);
    }
    if (saleControlsShrink) {
      res["SaleControls"] = boost::any(*saleControlsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUidAccount") != m.end() && !m["AliUidAccount"].empty()) {
      aliUidAccount = make_shared<string>(boost::any_cast<string>(m["AliUidAccount"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CustomAccount") != m.end() && !m["CustomAccount"].empty()) {
      customAccount = make_shared<string>(boost::any_cast<string>(m["CustomAccount"]));
    }
    if (m.find("SaleControls") != m.end() && !m["SaleControls"].empty()) {
      saleControlsShrink = make_shared<string>(boost::any_cast<string>(m["SaleControls"]));
    }
  }


  virtual ~UpdateEnsSaleControlShrinkRequest() = default;
};
class UpdateEnsSaleControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateEnsSaleControlResponseBody() {}

  explicit UpdateEnsSaleControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateEnsSaleControlResponseBody() = default;
};
class UpdateEnsSaleControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEnsSaleControlResponseBody> body{};

  UpdateEnsSaleControlResponse() {}

  explicit UpdateEnsSaleControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEnsSaleControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEnsSaleControlResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEnsSaleControlResponse() = default;
};
class UpgradeAICInstanceImageRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<vector<string>> serverIds{};
  shared_ptr<long> timeout{};

  UpgradeAICInstanceImageRequest() {}

  explicit UpgradeAICInstanceImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (serverIds) {
      res["ServerIds"] = boost::any(*serverIds);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ServerIds") != m.end() && !m["ServerIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ServerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ServerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      serverIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~UpgradeAICInstanceImageRequest() = default;
};
class UpgradeAICInstanceImageShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> serverIdsShrink{};
  shared_ptr<long> timeout{};

  UpgradeAICInstanceImageShrinkRequest() {}

  explicit UpgradeAICInstanceImageShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (serverIdsShrink) {
      res["ServerIds"] = boost::any(*serverIdsShrink);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ServerIds") != m.end() && !m["ServerIds"].empty()) {
      serverIdsShrink = make_shared<string>(boost::any_cast<string>(m["ServerIds"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~UpgradeAICInstanceImageShrinkRequest() = default;
};
class UpgradeAICInstanceImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpgradeAICInstanceImageResponseBody() {}

  explicit UpgradeAICInstanceImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpgradeAICInstanceImageResponseBody() = default;
};
class UpgradeAICInstanceImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpgradeAICInstanceImageResponseBody> body{};

  UpgradeAICInstanceImageResponse() {}

  explicit UpgradeAICInstanceImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeAICInstanceImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeAICInstanceImageResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeAICInstanceImageResponse() = default;
};
class UpgradeApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> template_{};
  shared_ptr<long> timeout{};

  UpgradeApplicationRequest() {}

  explicit UpgradeApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~UpgradeApplicationRequest() = default;
};
class UpgradeApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  UpgradeApplicationResponseBody() {}

  explicit UpgradeApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~UpgradeApplicationResponseBody() = default;
};
class UpgradeApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpgradeApplicationResponseBody> body{};

  UpgradeApplicationResponse() {}

  explicit UpgradeApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeApplicationResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AccosicateNetworkAclResponse accosicateNetworkAclWithOptions(shared_ptr<AccosicateNetworkAclRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AccosicateNetworkAclResponse accosicateNetworkAcl(shared_ptr<AccosicateNetworkAclRequest> request);
  AddBackendServersResponse addBackendServersWithOptions(shared_ptr<AddBackendServersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddBackendServersResponse addBackendServers(shared_ptr<AddBackendServersRequest> request);
  AddNetworkInterfaceToInstanceResponse addNetworkInterfaceToInstanceWithOptions(shared_ptr<AddNetworkInterfaceToInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddNetworkInterfaceToInstanceResponse addNetworkInterfaceToInstance(shared_ptr<AddNetworkInterfaceToInstanceRequest> request);
  AddSnatIpForSnatEntryResponse addSnatIpForSnatEntryWithOptions(shared_ptr<AddSnatIpForSnatEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddSnatIpForSnatEntryResponse addSnatIpForSnatEntry(shared_ptr<AddSnatIpForSnatEntryRequest> request);
  AssignPrivateIpAddressesResponse assignPrivateIpAddressesWithOptions(shared_ptr<AssignPrivateIpAddressesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssignPrivateIpAddressesResponse assignPrivateIpAddresses(shared_ptr<AssignPrivateIpAddressesRequest> request);
  AssociateEnsEipAddressResponse associateEnsEipAddressWithOptions(shared_ptr<AssociateEnsEipAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateEnsEipAddressResponse associateEnsEipAddress(shared_ptr<AssociateEnsEipAddressRequest> request);
  AssociateHaVipResponse associateHaVipWithOptions(shared_ptr<AssociateHaVipRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateHaVipResponse associateHaVip(shared_ptr<AssociateHaVipRequest> request);
  AttachDiskResponse attachDiskWithOptions(shared_ptr<AttachDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachDiskResponse attachDisk(shared_ptr<AttachDiskRequest> request);
  AttachEnsInstancesResponse attachEnsInstancesWithOptions(shared_ptr<AttachEnsInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachEnsInstancesResponse attachEnsInstances(shared_ptr<AttachEnsInstancesRequest> request);
  AttachInstanceSDGResponse attachInstanceSDGWithOptions(shared_ptr<AttachInstanceSDGRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachInstanceSDGResponse attachInstanceSDG(shared_ptr<AttachInstanceSDGRequest> request);
  AttachNetworkInterfaceResponse attachNetworkInterfaceWithOptions(shared_ptr<AttachNetworkInterfaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachNetworkInterfaceResponse attachNetworkInterface(shared_ptr<AttachNetworkInterfaceRequest> request);
  AuthorizeSecurityGroupResponse authorizeSecurityGroupWithOptions(shared_ptr<AuthorizeSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AuthorizeSecurityGroupResponse authorizeSecurityGroup(shared_ptr<AuthorizeSecurityGroupRequest> request);
  AuthorizeSecurityGroupEgressResponse authorizeSecurityGroupEgressWithOptions(shared_ptr<AuthorizeSecurityGroupEgressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AuthorizeSecurityGroupEgressResponse authorizeSecurityGroupEgress(shared_ptr<AuthorizeSecurityGroupEgressRequest> request);
  CleanDistDataResponse cleanDistDataWithOptions(shared_ptr<CleanDistDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CleanDistDataResponse cleanDistData(shared_ptr<CleanDistDataRequest> request);
  CopySDGResponse copySDGWithOptions(shared_ptr<CopySDGRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopySDGResponse copySDG(shared_ptr<CopySDGRequest> request);
  CopySnapshotResponse copySnapshotWithOptions(shared_ptr<CopySnapshotRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopySnapshotResponse copySnapshot(shared_ptr<CopySnapshotRequest> request);
  CreateARMServerInstancesResponse createARMServerInstancesWithOptions(shared_ptr<CreateARMServerInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateARMServerInstancesResponse createARMServerInstances(shared_ptr<CreateARMServerInstancesRequest> request);
  CreateApplicationResponse createApplicationWithOptions(shared_ptr<CreateApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApplicationResponse createApplication(shared_ptr<CreateApplicationRequest> request);
  CreateClassicNetworkResponse createClassicNetworkWithOptions(shared_ptr<CreateClassicNetworkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateClassicNetworkResponse createClassicNetwork(shared_ptr<CreateClassicNetworkRequest> request);
  CreateClusterResponse createClusterWithOptions(shared_ptr<CreateClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateClusterResponse createCluster(shared_ptr<CreateClusterRequest> request);
  CreateDiskResponse createDiskWithOptions(shared_ptr<CreateDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDiskResponse createDisk(shared_ptr<CreateDiskRequest> request);
  CreateEipInstanceResponse createEipInstanceWithOptions(shared_ptr<CreateEipInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEipInstanceResponse createEipInstance(shared_ptr<CreateEipInstanceRequest> request);
  CreateEnsRouteEntryResponse createEnsRouteEntryWithOptions(shared_ptr<CreateEnsRouteEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEnsRouteEntryResponse createEnsRouteEntry(shared_ptr<CreateEnsRouteEntryRequest> request);
  CreateEnsSaleControlResponse createEnsSaleControlWithOptions(shared_ptr<CreateEnsSaleControlRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEnsSaleControlResponse createEnsSaleControl(shared_ptr<CreateEnsSaleControlRequest> request);
  CreateEnsServiceResponse createEnsServiceWithOptions(shared_ptr<CreateEnsServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEnsServiceResponse createEnsService(shared_ptr<CreateEnsServiceRequest> request);
  CreateEpnInstanceResponse createEpnInstanceWithOptions(shared_ptr<CreateEpnInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEpnInstanceResponse createEpnInstance(shared_ptr<CreateEpnInstanceRequest> request);
  CreateFileSystemResponse createFileSystemWithOptions(shared_ptr<CreateFileSystemRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFileSystemResponse createFileSystem(shared_ptr<CreateFileSystemRequest> request);
  CreateForwardEntryResponse createForwardEntryWithOptions(shared_ptr<CreateForwardEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateForwardEntryResponse createForwardEntry(shared_ptr<CreateForwardEntryRequest> request);
  CreateHaVipResponse createHaVipWithOptions(shared_ptr<CreateHaVipRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHaVipResponse createHaVip(shared_ptr<CreateHaVipRequest> request);
  CreateImageResponse createImageWithOptions(shared_ptr<CreateImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateImageResponse createImage(shared_ptr<CreateImageRequest> request);
  CreateInstanceResponse createInstanceWithOptions(shared_ptr<CreateInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateInstanceResponse createInstance(shared_ptr<CreateInstanceRequest> request);
  CreateInstanceActiveOpsTaskResponse createInstanceActiveOpsTaskWithOptions(shared_ptr<CreateInstanceActiveOpsTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateInstanceActiveOpsTaskResponse createInstanceActiveOpsTask(shared_ptr<CreateInstanceActiveOpsTaskRequest> request);
  CreateKeyPairResponse createKeyPairWithOptions(shared_ptr<CreateKeyPairRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateKeyPairResponse createKeyPair(shared_ptr<CreateKeyPairRequest> request);
  CreateLoadBalancerResponse createLoadBalancerWithOptions(shared_ptr<CreateLoadBalancerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLoadBalancerResponse createLoadBalancer(shared_ptr<CreateLoadBalancerRequest> request);
  CreateLoadBalancerHTTPListenerResponse createLoadBalancerHTTPListenerWithOptions(shared_ptr<CreateLoadBalancerHTTPListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLoadBalancerHTTPListenerResponse createLoadBalancerHTTPListener(shared_ptr<CreateLoadBalancerHTTPListenerRequest> request);
  CreateLoadBalancerHTTPSListenerResponse createLoadBalancerHTTPSListenerWithOptions(shared_ptr<CreateLoadBalancerHTTPSListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLoadBalancerHTTPSListenerResponse createLoadBalancerHTTPSListener(shared_ptr<CreateLoadBalancerHTTPSListenerRequest> request);
  CreateLoadBalancerTCPListenerResponse createLoadBalancerTCPListenerWithOptions(shared_ptr<CreateLoadBalancerTCPListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLoadBalancerTCPListenerResponse createLoadBalancerTCPListener(shared_ptr<CreateLoadBalancerTCPListenerRequest> request);
  CreateLoadBalancerUDPListenerResponse createLoadBalancerUDPListenerWithOptions(shared_ptr<CreateLoadBalancerUDPListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLoadBalancerUDPListenerResponse createLoadBalancerUDPListener(shared_ptr<CreateLoadBalancerUDPListenerRequest> request);
  CreateMountTargetResponse createMountTargetWithOptions(shared_ptr<CreateMountTargetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMountTargetResponse createMountTarget(shared_ptr<CreateMountTargetRequest> request);
  CreateNatGatewayResponse createNatGatewayWithOptions(shared_ptr<CreateNatGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNatGatewayResponse createNatGateway(shared_ptr<CreateNatGatewayRequest> request);
  CreateNetworkResponse createNetworkWithOptions(shared_ptr<CreateNetworkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNetworkResponse createNetwork(shared_ptr<CreateNetworkRequest> request);
  CreateNetworkAclResponse createNetworkAclWithOptions(shared_ptr<CreateNetworkAclRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNetworkAclResponse createNetworkAcl(shared_ptr<CreateNetworkAclRequest> request);
  CreateNetworkAclEntryResponse createNetworkAclEntryWithOptions(shared_ptr<CreateNetworkAclEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNetworkAclEntryResponse createNetworkAclEntry(shared_ptr<CreateNetworkAclEntryRequest> request);
  CreateNetworkInterfaceResponse createNetworkInterfaceWithOptions(shared_ptr<CreateNetworkInterfaceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNetworkInterfaceResponse createNetworkInterface(shared_ptr<CreateNetworkInterfaceRequest> request);
  CreateSDGResponse createSDGWithOptions(shared_ptr<CreateSDGRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSDGResponse createSDG(shared_ptr<CreateSDGRequest> request);
  CreateSecurityGroupResponse createSecurityGroupWithOptions(shared_ptr<CreateSecurityGroupRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSecurityGroupResponse createSecurityGroup(shared_ptr<CreateSecurityGroupRequest> request);
  CreateSnapshotResponse createSnapshotWithOptions(shared_ptr<CreateSnapshotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSnapshotResponse createSnapshot(shared_ptr<CreateSnapshotRequest> request);
  CreateSnatEntryResponse createSnatEntryWithOptions(shared_ptr<CreateSnatEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSnatEntryResponse createSnatEntry(shared_ptr<CreateSnatEntryRequest> request);
  CreateStorageGatewayResponse createStorageGatewayWithOptions(shared_ptr<CreateStorageGatewayRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateStorageGatewayResponse createStorageGateway(shared_ptr<CreateStorageGatewayRequest> request);
  CreateStorageVolumeResponse createStorageVolumeWithOptions(shared_ptr<CreateStorageVolumeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateStorageVolumeResponse createStorageVolume(shared_ptr<CreateStorageVolumeRequest> request);
  CreateVSwitchResponse createVSwitchWithOptions(shared_ptr<CreateVSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVSwitchResponse createVSwitch(shared_ptr<CreateVSwitchRequest> request);
  DeleteApplicationResponse deleteApplicationWithOptions(shared_ptr<DeleteApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApplicationResponse deleteApplication(shared_ptr<DeleteApplicationRequest> request);
  DeleteBucketResponse deleteBucketWithOptions(shared_ptr<DeleteBucketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBucketResponse deleteBucket(shared_ptr<DeleteBucketRequest> request);
  DeleteBucketLifecycleResponse deleteBucketLifecycleWithOptions(shared_ptr<DeleteBucketLifecycleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBucketLifecycleResponse deleteBucketLifecycle(shared_ptr<DeleteBucketLifecycleRequest> request);
  DeleteDiskResponse deleteDiskWithOptions(shared_ptr<DeleteDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDiskResponse deleteDisk(shared_ptr<DeleteDiskRequest> request);
  DeleteEipResponse deleteEipWithOptions(shared_ptr<DeleteEipRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEipResponse deleteEip(shared_ptr<DeleteEipRequest> request);
  DeleteEnsRouteEntryResponse deleteEnsRouteEntryWithOptions(shared_ptr<DeleteEnsRouteEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEnsRouteEntryResponse deleteEnsRouteEntry(shared_ptr<DeleteEnsRouteEntryRequest> request);
  DeleteEnsSaleConditionControlResponse deleteEnsSaleConditionControlWithOptions(shared_ptr<DeleteEnsSaleConditionControlRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEnsSaleConditionControlResponse deleteEnsSaleConditionControl(shared_ptr<DeleteEnsSaleConditionControlRequest> request);
  DeleteEnsSaleControlResponse deleteEnsSaleControlWithOptions(shared_ptr<DeleteEnsSaleControlRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEnsSaleControlResponse deleteEnsSaleControl(shared_ptr<DeleteEnsSaleControlRequest> request);
  DeleteEpnInstanceResponse deleteEpnInstanceWithOptions(shared_ptr<DeleteEpnInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEpnInstanceResponse deleteEpnInstance(shared_ptr<DeleteEpnInstanceRequest> request);
  DeleteFileSystemResponse deleteFileSystemWithOptions(shared_ptr<DeleteFileSystemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFileSystemResponse deleteFileSystem(shared_ptr<DeleteFileSystemRequest> request);
  DeleteForwardEntryResponse deleteForwardEntryWithOptions(shared_ptr<DeleteForwardEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteForwardEntryResponse deleteForwardEntry(shared_ptr<DeleteForwardEntryRequest> request);
  DeleteHaVipsResponse deleteHaVipsWithOptions(shared_ptr<DeleteHaVipsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHaVipsResponse deleteHaVips(shared_ptr<DeleteHaVipsRequest> request);
  DeleteImageResponse deleteImageWithOptions(shared_ptr<DeleteImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteImageResponse deleteImage(shared_ptr<DeleteImageRequest> request);
  DeleteKeyPairsResponse deleteKeyPairsWithOptions(shared_ptr<DeleteKeyPairsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteKeyPairsResponse deleteKeyPairs(shared_ptr<DeleteKeyPairsRequest> request);
  DeleteLoadBalancerListenerResponse deleteLoadBalancerListenerWithOptions(shared_ptr<DeleteLoadBalancerListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLoadBalancerListenerResponse deleteLoadBalancerListener(shared_ptr<DeleteLoadBalancerListenerRequest> request);
  DeleteMountTargetResponse deleteMountTargetWithOptions(shared_ptr<DeleteMountTargetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMountTargetResponse deleteMountTarget(shared_ptr<DeleteMountTargetRequest> request);
  DeleteNatGatewayResponse deleteNatGatewayWithOptions(shared_ptr<DeleteNatGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNatGatewayResponse deleteNatGateway(shared_ptr<DeleteNatGatewayRequest> request);
  DeleteNetworkResponse deleteNetworkWithOptions(shared_ptr<DeleteNetworkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNetworkResponse deleteNetwork(shared_ptr<DeleteNetworkRequest> request);
  DeleteNetworkAclResponse deleteNetworkAclWithOptions(shared_ptr<DeleteNetworkAclRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNetworkAclResponse deleteNetworkAcl(shared_ptr<DeleteNetworkAclRequest> request);
  DeleteNetworkAclEntryResponse deleteNetworkAclEntryWithOptions(shared_ptr<DeleteNetworkAclEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNetworkAclEntryResponse deleteNetworkAclEntry(shared_ptr<DeleteNetworkAclEntryRequest> request);
  DeleteNetworkInterfacesResponse deleteNetworkInterfacesWithOptions(shared_ptr<DeleteNetworkInterfacesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNetworkInterfacesResponse deleteNetworkInterfaces(shared_ptr<DeleteNetworkInterfacesRequest> request);
  DeleteObjectResponse deleteObjectWithOptions(shared_ptr<DeleteObjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteObjectResponse deleteObject(shared_ptr<DeleteObjectRequest> request);
  DeleteSDGResponse deleteSDGWithOptions(shared_ptr<DeleteSDGRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSDGResponse deleteSDG(shared_ptr<DeleteSDGRequest> request);
  DeleteSecurityGroupResponse deleteSecurityGroupWithOptions(shared_ptr<DeleteSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSecurityGroupResponse deleteSecurityGroup(shared_ptr<DeleteSecurityGroupRequest> request);
  DeleteSnapshotResponse deleteSnapshotWithOptions(shared_ptr<DeleteSnapshotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSnapshotResponse deleteSnapshot(shared_ptr<DeleteSnapshotRequest> request);
  DeleteSnatEntryResponse deleteSnatEntryWithOptions(shared_ptr<DeleteSnatEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSnatEntryResponse deleteSnatEntry(shared_ptr<DeleteSnatEntryRequest> request);
  DeleteSnatIpForSnatEntryResponse deleteSnatIpForSnatEntryWithOptions(shared_ptr<DeleteSnatIpForSnatEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSnatIpForSnatEntryResponse deleteSnatIpForSnatEntry(shared_ptr<DeleteSnatIpForSnatEntryRequest> request);
  DeleteStorageGatewayResponse deleteStorageGatewayWithOptions(shared_ptr<DeleteStorageGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteStorageGatewayResponse deleteStorageGateway(shared_ptr<DeleteStorageGatewayRequest> request);
  DeleteStorageVolumeResponse deleteStorageVolumeWithOptions(shared_ptr<DeleteStorageVolumeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteStorageVolumeResponse deleteStorageVolume(shared_ptr<DeleteStorageVolumeRequest> request);
  DeleteVSwitchResponse deleteVSwitchWithOptions(shared_ptr<DeleteVSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVSwitchResponse deleteVSwitch(shared_ptr<DeleteVSwitchRequest> request);
  DeployInstanceSDGResponse deployInstanceSDGWithOptions(shared_ptr<DeployInstanceSDGRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeployInstanceSDGResponse deployInstanceSDG(shared_ptr<DeployInstanceSDGRequest> request);
  DeploySDGResponse deploySDGWithOptions(shared_ptr<DeploySDGRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeploySDGResponse deploySDG(shared_ptr<DeploySDGRequest> request);
  DescribeAICImagesResponse describeAICImagesWithOptions(shared_ptr<DescribeAICImagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAICImagesResponse describeAICImages(shared_ptr<DescribeAICImagesRequest> request);
  DescribeARMServerInstancesResponse describeARMServerInstancesWithOptions(shared_ptr<DescribeARMServerInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeARMServerInstancesResponse describeARMServerInstances(shared_ptr<DescribeARMServerInstancesRequest> request);
  DescribeApplicationResponse describeApplicationWithOptions(shared_ptr<DescribeApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApplicationResponse describeApplication(shared_ptr<DescribeApplicationRequest> request);
  DescribeAvailableResourceResponse describeAvailableResourceWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAvailableResourceResponse describeAvailableResource();
  DescribeAvailableResourceInfoResponse describeAvailableResourceInfoWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAvailableResourceInfoResponse describeAvailableResourceInfo();
  DescribeBandWithdChargeTypeResponse describeBandWithdChargeTypeWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBandWithdChargeTypeResponse describeBandWithdChargeType();
  DescribeBandwitdhByInternetChargeTypeResponse describeBandwitdhByInternetChargeTypeWithOptions(shared_ptr<DescribeBandwitdhByInternetChargeTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBandwitdhByInternetChargeTypeResponse describeBandwitdhByInternetChargeType(shared_ptr<DescribeBandwitdhByInternetChargeTypeRequest> request);
  DescribeCloudDiskAvailableResourceInfoResponse describeCloudDiskAvailableResourceInfoWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudDiskAvailableResourceInfoResponse describeCloudDiskAvailableResourceInfo();
  DescribeCloudDiskTypesResponse describeCloudDiskTypesWithOptions(shared_ptr<DescribeCloudDiskTypesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudDiskTypesResponse describeCloudDiskTypes(shared_ptr<DescribeCloudDiskTypesRequest> request);
  DescribeClusterResponse describeClusterWithOptions(shared_ptr<DescribeClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterResponse describeCluster(shared_ptr<DescribeClusterRequest> request);
  DescribeClusterKubeConfigResponse describeClusterKubeConfigWithOptions(shared_ptr<DescribeClusterKubeConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterKubeConfigResponse describeClusterKubeConfig(shared_ptr<DescribeClusterKubeConfigRequest> request);
  DescribeCreatePrePaidInstanceResultResponse describeCreatePrePaidInstanceResultWithOptions(shared_ptr<DescribeCreatePrePaidInstanceResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCreatePrePaidInstanceResultResponse describeCreatePrePaidInstanceResult(shared_ptr<DescribeCreatePrePaidInstanceResultRequest> request);
  DescribeDataDistResultResponse describeDataDistResultWithOptions(shared_ptr<DescribeDataDistResultRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDataDistResultResponse describeDataDistResult(shared_ptr<DescribeDataDistResultRequest> request);
  DescribeDataDownloadURLResponse describeDataDownloadURLWithOptions(shared_ptr<DescribeDataDownloadURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDataDownloadURLResponse describeDataDownloadURL(shared_ptr<DescribeDataDownloadURLRequest> request);
  DescribeDataPushResultResponse describeDataPushResultWithOptions(shared_ptr<DescribeDataPushResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDataPushResultResponse describeDataPushResult(shared_ptr<DescribeDataPushResultRequest> request);
  DescribeDeviceServiceResponse describeDeviceServiceWithOptions(shared_ptr<DescribeDeviceServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeviceServiceResponse describeDeviceService(shared_ptr<DescribeDeviceServiceRequest> request);
  DescribeDiskIopsListResponse describeDiskIopsListWithOptions(shared_ptr<DescribeDiskIopsListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDiskIopsListResponse describeDiskIopsList(shared_ptr<DescribeDiskIopsListRequest> request);
  DescribeDisksResponse describeDisksWithOptions(shared_ptr<DescribeDisksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDisksResponse describeDisks(shared_ptr<DescribeDisksRequest> request);
  DescribeElbAvailableResourceInfoResponse describeElbAvailableResourceInfoWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeElbAvailableResourceInfoResponse describeElbAvailableResourceInfo();
  DescribeEnsCommodityCodeResponse describeEnsCommodityCodeWithOptions(shared_ptr<DescribeEnsCommodityCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsCommodityCodeResponse describeEnsCommodityCode(shared_ptr<DescribeEnsCommodityCodeRequest> request);
  DescribeEnsCommodityModuleCodeResponse describeEnsCommodityModuleCodeWithOptions(shared_ptr<DescribeEnsCommodityModuleCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsCommodityModuleCodeResponse describeEnsCommodityModuleCode(shared_ptr<DescribeEnsCommodityModuleCodeRequest> request);
  DescribeEnsEipAddressesResponse describeEnsEipAddressesWithOptions(shared_ptr<DescribeEnsEipAddressesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsEipAddressesResponse describeEnsEipAddresses(shared_ptr<DescribeEnsEipAddressesRequest> request);
  DescribeEnsNetDistrictResponse describeEnsNetDistrictWithOptions(shared_ptr<DescribeEnsNetDistrictRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsNetDistrictResponse describeEnsNetDistrict(shared_ptr<DescribeEnsNetDistrictRequest> request);
  DescribeEnsNetLevelResponse describeEnsNetLevelWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsNetLevelResponse describeEnsNetLevel();
  DescribeEnsNetSaleDistrictResponse describeEnsNetSaleDistrictWithOptions(shared_ptr<DescribeEnsNetSaleDistrictRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsNetSaleDistrictResponse describeEnsNetSaleDistrict(shared_ptr<DescribeEnsNetSaleDistrictRequest> request);
  DescribeEnsRegionIdIpv6InfoResponse describeEnsRegionIdIpv6InfoWithOptions(shared_ptr<DescribeEnsRegionIdIpv6InfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsRegionIdIpv6InfoResponse describeEnsRegionIdIpv6Info(shared_ptr<DescribeEnsRegionIdIpv6InfoRequest> request);
  DescribeEnsRegionIdResourceResponse describeEnsRegionIdResourceWithOptions(shared_ptr<DescribeEnsRegionIdResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsRegionIdResourceResponse describeEnsRegionIdResource(shared_ptr<DescribeEnsRegionIdResourceRequest> request);
  DescribeEnsRegionsResponse describeEnsRegionsWithOptions(shared_ptr<DescribeEnsRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsRegionsResponse describeEnsRegions(shared_ptr<DescribeEnsRegionsRequest> request);
  DescribeEnsResourceUsageResponse describeEnsResourceUsageWithOptions(shared_ptr<DescribeEnsResourceUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsResourceUsageResponse describeEnsResourceUsage(shared_ptr<DescribeEnsResourceUsageRequest> request);
  DescribeEnsRouteEntryListResponse describeEnsRouteEntryListWithOptions(shared_ptr<DescribeEnsRouteEntryListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsRouteEntryListResponse describeEnsRouteEntryList(shared_ptr<DescribeEnsRouteEntryListRequest> request);
  DescribeEnsRouteTablesResponse describeEnsRouteTablesWithOptions(shared_ptr<DescribeEnsRouteTablesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsRouteTablesResponse describeEnsRouteTables(shared_ptr<DescribeEnsRouteTablesRequest> request);
  DescribeEnsSaleControlResponse describeEnsSaleControlWithOptions(shared_ptr<DescribeEnsSaleControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsSaleControlResponse describeEnsSaleControl(shared_ptr<DescribeEnsSaleControlRequest> request);
  DescribeEnsSaleControlAvailableResourceResponse describeEnsSaleControlAvailableResourceWithOptions(shared_ptr<DescribeEnsSaleControlAvailableResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsSaleControlAvailableResourceResponse describeEnsSaleControlAvailableResource(shared_ptr<DescribeEnsSaleControlAvailableResourceRequest> request);
  DescribeEnsSaleControlStockResponse describeEnsSaleControlStockWithOptions(shared_ptr<DescribeEnsSaleControlStockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsSaleControlStockResponse describeEnsSaleControlStock(shared_ptr<DescribeEnsSaleControlStockRequest> request);
  DescribeEpnBandWidthDataResponse describeEpnBandWidthDataWithOptions(shared_ptr<DescribeEpnBandWidthDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEpnBandWidthDataResponse describeEpnBandWidthData(shared_ptr<DescribeEpnBandWidthDataRequest> request);
  DescribeEpnBandwitdhByInternetChargeTypeResponse describeEpnBandwitdhByInternetChargeTypeWithOptions(shared_ptr<DescribeEpnBandwitdhByInternetChargeTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEpnBandwitdhByInternetChargeTypeResponse describeEpnBandwitdhByInternetChargeType(shared_ptr<DescribeEpnBandwitdhByInternetChargeTypeRequest> request);
  DescribeEpnInstanceAttributeResponse describeEpnInstanceAttributeWithOptions(shared_ptr<DescribeEpnInstanceAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEpnInstanceAttributeResponse describeEpnInstanceAttribute(shared_ptr<DescribeEpnInstanceAttributeRequest> request);
  DescribeEpnInstancesResponse describeEpnInstancesWithOptions(shared_ptr<DescribeEpnInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEpnInstancesResponse describeEpnInstances(shared_ptr<DescribeEpnInstancesRequest> request);
  DescribeEpnMeasurementDataResponse describeEpnMeasurementDataWithOptions(shared_ptr<DescribeEpnMeasurementDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEpnMeasurementDataResponse describeEpnMeasurementData(shared_ptr<DescribeEpnMeasurementDataRequest> request);
  DescribeExportImageInfoResponse describeExportImageInfoWithOptions(shared_ptr<DescribeExportImageInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExportImageInfoResponse describeExportImageInfo(shared_ptr<DescribeExportImageInfoRequest> request);
  DescribeExportImageStatusResponse describeExportImageStatusWithOptions(shared_ptr<DescribeExportImageStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExportImageStatusResponse describeExportImageStatus(shared_ptr<DescribeExportImageStatusRequest> request);
  DescribeFileSystemsResponse describeFileSystemsWithOptions(shared_ptr<DescribeFileSystemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFileSystemsResponse describeFileSystems(shared_ptr<DescribeFileSystemsRequest> request);
  DescribeForwardTableEntriesResponse describeForwardTableEntriesWithOptions(shared_ptr<DescribeForwardTableEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeForwardTableEntriesResponse describeForwardTableEntries(shared_ptr<DescribeForwardTableEntriesRequest> request);
  DescribeHaVipsResponse describeHaVipsWithOptions(shared_ptr<DescribeHaVipsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHaVipsResponse describeHaVips(shared_ptr<DescribeHaVipsRequest> request);
  DescribeImageInfosResponse describeImageInfosWithOptions(shared_ptr<DescribeImageInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageInfosResponse describeImageInfos(shared_ptr<DescribeImageInfosRequest> request);
  DescribeImageSharePermissionResponse describeImageSharePermissionWithOptions(shared_ptr<DescribeImageSharePermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageSharePermissionResponse describeImageSharePermission(shared_ptr<DescribeImageSharePermissionRequest> request);
  DescribeImagesResponse describeImagesWithOptions(shared_ptr<DescribeImagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImagesResponse describeImages(shared_ptr<DescribeImagesRequest> request);
  DescribeInstanceAutoRenewAttributeResponse describeInstanceAutoRenewAttributeWithOptions(shared_ptr<DescribeInstanceAutoRenewAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceAutoRenewAttributeResponse describeInstanceAutoRenewAttribute(shared_ptr<DescribeInstanceAutoRenewAttributeRequest> request);
  DescribeInstanceBandwidthDetailResponse describeInstanceBandwidthDetailWithOptions(shared_ptr<DescribeInstanceBandwidthDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceBandwidthDetailResponse describeInstanceBandwidthDetail(shared_ptr<DescribeInstanceBandwidthDetailRequest> request);
  DescribeInstanceBootConfigurationResponse describeInstanceBootConfigurationWithOptions(shared_ptr<DescribeInstanceBootConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceBootConfigurationResponse describeInstanceBootConfiguration(shared_ptr<DescribeInstanceBootConfigurationRequest> request);
  DescribeInstanceMonitorDataResponse describeInstanceMonitorDataWithOptions(shared_ptr<DescribeInstanceMonitorDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceMonitorDataResponse describeInstanceMonitorData(shared_ptr<DescribeInstanceMonitorDataRequest> request);
  DescribeInstanceSDGStatusResponse describeInstanceSDGStatusWithOptions(shared_ptr<DescribeInstanceSDGStatusRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceSDGStatusResponse describeInstanceSDGStatus(shared_ptr<DescribeInstanceSDGStatusRequest> request);
  DescribeInstanceSpecResponse describeInstanceSpecWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceSpecResponse describeInstanceSpec();
  DescribeInstanceTypesResponse describeInstanceTypesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceTypesResponse describeInstanceTypes();
  DescribeInstanceVncUrlResponse describeInstanceVncUrlWithOptions(shared_ptr<DescribeInstanceVncUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceVncUrlResponse describeInstanceVncUrl(shared_ptr<DescribeInstanceVncUrlRequest> request);
  DescribeInstancesResponse describeInstancesWithOptions(shared_ptr<DescribeInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstancesResponse describeInstances(shared_ptr<DescribeInstancesRequest> request);
  DescribeKeyPairsResponse describeKeyPairsWithOptions(shared_ptr<DescribeKeyPairsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeKeyPairsResponse describeKeyPairs(shared_ptr<DescribeKeyPairsRequest> request);
  DescribeLoadBalancerAttributeResponse describeLoadBalancerAttributeWithOptions(shared_ptr<DescribeLoadBalancerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoadBalancerAttributeResponse describeLoadBalancerAttribute(shared_ptr<DescribeLoadBalancerAttributeRequest> request);
  DescribeLoadBalancerHTTPListenerAttributeResponse describeLoadBalancerHTTPListenerAttributeWithOptions(shared_ptr<DescribeLoadBalancerHTTPListenerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoadBalancerHTTPListenerAttributeResponse describeLoadBalancerHTTPListenerAttribute(shared_ptr<DescribeLoadBalancerHTTPListenerAttributeRequest> request);
  DescribeLoadBalancerHTTPSListenerAttributeResponse describeLoadBalancerHTTPSListenerAttributeWithOptions(shared_ptr<DescribeLoadBalancerHTTPSListenerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoadBalancerHTTPSListenerAttributeResponse describeLoadBalancerHTTPSListenerAttribute(shared_ptr<DescribeLoadBalancerHTTPSListenerAttributeRequest> request);
  DescribeLoadBalancerListenMonitorResponse describeLoadBalancerListenMonitorWithOptions(shared_ptr<DescribeLoadBalancerListenMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoadBalancerListenMonitorResponse describeLoadBalancerListenMonitor(shared_ptr<DescribeLoadBalancerListenMonitorRequest> request);
  DescribeLoadBalancerListenersResponse describeLoadBalancerListenersWithOptions(shared_ptr<DescribeLoadBalancerListenersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoadBalancerListenersResponse describeLoadBalancerListeners(shared_ptr<DescribeLoadBalancerListenersRequest> request);
  DescribeLoadBalancerSpecResponse describeLoadBalancerSpecWithOptions(shared_ptr<DescribeLoadBalancerSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoadBalancerSpecResponse describeLoadBalancerSpec(shared_ptr<DescribeLoadBalancerSpecRequest> request);
  DescribeLoadBalancerTCPListenerAttributeResponse describeLoadBalancerTCPListenerAttributeWithOptions(shared_ptr<DescribeLoadBalancerTCPListenerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoadBalancerTCPListenerAttributeResponse describeLoadBalancerTCPListenerAttribute(shared_ptr<DescribeLoadBalancerTCPListenerAttributeRequest> request);
  DescribeLoadBalancerUDPListenerAttributeResponse describeLoadBalancerUDPListenerAttributeWithOptions(shared_ptr<DescribeLoadBalancerUDPListenerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoadBalancerUDPListenerAttributeResponse describeLoadBalancerUDPListenerAttribute(shared_ptr<DescribeLoadBalancerUDPListenerAttributeRequest> request);
  DescribeLoadBalancersResponse describeLoadBalancersWithOptions(shared_ptr<DescribeLoadBalancersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoadBalancersResponse describeLoadBalancers(shared_ptr<DescribeLoadBalancersRequest> request);
  DescribeMeasurementDataResponse describeMeasurementDataWithOptions(shared_ptr<DescribeMeasurementDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeasurementDataResponse describeMeasurementData(shared_ptr<DescribeMeasurementDataRequest> request);
  DescribeMountTargetsResponse describeMountTargetsWithOptions(shared_ptr<DescribeMountTargetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMountTargetsResponse describeMountTargets(shared_ptr<DescribeMountTargetsRequest> request);
  DescribeNCInformationResponse describeNCInformationWithOptions(shared_ptr<DescribeNCInformationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNCInformationResponse describeNCInformation(shared_ptr<DescribeNCInformationRequest> request);
  DescribeNatGatewaysResponse describeNatGatewaysWithOptions(shared_ptr<DescribeNatGatewaysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNatGatewaysResponse describeNatGateways(shared_ptr<DescribeNatGatewaysRequest> request);
  DescribeNetworkAclsResponse describeNetworkAclsWithOptions(shared_ptr<DescribeNetworkAclsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworkAclsResponse describeNetworkAcls(shared_ptr<DescribeNetworkAclsRequest> request);
  DescribeNetworkAttributeResponse describeNetworkAttributeWithOptions(shared_ptr<DescribeNetworkAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworkAttributeResponse describeNetworkAttribute(shared_ptr<DescribeNetworkAttributeRequest> request);
  DescribeNetworkInterfacesResponse describeNetworkInterfacesWithOptions(shared_ptr<DescribeNetworkInterfacesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworkInterfacesResponse describeNetworkInterfaces(shared_ptr<DescribeNetworkInterfacesRequest> request);
  DescribeNetworksResponse describeNetworksWithOptions(shared_ptr<DescribeNetworksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworksResponse describeNetworks(shared_ptr<DescribeNetworksRequest> request);
  DescribePrePaidInstanceStockResponse describePrePaidInstanceStockWithOptions(shared_ptr<DescribePrePaidInstanceStockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePrePaidInstanceStockResponse describePrePaidInstanceStock(shared_ptr<DescribePrePaidInstanceStockRequest> request);
  DescribePriceResponse describePriceWithOptions(shared_ptr<DescribePriceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePriceResponse describePrice(shared_ptr<DescribePriceRequest> request);
  DescribeRegionIspsResponse describeRegionIspsWithOptions(shared_ptr<DescribeRegionIspsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionIspsResponse describeRegionIsps(shared_ptr<DescribeRegionIspsRequest> request);
  DescribeRegionResourceResponse describeRegionResourceWithOptions(shared_ptr<DescribeRegionResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionResourceResponse describeRegionResource(shared_ptr<DescribeRegionResourceRequest> request);
  DescribeReservedResourceResponse describeReservedResourceWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeReservedResourceResponse describeReservedResource();
  DescribeResourceTimelineResponse describeResourceTimelineWithOptions(shared_ptr<DescribeResourceTimelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourceTimelineResponse describeResourceTimeline(shared_ptr<DescribeResourceTimelineRequest> request);
  DescribeSDGResponse describeSDGWithOptions(shared_ptr<DescribeSDGRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSDGResponse describeSDG(shared_ptr<DescribeSDGRequest> request);
  DescribeSDGDeploymentStatusResponse describeSDGDeploymentStatusWithOptions(shared_ptr<DescribeSDGDeploymentStatusRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSDGDeploymentStatusResponse describeSDGDeploymentStatus(shared_ptr<DescribeSDGDeploymentStatusRequest> request);
  DescribeSDGsResponse describeSDGsWithOptions(shared_ptr<DescribeSDGsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSDGsResponse describeSDGs(shared_ptr<DescribeSDGsRequest> request);
  DescribeSecondaryPublicIpAddressesResponse describeSecondaryPublicIpAddressesWithOptions(shared_ptr<DescribeSecondaryPublicIpAddressesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecondaryPublicIpAddressesResponse describeSecondaryPublicIpAddresses(shared_ptr<DescribeSecondaryPublicIpAddressesRequest> request);
  DescribeSecurityGroupAttributeResponse describeSecurityGroupAttributeWithOptions(shared_ptr<DescribeSecurityGroupAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityGroupAttributeResponse describeSecurityGroupAttribute(shared_ptr<DescribeSecurityGroupAttributeRequest> request);
  DescribeSecurityGroupsResponse describeSecurityGroupsWithOptions(shared_ptr<DescribeSecurityGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityGroupsResponse describeSecurityGroups(shared_ptr<DescribeSecurityGroupsRequest> request);
  DescribeSelfImagesResponse describeSelfImagesWithOptions(shared_ptr<DescribeSelfImagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSelfImagesResponse describeSelfImages(shared_ptr<DescribeSelfImagesRequest> request);
  DescribeServcieScheduleResponse describeServcieScheduleWithOptions(shared_ptr<DescribeServcieScheduleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeServcieScheduleResponse describeServcieSchedule(shared_ptr<DescribeServcieScheduleRequest> request);
  DescribeServerLoadBalancerListenMonitorResponse describeServerLoadBalancerListenMonitorWithOptions(shared_ptr<DescribeServerLoadBalancerListenMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeServerLoadBalancerListenMonitorResponse describeServerLoadBalancerListenMonitor(shared_ptr<DescribeServerLoadBalancerListenMonitorRequest> request);
  DescribeServerLoadBalancerMonitorResponse describeServerLoadBalancerMonitorWithOptions(shared_ptr<DescribeServerLoadBalancerMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeServerLoadBalancerMonitorResponse describeServerLoadBalancerMonitor(shared_ptr<DescribeServerLoadBalancerMonitorRequest> request);
  DescribeSnapshotsResponse describeSnapshotsWithOptions(shared_ptr<DescribeSnapshotsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSnapshotsResponse describeSnapshots(shared_ptr<DescribeSnapshotsRequest> request);
  DescribeSnatAttributeResponse describeSnatAttributeWithOptions(shared_ptr<DescribeSnatAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSnatAttributeResponse describeSnatAttribute(shared_ptr<DescribeSnatAttributeRequest> request);
  DescribeSnatTableEntriesResponse describeSnatTableEntriesWithOptions(shared_ptr<DescribeSnatTableEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSnatTableEntriesResponse describeSnatTableEntries(shared_ptr<DescribeSnatTableEntriesRequest> request);
  DescribeStorageGatewayResponse describeStorageGatewayWithOptions(shared_ptr<DescribeStorageGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStorageGatewayResponse describeStorageGateway(shared_ptr<DescribeStorageGatewayRequest> request);
  DescribeStorageVolumeResponse describeStorageVolumeWithOptions(shared_ptr<DescribeStorageVolumeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStorageVolumeResponse describeStorageVolume(shared_ptr<DescribeStorageVolumeRequest> request);
  DescribeUserBandWidthDataResponse describeUserBandWidthDataWithOptions(shared_ptr<DescribeUserBandWidthDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserBandWidthDataResponse describeUserBandWidthData(shared_ptr<DescribeUserBandWidthDataRequest> request);
  DescribeVSwitchAttributesResponse describeVSwitchAttributesWithOptions(shared_ptr<DescribeVSwitchAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVSwitchAttributesResponse describeVSwitchAttributes(shared_ptr<DescribeVSwitchAttributesRequest> request);
  DescribeVSwitchesResponse describeVSwitchesWithOptions(shared_ptr<DescribeVSwitchesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVSwitchesResponse describeVSwitches(shared_ptr<DescribeVSwitchesRequest> request);
  DetachDiskResponse detachDiskWithOptions(shared_ptr<DetachDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachDiskResponse detachDisk(shared_ptr<DetachDiskRequest> request);
  DetachInstanceSDGResponse detachInstanceSDGWithOptions(shared_ptr<DetachInstanceSDGRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachInstanceSDGResponse detachInstanceSDG(shared_ptr<DetachInstanceSDGRequest> request);
  DetachNetworkInterfaceResponse detachNetworkInterfaceWithOptions(shared_ptr<DetachNetworkInterfaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachNetworkInterfaceResponse detachNetworkInterface(shared_ptr<DetachNetworkInterfaceRequest> request);
  DistApplicationDataResponse distApplicationDataWithOptions(shared_ptr<DistApplicationDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DistApplicationDataResponse distApplicationData(shared_ptr<DistApplicationDataRequest> request);
  ExportBillDetailDataResponse exportBillDetailDataWithOptions(shared_ptr<ExportBillDetailDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportBillDetailDataResponse exportBillDetailData(shared_ptr<ExportBillDetailDataRequest> request);
  ExportImageResponse exportImageWithOptions(shared_ptr<ExportImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportImageResponse exportImage(shared_ptr<ExportImageRequest> request);
  ExportMeasurementDataResponse exportMeasurementDataWithOptions(shared_ptr<ExportMeasurementDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportMeasurementDataResponse exportMeasurementData(shared_ptr<ExportMeasurementDataRequest> request);
  GetBucketAclResponse getBucketAclWithOptions(shared_ptr<GetBucketAclRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBucketAclResponse getBucketAcl(shared_ptr<GetBucketAclRequest> request);
  GetBucketInfoResponse getBucketInfoWithOptions(shared_ptr<GetBucketInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBucketInfoResponse getBucketInfo(shared_ptr<GetBucketInfoRequest> request);
  GetBucketLifecycleResponse getBucketLifecycleWithOptions(shared_ptr<GetBucketLifecycleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBucketLifecycleResponse getBucketLifecycle(shared_ptr<GetBucketLifecycleRequest> request);
  GetOssStorageAndAccByBucketsResponse getOssStorageAndAccByBucketsWithOptions(shared_ptr<GetOssStorageAndAccByBucketsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOssStorageAndAccByBucketsResponse getOssStorageAndAccByBuckets(shared_ptr<GetOssStorageAndAccByBucketsRequest> request);
  GetOssUsageDataResponse getOssUsageDataWithOptions(shared_ptr<GetOssUsageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOssUsageDataResponse getOssUsageData(shared_ptr<GetOssUsageDataRequest> request);
  ImportImageResponse importImageWithOptions(shared_ptr<ImportImageRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportImageResponse importImage(shared_ptr<ImportImageRequest> request);
  ImportKeyPairResponse importKeyPairWithOptions(shared_ptr<ImportKeyPairRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportKeyPairResponse importKeyPair(shared_ptr<ImportKeyPairRequest> request);
  JoinPublicIpsToEpnInstanceResponse joinPublicIpsToEpnInstanceWithOptions(shared_ptr<JoinPublicIpsToEpnInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  JoinPublicIpsToEpnInstanceResponse joinPublicIpsToEpnInstance(shared_ptr<JoinPublicIpsToEpnInstanceRequest> request);
  JoinSecurityGroupResponse joinSecurityGroupWithOptions(shared_ptr<JoinSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  JoinSecurityGroupResponse joinSecurityGroup(shared_ptr<JoinSecurityGroupRequest> request);
  JoinVSwitchesToEpnInstanceResponse joinVSwitchesToEpnInstanceWithOptions(shared_ptr<JoinVSwitchesToEpnInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  JoinVSwitchesToEpnInstanceResponse joinVSwitchesToEpnInstance(shared_ptr<JoinVSwitchesToEpnInstanceRequest> request);
  LeaveSecurityGroupResponse leaveSecurityGroupWithOptions(shared_ptr<LeaveSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LeaveSecurityGroupResponse leaveSecurityGroup(shared_ptr<LeaveSecurityGroupRequest> request);
  ListApplicationsResponse listApplicationsWithOptions(shared_ptr<ListApplicationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationsResponse listApplications(shared_ptr<ListApplicationsRequest> request);
  ListBucketsResponse listBucketsWithOptions(shared_ptr<ListBucketsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBucketsResponse listBuckets(shared_ptr<ListBucketsRequest> request);
  ListObjectsResponse listObjectsWithOptions(shared_ptr<ListObjectsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListObjectsResponse listObjects(shared_ptr<ListObjectsRequest> request);
  ListProductAbilitiesResponse listProductAbilitiesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProductAbilitiesResponse listProductAbilities();
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ModifyEnsEipAddressAttributeResponse modifyEnsEipAddressAttributeWithOptions(shared_ptr<ModifyEnsEipAddressAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyEnsEipAddressAttributeResponse modifyEnsEipAddressAttribute(shared_ptr<ModifyEnsEipAddressAttributeRequest> request);
  ModifyEnsRouteEntryResponse modifyEnsRouteEntryWithOptions(shared_ptr<ModifyEnsRouteEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyEnsRouteEntryResponse modifyEnsRouteEntry(shared_ptr<ModifyEnsRouteEntryRequest> request);
  ModifyEpnInstanceResponse modifyEpnInstanceWithOptions(shared_ptr<ModifyEpnInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyEpnInstanceResponse modifyEpnInstance(shared_ptr<ModifyEpnInstanceRequest> request);
  ModifyFileSystemResponse modifyFileSystemWithOptions(shared_ptr<ModifyFileSystemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyFileSystemResponse modifyFileSystem(shared_ptr<ModifyFileSystemRequest> request);
  ModifyForwardEntryResponse modifyForwardEntryWithOptions(shared_ptr<ModifyForwardEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyForwardEntryResponse modifyForwardEntry(shared_ptr<ModifyForwardEntryRequest> request);
  ModifyHaVipAttributeResponse modifyHaVipAttributeWithOptions(shared_ptr<ModifyHaVipAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHaVipAttributeResponse modifyHaVipAttribute(shared_ptr<ModifyHaVipAttributeRequest> request);
  ModifyImageAttributeResponse modifyImageAttributeWithOptions(shared_ptr<ModifyImageAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyImageAttributeResponse modifyImageAttribute(shared_ptr<ModifyImageAttributeRequest> request);
  ModifyImageSharePermissionResponse modifyImageSharePermissionWithOptions(shared_ptr<ModifyImageSharePermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyImageSharePermissionResponse modifyImageSharePermission(shared_ptr<ModifyImageSharePermissionRequest> request);
  ModifyInstanceAttributeResponse modifyInstanceAttributeWithOptions(shared_ptr<ModifyInstanceAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceAttributeResponse modifyInstanceAttribute(shared_ptr<ModifyInstanceAttributeRequest> request);
  ModifyInstanceAutoRenewAttributeResponse modifyInstanceAutoRenewAttributeWithOptions(shared_ptr<ModifyInstanceAutoRenewAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceAutoRenewAttributeResponse modifyInstanceAutoRenewAttribute(shared_ptr<ModifyInstanceAutoRenewAttributeRequest> request);
  ModifyInstanceBootConfigurationResponse modifyInstanceBootConfigurationWithOptions(shared_ptr<ModifyInstanceBootConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceBootConfigurationResponse modifyInstanceBootConfiguration(shared_ptr<ModifyInstanceBootConfigurationRequest> request);
  ModifyInstanceChargeTypeResponse modifyInstanceChargeTypeWithOptions(shared_ptr<ModifyInstanceChargeTypeRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceChargeTypeResponse modifyInstanceChargeType(shared_ptr<ModifyInstanceChargeTypeRequest> request);
  ModifyLoadBalancerAttributeResponse modifyLoadBalancerAttributeWithOptions(shared_ptr<ModifyLoadBalancerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLoadBalancerAttributeResponse modifyLoadBalancerAttribute(shared_ptr<ModifyLoadBalancerAttributeRequest> request);
  ModifyNetworkAttributeResponse modifyNetworkAttributeWithOptions(shared_ptr<ModifyNetworkAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyNetworkAttributeResponse modifyNetworkAttribute(shared_ptr<ModifyNetworkAttributeRequest> request);
  ModifyNetworkInterfaceAttributeResponse modifyNetworkInterfaceAttributeWithOptions(shared_ptr<ModifyNetworkInterfaceAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyNetworkInterfaceAttributeResponse modifyNetworkInterfaceAttribute(shared_ptr<ModifyNetworkInterfaceAttributeRequest> request);
  ModifyPrepayInstanceSpecResponse modifyPrepayInstanceSpecWithOptions(shared_ptr<ModifyPrepayInstanceSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPrepayInstanceSpecResponse modifyPrepayInstanceSpec(shared_ptr<ModifyPrepayInstanceSpecRequest> request);
  ModifySecurityGroupAttributeResponse modifySecurityGroupAttributeWithOptions(shared_ptr<ModifySecurityGroupAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySecurityGroupAttributeResponse modifySecurityGroupAttribute(shared_ptr<ModifySecurityGroupAttributeRequest> request);
  ModifySnapshotAttributeResponse modifySnapshotAttributeWithOptions(shared_ptr<ModifySnapshotAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySnapshotAttributeResponse modifySnapshotAttribute(shared_ptr<ModifySnapshotAttributeRequest> request);
  ModifySnatEntryResponse modifySnatEntryWithOptions(shared_ptr<ModifySnatEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySnatEntryResponse modifySnatEntry(shared_ptr<ModifySnatEntryRequest> request);
  ModifyVSwitchAttributeResponse modifyVSwitchAttributeWithOptions(shared_ptr<ModifyVSwitchAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVSwitchAttributeResponse modifyVSwitchAttribute(shared_ptr<ModifyVSwitchAttributeRequest> request);
  MountInstanceSDGResponse mountInstanceSDGWithOptions(shared_ptr<MountInstanceSDGRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MountInstanceSDGResponse mountInstanceSDG(shared_ptr<MountInstanceSDGRequest> request);
  PreloadRegionSDGResponse preloadRegionSDGWithOptions(shared_ptr<PreloadRegionSDGRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PreloadRegionSDGResponse preloadRegionSDG(shared_ptr<PreloadRegionSDGRequest> request);
  PrepareUploadResponse prepareUploadWithOptions(shared_ptr<PrepareUploadRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PrepareUploadResponse prepareUpload(shared_ptr<PrepareUploadRequest> request);
  PushApplicationDataResponse pushApplicationDataWithOptions(shared_ptr<PushApplicationDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PushApplicationDataResponse pushApplicationData(shared_ptr<PushApplicationDataRequest> request);
  PutBucketResponse putBucketWithOptions(shared_ptr<PutBucketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutBucketResponse putBucket(shared_ptr<PutBucketRequest> request);
  PutBucketAclResponse putBucketAclWithOptions(shared_ptr<PutBucketAclRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutBucketAclResponse putBucketAcl(shared_ptr<PutBucketAclRequest> request);
  PutBucketLifecycleResponse putBucketLifecycleWithOptions(shared_ptr<PutBucketLifecycleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutBucketLifecycleResponse putBucketLifecycle(shared_ptr<PutBucketLifecycleRequest> request);
  ReInitDiskResponse reInitDiskWithOptions(shared_ptr<ReInitDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReInitDiskResponse reInitDisk(shared_ptr<ReInitDiskRequest> request);
  RebootAICInstanceResponse rebootAICInstanceWithOptions(shared_ptr<RebootAICInstanceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RebootAICInstanceResponse rebootAICInstance(shared_ptr<RebootAICInstanceRequest> request);
  RebootARMServerInstanceResponse rebootARMServerInstanceWithOptions(shared_ptr<RebootARMServerInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RebootARMServerInstanceResponse rebootARMServerInstance(shared_ptr<RebootARMServerInstanceRequest> request);
  RebootInstanceResponse rebootInstanceWithOptions(shared_ptr<RebootInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RebootInstanceResponse rebootInstance(shared_ptr<RebootInstanceRequest> request);
  RebootInstancesResponse rebootInstancesWithOptions(shared_ptr<RebootInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RebootInstancesResponse rebootInstances(shared_ptr<RebootInstancesRequest> request);
  RecoverAICInstanceResponse recoverAICInstanceWithOptions(shared_ptr<RecoverAICInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RecoverAICInstanceResponse recoverAICInstance(shared_ptr<RecoverAICInstanceRequest> request);
  ReinitInstanceResponse reinitInstanceWithOptions(shared_ptr<ReinitInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReinitInstanceResponse reinitInstance(shared_ptr<ReinitInstanceRequest> request);
  ReinitInstancesResponse reinitInstancesWithOptions(shared_ptr<ReinitInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReinitInstancesResponse reinitInstances(shared_ptr<ReinitInstancesRequest> request);
  ReleaseAICInstanceResponse releaseAICInstanceWithOptions(shared_ptr<ReleaseAICInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseAICInstanceResponse releaseAICInstance(shared_ptr<ReleaseAICInstanceRequest> request);
  ReleaseARMServerInstanceResponse releaseARMServerInstanceWithOptions(shared_ptr<ReleaseARMServerInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseARMServerInstanceResponse releaseARMServerInstance(shared_ptr<ReleaseARMServerInstanceRequest> request);
  ReleaseInstanceResponse releaseInstanceWithOptions(shared_ptr<ReleaseInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseInstanceResponse releaseInstance(shared_ptr<ReleaseInstanceRequest> request);
  ReleasePostPaidInstanceResponse releasePostPaidInstanceWithOptions(shared_ptr<ReleasePostPaidInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleasePostPaidInstanceResponse releasePostPaidInstance(shared_ptr<ReleasePostPaidInstanceRequest> request);
  ReleasePrePaidInstanceResponse releasePrePaidInstanceWithOptions(shared_ptr<ReleasePrePaidInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleasePrePaidInstanceResponse releasePrePaidInstance(shared_ptr<ReleasePrePaidInstanceRequest> request);
  RemoveBackendServersResponse removeBackendServersWithOptions(shared_ptr<RemoveBackendServersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveBackendServersResponse removeBackendServers(shared_ptr<RemoveBackendServersRequest> request);
  RemoveInstanceSDGResponse removeInstanceSDGWithOptions(shared_ptr<RemoveInstanceSDGRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveInstanceSDGResponse removeInstanceSDG(shared_ptr<RemoveInstanceSDGRequest> request);
  RemovePublicIpsFromEpnInstanceResponse removePublicIpsFromEpnInstanceWithOptions(shared_ptr<RemovePublicIpsFromEpnInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemovePublicIpsFromEpnInstanceResponse removePublicIpsFromEpnInstance(shared_ptr<RemovePublicIpsFromEpnInstanceRequest> request);
  RemoveSDGResponse removeSDGWithOptions(shared_ptr<RemoveSDGRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveSDGResponse removeSDG(shared_ptr<RemoveSDGRequest> request);
  RemoveVSwitchesFromEpnInstanceResponse removeVSwitchesFromEpnInstanceWithOptions(shared_ptr<RemoveVSwitchesFromEpnInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveVSwitchesFromEpnInstanceResponse removeVSwitchesFromEpnInstance(shared_ptr<RemoveVSwitchesFromEpnInstanceRequest> request);
  RenewARMServerInstanceResponse renewARMServerInstanceWithOptions(shared_ptr<RenewARMServerInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenewARMServerInstanceResponse renewARMServerInstance(shared_ptr<RenewARMServerInstanceRequest> request);
  RenewInstanceResponse renewInstanceWithOptions(shared_ptr<RenewInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenewInstanceResponse renewInstance(shared_ptr<RenewInstanceRequest> request);
  RescaleApplicationResponse rescaleApplicationWithOptions(shared_ptr<RescaleApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RescaleApplicationResponse rescaleApplication(shared_ptr<RescaleApplicationRequest> request);
  RescaleDeviceServiceResponse rescaleDeviceServiceWithOptions(shared_ptr<RescaleDeviceServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RescaleDeviceServiceResponse rescaleDeviceService(shared_ptr<RescaleDeviceServiceRequest> request);
  ResetAICInstanceResponse resetAICInstanceWithOptions(shared_ptr<ResetAICInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetAICInstanceResponse resetAICInstance(shared_ptr<ResetAICInstanceRequest> request);
  ResetDiskResponse resetDiskWithOptions(shared_ptr<ResetDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetDiskResponse resetDisk(shared_ptr<ResetDiskRequest> request);
  ResizeDiskResponse resizeDiskWithOptions(shared_ptr<ResizeDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResizeDiskResponse resizeDisk(shared_ptr<ResizeDiskRequest> request);
  RevokeSecurityGroupResponse revokeSecurityGroupWithOptions(shared_ptr<RevokeSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeSecurityGroupResponse revokeSecurityGroup(shared_ptr<RevokeSecurityGroupRequest> request);
  RevokeSecurityGroupEgressResponse revokeSecurityGroupEgressWithOptions(shared_ptr<RevokeSecurityGroupEgressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeSecurityGroupEgressResponse revokeSecurityGroupEgress(shared_ptr<RevokeSecurityGroupEgressRequest> request);
  RollbackApplicationResponse rollbackApplicationWithOptions(shared_ptr<RollbackApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RollbackApplicationResponse rollbackApplication(shared_ptr<RollbackApplicationRequest> request);
  RunInstancesResponse runInstancesWithOptions(shared_ptr<RunInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunInstancesResponse runInstances(shared_ptr<RunInstancesRequest> request);
  RunServiceScheduleResponse runServiceScheduleWithOptions(shared_ptr<RunServiceScheduleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunServiceScheduleResponse runServiceSchedule(shared_ptr<RunServiceScheduleRequest> request);
  SaveSDGResponse saveSDGWithOptions(shared_ptr<SaveSDGRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveSDGResponse saveSDG(shared_ptr<SaveSDGRequest> request);
  SetBackendServersResponse setBackendServersWithOptions(shared_ptr<SetBackendServersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetBackendServersResponse setBackendServers(shared_ptr<SetBackendServersRequest> request);
  SetLoadBalancerHTTPListenerAttributeResponse setLoadBalancerHTTPListenerAttributeWithOptions(shared_ptr<SetLoadBalancerHTTPListenerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLoadBalancerHTTPListenerAttributeResponse setLoadBalancerHTTPListenerAttribute(shared_ptr<SetLoadBalancerHTTPListenerAttributeRequest> request);
  SetLoadBalancerHTTPSListenerAttributeResponse setLoadBalancerHTTPSListenerAttributeWithOptions(shared_ptr<SetLoadBalancerHTTPSListenerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLoadBalancerHTTPSListenerAttributeResponse setLoadBalancerHTTPSListenerAttribute(shared_ptr<SetLoadBalancerHTTPSListenerAttributeRequest> request);
  SetLoadBalancerStatusResponse setLoadBalancerStatusWithOptions(shared_ptr<SetLoadBalancerStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLoadBalancerStatusResponse setLoadBalancerStatus(shared_ptr<SetLoadBalancerStatusRequest> request);
  SetLoadBalancerTCPListenerAttributeResponse setLoadBalancerTCPListenerAttributeWithOptions(shared_ptr<SetLoadBalancerTCPListenerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLoadBalancerTCPListenerAttributeResponse setLoadBalancerTCPListenerAttribute(shared_ptr<SetLoadBalancerTCPListenerAttributeRequest> request);
  SetLoadBalancerUDPListenerAttributeResponse setLoadBalancerUDPListenerAttributeWithOptions(shared_ptr<SetLoadBalancerUDPListenerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLoadBalancerUDPListenerAttributeResponse setLoadBalancerUDPListenerAttribute(shared_ptr<SetLoadBalancerUDPListenerAttributeRequest> request);
  StartEpnInstanceResponse startEpnInstanceWithOptions(shared_ptr<StartEpnInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartEpnInstanceResponse startEpnInstance(shared_ptr<StartEpnInstanceRequest> request);
  StartInstanceResponse startInstanceWithOptions(shared_ptr<StartInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartInstanceResponse startInstance(shared_ptr<StartInstanceRequest> request);
  StartInstancesResponse startInstancesWithOptions(shared_ptr<StartInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartInstancesResponse startInstances(shared_ptr<StartInstancesRequest> request);
  StartLoadBalancerListenerResponse startLoadBalancerListenerWithOptions(shared_ptr<StartLoadBalancerListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartLoadBalancerListenerResponse startLoadBalancerListener(shared_ptr<StartLoadBalancerListenerRequest> request);
  StartSnatIpForSnatEntryResponse startSnatIpForSnatEntryWithOptions(shared_ptr<StartSnatIpForSnatEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartSnatIpForSnatEntryResponse startSnatIpForSnatEntry(shared_ptr<StartSnatIpForSnatEntryRequest> request);
  StopEpnInstanceResponse stopEpnInstanceWithOptions(shared_ptr<StopEpnInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopEpnInstanceResponse stopEpnInstance(shared_ptr<StopEpnInstanceRequest> request);
  StopInstanceResponse stopInstanceWithOptions(shared_ptr<StopInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopInstanceResponse stopInstance(shared_ptr<StopInstanceRequest> request);
  StopInstancesResponse stopInstancesWithOptions(shared_ptr<StopInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopInstancesResponse stopInstances(shared_ptr<StopInstancesRequest> request);
  StopLoadBalancerListenerResponse stopLoadBalancerListenerWithOptions(shared_ptr<StopLoadBalancerListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopLoadBalancerListenerResponse stopLoadBalancerListener(shared_ptr<StopLoadBalancerListenerRequest> request);
  StopSnatIpForSnatEntryResponse stopSnatIpForSnatEntryWithOptions(shared_ptr<StopSnatIpForSnatEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopSnatIpForSnatEntryResponse stopSnatIpForSnatEntry(shared_ptr<StopSnatIpForSnatEntryRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  UnAssociateEnsEipAddressResponse unAssociateEnsEipAddressWithOptions(shared_ptr<UnAssociateEnsEipAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnAssociateEnsEipAddressResponse unAssociateEnsEipAddress(shared_ptr<UnAssociateEnsEipAddressRequest> request);
  UnassignPrivateIpAddressesResponse unassignPrivateIpAddressesWithOptions(shared_ptr<UnassignPrivateIpAddressesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnassignPrivateIpAddressesResponse unassignPrivateIpAddresses(shared_ptr<UnassignPrivateIpAddressesRequest> request);
  UnassociateHaVipResponse unassociateHaVipWithOptions(shared_ptr<UnassociateHaVipRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnassociateHaVipResponse unassociateHaVip(shared_ptr<UnassociateHaVipRequest> request);
  UnassociateNetworkAclResponse unassociateNetworkAclWithOptions(shared_ptr<UnassociateNetworkAclRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnassociateNetworkAclResponse unassociateNetworkAcl(shared_ptr<UnassociateNetworkAclRequest> request);
  UnloadRegionSDGResponse unloadRegionSDGWithOptions(shared_ptr<UnloadRegionSDGRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnloadRegionSDGResponse unloadRegionSDG(shared_ptr<UnloadRegionSDGRequest> request);
  UnmountInstanceSDGResponse unmountInstanceSDGWithOptions(shared_ptr<UnmountInstanceSDGRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnmountInstanceSDGResponse unmountInstanceSDG(shared_ptr<UnmountInstanceSDGRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UpdateEnsSaleControlResponse updateEnsSaleControlWithOptions(shared_ptr<UpdateEnsSaleControlRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEnsSaleControlResponse updateEnsSaleControl(shared_ptr<UpdateEnsSaleControlRequest> request);
  UpgradeAICInstanceImageResponse upgradeAICInstanceImageWithOptions(shared_ptr<UpgradeAICInstanceImageRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeAICInstanceImageResponse upgradeAICInstanceImage(shared_ptr<UpgradeAICInstanceImageRequest> request);
  UpgradeApplicationResponse upgradeApplicationWithOptions(shared_ptr<UpgradeApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeApplicationResponse upgradeApplication(shared_ptr<UpgradeApplicationRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Ens20171110

#endif
