// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_ENS20171110_H_
#define ALIBABACLOUD_ENS20171110_H_

#include <alibabacloud/open_api.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Ens20171110 {
class DataDisk : public Darabonba::Model {
public:
  shared_ptr<long> size{};

  DataDisk() {}

  explicit DataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DataDisk() = default;
};
class HealthCheck : public Darabonba::Model {
public:
  shared_ptr<string> healthCheck{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<long> healthCheckConnectTimeout{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckMethod{};
  shared_ptr<long> healthCheckTimeout{};
  shared_ptr<string> healthCheckType{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> unhealthyThreshold{};

  HealthCheck() {}

  explicit HealthCheck(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckConnectTimeout) {
      res["HealthCheckConnectTimeout"] = boost::any(*healthCheckConnectTimeout);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckMethod) {
      res["HealthCheckMethod"] = boost::any(*healthCheckMethod);
    }
    if (healthCheckTimeout) {
      res["HealthCheckTimeout"] = boost::any(*healthCheckTimeout);
    }
    if (healthCheckType) {
      res["HealthCheckType"] = boost::any(*healthCheckType);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckConnectTimeout") != m.end() && !m["HealthCheckConnectTimeout"].empty()) {
      healthCheckConnectTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectTimeout"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckMethod") != m.end() && !m["HealthCheckMethod"].empty()) {
      healthCheckMethod = make_shared<string>(boost::any_cast<string>(m["HealthCheckMethod"]));
    }
    if (m.find("HealthCheckTimeout") != m.end() && !m["HealthCheckTimeout"].empty()) {
      healthCheckTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckTimeout"]));
    }
    if (m.find("HealthCheckType") != m.end() && !m["HealthCheckType"].empty()) {
      healthCheckType = make_shared<string>(boost::any_cast<string>(m["HealthCheckType"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~HealthCheck() = default;
};
class HttpConfig : public Darabonba::Model {
public:
  shared_ptr<string> cookie{};
  shared_ptr<long> cookieTimeout{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<long> requestTimeout{};
  shared_ptr<string> scheduler{};
  shared_ptr<string> serverCertificateId{};
  shared_ptr<string> stickySession{};
  shared_ptr<string> stickySessionType{};
  shared_ptr<string> XForwardedFor{};

  HttpConfig() {}

  explicit HttpConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cookie) {
      res["Cookie"] = boost::any(*cookie);
    }
    if (cookieTimeout) {
      res["CookieTimeout"] = boost::any(*cookieTimeout);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (requestTimeout) {
      res["RequestTimeout"] = boost::any(*requestTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (serverCertificateId) {
      res["ServerCertificateId"] = boost::any(*serverCertificateId);
    }
    if (stickySession) {
      res["StickySession"] = boost::any(*stickySession);
    }
    if (stickySessionType) {
      res["StickySessionType"] = boost::any(*stickySessionType);
    }
    if (XForwardedFor) {
      res["XForwardedFor"] = boost::any(*XForwardedFor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cookie") != m.end() && !m["Cookie"].empty()) {
      cookie = make_shared<string>(boost::any_cast<string>(m["Cookie"]));
    }
    if (m.find("CookieTimeout") != m.end() && !m["CookieTimeout"].empty()) {
      cookieTimeout = make_shared<long>(boost::any_cast<long>(m["CookieTimeout"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("RequestTimeout") != m.end() && !m["RequestTimeout"].empty()) {
      requestTimeout = make_shared<long>(boost::any_cast<long>(m["RequestTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("ServerCertificateId") != m.end() && !m["ServerCertificateId"].empty()) {
      serverCertificateId = make_shared<string>(boost::any_cast<string>(m["ServerCertificateId"]));
    }
    if (m.find("StickySession") != m.end() && !m["StickySession"].empty()) {
      stickySession = make_shared<string>(boost::any_cast<string>(m["StickySession"]));
    }
    if (m.find("StickySessionType") != m.end() && !m["StickySessionType"].empty()) {
      stickySessionType = make_shared<string>(boost::any_cast<string>(m["StickySessionType"]));
    }
    if (m.find("XForwardedFor") != m.end() && !m["XForwardedFor"].empty()) {
      XForwardedFor = make_shared<string>(boost::any_cast<string>(m["XForwardedFor"]));
    }
  }


  virtual ~HttpConfig() = default;
};
class SecurityGroupRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> direction{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<long> priority{};

  SecurityGroupRule() {}

  explicit SecurityGroupRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
  }


  virtual ~SecurityGroupRule() = default;
};
class TcpConfig : public Darabonba::Model {
public:
  shared_ptr<long> establishedTimeout{};
  shared_ptr<long> persistenceTimeout{};
  shared_ptr<string> scheduler{};

  TcpConfig() {}

  explicit TcpConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (establishedTimeout) {
      res["EstablishedTimeout"] = boost::any(*establishedTimeout);
    }
    if (persistenceTimeout) {
      res["PersistenceTimeout"] = boost::any(*persistenceTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EstablishedTimeout") != m.end() && !m["EstablishedTimeout"].empty()) {
      establishedTimeout = make_shared<long>(boost::any_cast<long>(m["EstablishedTimeout"]));
    }
    if (m.find("PersistenceTimeout") != m.end() && !m["PersistenceTimeout"].empty()) {
      persistenceTimeout = make_shared<long>(boost::any_cast<long>(m["PersistenceTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
  }


  virtual ~TcpConfig() = default;
};
class UdpCheck : public Darabonba::Model {
public:
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<long> healthCheckConnectTimeout{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> unhealthyThreshold{};

  UdpCheck() {}

  explicit UdpCheck(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckConnectTimeout) {
      res["HealthCheckConnectTimeout"] = boost::any(*healthCheckConnectTimeout);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckConnectTimeout") != m.end() && !m["HealthCheckConnectTimeout"].empty()) {
      healthCheckConnectTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectTimeout"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~UdpCheck() = default;
};
class UdpConfig : public Darabonba::Model {
public:
  shared_ptr<string> hashKey{};
  shared_ptr<string> scheduler{};

  UdpConfig() {}

  explicit UdpConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hashKey) {
      res["HashKey"] = boost::any(*hashKey);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HashKey") != m.end() && !m["HashKey"].empty()) {
      hashKey = make_shared<string>(boost::any_cast<string>(m["HashKey"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
  }


  virtual ~UdpConfig() = default;
};
class AddBackendServersRequestBackendServers : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<long> port{};
  shared_ptr<string> serverId{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  AddBackendServersRequestBackendServers() {}

  explicit AddBackendServersRequestBackendServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~AddBackendServersRequestBackendServers() = default;
};
class AddBackendServersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AddBackendServersRequestBackendServers>> backendServers{};
  shared_ptr<string> loadBalancerId{};

  AddBackendServersRequest() {}

  explicit AddBackendServersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServers) {
      vector<boost::any> temp1;
      for(auto item1:*backendServers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendServers"] = boost::any(temp1);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendServers"].type()) {
        vector<AddBackendServersRequestBackendServers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendServers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddBackendServersRequestBackendServers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendServers = make_shared<vector<AddBackendServersRequestBackendServers>>(expect1);
      }
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~AddBackendServersRequest() = default;
};
class AddBackendServersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> backendServersShrink{};
  shared_ptr<string> loadBalancerId{};

  AddBackendServersShrinkRequest() {}

  explicit AddBackendServersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServersShrink) {
      res["BackendServers"] = boost::any(*backendServersShrink);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      backendServersShrink = make_shared<string>(boost::any_cast<string>(m["BackendServers"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~AddBackendServersShrinkRequest() = default;
};
class AddBackendServersResponseBodyBackendServersBackendServer : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<long> port{};
  shared_ptr<string> serverId{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  AddBackendServersResponseBodyBackendServersBackendServer() {}

  explicit AddBackendServersResponseBodyBackendServersBackendServer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~AddBackendServersResponseBodyBackendServersBackendServer() = default;
};
class AddBackendServersResponseBodyBackendServers : public Darabonba::Model {
public:
  shared_ptr<vector<AddBackendServersResponseBodyBackendServersBackendServer>> backendServer{};

  AddBackendServersResponseBodyBackendServers() {}

  explicit AddBackendServersResponseBodyBackendServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServer) {
      vector<boost::any> temp1;
      for(auto item1:*backendServer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendServer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServer") != m.end() && !m["BackendServer"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendServer"].type()) {
        vector<AddBackendServersResponseBodyBackendServersBackendServer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendServer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddBackendServersResponseBodyBackendServersBackendServer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendServer = make_shared<vector<AddBackendServersResponseBodyBackendServersBackendServer>>(expect1);
      }
    }
  }


  virtual ~AddBackendServersResponseBodyBackendServers() = default;
};
class AddBackendServersResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddBackendServersResponseBodyBackendServers> backendServers{};
  shared_ptr<string> requestId{};

  AddBackendServersResponseBody() {}

  explicit AddBackendServersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServers) {
      res["BackendServers"] = backendServers ? boost::any(backendServers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackendServers"].type()) {
        AddBackendServersResponseBodyBackendServers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackendServers"]));
        backendServers = make_shared<AddBackendServersResponseBodyBackendServers>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddBackendServersResponseBody() = default;
};
class AddBackendServersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddBackendServersResponseBody> body{};

  AddBackendServersResponse() {}

  explicit AddBackendServersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddBackendServersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddBackendServersResponseBody>(model1);
      }
    }
  }


  virtual ~AddBackendServersResponse() = default;
};
class AddDeviceInternetPortRequest : public Darabonba::Model {
public:
  shared_ptr<string> ISP{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> internalIp{};
  shared_ptr<string> internalPort{};
  shared_ptr<string> natType{};
  shared_ptr<string> regionId{};

  AddDeviceInternetPortRequest() {}

  explicit AddDeviceInternetPortRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (internalIp) {
      res["InternalIp"] = boost::any(*internalIp);
    }
    if (internalPort) {
      res["InternalPort"] = boost::any(*internalPort);
    }
    if (natType) {
      res["NatType"] = boost::any(*natType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InternalIp") != m.end() && !m["InternalIp"].empty()) {
      internalIp = make_shared<string>(boost::any_cast<string>(m["InternalIp"]));
    }
    if (m.find("InternalPort") != m.end() && !m["InternalPort"].empty()) {
      internalPort = make_shared<string>(boost::any_cast<string>(m["InternalPort"]));
    }
    if (m.find("NatType") != m.end() && !m["NatType"].empty()) {
      natType = make_shared<string>(boost::any_cast<string>(m["NatType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddDeviceInternetPortRequest() = default;
};
class AddDeviceInternetPortResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> ruleIds{};

  AddDeviceInternetPortResponseBody() {}

  explicit AddDeviceInternetPortResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleIds) {
      res["RuleIds"] = boost::any(*ruleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleIds") != m.end() && !m["RuleIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddDeviceInternetPortResponseBody() = default;
};
class AddDeviceInternetPortResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddDeviceInternetPortResponseBody> body{};

  AddDeviceInternetPortResponse() {}

  explicit AddDeviceInternetPortResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDeviceInternetPortResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDeviceInternetPortResponseBody>(model1);
      }
    }
  }


  virtual ~AddDeviceInternetPortResponse() = default;
};
class AddNetworkInterfaceToInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoStart{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> networks{};

  AddNetworkInterfaceToInstanceRequest() {}

  explicit AddNetworkInterfaceToInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoStart) {
      res["AutoStart"] = boost::any(*autoStart);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networks) {
      res["Networks"] = boost::any(*networks);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoStart") != m.end() && !m["AutoStart"].empty()) {
      autoStart = make_shared<bool>(boost::any_cast<bool>(m["AutoStart"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Networks") != m.end() && !m["Networks"].empty()) {
      networks = make_shared<string>(boost::any_cast<string>(m["Networks"]));
    }
  }


  virtual ~AddNetworkInterfaceToInstanceRequest() = default;
};
class AddNetworkInterfaceToInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddNetworkInterfaceToInstanceResponseBody() {}

  explicit AddNetworkInterfaceToInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddNetworkInterfaceToInstanceResponseBody() = default;
};
class AddNetworkInterfaceToInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddNetworkInterfaceToInstanceResponseBody> body{};

  AddNetworkInterfaceToInstanceResponse() {}

  explicit AddNetworkInterfaceToInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddNetworkInterfaceToInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddNetworkInterfaceToInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~AddNetworkInterfaceToInstanceResponse() = default;
};
class AllocateEipAddressRequest : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<long> minCount{};
  shared_ptr<string> version{};

  AllocateEipAddressRequest() {}

  explicit AllocateEipAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (minCount) {
      res["MinCount"] = boost::any(*minCount);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("MinCount") != m.end() && !m["MinCount"].empty()) {
      minCount = make_shared<long>(boost::any_cast<long>(m["MinCount"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~AllocateEipAddressRequest() = default;
};
class AllocateEipAddressResponseBodyEipAddressesEipAddress : public Darabonba::Model {
public:
  shared_ptr<string> eip{};

  AllocateEipAddressResponseBodyEipAddressesEipAddress() {}

  explicit AllocateEipAddressResponseBodyEipAddressesEipAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eip) {
      res["Eip"] = boost::any(*eip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Eip") != m.end() && !m["Eip"].empty()) {
      eip = make_shared<string>(boost::any_cast<string>(m["Eip"]));
    }
  }


  virtual ~AllocateEipAddressResponseBodyEipAddressesEipAddress() = default;
};
class AllocateEipAddressResponseBodyEipAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<AllocateEipAddressResponseBodyEipAddressesEipAddress>> eipAddress{};

  AllocateEipAddressResponseBodyEipAddresses() {}

  explicit AllocateEipAddressResponseBodyEipAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipAddress) {
      vector<boost::any> temp1;
      for(auto item1:*eipAddress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EipAddress"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipAddress") != m.end() && !m["EipAddress"].empty()) {
      if (typeid(vector<boost::any>) == m["EipAddress"].type()) {
        vector<AllocateEipAddressResponseBodyEipAddressesEipAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EipAddress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AllocateEipAddressResponseBodyEipAddressesEipAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eipAddress = make_shared<vector<AllocateEipAddressResponseBodyEipAddressesEipAddress>>(expect1);
      }
    }
  }


  virtual ~AllocateEipAddressResponseBodyEipAddresses() = default;
};
class AllocateEipAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bizStatusCode{};
  shared_ptr<AllocateEipAddressResponseBodyEipAddresses> eipAddresses{};
  shared_ptr<string> requestId{};

  AllocateEipAddressResponseBody() {}

  explicit AllocateEipAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizStatusCode) {
      res["BizStatusCode"] = boost::any(*bizStatusCode);
    }
    if (eipAddresses) {
      res["EipAddresses"] = eipAddresses ? boost::any(eipAddresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizStatusCode") != m.end() && !m["BizStatusCode"].empty()) {
      bizStatusCode = make_shared<string>(boost::any_cast<string>(m["BizStatusCode"]));
    }
    if (m.find("EipAddresses") != m.end() && !m["EipAddresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["EipAddresses"].type()) {
        AllocateEipAddressResponseBodyEipAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EipAddresses"]));
        eipAddresses = make_shared<AllocateEipAddressResponseBodyEipAddresses>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AllocateEipAddressResponseBody() = default;
};
class AllocateEipAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AllocateEipAddressResponseBody> body{};

  AllocateEipAddressResponse() {}

  explicit AllocateEipAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AllocateEipAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AllocateEipAddressResponseBody>(model1);
      }
    }
  }


  virtual ~AllocateEipAddressResponse() = default;
};
class AssociateEipAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> eip{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceIdInternetIp{};
  shared_ptr<string> version{};

  AssociateEipAddressRequest() {}

  explicit AssociateEipAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eip) {
      res["Eip"] = boost::any(*eip);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceIdInternetIp) {
      res["InstanceIdInternetIp"] = boost::any(*instanceIdInternetIp);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Eip") != m.end() && !m["Eip"].empty()) {
      eip = make_shared<string>(boost::any_cast<string>(m["Eip"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceIdInternetIp") != m.end() && !m["InstanceIdInternetIp"].empty()) {
      instanceIdInternetIp = make_shared<string>(boost::any_cast<string>(m["InstanceIdInternetIp"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~AssociateEipAddressRequest() = default;
};
class AssociateEipAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateEipAddressResponseBody() {}

  explicit AssociateEipAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateEipAddressResponseBody() = default;
};
class AssociateEipAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AssociateEipAddressResponseBody> body{};

  AssociateEipAddressResponse() {}

  explicit AssociateEipAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateEipAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateEipAddressResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateEipAddressResponse() = default;
};
class AssociateEnsEipAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};

  AssociateEnsEipAddressRequest() {}

  explicit AssociateEnsEipAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~AssociateEnsEipAddressRequest() = default;
};
class AssociateEnsEipAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateEnsEipAddressResponseBody() {}

  explicit AssociateEnsEipAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateEnsEipAddressResponseBody() = default;
};
class AssociateEnsEipAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AssociateEnsEipAddressResponseBody> body{};

  AssociateEnsEipAddressResponse() {}

  explicit AssociateEnsEipAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateEnsEipAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateEnsEipAddressResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateEnsEipAddressResponse() = default;
};
class AttachDiskRequest : public Darabonba::Model {
public:
  shared_ptr<string> deleteWithInstance{};
  shared_ptr<string> diskId{};
  shared_ptr<string> instanceId{};

  AttachDiskRequest() {}

  explicit AttachDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteWithInstance) {
      res["DeleteWithInstance"] = boost::any(*deleteWithInstance);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteWithInstance") != m.end() && !m["DeleteWithInstance"].empty()) {
      deleteWithInstance = make_shared<string>(boost::any_cast<string>(m["DeleteWithInstance"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~AttachDiskRequest() = default;
};
class AttachDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  AttachDiskResponseBody() {}

  explicit AttachDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachDiskResponseBody() = default;
};
class AttachDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AttachDiskResponseBody> body{};

  AttachDiskResponse() {}

  explicit AttachDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachDiskResponseBody>(model1);
      }
    }
  }


  virtual ~AttachDiskResponse() = default;
};
class AttachEnsInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scripts{};
  shared_ptr<string> version{};

  AttachEnsInstancesRequest() {}

  explicit AttachEnsInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scripts) {
      res["Scripts"] = boost::any(*scripts);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Scripts") != m.end() && !m["Scripts"].empty()) {
      scripts = make_shared<string>(boost::any_cast<string>(m["Scripts"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~AttachEnsInstancesRequest() = default;
};
class AttachEnsInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AttachEnsInstancesResponseBody() {}

  explicit AttachEnsInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachEnsInstancesResponseBody() = default;
};
class AttachEnsInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AttachEnsInstancesResponseBody> body{};

  AttachEnsInstancesResponse() {}

  explicit AttachEnsInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachEnsInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachEnsInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~AttachEnsInstancesResponse() = default;
};
class AuthorizeSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> version{};

  AuthorizeSecurityGroupRequest() {}

  explicit AuthorizeSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~AuthorizeSecurityGroupRequest() = default;
};
class AuthorizeSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AuthorizeSecurityGroupResponseBody() {}

  explicit AuthorizeSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AuthorizeSecurityGroupResponseBody() = default;
};
class AuthorizeSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AuthorizeSecurityGroupResponseBody> body{};

  AuthorizeSecurityGroupResponse() {}

  explicit AuthorizeSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AuthorizeSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AuthorizeSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AuthorizeSecurityGroupResponse() = default;
};
class AuthorizeSecurityGroupEgressRequest : public Darabonba::Model {
public:
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> version{};

  AuthorizeSecurityGroupEgressRequest() {}

  explicit AuthorizeSecurityGroupEgressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~AuthorizeSecurityGroupEgressRequest() = default;
};
class AuthorizeSecurityGroupEgressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AuthorizeSecurityGroupEgressResponseBody() {}

  explicit AuthorizeSecurityGroupEgressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AuthorizeSecurityGroupEgressResponseBody() = default;
};
class AuthorizeSecurityGroupEgressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AuthorizeSecurityGroupEgressResponseBody> body{};

  AuthorizeSecurityGroupEgressResponse() {}

  explicit AuthorizeSecurityGroupEgressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AuthorizeSecurityGroupEgressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AuthorizeSecurityGroupEgressResponseBody>(model1);
      }
    }
  }


  virtual ~AuthorizeSecurityGroupEgressResponse() = default;
};
class CheckQuotaRequest : public Darabonba::Model {
public:
  shared_ptr<long> aliUid{};
  shared_ptr<string> groupUuid{};
  shared_ptr<string> resourceAttribute{};

  CheckQuotaRequest() {}

  explicit CheckQuotaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (groupUuid) {
      res["GroupUuid"] = boost::any(*groupUuid);
    }
    if (resourceAttribute) {
      res["ResourceAttribute"] = boost::any(*resourceAttribute);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("GroupUuid") != m.end() && !m["GroupUuid"].empty()) {
      groupUuid = make_shared<string>(boost::any_cast<string>(m["GroupUuid"]));
    }
    if (m.find("ResourceAttribute") != m.end() && !m["ResourceAttribute"].empty()) {
      resourceAttribute = make_shared<string>(boost::any_cast<string>(m["ResourceAttribute"]));
    }
  }


  virtual ~CheckQuotaRequest() = default;
};
class CheckQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> desc{};
  shared_ptr<string> msg{};
  shared_ptr<string> requestId{};

  CheckQuotaResponseBody() {}

  explicit CheckQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckQuotaResponseBody() = default;
};
class CheckQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CheckQuotaResponseBody> body{};

  CheckQuotaResponse() {}

  explicit CheckQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~CheckQuotaResponse() = default;
};
class ConfigureSecurityGroupPermissionsRequestAuthorizePermissions : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> direction{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> sourcePortRange{};

  ConfigureSecurityGroupPermissionsRequestAuthorizePermissions() {}

  explicit ConfigureSecurityGroupPermissionsRequestAuthorizePermissions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
  }


  virtual ~ConfigureSecurityGroupPermissionsRequestAuthorizePermissions() = default;
};
class ConfigureSecurityGroupPermissionsRequestRevokePermissions : public Darabonba::Model {
public:
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> direction{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> sourcePortRange{};

  ConfigureSecurityGroupPermissionsRequestRevokePermissions() {}

  explicit ConfigureSecurityGroupPermissionsRequestRevokePermissions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
  }


  virtual ~ConfigureSecurityGroupPermissionsRequestRevokePermissions() = default;
};
class ConfigureSecurityGroupPermissionsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ConfigureSecurityGroupPermissionsRequestAuthorizePermissions>> authorizePermissions{};
  shared_ptr<vector<ConfigureSecurityGroupPermissionsRequestRevokePermissions>> revokePermissions{};
  shared_ptr<string> securityGroupId{};

  ConfigureSecurityGroupPermissionsRequest() {}

  explicit ConfigureSecurityGroupPermissionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizePermissions) {
      vector<boost::any> temp1;
      for(auto item1:*authorizePermissions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizePermissions"] = boost::any(temp1);
    }
    if (revokePermissions) {
      vector<boost::any> temp1;
      for(auto item1:*revokePermissions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RevokePermissions"] = boost::any(temp1);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizePermissions") != m.end() && !m["AuthorizePermissions"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizePermissions"].type()) {
        vector<ConfigureSecurityGroupPermissionsRequestAuthorizePermissions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizePermissions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ConfigureSecurityGroupPermissionsRequestAuthorizePermissions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizePermissions = make_shared<vector<ConfigureSecurityGroupPermissionsRequestAuthorizePermissions>>(expect1);
      }
    }
    if (m.find("RevokePermissions") != m.end() && !m["RevokePermissions"].empty()) {
      if (typeid(vector<boost::any>) == m["RevokePermissions"].type()) {
        vector<ConfigureSecurityGroupPermissionsRequestRevokePermissions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RevokePermissions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ConfigureSecurityGroupPermissionsRequestRevokePermissions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        revokePermissions = make_shared<vector<ConfigureSecurityGroupPermissionsRequestRevokePermissions>>(expect1);
      }
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~ConfigureSecurityGroupPermissionsRequest() = default;
};
class ConfigureSecurityGroupPermissionsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> authorizePermissionsShrink{};
  shared_ptr<string> revokePermissionsShrink{};
  shared_ptr<string> securityGroupId{};

  ConfigureSecurityGroupPermissionsShrinkRequest() {}

  explicit ConfigureSecurityGroupPermissionsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizePermissionsShrink) {
      res["AuthorizePermissions"] = boost::any(*authorizePermissionsShrink);
    }
    if (revokePermissionsShrink) {
      res["RevokePermissions"] = boost::any(*revokePermissionsShrink);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizePermissions") != m.end() && !m["AuthorizePermissions"].empty()) {
      authorizePermissionsShrink = make_shared<string>(boost::any_cast<string>(m["AuthorizePermissions"]));
    }
    if (m.find("RevokePermissions") != m.end() && !m["RevokePermissions"].empty()) {
      revokePermissionsShrink = make_shared<string>(boost::any_cast<string>(m["RevokePermissions"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~ConfigureSecurityGroupPermissionsShrinkRequest() = default;
};
class ConfigureSecurityGroupPermissionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConfigureSecurityGroupPermissionsResponseBody() {}

  explicit ConfigureSecurityGroupPermissionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfigureSecurityGroupPermissionsResponseBody() = default;
};
class ConfigureSecurityGroupPermissionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ConfigureSecurityGroupPermissionsResponseBody> body{};

  ConfigureSecurityGroupPermissionsResponse() {}

  explicit ConfigureSecurityGroupPermissionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigureSecurityGroupPermissionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigureSecurityGroupPermissionsResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigureSecurityGroupPermissionsResponse() = default;
};
class CreateApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> template_{};
  shared_ptr<long> timeout{};

  CreateApplicationRequest() {}

  explicit CreateApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~CreateApplicationRequest() = default;
};
class CreateApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> requestId{};

  CreateApplicationResponseBody() {}

  explicit CreateApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateApplicationResponseBody() = default;
};
class CreateApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateApplicationResponseBody> body{};

  CreateApplicationResponse() {}

  explicit CreateApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApplicationResponse() = default;
};
class CreateDiskRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> size{};

  CreateDiskRequest() {}

  explicit CreateDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
  }


  virtual ~CreateDiskRequest() = default;
};
class CreateDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  CreateDiskResponseBody() {}

  explicit CreateDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDiskResponseBody() = default;
};
class CreateDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDiskResponseBody> body{};

  CreateDiskResponse() {}

  explicit CreateDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDiskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDiskResponse() = default;
};
class CreateDiskBuyOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> orderDetails{};

  CreateDiskBuyOrderRequest() {}

  explicit CreateDiskBuyOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderDetails) {
      res["OrderDetails"] = boost::any(*orderDetails);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderDetails") != m.end() && !m["OrderDetails"].empty()) {
      orderDetails = make_shared<string>(boost::any_cast<string>(m["OrderDetails"]));
    }
  }


  virtual ~CreateDiskBuyOrderRequest() = default;
};
class CreateDiskBuyOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  CreateDiskBuyOrderResponseBody() {}

  explicit CreateDiskBuyOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDiskBuyOrderResponseBody() = default;
};
class CreateDiskBuyOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDiskBuyOrderResponseBody> body{};

  CreateDiskBuyOrderResponse() {}

  explicit CreateDiskBuyOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDiskBuyOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDiskBuyOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDiskBuyOrderResponse() = default;
};
class CreateEPInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceName{};
  shared_ptr<string> EPNInstanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> networkingModel{};

  CreateEPInstanceRequest() {}

  explicit CreateEPInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceName) {
      res["EPNInstanceName"] = boost::any(*EPNInstanceName);
    }
    if (EPNInstanceType) {
      res["EPNInstanceType"] = boost::any(*EPNInstanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (networkingModel) {
      res["NetworkingModel"] = boost::any(*networkingModel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceName") != m.end() && !m["EPNInstanceName"].empty()) {
      EPNInstanceName = make_shared<string>(boost::any_cast<string>(m["EPNInstanceName"]));
    }
    if (m.find("EPNInstanceType") != m.end() && !m["EPNInstanceType"].empty()) {
      EPNInstanceType = make_shared<string>(boost::any_cast<string>(m["EPNInstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("NetworkingModel") != m.end() && !m["NetworkingModel"].empty()) {
      networkingModel = make_shared<string>(boost::any_cast<string>(m["NetworkingModel"]));
    }
  }


  virtual ~CreateEPInstanceRequest() = default;
};
class CreateEPInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> requestId{};

  CreateEPInstanceResponseBody() {}

  explicit CreateEPInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEPInstanceResponseBody() = default;
};
class CreateEPInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateEPInstanceResponseBody> body{};

  CreateEPInstanceResponse() {}

  explicit CreateEPInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEPInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEPInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEPInstanceResponse() = default;
};
class CreateEipInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> isp{};
  shared_ptr<string> name{};

  CreateEipInstanceRequest() {}

  explicit CreateEipInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateEipInstanceRequest() = default;
};
class CreateEipInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> requestId{};

  CreateEipInstanceResponseBody() {}

  explicit CreateEipInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEipInstanceResponseBody() = default;
};
class CreateEipInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateEipInstanceResponseBody> body{};

  CreateEipInstanceResponse() {}

  explicit CreateEipInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEipInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEipInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEipInstanceResponse() = default;
};
class CreateElbBuyOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> orderDetails{};

  CreateElbBuyOrderRequest() {}

  explicit CreateElbBuyOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderDetails) {
      res["OrderDetails"] = boost::any(*orderDetails);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderDetails") != m.end() && !m["OrderDetails"].empty()) {
      orderDetails = make_shared<string>(boost::any_cast<string>(m["OrderDetails"]));
    }
  }


  virtual ~CreateElbBuyOrderRequest() = default;
};
class CreateElbBuyOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> loadBalancerIds{};
  shared_ptr<string> requestId{};

  CreateElbBuyOrderResponseBody() {}

  explicit CreateElbBuyOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerIds) {
      res["LoadBalancerIds"] = boost::any(*loadBalancerIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerIds") != m.end() && !m["LoadBalancerIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LoadBalancerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LoadBalancerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      loadBalancerIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateElbBuyOrderResponseBody() = default;
};
class CreateElbBuyOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateElbBuyOrderResponseBody> body{};

  CreateElbBuyOrderResponse() {}

  explicit CreateElbBuyOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateElbBuyOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateElbBuyOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateElbBuyOrderResponse() = default;
};
class CreateEnsServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensServiceId{};
  shared_ptr<string> orderType{};
  shared_ptr<string> version{};

  CreateEnsServiceRequest() {}

  explicit CreateEnsServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensServiceId) {
      res["EnsServiceId"] = boost::any(*ensServiceId);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsServiceId") != m.end() && !m["EnsServiceId"].empty()) {
      ensServiceId = make_shared<string>(boost::any_cast<string>(m["EnsServiceId"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~CreateEnsServiceRequest() = default;
};
class CreateEnsServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  CreateEnsServiceResponseBody() {}

  explicit CreateEnsServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEnsServiceResponseBody() = default;
};
class CreateEnsServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateEnsServiceResponseBody> body{};

  CreateEnsServiceResponse() {}

  explicit CreateEnsServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEnsServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEnsServiceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEnsServiceResponse() = default;
};
class CreateEpnInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceName{};
  shared_ptr<string> EPNInstanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> networkingModel{};

  CreateEpnInstanceRequest() {}

  explicit CreateEpnInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceName) {
      res["EPNInstanceName"] = boost::any(*EPNInstanceName);
    }
    if (EPNInstanceType) {
      res["EPNInstanceType"] = boost::any(*EPNInstanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (networkingModel) {
      res["NetworkingModel"] = boost::any(*networkingModel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceName") != m.end() && !m["EPNInstanceName"].empty()) {
      EPNInstanceName = make_shared<string>(boost::any_cast<string>(m["EPNInstanceName"]));
    }
    if (m.find("EPNInstanceType") != m.end() && !m["EPNInstanceType"].empty()) {
      EPNInstanceType = make_shared<string>(boost::any_cast<string>(m["EPNInstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("NetworkingModel") != m.end() && !m["NetworkingModel"].empty()) {
      networkingModel = make_shared<string>(boost::any_cast<string>(m["NetworkingModel"]));
    }
  }


  virtual ~CreateEpnInstanceRequest() = default;
};
class CreateEpnInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> requestId{};

  CreateEpnInstanceResponseBody() {}

  explicit CreateEpnInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEpnInstanceResponseBody() = default;
};
class CreateEpnInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateEpnInstanceResponseBody> body{};

  CreateEpnInstanceResponse() {}

  explicit CreateEpnInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEpnInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEpnInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEpnInstanceResponse() = default;
};
class CreateImageRequest : public Darabonba::Model {
public:
  shared_ptr<string> deleteAfterImageUpload{};
  shared_ptr<string> imageName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> product{};

  CreateImageRequest() {}

  explicit CreateImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteAfterImageUpload) {
      res["DeleteAfterImageUpload"] = boost::any(*deleteAfterImageUpload);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (product) {
      res["product"] = boost::any(*product);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteAfterImageUpload") != m.end() && !m["DeleteAfterImageUpload"].empty()) {
      deleteAfterImageUpload = make_shared<string>(boost::any_cast<string>(m["DeleteAfterImageUpload"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("product") != m.end() && !m["product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["product"]));
    }
  }


  virtual ~CreateImageRequest() = default;
};
class CreateImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> imageId{};
  shared_ptr<string> requestId{};

  CreateImageResponseBody() {}

  explicit CreateImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateImageResponseBody() = default;
};
class CreateImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateImageResponseBody> body{};

  CreateImageResponse() {}

  explicit CreateImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateImageResponseBody>(model1);
      }
    }
  }


  virtual ~CreateImageResponse() = default;
};
class CreateInstanceRequestDataDisk : public Darabonba::Model {
public:
  shared_ptr<string> size{};

  CreateInstanceRequestDataDisk() {}

  explicit CreateInstanceRequestDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
  }


  virtual ~CreateInstanceRequestDataDisk() = default;
};
class CreateInstanceRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> size{};

  CreateInstanceRequestSystemDisk() {}

  explicit CreateInstanceRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
  }


  virtual ~CreateInstanceRequestSystemDisk() = default;
};
class CreateInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateInstanceRequestDataDisk>> dataDisk{};
  shared_ptr<CreateInstanceRequestSystemDisk> systemDisk{};
  shared_ptr<string> autoRenew{};
  shared_ptr<string> autoRenewPeriod{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> ipType{};
  shared_ptr<string> keyPairName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> password{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> period{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<bool> publicIpIdentification{};
  shared_ptr<string> quantity{};
  shared_ptr<bool> uniqueSuffix{};
  shared_ptr<string> userData{};
  shared_ptr<string> vSwitchId{};

  CreateInstanceRequest() {}

  explicit CreateInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewPeriod) {
      res["AutoRenewPeriod"] = boost::any(*autoRenewPeriod);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (paymentType) {
      res["PaymentType"] = boost::any(*paymentType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (publicIpIdentification) {
      res["PublicIpIdentification"] = boost::any(*publicIpIdentification);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (uniqueSuffix) {
      res["UniqueSuffix"] = boost::any(*uniqueSuffix);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<CreateInstanceRequestDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateInstanceRequestDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<CreateInstanceRequestDataDisk>>(expect1);
      }
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        CreateInstanceRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<CreateInstanceRequestSystemDisk>(model1);
      }
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<string>(boost::any_cast<string>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewPeriod") != m.end() && !m["AutoRenewPeriod"].empty()) {
      autoRenewPeriod = make_shared<string>(boost::any_cast<string>(m["AutoRenewPeriod"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<string>(boost::any_cast<string>(m["IpType"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PaymentType") != m.end() && !m["PaymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["PaymentType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("PublicIpIdentification") != m.end() && !m["PublicIpIdentification"].empty()) {
      publicIpIdentification = make_shared<bool>(boost::any_cast<bool>(m["PublicIpIdentification"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<string>(boost::any_cast<string>(m["Quantity"]));
    }
    if (m.find("UniqueSuffix") != m.end() && !m["UniqueSuffix"].empty()) {
      uniqueSuffix = make_shared<bool>(boost::any_cast<bool>(m["UniqueSuffix"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateInstanceRequest() = default;
};
class CreateInstanceResponseBodyInstanceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceId{};

  CreateInstanceResponseBodyInstanceIds() {}

  explicit CreateInstanceResponseBodyInstanceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateInstanceResponseBodyInstanceIds() = default;
};
class CreateInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<CreateInstanceResponseBodyInstanceIds> instanceIds{};
  shared_ptr<string> requestId{};

  CreateInstanceResponseBody() {}

  explicit CreateInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (instanceIds) {
      res["InstanceIds"] = instanceIds ? boost::any(instanceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceIds"].type()) {
        CreateInstanceResponseBodyInstanceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceIds"]));
        instanceIds = make_shared<CreateInstanceResponseBodyInstanceIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateInstanceResponseBody() = default;
};
class CreateInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateInstanceResponseBody> body{};

  CreateInstanceResponse() {}

  explicit CreateInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateInstanceResponse() = default;
};
class CreateKeyPairRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyPairName{};
  shared_ptr<string> version{};

  CreateKeyPairRequest() {}

  explicit CreateKeyPairRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~CreateKeyPairRequest() = default;
};
class CreateKeyPairResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> keyPairFingerPrint{};
  shared_ptr<string> keyPairId{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> privateKeyBody{};
  shared_ptr<string> requestId{};

  CreateKeyPairResponseBody() {}

  explicit CreateKeyPairResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPairFingerPrint) {
      res["KeyPairFingerPrint"] = boost::any(*keyPairFingerPrint);
    }
    if (keyPairId) {
      res["KeyPairId"] = boost::any(*keyPairId);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (privateKeyBody) {
      res["PrivateKeyBody"] = boost::any(*privateKeyBody);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPairFingerPrint") != m.end() && !m["KeyPairFingerPrint"].empty()) {
      keyPairFingerPrint = make_shared<string>(boost::any_cast<string>(m["KeyPairFingerPrint"]));
    }
    if (m.find("KeyPairId") != m.end() && !m["KeyPairId"].empty()) {
      keyPairId = make_shared<string>(boost::any_cast<string>(m["KeyPairId"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("PrivateKeyBody") != m.end() && !m["PrivateKeyBody"].empty()) {
      privateKeyBody = make_shared<string>(boost::any_cast<string>(m["PrivateKeyBody"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateKeyPairResponseBody() = default;
};
class CreateKeyPairResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateKeyPairResponseBody> body{};

  CreateKeyPairResponse() {}

  explicit CreateKeyPairResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateKeyPairResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateKeyPairResponseBody>(model1);
      }
    }
  }


  virtual ~CreateKeyPairResponse() = default;
};
class CreateLoadBalancerRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> loadBalancerName{};
  shared_ptr<string> loadBalancerSpec{};
  shared_ptr<string> networkId{};
  shared_ptr<string> payType{};
  shared_ptr<string> vSwitchId{};

  CreateLoadBalancerRequest() {}

  explicit CreateLoadBalancerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (loadBalancerName) {
      res["LoadBalancerName"] = boost::any(*loadBalancerName);
    }
    if (loadBalancerSpec) {
      res["LoadBalancerSpec"] = boost::any(*loadBalancerSpec);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("LoadBalancerName") != m.end() && !m["LoadBalancerName"].empty()) {
      loadBalancerName = make_shared<string>(boost::any_cast<string>(m["LoadBalancerName"]));
    }
    if (m.find("LoadBalancerSpec") != m.end() && !m["LoadBalancerSpec"].empty()) {
      loadBalancerSpec = make_shared<string>(boost::any_cast<string>(m["LoadBalancerSpec"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateLoadBalancerRequest() = default;
};
class CreateLoadBalancerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> loadBalancerName{};
  shared_ptr<string> networkId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vSwitchId{};

  CreateLoadBalancerResponseBody() {}

  explicit CreateLoadBalancerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (loadBalancerName) {
      res["LoadBalancerName"] = boost::any(*loadBalancerName);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("LoadBalancerName") != m.end() && !m["LoadBalancerName"].empty()) {
      loadBalancerName = make_shared<string>(boost::any_cast<string>(m["LoadBalancerName"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateLoadBalancerResponseBody() = default;
};
class CreateLoadBalancerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateLoadBalancerResponseBody> body{};

  CreateLoadBalancerResponse() {}

  explicit CreateLoadBalancerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLoadBalancerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLoadBalancerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLoadBalancerResponse() = default;
};
class CreateLoadBalancerHTTPListenerRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> forwardPort{};
  shared_ptr<string> healthCheck{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckMethod{};
  shared_ptr<long> healthCheckTimeout{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<string> listenerForward{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<long> requestTimeout{};
  shared_ptr<string> scheduler{};
  shared_ptr<long> unhealthyThreshold{};
  shared_ptr<string> XForwardedFor{};

  CreateLoadBalancerHTTPListenerRequest() {}

  explicit CreateLoadBalancerHTTPListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (forwardPort) {
      res["ForwardPort"] = boost::any(*forwardPort);
    }
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckMethod) {
      res["HealthCheckMethod"] = boost::any(*healthCheckMethod);
    }
    if (healthCheckTimeout) {
      res["HealthCheckTimeout"] = boost::any(*healthCheckTimeout);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (listenerForward) {
      res["ListenerForward"] = boost::any(*listenerForward);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (requestTimeout) {
      res["RequestTimeout"] = boost::any(*requestTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    if (XForwardedFor) {
      res["XForwardedFor"] = boost::any(*XForwardedFor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ForwardPort") != m.end() && !m["ForwardPort"].empty()) {
      forwardPort = make_shared<long>(boost::any_cast<long>(m["ForwardPort"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckMethod") != m.end() && !m["HealthCheckMethod"].empty()) {
      healthCheckMethod = make_shared<string>(boost::any_cast<string>(m["HealthCheckMethod"]));
    }
    if (m.find("HealthCheckTimeout") != m.end() && !m["HealthCheckTimeout"].empty()) {
      healthCheckTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckTimeout"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("ListenerForward") != m.end() && !m["ListenerForward"].empty()) {
      listenerForward = make_shared<string>(boost::any_cast<string>(m["ListenerForward"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("RequestTimeout") != m.end() && !m["RequestTimeout"].empty()) {
      requestTimeout = make_shared<long>(boost::any_cast<long>(m["RequestTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
    if (m.find("XForwardedFor") != m.end() && !m["XForwardedFor"].empty()) {
      XForwardedFor = make_shared<string>(boost::any_cast<string>(m["XForwardedFor"]));
    }
  }


  virtual ~CreateLoadBalancerHTTPListenerRequest() = default;
};
class CreateLoadBalancerHTTPListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateLoadBalancerHTTPListenerResponseBody() {}

  explicit CreateLoadBalancerHTTPListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLoadBalancerHTTPListenerResponseBody() = default;
};
class CreateLoadBalancerHTTPListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateLoadBalancerHTTPListenerResponseBody> body{};

  CreateLoadBalancerHTTPListenerResponse() {}

  explicit CreateLoadBalancerHTTPListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLoadBalancerHTTPListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLoadBalancerHTTPListenerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLoadBalancerHTTPListenerResponse() = default;
};
class CreateLoadBalancerHTTPSListenerRequest : public Darabonba::Model {
public:
  shared_ptr<string> cookie{};
  shared_ptr<long> cookieTimeout{};
  shared_ptr<string> description{};
  shared_ptr<long> forwardPort{};
  shared_ptr<string> healthCheck{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckMethod{};
  shared_ptr<long> healthCheckTimeout{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<string> listenerForward{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<long> requestTimeout{};
  shared_ptr<string> scheduler{};
  shared_ptr<string> serverCertificateId{};
  shared_ptr<string> stickySessionType{};
  shared_ptr<long> unhealthyThreshold{};

  CreateLoadBalancerHTTPSListenerRequest() {}

  explicit CreateLoadBalancerHTTPSListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cookie) {
      res["Cookie"] = boost::any(*cookie);
    }
    if (cookieTimeout) {
      res["CookieTimeout"] = boost::any(*cookieTimeout);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (forwardPort) {
      res["ForwardPort"] = boost::any(*forwardPort);
    }
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckMethod) {
      res["HealthCheckMethod"] = boost::any(*healthCheckMethod);
    }
    if (healthCheckTimeout) {
      res["HealthCheckTimeout"] = boost::any(*healthCheckTimeout);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (listenerForward) {
      res["ListenerForward"] = boost::any(*listenerForward);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (requestTimeout) {
      res["RequestTimeout"] = boost::any(*requestTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (serverCertificateId) {
      res["ServerCertificateId"] = boost::any(*serverCertificateId);
    }
    if (stickySessionType) {
      res["StickySessionType"] = boost::any(*stickySessionType);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cookie") != m.end() && !m["Cookie"].empty()) {
      cookie = make_shared<string>(boost::any_cast<string>(m["Cookie"]));
    }
    if (m.find("CookieTimeout") != m.end() && !m["CookieTimeout"].empty()) {
      cookieTimeout = make_shared<long>(boost::any_cast<long>(m["CookieTimeout"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ForwardPort") != m.end() && !m["ForwardPort"].empty()) {
      forwardPort = make_shared<long>(boost::any_cast<long>(m["ForwardPort"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckMethod") != m.end() && !m["HealthCheckMethod"].empty()) {
      healthCheckMethod = make_shared<string>(boost::any_cast<string>(m["HealthCheckMethod"]));
    }
    if (m.find("HealthCheckTimeout") != m.end() && !m["HealthCheckTimeout"].empty()) {
      healthCheckTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckTimeout"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("ListenerForward") != m.end() && !m["ListenerForward"].empty()) {
      listenerForward = make_shared<string>(boost::any_cast<string>(m["ListenerForward"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("RequestTimeout") != m.end() && !m["RequestTimeout"].empty()) {
      requestTimeout = make_shared<long>(boost::any_cast<long>(m["RequestTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("ServerCertificateId") != m.end() && !m["ServerCertificateId"].empty()) {
      serverCertificateId = make_shared<string>(boost::any_cast<string>(m["ServerCertificateId"]));
    }
    if (m.find("StickySessionType") != m.end() && !m["StickySessionType"].empty()) {
      stickySessionType = make_shared<string>(boost::any_cast<string>(m["StickySessionType"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~CreateLoadBalancerHTTPSListenerRequest() = default;
};
class CreateLoadBalancerHTTPSListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateLoadBalancerHTTPSListenerResponseBody() {}

  explicit CreateLoadBalancerHTTPSListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLoadBalancerHTTPSListenerResponseBody() = default;
};
class CreateLoadBalancerHTTPSListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateLoadBalancerHTTPSListenerResponseBody> body{};

  CreateLoadBalancerHTTPSListenerResponse() {}

  explicit CreateLoadBalancerHTTPSListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLoadBalancerHTTPSListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLoadBalancerHTTPSListenerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLoadBalancerHTTPSListenerResponse() = default;
};
class CreateLoadBalancerTCPListenerRequest : public Darabonba::Model {
public:
  shared_ptr<long> backendServerPort{};
  shared_ptr<string> description{};
  shared_ptr<string> eipTransmit{};
  shared_ptr<long> establishedTimeout{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<long> healthCheckConnectTimeout{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckType{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<long> persistenceTimeout{};
  shared_ptr<string> scheduler{};
  shared_ptr<long> unhealthyThreshold{};

  CreateLoadBalancerTCPListenerRequest() {}

  explicit CreateLoadBalancerTCPListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServerPort) {
      res["BackendServerPort"] = boost::any(*backendServerPort);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eipTransmit) {
      res["EipTransmit"] = boost::any(*eipTransmit);
    }
    if (establishedTimeout) {
      res["EstablishedTimeout"] = boost::any(*establishedTimeout);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckConnectTimeout) {
      res["HealthCheckConnectTimeout"] = boost::any(*healthCheckConnectTimeout);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckType) {
      res["HealthCheckType"] = boost::any(*healthCheckType);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (persistenceTimeout) {
      res["PersistenceTimeout"] = boost::any(*persistenceTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServerPort") != m.end() && !m["BackendServerPort"].empty()) {
      backendServerPort = make_shared<long>(boost::any_cast<long>(m["BackendServerPort"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EipTransmit") != m.end() && !m["EipTransmit"].empty()) {
      eipTransmit = make_shared<string>(boost::any_cast<string>(m["EipTransmit"]));
    }
    if (m.find("EstablishedTimeout") != m.end() && !m["EstablishedTimeout"].empty()) {
      establishedTimeout = make_shared<long>(boost::any_cast<long>(m["EstablishedTimeout"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckConnectTimeout") != m.end() && !m["HealthCheckConnectTimeout"].empty()) {
      healthCheckConnectTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectTimeout"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckType") != m.end() && !m["HealthCheckType"].empty()) {
      healthCheckType = make_shared<string>(boost::any_cast<string>(m["HealthCheckType"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("PersistenceTimeout") != m.end() && !m["PersistenceTimeout"].empty()) {
      persistenceTimeout = make_shared<long>(boost::any_cast<long>(m["PersistenceTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~CreateLoadBalancerTCPListenerRequest() = default;
};
class CreateLoadBalancerTCPListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateLoadBalancerTCPListenerResponseBody() {}

  explicit CreateLoadBalancerTCPListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLoadBalancerTCPListenerResponseBody() = default;
};
class CreateLoadBalancerTCPListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateLoadBalancerTCPListenerResponseBody> body{};

  CreateLoadBalancerTCPListenerResponse() {}

  explicit CreateLoadBalancerTCPListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLoadBalancerTCPListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLoadBalancerTCPListenerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLoadBalancerTCPListenerResponse() = default;
};
class CreateLoadBalancerUDPListenerRequest : public Darabonba::Model {
public:
  shared_ptr<long> backendServerPort{};
  shared_ptr<string> description{};
  shared_ptr<string> eipTransmit{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<long> healthCheckConnectTimeout{};
  shared_ptr<string> healthCheckExp{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckReq{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> scheduler{};
  shared_ptr<long> unhealthyThreshold{};

  CreateLoadBalancerUDPListenerRequest() {}

  explicit CreateLoadBalancerUDPListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServerPort) {
      res["BackendServerPort"] = boost::any(*backendServerPort);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eipTransmit) {
      res["EipTransmit"] = boost::any(*eipTransmit);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckConnectTimeout) {
      res["HealthCheckConnectTimeout"] = boost::any(*healthCheckConnectTimeout);
    }
    if (healthCheckExp) {
      res["HealthCheckExp"] = boost::any(*healthCheckExp);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckReq) {
      res["HealthCheckReq"] = boost::any(*healthCheckReq);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServerPort") != m.end() && !m["BackendServerPort"].empty()) {
      backendServerPort = make_shared<long>(boost::any_cast<long>(m["BackendServerPort"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EipTransmit") != m.end() && !m["EipTransmit"].empty()) {
      eipTransmit = make_shared<string>(boost::any_cast<string>(m["EipTransmit"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckConnectTimeout") != m.end() && !m["HealthCheckConnectTimeout"].empty()) {
      healthCheckConnectTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectTimeout"]));
    }
    if (m.find("HealthCheckExp") != m.end() && !m["HealthCheckExp"].empty()) {
      healthCheckExp = make_shared<string>(boost::any_cast<string>(m["HealthCheckExp"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckReq") != m.end() && !m["HealthCheckReq"].empty()) {
      healthCheckReq = make_shared<string>(boost::any_cast<string>(m["HealthCheckReq"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~CreateLoadBalancerUDPListenerRequest() = default;
};
class CreateLoadBalancerUDPListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateLoadBalancerUDPListenerResponseBody() {}

  explicit CreateLoadBalancerUDPListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLoadBalancerUDPListenerResponseBody() = default;
};
class CreateLoadBalancerUDPListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateLoadBalancerUDPListenerResponseBody> body{};

  CreateLoadBalancerUDPListenerResponse() {}

  explicit CreateLoadBalancerUDPListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLoadBalancerUDPListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLoadBalancerUDPListenerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLoadBalancerUDPListenerResponse() = default;
};
class CreateNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> networkName{};

  CreateNetworkRequest() {}

  explicit CreateNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (networkName) {
      res["NetworkName"] = boost::any(*networkName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("NetworkName") != m.end() && !m["NetworkName"].empty()) {
      networkName = make_shared<string>(boost::any_cast<string>(m["NetworkName"]));
    }
  }


  virtual ~CreateNetworkRequest() = default;
};
class CreateNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> networkId{};
  shared_ptr<string> requestId{};

  CreateNetworkResponseBody() {}

  explicit CreateNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateNetworkResponseBody() = default;
};
class CreateNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateNetworkResponseBody> body{};

  CreateNetworkResponse() {}

  explicit CreateNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNetworkResponse() = default;
};
class CreateSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<string> version{};

  CreateSecurityGroupRequest() {}

  explicit CreateSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~CreateSecurityGroupRequest() = default;
};
class CreateSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> securityGroupId{};

  CreateSecurityGroupResponseBody() {}

  explicit CreateSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~CreateSecurityGroupResponseBody() = default;
};
class CreateSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateSecurityGroupResponseBody> body{};

  CreateSecurityGroupResponse() {}

  explicit CreateSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSecurityGroupResponse() = default;
};
class CreateVSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> networkId{};
  shared_ptr<string> vSwitchName{};
  shared_ptr<string> version{};

  CreateVSwitchRequest() {}

  explicit CreateVSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~CreateVSwitchRequest() = default;
};
class CreateVSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vSwitchId{};

  CreateVSwitchResponseBody() {}

  explicit CreateVSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateVSwitchResponseBody() = default;
};
class CreateVSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateVSwitchResponseBody> body{};

  CreateVSwitchResponse() {}

  explicit CreateVSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVSwitchResponse() = default;
};
class CreateVmAndSaveStockRequest : public Darabonba::Model {
public:
  shared_ptr<long> aliUid{};
  shared_ptr<string> groupUuid{};
  shared_ptr<string> resourceAttribute{};
  shared_ptr<string> tenant{};
  shared_ptr<string> workloadUuid{};

  CreateVmAndSaveStockRequest() {}

  explicit CreateVmAndSaveStockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (groupUuid) {
      res["GroupUuid"] = boost::any(*groupUuid);
    }
    if (resourceAttribute) {
      res["ResourceAttribute"] = boost::any(*resourceAttribute);
    }
    if (tenant) {
      res["Tenant"] = boost::any(*tenant);
    }
    if (workloadUuid) {
      res["WorkloadUuid"] = boost::any(*workloadUuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("GroupUuid") != m.end() && !m["GroupUuid"].empty()) {
      groupUuid = make_shared<string>(boost::any_cast<string>(m["GroupUuid"]));
    }
    if (m.find("ResourceAttribute") != m.end() && !m["ResourceAttribute"].empty()) {
      resourceAttribute = make_shared<string>(boost::any_cast<string>(m["ResourceAttribute"]));
    }
    if (m.find("Tenant") != m.end() && !m["Tenant"].empty()) {
      tenant = make_shared<string>(boost::any_cast<string>(m["Tenant"]));
    }
    if (m.find("WorkloadUuid") != m.end() && !m["WorkloadUuid"].empty()) {
      workloadUuid = make_shared<string>(boost::any_cast<string>(m["WorkloadUuid"]));
    }
  }


  virtual ~CreateVmAndSaveStockRequest() = default;
};
class CreateVmAndSaveStockResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> desc{};
  shared_ptr<string> msg{};
  shared_ptr<string> requestId{};

  CreateVmAndSaveStockResponseBody() {}

  explicit CreateVmAndSaveStockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateVmAndSaveStockResponseBody() = default;
};
class CreateVmAndSaveStockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateVmAndSaveStockResponseBody> body{};

  CreateVmAndSaveStockResponse() {}

  explicit CreateVmAndSaveStockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVmAndSaveStockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVmAndSaveStockResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVmAndSaveStockResponse() = default;
};
class DeleteApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> timeout{};

  DeleteApplicationRequest() {}

  explicit DeleteApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~DeleteApplicationRequest() = default;
};
class DeleteApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteApplicationResponseBody() {}

  explicit DeleteApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteApplicationResponseBody() = default;
};
class DeleteApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteApplicationResponseBody> body{};

  DeleteApplicationResponse() {}

  explicit DeleteApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApplicationResponse() = default;
};
class DeleteDeviceInternetPortRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> natType{};
  shared_ptr<string> ruleId{};

  DeleteDeviceInternetPortRequest() {}

  explicit DeleteDeviceInternetPortRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (natType) {
      res["NatType"] = boost::any(*natType);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NatType") != m.end() && !m["NatType"].empty()) {
      natType = make_shared<string>(boost::any_cast<string>(m["NatType"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DeleteDeviceInternetPortRequest() = default;
};
class DeleteDeviceInternetPortResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> ruleIds{};

  DeleteDeviceInternetPortResponseBody() {}

  explicit DeleteDeviceInternetPortResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleIds) {
      res["RuleIds"] = boost::any(*ruleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleIds") != m.end() && !m["RuleIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteDeviceInternetPortResponseBody() = default;
};
class DeleteDeviceInternetPortResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDeviceInternetPortResponseBody> body{};

  DeleteDeviceInternetPortResponse() {}

  explicit DeleteDeviceInternetPortResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeviceInternetPortResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeviceInternetPortResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeviceInternetPortResponse() = default;
};
class DeleteEpnInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};

  DeleteEpnInstanceRequest() {}

  explicit DeleteEpnInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
  }


  virtual ~DeleteEpnInstanceRequest() = default;
};
class DeleteEpnInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEpnInstanceResponseBody() {}

  explicit DeleteEpnInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEpnInstanceResponseBody() = default;
};
class DeleteEpnInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteEpnInstanceResponseBody> body{};

  DeleteEpnInstanceResponse() {}

  explicit DeleteEpnInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEpnInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEpnInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEpnInstanceResponse() = default;
};
class DeleteKeyPairsRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyPairName{};
  shared_ptr<string> version{};

  DeleteKeyPairsRequest() {}

  explicit DeleteKeyPairsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DeleteKeyPairsRequest() = default;
};
class DeleteKeyPairsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteKeyPairsResponseBody() {}

  explicit DeleteKeyPairsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteKeyPairsResponseBody() = default;
};
class DeleteKeyPairsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteKeyPairsResponseBody> body{};

  DeleteKeyPairsResponse() {}

  explicit DeleteKeyPairsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteKeyPairsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteKeyPairsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteKeyPairsResponse() = default;
};
class DeleteLoadBalancerListenerRequest : public Darabonba::Model {
public:
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};

  DeleteLoadBalancerListenerRequest() {}

  explicit DeleteLoadBalancerListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~DeleteLoadBalancerListenerRequest() = default;
};
class DeleteLoadBalancerListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLoadBalancerListenerResponseBody() {}

  explicit DeleteLoadBalancerListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLoadBalancerListenerResponseBody() = default;
};
class DeleteLoadBalancerListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteLoadBalancerListenerResponseBody> body{};

  DeleteLoadBalancerListenerResponse() {}

  explicit DeleteLoadBalancerListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLoadBalancerListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLoadBalancerListenerResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLoadBalancerListenerResponse() = default;
};
class DeleteNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkId{};

  DeleteNetworkRequest() {}

  explicit DeleteNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
  }


  virtual ~DeleteNetworkRequest() = default;
};
class DeleteNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNetworkResponseBody() {}

  explicit DeleteNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNetworkResponseBody() = default;
};
class DeleteNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteNetworkResponseBody> body{};

  DeleteNetworkResponse() {}

  explicit DeleteNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNetworkResponse() = default;
};
class DeleteSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> version{};

  DeleteSecurityGroupRequest() {}

  explicit DeleteSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DeleteSecurityGroupRequest() = default;
};
class DeleteSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSecurityGroupResponseBody() {}

  explicit DeleteSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSecurityGroupResponseBody() = default;
};
class DeleteSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSecurityGroupResponseBody> body{};

  DeleteSecurityGroupResponse() {}

  explicit DeleteSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSecurityGroupResponse() = default;
};
class DeleteVSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> version{};

  DeleteVSwitchRequest() {}

  explicit DeleteVSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DeleteVSwitchRequest() = default;
};
class DeleteVSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVSwitchResponseBody() {}

  explicit DeleteVSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVSwitchResponseBody() = default;
};
class DeleteVSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteVSwitchResponseBody> body{};

  DeleteVSwitchResponse() {}

  explicit DeleteVSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVSwitchResponse() = default;
};
class DeleteVmRequest : public Darabonba::Model {
public:
  shared_ptr<long> aliUid{};
  shared_ptr<string> workloadUuid{};

  DeleteVmRequest() {}

  explicit DeleteVmRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (workloadUuid) {
      res["WorkloadUuid"] = boost::any(*workloadUuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("WorkloadUuid") != m.end() && !m["WorkloadUuid"].empty()) {
      workloadUuid = make_shared<string>(boost::any_cast<string>(m["WorkloadUuid"]));
    }
  }


  virtual ~DeleteVmRequest() = default;
};
class DeleteVmResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> desc{};
  shared_ptr<string> msg{};
  shared_ptr<string> requestId{};

  DeleteVmResponseBody() {}

  explicit DeleteVmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVmResponseBody() = default;
};
class DeleteVmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteVmResponseBody> body{};

  DeleteVmResponse() {}

  explicit DeleteVmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVmResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVmResponse() = default;
};
class DescribeApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appVersions{};
  shared_ptr<string> level{};
  shared_ptr<string> outDetailStatParams{};

  DescribeApplicationRequest() {}

  explicit DescribeApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appVersions) {
      res["AppVersions"] = boost::any(*appVersions);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (outDetailStatParams) {
      res["OutDetailStatParams"] = boost::any(*outDetailStatParams);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppVersions") != m.end() && !m["AppVersions"].empty()) {
      appVersions = make_shared<string>(boost::any_cast<string>(m["AppVersions"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("OutDetailStatParams") != m.end() && !m["OutDetailStatParams"].empty()) {
      outDetailStatParams = make_shared<string>(boost::any_cast<string>(m["OutDetailStatParams"]));
    }
  }


  virtual ~DescribeApplicationRequest() = default;
};
class DescribeApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> application{};
  shared_ptr<string> requestId{};

  DescribeApplicationResponseBody() {}

  explicit DescribeApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (application) {
      res["Application"] = boost::any(*application);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      application = make_shared<string>(boost::any_cast<string>(m["Application"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApplicationResponseBody() = default;
};
class DescribeApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApplicationResponseBody> body{};

  DescribeApplicationResponse() {}

  explicit DescribeApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApplicationResponse() = default;
};
class DescribeApplicationResourceSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> resourceType{};

  DescribeApplicationResourceSummaryRequest() {}

  explicit DescribeApplicationResourceSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribeApplicationResourceSummaryRequest() = default;
};
class DescribeApplicationResourceSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> applicationResource{};
  shared_ptr<string> requestId{};

  DescribeApplicationResourceSummaryResponseBody() {}

  explicit DescribeApplicationResourceSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationResource) {
      res["ApplicationResource"] = boost::any(*applicationResource);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationResource") != m.end() && !m["ApplicationResource"].empty()) {
      applicationResource = make_shared<string>(boost::any_cast<string>(m["ApplicationResource"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApplicationResourceSummaryResponseBody() = default;
};
class DescribeApplicationResourceSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApplicationResourceSummaryResponseBody> body{};

  DescribeApplicationResourceSummaryResponse() {}

  explicit DescribeApplicationResourceSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApplicationResourceSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApplicationResourceSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApplicationResourceSummaryResponse() = default;
};
class DescribeAvailableResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> version{};

  DescribeAvailableResourceRequest() {}

  explicit DescribeAvailableResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeAvailableResourceRequest() = default;
};
class DescribeAvailableResourceResponseBodyImagesImage : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};

  DescribeAvailableResourceResponseBodyImagesImage() {}

  explicit DescribeAvailableResourceResponseBodyImagesImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
  }


  virtual ~DescribeAvailableResourceResponseBodyImagesImage() = default;
};
class DescribeAvailableResourceResponseBodyImages : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAvailableResourceResponseBodyImagesImage>> image{};

  DescribeAvailableResourceResponseBodyImages() {}

  explicit DescribeAvailableResourceResponseBodyImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      vector<boost::any> temp1;
      for(auto item1:*image){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Image"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      if (typeid(vector<boost::any>) == m["Image"].type()) {
        vector<DescribeAvailableResourceResponseBodyImagesImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Image"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableResourceResponseBodyImagesImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        image = make_shared<vector<DescribeAvailableResourceResponseBodyImagesImage>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableResourceResponseBodyImages() = default;
};
class DescribeAvailableResourceResponseBodySupportResourcesSupportResource : public Darabonba::Model {
public:
  shared_ptr<string> dataDiskSize{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceSpec{};
  shared_ptr<string> supportResourcesCount{};
  shared_ptr<string> systemDiskSize{};

  DescribeAvailableResourceResponseBodySupportResourcesSupportResource() {}

  explicit DescribeAvailableResourceResponseBodySupportResourcesSupportResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceSpec) {
      res["InstanceSpec"] = boost::any(*instanceSpec);
    }
    if (supportResourcesCount) {
      res["SupportResourcesCount"] = boost::any(*supportResourcesCount);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<string>(boost::any_cast<string>(m["DataDiskSize"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceSpec") != m.end() && !m["InstanceSpec"].empty()) {
      instanceSpec = make_shared<string>(boost::any_cast<string>(m["InstanceSpec"]));
    }
    if (m.find("SupportResourcesCount") != m.end() && !m["SupportResourcesCount"].empty()) {
      supportResourcesCount = make_shared<string>(boost::any_cast<string>(m["SupportResourcesCount"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<string>(boost::any_cast<string>(m["SystemDiskSize"]));
    }
  }


  virtual ~DescribeAvailableResourceResponseBodySupportResourcesSupportResource() = default;
};
class DescribeAvailableResourceResponseBodySupportResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAvailableResourceResponseBodySupportResourcesSupportResource>> supportResource{};

  DescribeAvailableResourceResponseBodySupportResources() {}

  explicit DescribeAvailableResourceResponseBodySupportResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportResource) {
      vector<boost::any> temp1;
      for(auto item1:*supportResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportResource") != m.end() && !m["SupportResource"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportResource"].type()) {
        vector<DescribeAvailableResourceResponseBodySupportResourcesSupportResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableResourceResponseBodySupportResourcesSupportResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportResource = make_shared<vector<DescribeAvailableResourceResponseBodySupportResourcesSupportResource>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableResourceResponseBodySupportResources() = default;
};
class DescribeAvailableResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeAvailableResourceResponseBodyImages> images{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAvailableResourceResponseBodySupportResources> supportResources{};

  DescribeAvailableResourceResponseBody() {}

  explicit DescribeAvailableResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (images) {
      res["Images"] = images ? boost::any(images->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (supportResources) {
      res["SupportResources"] = supportResources ? boost::any(supportResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(map<string, boost::any>) == m["Images"].type()) {
        DescribeAvailableResourceResponseBodyImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Images"]));
        images = make_shared<DescribeAvailableResourceResponseBodyImages>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SupportResources") != m.end() && !m["SupportResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportResources"].type()) {
        DescribeAvailableResourceResponseBodySupportResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportResources"]));
        supportResources = make_shared<DescribeAvailableResourceResponseBodySupportResources>(model1);
      }
    }
  }


  virtual ~DescribeAvailableResourceResponseBody() = default;
};
class DescribeAvailableResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAvailableResourceResponseBody> body{};

  DescribeAvailableResourceResponse() {}

  explicit DescribeAvailableResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAvailableResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAvailableResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAvailableResourceResponse() = default;
};
class DescribeAvailableResourceInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> version{};

  DescribeAvailableResourceInfoRequest() {}

  explicit DescribeAvailableResourceInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeAvailableResourceInfoRequest() = default;
};
class DescribeAvailableResourceInfoResponseBodyImagesImage : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<long> imageSize{};

  DescribeAvailableResourceInfoResponseBodyImagesImage() {}

  explicit DescribeAvailableResourceInfoResponseBodyImagesImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (imageSize) {
      res["ImageSize"] = boost::any(*imageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("ImageSize") != m.end() && !m["ImageSize"].empty()) {
      imageSize = make_shared<long>(boost::any_cast<long>(m["ImageSize"]));
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBodyImagesImage() = default;
};
class DescribeAvailableResourceInfoResponseBodyImages : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAvailableResourceInfoResponseBodyImagesImage>> image{};

  DescribeAvailableResourceInfoResponseBodyImages() {}

  explicit DescribeAvailableResourceInfoResponseBodyImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      vector<boost::any> temp1;
      for(auto item1:*image){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Image"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      if (typeid(vector<boost::any>) == m["Image"].type()) {
        vector<DescribeAvailableResourceInfoResponseBodyImagesImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Image"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableResourceInfoResponseBodyImagesImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        image = make_shared<vector<DescribeAvailableResourceInfoResponseBodyImagesImage>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBodyImages() = default;
};
class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceBandwidthTypes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> bandwidthType{};

  DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceBandwidthTypes() {}

  explicit DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceBandwidthTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthType) {
      res["BandwidthType"] = boost::any(*bandwidthType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthType") != m.end() && !m["BandwidthType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BandwidthType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BandwidthType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      bandwidthType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceBandwidthTypes() = default;
};
class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ensRegionId{};

  DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIds() {}

  explicit DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnsRegionId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnsRegionId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ensRegionId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIds() = default;
};
class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtendsEnsRegionId : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> enName{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> name{};
  shared_ptr<string> province{};

  DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtendsEnsRegionId() {}

  explicit DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtendsEnsRegionId(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (enName) {
      res["EnName"] = boost::any(*enName);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("EnName") != m.end() && !m["EnName"].empty()) {
      enName = make_shared<string>(boost::any_cast<string>(m["EnName"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtendsEnsRegionId() = default;
};
class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtends : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtendsEnsRegionId>> ensRegionId{};

  DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtends() {}

  explicit DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtends(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      vector<boost::any> temp1;
      for(auto item1:*ensRegionId){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnsRegionId"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      if (typeid(vector<boost::any>) == m["EnsRegionId"].type()) {
        vector<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtendsEnsRegionId> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnsRegionId"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtendsEnsRegionId model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ensRegionId = make_shared<vector<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtendsEnsRegionId>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtends() = default;
};
class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceInstanceSpeces : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceSpec{};

  DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceInstanceSpeces() {}

  explicit DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceInstanceSpeces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceSpec) {
      res["InstanceSpec"] = boost::any(*instanceSpec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceSpec") != m.end() && !m["InstanceSpec"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceSpec"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceSpec"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceSpec = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceInstanceSpeces() = default;
};
class DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResource : public Darabonba::Model {
public:
  shared_ptr<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceBandwidthTypes> bandwidthTypes{};
  shared_ptr<long> dataDiskMaxSize{};
  shared_ptr<long> dataDiskMinSize{};
  shared_ptr<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIds> ensRegionIds{};
  shared_ptr<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtends> ensRegionIdsExtends{};
  shared_ptr<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceInstanceSpeces> instanceSpeces{};
  shared_ptr<long> systemDiskMaxSize{};
  shared_ptr<long> systemDiskMinSize{};

  DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResource() {}

  explicit DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthTypes) {
      res["BandwidthTypes"] = bandwidthTypes ? boost::any(bandwidthTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataDiskMaxSize) {
      res["DataDiskMaxSize"] = boost::any(*dataDiskMaxSize);
    }
    if (dataDiskMinSize) {
      res["DataDiskMinSize"] = boost::any(*dataDiskMinSize);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = ensRegionIds ? boost::any(ensRegionIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ensRegionIdsExtends) {
      res["EnsRegionIdsExtends"] = ensRegionIdsExtends ? boost::any(ensRegionIdsExtends->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceSpeces) {
      res["InstanceSpeces"] = instanceSpeces ? boost::any(instanceSpeces->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (systemDiskMaxSize) {
      res["SystemDiskMaxSize"] = boost::any(*systemDiskMaxSize);
    }
    if (systemDiskMinSize) {
      res["SystemDiskMinSize"] = boost::any(*systemDiskMinSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthTypes") != m.end() && !m["BandwidthTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["BandwidthTypes"].type()) {
        DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceBandwidthTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BandwidthTypes"]));
        bandwidthTypes = make_shared<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceBandwidthTypes>(model1);
      }
    }
    if (m.find("DataDiskMaxSize") != m.end() && !m["DataDiskMaxSize"].empty()) {
      dataDiskMaxSize = make_shared<long>(boost::any_cast<long>(m["DataDiskMaxSize"]));
    }
    if (m.find("DataDiskMinSize") != m.end() && !m["DataDiskMinSize"].empty()) {
      dataDiskMinSize = make_shared<long>(boost::any_cast<long>(m["DataDiskMinSize"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["EnsRegionIds"].type()) {
        DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EnsRegionIds"]));
        ensRegionIds = make_shared<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIds>(model1);
      }
    }
    if (m.find("EnsRegionIdsExtends") != m.end() && !m["EnsRegionIdsExtends"].empty()) {
      if (typeid(map<string, boost::any>) == m["EnsRegionIdsExtends"].type()) {
        DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtends model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EnsRegionIdsExtends"]));
        ensRegionIdsExtends = make_shared<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceEnsRegionIdsExtends>(model1);
      }
    }
    if (m.find("InstanceSpeces") != m.end() && !m["InstanceSpeces"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceSpeces"].type()) {
        DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceInstanceSpeces model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceSpeces"]));
        instanceSpeces = make_shared<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResourceInstanceSpeces>(model1);
      }
    }
    if (m.find("SystemDiskMaxSize") != m.end() && !m["SystemDiskMaxSize"].empty()) {
      systemDiskMaxSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskMaxSize"]));
    }
    if (m.find("SystemDiskMinSize") != m.end() && !m["SystemDiskMinSize"].empty()) {
      systemDiskMinSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskMinSize"]));
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResource() = default;
};
class DescribeAvailableResourceInfoResponseBodySupportResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResource>> supportResource{};

  DescribeAvailableResourceInfoResponseBodySupportResources() {}

  explicit DescribeAvailableResourceInfoResponseBodySupportResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportResource) {
      vector<boost::any> temp1;
      for(auto item1:*supportResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportResource") != m.end() && !m["SupportResource"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportResource"].type()) {
        vector<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportResource = make_shared<vector<DescribeAvailableResourceInfoResponseBodySupportResourcesSupportResource>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBodySupportResources() = default;
};
class DescribeAvailableResourceInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAvailableResourceInfoResponseBodyImages> images{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAvailableResourceInfoResponseBodySupportResources> supportResources{};

  DescribeAvailableResourceInfoResponseBody() {}

  explicit DescribeAvailableResourceInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (images) {
      res["Images"] = images ? boost::any(images->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (supportResources) {
      res["SupportResources"] = supportResources ? boost::any(supportResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(map<string, boost::any>) == m["Images"].type()) {
        DescribeAvailableResourceInfoResponseBodyImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Images"]));
        images = make_shared<DescribeAvailableResourceInfoResponseBodyImages>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SupportResources") != m.end() && !m["SupportResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportResources"].type()) {
        DescribeAvailableResourceInfoResponseBodySupportResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportResources"]));
        supportResources = make_shared<DescribeAvailableResourceInfoResponseBodySupportResources>(model1);
      }
    }
  }


  virtual ~DescribeAvailableResourceInfoResponseBody() = default;
};
class DescribeAvailableResourceInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAvailableResourceInfoResponseBody> body{};

  DescribeAvailableResourceInfoResponse() {}

  explicit DescribeAvailableResourceInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAvailableResourceInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAvailableResourceInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAvailableResourceInfoResponse() = default;
};
class DescribeBandWithdChargeTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> version{};

  DescribeBandWithdChargeTypeRequest() {}

  explicit DescribeBandWithdChargeTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeBandWithdChargeTypeRequest() = default;
};
class DescribeBandWithdChargeTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bandWithTypeInfo{};
  shared_ptr<string> chargeContractType{};
  shared_ptr<string> chargeCycleInfo{};
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  DescribeBandWithdChargeTypeResponseBody() {}

  explicit DescribeBandWithdChargeTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWithTypeInfo) {
      res["BandWithTypeInfo"] = boost::any(*bandWithTypeInfo);
    }
    if (chargeContractType) {
      res["ChargeContractType"] = boost::any(*chargeContractType);
    }
    if (chargeCycleInfo) {
      res["ChargeCycleInfo"] = boost::any(*chargeCycleInfo);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWithTypeInfo") != m.end() && !m["BandWithTypeInfo"].empty()) {
      bandWithTypeInfo = make_shared<string>(boost::any_cast<string>(m["BandWithTypeInfo"]));
    }
    if (m.find("ChargeContractType") != m.end() && !m["ChargeContractType"].empty()) {
      chargeContractType = make_shared<string>(boost::any_cast<string>(m["ChargeContractType"]));
    }
    if (m.find("ChargeCycleInfo") != m.end() && !m["ChargeCycleInfo"].empty()) {
      chargeCycleInfo = make_shared<string>(boost::any_cast<string>(m["ChargeCycleInfo"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBandWithdChargeTypeResponseBody() = default;
};
class DescribeBandWithdChargeTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeBandWithdChargeTypeResponseBody> body{};

  DescribeBandWithdChargeTypeResponse() {}

  explicit DescribeBandWithdChargeTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBandWithdChargeTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBandWithdChargeTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBandWithdChargeTypeResponse() = default;
};
class DescribeBandwitdhByInternetChargeTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> isp{};
  shared_ptr<string> startTime{};
  shared_ptr<string> version{};

  DescribeBandwitdhByInternetChargeTypeRequest() {}

  explicit DescribeBandwitdhByInternetChargeTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeBandwitdhByInternetChargeTypeRequest() = default;
};
class DescribeBandwitdhByInternetChargeTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> bandwidthValue{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> timeStamp{};

  DescribeBandwitdhByInternetChargeTypeResponseBody() {}

  explicit DescribeBandwitdhByInternetChargeTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthValue) {
      res["BandwidthValue"] = boost::any(*bandwidthValue);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthValue") != m.end() && !m["BandwidthValue"].empty()) {
      bandwidthValue = make_shared<long>(boost::any_cast<long>(m["BandwidthValue"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeBandwitdhByInternetChargeTypeResponseBody() = default;
};
class DescribeBandwitdhByInternetChargeTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeBandwitdhByInternetChargeTypeResponseBody> body{};

  DescribeBandwitdhByInternetChargeTypeResponse() {}

  explicit DescribeBandwitdhByInternetChargeTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBandwitdhByInternetChargeTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBandwitdhByInternetChargeTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBandwitdhByInternetChargeTypeResponse() = default;
};
class DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResource : public Darabonba::Model {
public:
  shared_ptr<long> canBuyCount{};
  shared_ptr<string> category{};
  shared_ptr<long> defaultDiskSize{};
  shared_ptr<long> diskMaxSize{};
  shared_ptr<long> diskMinSize{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> ensRegionName{};

  DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResource() {}

  explicit DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canBuyCount) {
      res["CanBuyCount"] = boost::any(*canBuyCount);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (defaultDiskSize) {
      res["DefaultDiskSize"] = boost::any(*defaultDiskSize);
    }
    if (diskMaxSize) {
      res["DiskMaxSize"] = boost::any(*diskMaxSize);
    }
    if (diskMinSize) {
      res["DiskMinSize"] = boost::any(*diskMinSize);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionName) {
      res["EnsRegionName"] = boost::any(*ensRegionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanBuyCount") != m.end() && !m["CanBuyCount"].empty()) {
      canBuyCount = make_shared<long>(boost::any_cast<long>(m["CanBuyCount"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DefaultDiskSize") != m.end() && !m["DefaultDiskSize"].empty()) {
      defaultDiskSize = make_shared<long>(boost::any_cast<long>(m["DefaultDiskSize"]));
    }
    if (m.find("DiskMaxSize") != m.end() && !m["DiskMaxSize"].empty()) {
      diskMaxSize = make_shared<long>(boost::any_cast<long>(m["DiskMaxSize"]));
    }
    if (m.find("DiskMinSize") != m.end() && !m["DiskMinSize"].empty()) {
      diskMinSize = make_shared<long>(boost::any_cast<long>(m["DiskMinSize"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionName") != m.end() && !m["EnsRegionName"].empty()) {
      ensRegionName = make_shared<string>(boost::any_cast<string>(m["EnsRegionName"]));
    }
  }


  virtual ~DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResource() = default;
};
class DescribeCloudDiskAvailableResourceInfoResponseBodySupportResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResource>> supportResource{};

  DescribeCloudDiskAvailableResourceInfoResponseBodySupportResources() {}

  explicit DescribeCloudDiskAvailableResourceInfoResponseBodySupportResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportResource) {
      vector<boost::any> temp1;
      for(auto item1:*supportResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportResource") != m.end() && !m["SupportResource"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportResource"].type()) {
        vector<DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportResource = make_shared<vector<DescribeCloudDiskAvailableResourceInfoResponseBodySupportResourcesSupportResource>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudDiskAvailableResourceInfoResponseBodySupportResources() = default;
};
class DescribeCloudDiskAvailableResourceInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeCloudDiskAvailableResourceInfoResponseBodySupportResources> supportResources{};

  DescribeCloudDiskAvailableResourceInfoResponseBody() {}

  explicit DescribeCloudDiskAvailableResourceInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (supportResources) {
      res["SupportResources"] = supportResources ? boost::any(supportResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SupportResources") != m.end() && !m["SupportResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportResources"].type()) {
        DescribeCloudDiskAvailableResourceInfoResponseBodySupportResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportResources"]));
        supportResources = make_shared<DescribeCloudDiskAvailableResourceInfoResponseBodySupportResources>(model1);
      }
    }
  }


  virtual ~DescribeCloudDiskAvailableResourceInfoResponseBody() = default;
};
class DescribeCloudDiskAvailableResourceInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCloudDiskAvailableResourceInfoResponseBody> body{};

  DescribeCloudDiskAvailableResourceInfoResponse() {}

  explicit DescribeCloudDiskAvailableResourceInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudDiskAvailableResourceInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudDiskAvailableResourceInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudDiskAvailableResourceInfoResponse() = default;
};
class DescribeCloudDiskTypesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};

  DescribeCloudDiskTypesRequest() {}

  explicit DescribeCloudDiskTypesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
  }


  virtual ~DescribeCloudDiskTypesRequest() = default;
};
class DescribeCloudDiskTypesResponseBodySupportResourcesSupportResource : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> ensRegionId{};

  DescribeCloudDiskTypesResponseBodySupportResourcesSupportResource() {}

  explicit DescribeCloudDiskTypesResponseBodySupportResourcesSupportResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
  }


  virtual ~DescribeCloudDiskTypesResponseBodySupportResourcesSupportResource() = default;
};
class DescribeCloudDiskTypesResponseBodySupportResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudDiskTypesResponseBodySupportResourcesSupportResource>> supportResource{};

  DescribeCloudDiskTypesResponseBodySupportResources() {}

  explicit DescribeCloudDiskTypesResponseBodySupportResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportResource) {
      vector<boost::any> temp1;
      for(auto item1:*supportResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportResource") != m.end() && !m["SupportResource"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportResource"].type()) {
        vector<DescribeCloudDiskTypesResponseBodySupportResourcesSupportResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudDiskTypesResponseBodySupportResourcesSupportResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportResource = make_shared<vector<DescribeCloudDiskTypesResponseBodySupportResourcesSupportResource>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudDiskTypesResponseBodySupportResources() = default;
};
class DescribeCloudDiskTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeCloudDiskTypesResponseBodySupportResources> supportResources{};

  DescribeCloudDiskTypesResponseBody() {}

  explicit DescribeCloudDiskTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (supportResources) {
      res["SupportResources"] = supportResources ? boost::any(supportResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SupportResources") != m.end() && !m["SupportResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportResources"].type()) {
        DescribeCloudDiskTypesResponseBodySupportResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportResources"]));
        supportResources = make_shared<DescribeCloudDiskTypesResponseBodySupportResources>(model1);
      }
    }
  }


  virtual ~DescribeCloudDiskTypesResponseBody() = default;
};
class DescribeCloudDiskTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCloudDiskTypesResponseBody> body{};

  DescribeCloudDiskTypesResponse() {}

  explicit DescribeCloudDiskTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudDiskTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudDiskTypesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudDiskTypesResponse() = default;
};
class DescribeCreatePrePaidInstanceResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> version{};

  DescribeCreatePrePaidInstanceResultRequest() {}

  explicit DescribeCreatePrePaidInstanceResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeCreatePrePaidInstanceResultRequest() = default;
};
class DescribeCreatePrePaidInstanceResultResponseBodyInstanceCreateResult : public Darabonba::Model {
public:
  shared_ptr<string> instanceCreateStatus{};
  shared_ptr<string> instanceId{};

  DescribeCreatePrePaidInstanceResultResponseBodyInstanceCreateResult() {}

  explicit DescribeCreatePrePaidInstanceResultResponseBodyInstanceCreateResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceCreateStatus) {
      res["InstanceCreateStatus"] = boost::any(*instanceCreateStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceCreateStatus") != m.end() && !m["InstanceCreateStatus"].empty()) {
      instanceCreateStatus = make_shared<string>(boost::any_cast<string>(m["InstanceCreateStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeCreatePrePaidInstanceResultResponseBodyInstanceCreateResult() = default;
};
class DescribeCreatePrePaidInstanceResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCreatePrePaidInstanceResultResponseBodyInstanceCreateResult> instanceCreateResult{};
  shared_ptr<string> requestId{};

  DescribeCreatePrePaidInstanceResultResponseBody() {}

  explicit DescribeCreatePrePaidInstanceResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceCreateResult) {
      res["InstanceCreateResult"] = instanceCreateResult ? boost::any(instanceCreateResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceCreateResult") != m.end() && !m["InstanceCreateResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceCreateResult"].type()) {
        DescribeCreatePrePaidInstanceResultResponseBodyInstanceCreateResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceCreateResult"]));
        instanceCreateResult = make_shared<DescribeCreatePrePaidInstanceResultResponseBodyInstanceCreateResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCreatePrePaidInstanceResultResponseBody() = default;
};
class DescribeCreatePrePaidInstanceResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCreatePrePaidInstanceResultResponseBody> body{};

  DescribeCreatePrePaidInstanceResultResponse() {}

  explicit DescribeCreatePrePaidInstanceResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCreatePrePaidInstanceResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCreatePrePaidInstanceResultResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCreatePrePaidInstanceResultResponse() = default;
};
class DescribeDataDistResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataNames{};
  shared_ptr<string> dataVersions{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> maxDate{};
  shared_ptr<string> minDate{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeDataDistResultRequest() {}

  explicit DescribeDataDistResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataNames) {
      res["DataNames"] = boost::any(*dataNames);
    }
    if (dataVersions) {
      res["DataVersions"] = boost::any(*dataVersions);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (maxDate) {
      res["MaxDate"] = boost::any(*maxDate);
    }
    if (minDate) {
      res["MinDate"] = boost::any(*minDate);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataNames") != m.end() && !m["DataNames"].empty()) {
      dataNames = make_shared<string>(boost::any_cast<string>(m["DataNames"]));
    }
    if (m.find("DataVersions") != m.end() && !m["DataVersions"].empty()) {
      dataVersions = make_shared<string>(boost::any_cast<string>(m["DataVersions"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("MaxDate") != m.end() && !m["MaxDate"].empty()) {
      maxDate = make_shared<string>(boost::any_cast<string>(m["MaxDate"]));
    }
    if (m.find("MinDate") != m.end() && !m["MinDate"].empty()) {
      minDate = make_shared<string>(boost::any_cast<string>(m["MinDate"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeDataDistResultRequest() = default;
};
class DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstancesInstance : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> statusDescrip{};
  shared_ptr<string> updateTime{};

  DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstancesInstance() {}

  explicit DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstancesInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (statusDescrip) {
      res["StatusDescrip"] = boost::any(*statusDescrip);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StatusDescrip") != m.end() && !m["StatusDescrip"].empty()) {
      statusDescrip = make_shared<string>(boost::any_cast<string>(m["StatusDescrip"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstancesInstance() = default;
};
class DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstancesInstance>> instance{};

  DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstances() {}

  explicit DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      vector<boost::any> temp1;
      for(auto item1:*instance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(vector<boost::any>) == m["Instance"].type()) {
        vector<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstancesInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstancesInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instance = make_shared<vector<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstancesInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstances() = default;
};
class DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStat : public Darabonba::Model {
public:
  shared_ptr<string> instanceCount{};
  shared_ptr<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstances> instances{};
  shared_ptr<string> status{};

  DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStat() {}

  explicit DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (instances) {
      res["Instances"] = instances ? boost::any(instances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<string>(boost::any_cast<string>(m["InstanceCount"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instances"].type()) {
        DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instances"]));
        instances = make_shared<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStatInstances>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStat() = default;
};
class DescribeDataDistResultResponseBodyDistResultsDistResultStatusStats : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStat>> statusStat{};

  DescribeDataDistResultResponseBodyDistResultsDistResultStatusStats() {}

  explicit DescribeDataDistResultResponseBodyDistResultsDistResultStatusStats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (statusStat) {
      vector<boost::any> temp1;
      for(auto item1:*statusStat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StatusStat"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StatusStat") != m.end() && !m["StatusStat"].empty()) {
      if (typeid(vector<boost::any>) == m["StatusStat"].type()) {
        vector<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StatusStat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statusStat = make_shared<vector<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStatsStatusStat>>(expect1);
      }
    }
  }


  virtual ~DescribeDataDistResultResponseBodyDistResultsDistResultStatusStats() = default;
};
class DescribeDataDistResultResponseBodyDistResultsDistResult : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStats> statusStats{};
  shared_ptr<string> version{};

  DescribeDataDistResultResponseBodyDistResultsDistResult() {}

  explicit DescribeDataDistResultResponseBodyDistResultsDistResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (statusStats) {
      res["StatusStats"] = statusStats ? boost::any(statusStats->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StatusStats") != m.end() && !m["StatusStats"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatusStats"].type()) {
        DescribeDataDistResultResponseBodyDistResultsDistResultStatusStats model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatusStats"]));
        statusStats = make_shared<DescribeDataDistResultResponseBodyDistResultsDistResultStatusStats>(model1);
      }
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeDataDistResultResponseBodyDistResultsDistResult() = default;
};
class DescribeDataDistResultResponseBodyDistResults : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDataDistResultResponseBodyDistResultsDistResult>> distResult{};

  DescribeDataDistResultResponseBodyDistResults() {}

  explicit DescribeDataDistResultResponseBodyDistResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distResult) {
      vector<boost::any> temp1;
      for(auto item1:*distResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DistResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistResult") != m.end() && !m["DistResult"].empty()) {
      if (typeid(vector<boost::any>) == m["DistResult"].type()) {
        vector<DescribeDataDistResultResponseBodyDistResultsDistResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DistResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataDistResultResponseBodyDistResultsDistResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        distResult = make_shared<vector<DescribeDataDistResultResponseBodyDistResultsDistResult>>(expect1);
      }
    }
  }


  virtual ~DescribeDataDistResultResponseBodyDistResults() = default;
};
class DescribeDataDistResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDataDistResultResponseBodyDistResults> distResults{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDataDistResultResponseBody() {}

  explicit DescribeDataDistResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distResults) {
      res["DistResults"] = distResults ? boost::any(distResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistResults") != m.end() && !m["DistResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["DistResults"].type()) {
        DescribeDataDistResultResponseBodyDistResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DistResults"]));
        distResults = make_shared<DescribeDataDistResultResponseBodyDistResults>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDataDistResultResponseBody() = default;
};
class DescribeDataDistResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDataDistResultResponseBody> body{};

  DescribeDataDistResultResponse() {}

  explicit DescribeDataDistResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDataDistResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDataDistResultResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDataDistResultResponse() = default;
};
class DescribeDataDownloadURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataName{};
  shared_ptr<string> dataVersion{};
  shared_ptr<long> expireTimeout{};
  shared_ptr<string> serverFilterStrategy{};

  DescribeDataDownloadURLRequest() {}

  explicit DescribeDataDownloadURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataName) {
      res["DataName"] = boost::any(*dataName);
    }
    if (dataVersion) {
      res["DataVersion"] = boost::any(*dataVersion);
    }
    if (expireTimeout) {
      res["ExpireTimeout"] = boost::any(*expireTimeout);
    }
    if (serverFilterStrategy) {
      res["ServerFilterStrategy"] = boost::any(*serverFilterStrategy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataName") != m.end() && !m["DataName"].empty()) {
      dataName = make_shared<string>(boost::any_cast<string>(m["DataName"]));
    }
    if (m.find("DataVersion") != m.end() && !m["DataVersion"].empty()) {
      dataVersion = make_shared<string>(boost::any_cast<string>(m["DataVersion"]));
    }
    if (m.find("ExpireTimeout") != m.end() && !m["ExpireTimeout"].empty()) {
      expireTimeout = make_shared<long>(boost::any_cast<long>(m["ExpireTimeout"]));
    }
    if (m.find("ServerFilterStrategy") != m.end() && !m["ServerFilterStrategy"].empty()) {
      serverFilterStrategy = make_shared<string>(boost::any_cast<string>(m["ServerFilterStrategy"]));
    }
  }


  virtual ~DescribeDataDownloadURLRequest() = default;
};
class DescribeDataDownloadURLResponseBodyDataServerList : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<string> regionId{};

  DescribeDataDownloadURLResponseBodyDataServerList() {}

  explicit DescribeDataDownloadURLResponseBodyDataServerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeDataDownloadURLResponseBodyDataServerList() = default;
};
class DescribeDataDownloadURLResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> expireTime{};
  shared_ptr<vector<DescribeDataDownloadURLResponseBodyDataServerList>> serverList{};
  shared_ptr<string> url{};

  DescribeDataDownloadURLResponseBodyData() {}

  explicit DescribeDataDownloadURLResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (serverList) {
      vector<boost::any> temp1;
      for(auto item1:*serverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServerList"] = boost::any(temp1);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("ServerList") != m.end() && !m["ServerList"].empty()) {
      if (typeid(vector<boost::any>) == m["ServerList"].type()) {
        vector<DescribeDataDownloadURLResponseBodyDataServerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServerList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataDownloadURLResponseBodyDataServerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serverList = make_shared<vector<DescribeDataDownloadURLResponseBodyDataServerList>>(expect1);
      }
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribeDataDownloadURLResponseBodyData() = default;
};
class DescribeDataDownloadURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeDataDownloadURLResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DescribeDataDownloadURLResponseBody() {}

  explicit DescribeDataDownloadURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeDataDownloadURLResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeDataDownloadURLResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDataDownloadURLResponseBody() = default;
};
class DescribeDataDownloadURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDataDownloadURLResponseBody> body{};

  DescribeDataDownloadURLResponse() {}

  explicit DescribeDataDownloadURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDataDownloadURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDataDownloadURLResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDataDownloadURLResponse() = default;
};
class DescribeDataPushResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataNames{};
  shared_ptr<string> dataVersions{};
  shared_ptr<string> maxDate{};
  shared_ptr<string> minDate{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionIds{};

  DescribeDataPushResultRequest() {}

  explicit DescribeDataPushResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataNames) {
      res["DataNames"] = boost::any(*dataNames);
    }
    if (dataVersions) {
      res["DataVersions"] = boost::any(*dataVersions);
    }
    if (maxDate) {
      res["MaxDate"] = boost::any(*maxDate);
    }
    if (minDate) {
      res["MinDate"] = boost::any(*minDate);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionIds) {
      res["RegionIds"] = boost::any(*regionIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataNames") != m.end() && !m["DataNames"].empty()) {
      dataNames = make_shared<string>(boost::any_cast<string>(m["DataNames"]));
    }
    if (m.find("DataVersions") != m.end() && !m["DataVersions"].empty()) {
      dataVersions = make_shared<string>(boost::any_cast<string>(m["DataVersions"]));
    }
    if (m.find("MaxDate") != m.end() && !m["MaxDate"].empty()) {
      maxDate = make_shared<string>(boost::any_cast<string>(m["MaxDate"]));
    }
    if (m.find("MinDate") != m.end() && !m["MinDate"].empty()) {
      minDate = make_shared<string>(boost::any_cast<string>(m["MinDate"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionIds") != m.end() && !m["RegionIds"].empty()) {
      regionIds = make_shared<string>(boost::any_cast<string>(m["RegionIds"]));
    }
  }


  virtual ~DescribeDataPushResultRequest() = default;
};
class DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIdsRegionId : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> statusDescrip{};
  shared_ptr<string> updateTime{};

  DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIdsRegionId() {}

  explicit DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIdsRegionId(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (statusDescrip) {
      res["StatusDescrip"] = boost::any(*statusDescrip);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StatusDescrip") != m.end() && !m["StatusDescrip"].empty()) {
      statusDescrip = make_shared<string>(boost::any_cast<string>(m["StatusDescrip"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIdsRegionId() = default;
};
class DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIds : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIdsRegionId>> regionId{};

  DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIds() {}

  explicit DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      vector<boost::any> temp1;
      for(auto item1:*regionId){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegionId"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      if (typeid(vector<boost::any>) == m["RegionId"].type()) {
        vector<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIdsRegionId> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegionId"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIdsRegionId model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regionId = make_shared<vector<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIdsRegionId>>(expect1);
      }
    }
  }


  virtual ~DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIds() = default;
};
class DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStat : public Darabonba::Model {
public:
  shared_ptr<long> regionIdCount{};
  shared_ptr<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIds> regionIds{};
  shared_ptr<string> status{};

  DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStat() {}

  explicit DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionIdCount) {
      res["RegionIdCount"] = boost::any(*regionIdCount);
    }
    if (regionIds) {
      res["RegionIds"] = regionIds ? boost::any(regionIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionIdCount") != m.end() && !m["RegionIdCount"].empty()) {
      regionIdCount = make_shared<long>(boost::any_cast<long>(m["RegionIdCount"]));
    }
    if (m.find("RegionIds") != m.end() && !m["RegionIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegionIds"].type()) {
        DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegionIds"]));
        regionIds = make_shared<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStatRegionIds>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStat() = default;
};
class DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatS : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStat>> statusStat{};

  DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatS() {}

  explicit DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (statusStat) {
      vector<boost::any> temp1;
      for(auto item1:*statusStat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StatusStat"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StatusStat") != m.end() && !m["StatusStat"].empty()) {
      if (typeid(vector<boost::any>) == m["StatusStat"].type()) {
        vector<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StatusStat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statusStat = make_shared<vector<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatSStatusStat>>(expect1);
      }
    }
  }


  virtual ~DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatS() = default;
};
class DescribeDataPushResultResponseBodyPushResultsPushResult : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatS> statusStatS{};
  shared_ptr<string> version{};

  DescribeDataPushResultResponseBodyPushResultsPushResult() {}

  explicit DescribeDataPushResultResponseBodyPushResultsPushResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (statusStatS) {
      res["StatusStatS"] = statusStatS ? boost::any(statusStatS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StatusStatS") != m.end() && !m["StatusStatS"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatusStatS"].type()) {
        DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatusStatS"]));
        statusStatS = make_shared<DescribeDataPushResultResponseBodyPushResultsPushResultStatusStatS>(model1);
      }
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeDataPushResultResponseBodyPushResultsPushResult() = default;
};
class DescribeDataPushResultResponseBodyPushResults : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDataPushResultResponseBodyPushResultsPushResult>> pushResult{};

  DescribeDataPushResultResponseBodyPushResults() {}

  explicit DescribeDataPushResultResponseBodyPushResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushResult) {
      vector<boost::any> temp1;
      for(auto item1:*pushResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PushResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushResult") != m.end() && !m["PushResult"].empty()) {
      if (typeid(vector<boost::any>) == m["PushResult"].type()) {
        vector<DescribeDataPushResultResponseBodyPushResultsPushResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PushResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataPushResultResponseBodyPushResultsPushResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pushResult = make_shared<vector<DescribeDataPushResultResponseBodyPushResultsPushResult>>(expect1);
      }
    }
  }


  virtual ~DescribeDataPushResultResponseBodyPushResults() = default;
};
class DescribeDataPushResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribeDataPushResultResponseBodyPushResults> pushResults{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDataPushResultResponseBody() {}

  explicit DescribeDataPushResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pushResults) {
      res["PushResults"] = pushResults ? boost::any(pushResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PushResults") != m.end() && !m["PushResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["PushResults"].type()) {
        DescribeDataPushResultResponseBodyPushResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PushResults"]));
        pushResults = make_shared<DescribeDataPushResultResponseBodyPushResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDataPushResultResponseBody() = default;
};
class DescribeDataPushResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDataPushResultResponseBody> body{};

  DescribeDataPushResultResponse() {}

  explicit DescribeDataPushResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDataPushResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDataPushResultResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDataPushResultResponse() = default;
};
class DescribeDeviceServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> orderId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> serviceId{};

  DescribeDeviceServiceRequest() {}

  explicit DescribeDeviceServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["ServiceId"]));
    }
  }


  virtual ~DescribeDeviceServiceRequest() = default;
};
class DescribeDeviceServiceResponseBodyAppMetaData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> appStableVersion{};
  shared_ptr<string> appType{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};

  DescribeDeviceServiceResponseBodyAppMetaData() {}

  explicit DescribeDeviceServiceResponseBodyAppMetaData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appStableVersion) {
      res["AppStableVersion"] = boost::any(*appStableVersion);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppStableVersion") != m.end() && !m["AppStableVersion"].empty()) {
      appStableVersion = make_shared<string>(boost::any_cast<string>(m["AppStableVersion"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~DescribeDeviceServiceResponseBodyAppMetaData() = default;
};
class DescribeDeviceServiceResponseBodyAppStatus : public Darabonba::Model {
public:
  shared_ptr<string> phase{};
  shared_ptr<string> statusDescrip{};
  shared_ptr<string> updateTime{};

  DescribeDeviceServiceResponseBodyAppStatus() {}

  explicit DescribeDeviceServiceResponseBodyAppStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (statusDescrip) {
      res["StatusDescrip"] = boost::any(*statusDescrip);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("StatusDescrip") != m.end() && !m["StatusDescrip"].empty()) {
      statusDescrip = make_shared<string>(boost::any_cast<string>(m["StatusDescrip"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeDeviceServiceResponseBodyAppStatus() = default;
};
class DescribeDeviceServiceResponseBodyResourceDetailInfos : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> ID{};
  shared_ptr<string> IP{};
  shared_ptr<string> ISP{};
  shared_ptr<string> imageID{};
  shared_ptr<string> mac{};
  shared_ptr<string> regionID{};
  shared_ptr<string> server{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeDeviceServiceResponseBodyResourceDetailInfos() {}

  explicit DescribeDeviceServiceResponseBodyResourceDetailInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (ID) {
      res["ID"] = boost::any(*ID);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (imageID) {
      res["ImageID"] = boost::any(*imageID);
    }
    if (mac) {
      res["Mac"] = boost::any(*mac);
    }
    if (regionID) {
      res["RegionID"] = boost::any(*regionID);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("ID") != m.end() && !m["ID"].empty()) {
      ID = make_shared<string>(boost::any_cast<string>(m["ID"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("ImageID") != m.end() && !m["ImageID"].empty()) {
      imageID = make_shared<string>(boost::any_cast<string>(m["ImageID"]));
    }
    if (m.find("Mac") != m.end() && !m["Mac"].empty()) {
      mac = make_shared<string>(boost::any_cast<string>(m["Mac"]));
    }
    if (m.find("RegionID") != m.end() && !m["RegionID"].empty()) {
      regionID = make_shared<string>(boost::any_cast<string>(m["RegionID"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDeviceServiceResponseBodyResourceDetailInfos() = default;
};
class DescribeDeviceServiceResponseBodyResourceInfosDeviceInfosNetwork : public Darabonba::Model {
public:
  shared_ptr<string> containerPorts{};
  shared_ptr<string> externalIp{};
  shared_ptr<string> hostPorts{};
  shared_ptr<string> protocol{};

  DescribeDeviceServiceResponseBodyResourceInfosDeviceInfosNetwork() {}

  explicit DescribeDeviceServiceResponseBodyResourceInfosDeviceInfosNetwork(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerPorts) {
      res["ContainerPorts"] = boost::any(*containerPorts);
    }
    if (externalIp) {
      res["ExternalIp"] = boost::any(*externalIp);
    }
    if (hostPorts) {
      res["HostPorts"] = boost::any(*hostPorts);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerPorts") != m.end() && !m["ContainerPorts"].empty()) {
      containerPorts = make_shared<string>(boost::any_cast<string>(m["ContainerPorts"]));
    }
    if (m.find("ExternalIp") != m.end() && !m["ExternalIp"].empty()) {
      externalIp = make_shared<string>(boost::any_cast<string>(m["ExternalIp"]));
    }
    if (m.find("HostPorts") != m.end() && !m["HostPorts"].empty()) {
      hostPorts = make_shared<string>(boost::any_cast<string>(m["HostPorts"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~DescribeDeviceServiceResponseBodyResourceInfosDeviceInfosNetwork() = default;
};
class DescribeDeviceServiceResponseBodyResourceInfosDeviceInfos : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeDeviceServiceResponseBodyResourceInfosDeviceInfosNetwork>> network{};
  shared_ptr<string> status{};

  DescribeDeviceServiceResponseBodyResourceInfosDeviceInfos() {}

  explicit DescribeDeviceServiceResponseBodyResourceInfosDeviceInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (network) {
      vector<boost::any> temp1;
      for(auto item1:*network){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Network"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Network") != m.end() && !m["Network"].empty()) {
      if (typeid(vector<boost::any>) == m["Network"].type()) {
        vector<DescribeDeviceServiceResponseBodyResourceInfosDeviceInfosNetwork> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Network"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeviceServiceResponseBodyResourceInfosDeviceInfosNetwork model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        network = make_shared<vector<DescribeDeviceServiceResponseBodyResourceInfosDeviceInfosNetwork>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDeviceServiceResponseBodyResourceInfosDeviceInfos() = default;
};
class DescribeDeviceServiceResponseBodyResourceInfosInternalIps : public Darabonba::Model {
public:
  shared_ptr<string> ip{};

  DescribeDeviceServiceResponseBodyResourceInfosInternalIps() {}

  explicit DescribeDeviceServiceResponseBodyResourceInfosInternalIps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
  }


  virtual ~DescribeDeviceServiceResponseBodyResourceInfosInternalIps() = default;
};
class DescribeDeviceServiceResponseBodyResourceInfosPublicIps : public Darabonba::Model {
public:
  shared_ptr<string> ip{};

  DescribeDeviceServiceResponseBodyResourceInfosPublicIps() {}

  explicit DescribeDeviceServiceResponseBodyResourceInfosPublicIps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
  }


  virtual ~DescribeDeviceServiceResponseBodyResourceInfosPublicIps() = default;
};
class DescribeDeviceServiceResponseBodyResourceInfos : public Darabonba::Model {
public:
  shared_ptr<string> appVersion{};
  shared_ptr<string> areaCode{};
  shared_ptr<string> areaName{};
  shared_ptr<string> createTime{};
  shared_ptr<vector<DescribeDeviceServiceResponseBodyResourceInfosDeviceInfos>> deviceInfos{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceStatus{};
  shared_ptr<vector<DescribeDeviceServiceResponseBodyResourceInfosInternalIps>> internalIps{};
  shared_ptr<vector<DescribeDeviceServiceResponseBodyResourceInfosPublicIps>> publicIps{};
  shared_ptr<string> regionCode{};
  shared_ptr<string> regionId{};
  shared_ptr<string> regionName{};

  DescribeDeviceServiceResponseBodyResourceInfos() {}

  explicit DescribeDeviceServiceResponseBodyResourceInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (areaCode) {
      res["AreaCode"] = boost::any(*areaCode);
    }
    if (areaName) {
      res["AreaName"] = boost::any(*areaName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deviceInfos) {
      vector<boost::any> temp1;
      for(auto item1:*deviceInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceInfos"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceStatus) {
      res["InstanceStatus"] = boost::any(*instanceStatus);
    }
    if (internalIps) {
      vector<boost::any> temp1;
      for(auto item1:*internalIps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InternalIps"] = boost::any(temp1);
    }
    if (publicIps) {
      vector<boost::any> temp1;
      for(auto item1:*publicIps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PublicIps"] = boost::any(temp1);
    }
    if (regionCode) {
      res["RegionCode"] = boost::any(*regionCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("AreaCode") != m.end() && !m["AreaCode"].empty()) {
      areaCode = make_shared<string>(boost::any_cast<string>(m["AreaCode"]));
    }
    if (m.find("AreaName") != m.end() && !m["AreaName"].empty()) {
      areaName = make_shared<string>(boost::any_cast<string>(m["AreaName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeviceInfos") != m.end() && !m["DeviceInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceInfos"].type()) {
        vector<DescribeDeviceServiceResponseBodyResourceInfosDeviceInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeviceServiceResponseBodyResourceInfosDeviceInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceInfos = make_shared<vector<DescribeDeviceServiceResponseBodyResourceInfosDeviceInfos>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceStatus") != m.end() && !m["InstanceStatus"].empty()) {
      instanceStatus = make_shared<string>(boost::any_cast<string>(m["InstanceStatus"]));
    }
    if (m.find("InternalIps") != m.end() && !m["InternalIps"].empty()) {
      if (typeid(vector<boost::any>) == m["InternalIps"].type()) {
        vector<DescribeDeviceServiceResponseBodyResourceInfosInternalIps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InternalIps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeviceServiceResponseBodyResourceInfosInternalIps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        internalIps = make_shared<vector<DescribeDeviceServiceResponseBodyResourceInfosInternalIps>>(expect1);
      }
    }
    if (m.find("PublicIps") != m.end() && !m["PublicIps"].empty()) {
      if (typeid(vector<boost::any>) == m["PublicIps"].type()) {
        vector<DescribeDeviceServiceResponseBodyResourceInfosPublicIps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PublicIps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeviceServiceResponseBodyResourceInfosPublicIps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        publicIps = make_shared<vector<DescribeDeviceServiceResponseBodyResourceInfosPublicIps>>(expect1);
      }
    }
    if (m.find("RegionCode") != m.end() && !m["RegionCode"].empty()) {
      regionCode = make_shared<string>(boost::any_cast<string>(m["RegionCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
  }


  virtual ~DescribeDeviceServiceResponseBodyResourceInfos() = default;
};
class DescribeDeviceServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDeviceServiceResponseBodyAppMetaData> appMetaData{};
  shared_ptr<DescribeDeviceServiceResponseBodyAppStatus> appStatus{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDeviceServiceResponseBodyResourceDetailInfos>> resourceDetailInfos{};
  shared_ptr<vector<DescribeDeviceServiceResponseBodyResourceInfos>> resourceInfos{};

  DescribeDeviceServiceResponseBody() {}

  explicit DescribeDeviceServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appMetaData) {
      res["AppMetaData"] = appMetaData ? boost::any(appMetaData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (appStatus) {
      res["AppStatus"] = appStatus ? boost::any(appStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceDetailInfos) {
      vector<boost::any> temp1;
      for(auto item1:*resourceDetailInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceDetailInfos"] = boost::any(temp1);
    }
    if (resourceInfos) {
      vector<boost::any> temp1;
      for(auto item1:*resourceInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppMetaData") != m.end() && !m["AppMetaData"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppMetaData"].type()) {
        DescribeDeviceServiceResponseBodyAppMetaData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppMetaData"]));
        appMetaData = make_shared<DescribeDeviceServiceResponseBodyAppMetaData>(model1);
      }
    }
    if (m.find("AppStatus") != m.end() && !m["AppStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppStatus"].type()) {
        DescribeDeviceServiceResponseBodyAppStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppStatus"]));
        appStatus = make_shared<DescribeDeviceServiceResponseBodyAppStatus>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceDetailInfos") != m.end() && !m["ResourceDetailInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceDetailInfos"].type()) {
        vector<DescribeDeviceServiceResponseBodyResourceDetailInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceDetailInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeviceServiceResponseBodyResourceDetailInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceDetailInfos = make_shared<vector<DescribeDeviceServiceResponseBodyResourceDetailInfos>>(expect1);
      }
    }
    if (m.find("ResourceInfos") != m.end() && !m["ResourceInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceInfos"].type()) {
        vector<DescribeDeviceServiceResponseBodyResourceInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeviceServiceResponseBodyResourceInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceInfos = make_shared<vector<DescribeDeviceServiceResponseBodyResourceInfos>>(expect1);
      }
    }
  }


  virtual ~DescribeDeviceServiceResponseBody() = default;
};
class DescribeDeviceServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDeviceServiceResponseBody> body{};

  DescribeDeviceServiceResponse() {}

  explicit DescribeDeviceServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeviceServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeviceServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeviceServiceResponse() = default;
};
class DescribeDisksRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> diskChargeType{};
  shared_ptr<string> diskId{};
  shared_ptr<string> diskIds{};
  shared_ptr<string> diskName{};
  shared_ptr<string> diskType{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> ensRegionIds{};
  shared_ptr<string> orderByParams{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeDisksRequest() {}

  explicit DescribeDisksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (diskChargeType) {
      res["DiskChargeType"] = boost::any(*diskChargeType);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (diskIds) {
      res["DiskIds"] = boost::any(*diskIds);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = boost::any(*ensRegionIds);
    }
    if (orderByParams) {
      res["OrderByParams"] = boost::any(*orderByParams);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DiskChargeType") != m.end() && !m["DiskChargeType"].empty()) {
      diskChargeType = make_shared<string>(boost::any_cast<string>(m["DiskChargeType"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("DiskIds") != m.end() && !m["DiskIds"].empty()) {
      diskIds = make_shared<string>(boost::any_cast<string>(m["DiskIds"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      ensRegionIds = make_shared<string>(boost::any_cast<string>(m["EnsRegionIds"]));
    }
    if (m.find("OrderByParams") != m.end() && !m["OrderByParams"].empty()) {
      orderByParams = make_shared<string>(boost::any_cast<string>(m["OrderByParams"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDisksRequest() = default;
};
class DescribeDisksResponseBodyDisksDisks : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> diskChargeType{};
  shared_ptr<string> diskId{};
  shared_ptr<string> diskName{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<bool> portable{};
  shared_ptr<long> size{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeDisksResponseBodyDisksDisks() {}

  explicit DescribeDisksResponseBodyDisksDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (diskChargeType) {
      res["DiskChargeType"] = boost::any(*diskChargeType);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (portable) {
      res["Portable"] = boost::any(*portable);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DiskChargeType") != m.end() && !m["DiskChargeType"].empty()) {
      diskChargeType = make_shared<string>(boost::any_cast<string>(m["DiskChargeType"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Portable") != m.end() && !m["Portable"].empty()) {
      portable = make_shared<bool>(boost::any_cast<bool>(m["Portable"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDisksResponseBodyDisksDisks() = default;
};
class DescribeDisksResponseBodyDisks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDisksResponseBodyDisksDisks>> disks{};

  DescribeDisksResponseBodyDisks() {}

  explicit DescribeDisksResponseBodyDisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disks) {
      vector<boost::any> temp1;
      for(auto item1:*disks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Disks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Disks") != m.end() && !m["Disks"].empty()) {
      if (typeid(vector<boost::any>) == m["Disks"].type()) {
        vector<DescribeDisksResponseBodyDisksDisks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Disks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDisksResponseBodyDisksDisks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        disks = make_shared<vector<DescribeDisksResponseBodyDisksDisks>>(expect1);
      }
    }
  }


  virtual ~DescribeDisksResponseBodyDisks() = default;
};
class DescribeDisksResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeDisksResponseBodyDisks> disks{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDisksResponseBody() {}

  explicit DescribeDisksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (disks) {
      res["Disks"] = disks ? boost::any(disks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Disks") != m.end() && !m["Disks"].empty()) {
      if (typeid(map<string, boost::any>) == m["Disks"].type()) {
        DescribeDisksResponseBodyDisks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Disks"]));
        disks = make_shared<DescribeDisksResponseBodyDisks>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDisksResponseBody() = default;
};
class DescribeDisksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDisksResponseBody> body{};

  DescribeDisksResponse() {}

  explicit DescribeDisksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDisksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDisksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDisksResponse() = default;
};
class DescribeEipAddressesRequest : public Darabonba::Model {
public:
  shared_ptr<string> eips{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> version{};

  DescribeEipAddressesRequest() {}

  explicit DescribeEipAddressesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eips) {
      res["Eips"] = boost::any(*eips);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Eips") != m.end() && !m["Eips"].empty()) {
      eips = make_shared<string>(boost::any_cast<string>(m["Eips"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeEipAddressesRequest() = default;
};
class DescribeEipAddressesResponseBodyEipAddressesEipAddress : public Darabonba::Model {
public:
  shared_ptr<string> eip{};
  shared_ptr<string> instanceIdInternetIp{};

  DescribeEipAddressesResponseBodyEipAddressesEipAddress() {}

  explicit DescribeEipAddressesResponseBodyEipAddressesEipAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eip) {
      res["Eip"] = boost::any(*eip);
    }
    if (instanceIdInternetIp) {
      res["InstanceIdInternetIp"] = boost::any(*instanceIdInternetIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Eip") != m.end() && !m["Eip"].empty()) {
      eip = make_shared<string>(boost::any_cast<string>(m["Eip"]));
    }
    if (m.find("InstanceIdInternetIp") != m.end() && !m["InstanceIdInternetIp"].empty()) {
      instanceIdInternetIp = make_shared<string>(boost::any_cast<string>(m["InstanceIdInternetIp"]));
    }
  }


  virtual ~DescribeEipAddressesResponseBodyEipAddressesEipAddress() = default;
};
class DescribeEipAddressesResponseBodyEipAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEipAddressesResponseBodyEipAddressesEipAddress>> eipAddress{};

  DescribeEipAddressesResponseBodyEipAddresses() {}

  explicit DescribeEipAddressesResponseBodyEipAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipAddress) {
      vector<boost::any> temp1;
      for(auto item1:*eipAddress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EipAddress"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipAddress") != m.end() && !m["EipAddress"].empty()) {
      if (typeid(vector<boost::any>) == m["EipAddress"].type()) {
        vector<DescribeEipAddressesResponseBodyEipAddressesEipAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EipAddress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEipAddressesResponseBodyEipAddressesEipAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eipAddress = make_shared<vector<DescribeEipAddressesResponseBodyEipAddressesEipAddress>>(expect1);
      }
    }
  }


  virtual ~DescribeEipAddressesResponseBodyEipAddresses() = default;
};
class DescribeEipAddressesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeEipAddressesResponseBodyEipAddresses> eipAddresses{};
  shared_ptr<string> requestId{};

  DescribeEipAddressesResponseBody() {}

  explicit DescribeEipAddressesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipAddresses) {
      res["EipAddresses"] = eipAddresses ? boost::any(eipAddresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipAddresses") != m.end() && !m["EipAddresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["EipAddresses"].type()) {
        DescribeEipAddressesResponseBodyEipAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EipAddresses"]));
        eipAddresses = make_shared<DescribeEipAddressesResponseBodyEipAddresses>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEipAddressesResponseBody() = default;
};
class DescribeEipAddressesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeEipAddressesResponseBody> body{};

  DescribeEipAddressesResponse() {}

  explicit DescribeEipAddressesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEipAddressesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEipAddressesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEipAddressesResponse() = default;
};
class DescribeElbAvailableResourceInfoResponseBodyElbAvailableResourceInfo : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> canBuyCount{};
  shared_ptr<string> enName{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<vector<string>> loadBalancerSpec{};
  shared_ptr<string> name{};
  shared_ptr<string> province{};

  DescribeElbAvailableResourceInfoResponseBodyElbAvailableResourceInfo() {}

  explicit DescribeElbAvailableResourceInfoResponseBodyElbAvailableResourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (canBuyCount) {
      res["CanBuyCount"] = boost::any(*canBuyCount);
    }
    if (enName) {
      res["EnName"] = boost::any(*enName);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (loadBalancerSpec) {
      res["LoadBalancerSpec"] = boost::any(*loadBalancerSpec);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("CanBuyCount") != m.end() && !m["CanBuyCount"].empty()) {
      canBuyCount = make_shared<string>(boost::any_cast<string>(m["CanBuyCount"]));
    }
    if (m.find("EnName") != m.end() && !m["EnName"].empty()) {
      enName = make_shared<string>(boost::any_cast<string>(m["EnName"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("LoadBalancerSpec") != m.end() && !m["LoadBalancerSpec"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LoadBalancerSpec"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LoadBalancerSpec"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      loadBalancerSpec = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~DescribeElbAvailableResourceInfoResponseBodyElbAvailableResourceInfo() = default;
};
class DescribeElbAvailableResourceInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeElbAvailableResourceInfoResponseBodyElbAvailableResourceInfo>> elbAvailableResourceInfo{};
  shared_ptr<string> requestId{};

  DescribeElbAvailableResourceInfoResponseBody() {}

  explicit DescribeElbAvailableResourceInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (elbAvailableResourceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*elbAvailableResourceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ElbAvailableResourceInfo"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ElbAvailableResourceInfo") != m.end() && !m["ElbAvailableResourceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ElbAvailableResourceInfo"].type()) {
        vector<DescribeElbAvailableResourceInfoResponseBodyElbAvailableResourceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ElbAvailableResourceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeElbAvailableResourceInfoResponseBodyElbAvailableResourceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        elbAvailableResourceInfo = make_shared<vector<DescribeElbAvailableResourceInfoResponseBodyElbAvailableResourceInfo>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeElbAvailableResourceInfoResponseBody() = default;
};
class DescribeElbAvailableResourceInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeElbAvailableResourceInfoResponseBody> body{};

  DescribeElbAvailableResourceInfoResponse() {}

  explicit DescribeElbAvailableResourceInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeElbAvailableResourceInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeElbAvailableResourceInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeElbAvailableResourceInfoResponse() = default;
};
class DescribeEnsEipAddressesRequest : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> associatedInstanceId{};
  shared_ptr<string> associatedInstanceType{};
  shared_ptr<string> eipAddress{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeEnsEipAddressesRequest() {}

  explicit DescribeEnsEipAddressesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (associatedInstanceId) {
      res["AssociatedInstanceId"] = boost::any(*associatedInstanceId);
    }
    if (associatedInstanceType) {
      res["AssociatedInstanceType"] = boost::any(*associatedInstanceType);
    }
    if (eipAddress) {
      res["EipAddress"] = boost::any(*eipAddress);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("AssociatedInstanceId") != m.end() && !m["AssociatedInstanceId"].empty()) {
      associatedInstanceId = make_shared<string>(boost::any_cast<string>(m["AssociatedInstanceId"]));
    }
    if (m.find("AssociatedInstanceType") != m.end() && !m["AssociatedInstanceType"].empty()) {
      associatedInstanceType = make_shared<string>(boost::any_cast<string>(m["AssociatedInstanceType"]));
    }
    if (m.find("EipAddress") != m.end() && !m["EipAddress"].empty()) {
      eipAddress = make_shared<string>(boost::any_cast<string>(m["EipAddress"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeEnsEipAddressesRequest() = default;
};
class DescribeEnsEipAddressesResponseBodyEipAddressesEipAddress : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> allocationTime{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> isp{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};

  DescribeEnsEipAddressesResponseBodyEipAddressesEipAddress() {}

  explicit DescribeEnsEipAddressesResponseBodyEipAddressesEipAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (allocationTime) {
      res["AllocationTime"] = boost::any(*allocationTime);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("AllocationTime") != m.end() && !m["AllocationTime"].empty()) {
      allocationTime = make_shared<string>(boost::any_cast<string>(m["AllocationTime"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeEnsEipAddressesResponseBodyEipAddressesEipAddress() = default;
};
class DescribeEnsEipAddressesResponseBodyEipAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEnsEipAddressesResponseBodyEipAddressesEipAddress>> eipAddress{};

  DescribeEnsEipAddressesResponseBodyEipAddresses() {}

  explicit DescribeEnsEipAddressesResponseBodyEipAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipAddress) {
      vector<boost::any> temp1;
      for(auto item1:*eipAddress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EipAddress"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipAddress") != m.end() && !m["EipAddress"].empty()) {
      if (typeid(vector<boost::any>) == m["EipAddress"].type()) {
        vector<DescribeEnsEipAddressesResponseBodyEipAddressesEipAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EipAddress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsEipAddressesResponseBodyEipAddressesEipAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eipAddress = make_shared<vector<DescribeEnsEipAddressesResponseBodyEipAddressesEipAddress>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsEipAddressesResponseBodyEipAddresses() = default;
};
class DescribeEnsEipAddressesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeEnsEipAddressesResponseBodyEipAddresses> eipAddresses{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeEnsEipAddressesResponseBody() {}

  explicit DescribeEnsEipAddressesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipAddresses) {
      res["EipAddresses"] = eipAddresses ? boost::any(eipAddresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipAddresses") != m.end() && !m["EipAddresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["EipAddresses"].type()) {
        DescribeEnsEipAddressesResponseBodyEipAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EipAddresses"]));
        eipAddresses = make_shared<DescribeEnsEipAddressesResponseBodyEipAddresses>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeEnsEipAddressesResponseBody() = default;
};
class DescribeEnsEipAddressesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeEnsEipAddressesResponseBody> body{};

  DescribeEnsEipAddressesResponse() {}

  explicit DescribeEnsEipAddressesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsEipAddressesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsEipAddressesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsEipAddressesResponse() = default;
};
class DescribeEnsNetDistrictRequest : public Darabonba::Model {
public:
  shared_ptr<string> netDistrictCode{};
  shared_ptr<string> netLevelCode{};
  shared_ptr<string> version{};

  DescribeEnsNetDistrictRequest() {}

  explicit DescribeEnsNetDistrictRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (netDistrictCode) {
      res["NetDistrictCode"] = boost::any(*netDistrictCode);
    }
    if (netLevelCode) {
      res["NetLevelCode"] = boost::any(*netLevelCode);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetDistrictCode") != m.end() && !m["NetDistrictCode"].empty()) {
      netDistrictCode = make_shared<string>(boost::any_cast<string>(m["NetDistrictCode"]));
    }
    if (m.find("NetLevelCode") != m.end() && !m["NetLevelCode"].empty()) {
      netLevelCode = make_shared<string>(boost::any_cast<string>(m["NetLevelCode"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeEnsNetDistrictRequest() = default;
};
class DescribeEnsNetDistrictResponseBodyEnsNetDistrictsEnsNetDistrict : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionIdCount{};
  shared_ptr<string> netDistrictCode{};
  shared_ptr<string> netDistrictEnName{};
  shared_ptr<string> netDistrictFatherCode{};
  shared_ptr<string> netDistrictLevel{};
  shared_ptr<string> netDistrictName{};

  DescribeEnsNetDistrictResponseBodyEnsNetDistrictsEnsNetDistrict() {}

  explicit DescribeEnsNetDistrictResponseBodyEnsNetDistrictsEnsNetDistrict(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionIdCount) {
      res["EnsRegionIdCount"] = boost::any(*ensRegionIdCount);
    }
    if (netDistrictCode) {
      res["NetDistrictCode"] = boost::any(*netDistrictCode);
    }
    if (netDistrictEnName) {
      res["NetDistrictEnName"] = boost::any(*netDistrictEnName);
    }
    if (netDistrictFatherCode) {
      res["NetDistrictFatherCode"] = boost::any(*netDistrictFatherCode);
    }
    if (netDistrictLevel) {
      res["NetDistrictLevel"] = boost::any(*netDistrictLevel);
    }
    if (netDistrictName) {
      res["NetDistrictName"] = boost::any(*netDistrictName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionIdCount") != m.end() && !m["EnsRegionIdCount"].empty()) {
      ensRegionIdCount = make_shared<string>(boost::any_cast<string>(m["EnsRegionIdCount"]));
    }
    if (m.find("NetDistrictCode") != m.end() && !m["NetDistrictCode"].empty()) {
      netDistrictCode = make_shared<string>(boost::any_cast<string>(m["NetDistrictCode"]));
    }
    if (m.find("NetDistrictEnName") != m.end() && !m["NetDistrictEnName"].empty()) {
      netDistrictEnName = make_shared<string>(boost::any_cast<string>(m["NetDistrictEnName"]));
    }
    if (m.find("NetDistrictFatherCode") != m.end() && !m["NetDistrictFatherCode"].empty()) {
      netDistrictFatherCode = make_shared<string>(boost::any_cast<string>(m["NetDistrictFatherCode"]));
    }
    if (m.find("NetDistrictLevel") != m.end() && !m["NetDistrictLevel"].empty()) {
      netDistrictLevel = make_shared<string>(boost::any_cast<string>(m["NetDistrictLevel"]));
    }
    if (m.find("NetDistrictName") != m.end() && !m["NetDistrictName"].empty()) {
      netDistrictName = make_shared<string>(boost::any_cast<string>(m["NetDistrictName"]));
    }
  }


  virtual ~DescribeEnsNetDistrictResponseBodyEnsNetDistrictsEnsNetDistrict() = default;
};
class DescribeEnsNetDistrictResponseBodyEnsNetDistricts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEnsNetDistrictResponseBodyEnsNetDistrictsEnsNetDistrict>> ensNetDistrict{};

  DescribeEnsNetDistrictResponseBodyEnsNetDistricts() {}

  explicit DescribeEnsNetDistrictResponseBodyEnsNetDistricts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensNetDistrict) {
      vector<boost::any> temp1;
      for(auto item1:*ensNetDistrict){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnsNetDistrict"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsNetDistrict") != m.end() && !m["EnsNetDistrict"].empty()) {
      if (typeid(vector<boost::any>) == m["EnsNetDistrict"].type()) {
        vector<DescribeEnsNetDistrictResponseBodyEnsNetDistrictsEnsNetDistrict> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnsNetDistrict"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsNetDistrictResponseBodyEnsNetDistrictsEnsNetDistrict model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ensNetDistrict = make_shared<vector<DescribeEnsNetDistrictResponseBodyEnsNetDistrictsEnsNetDistrict>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsNetDistrictResponseBodyEnsNetDistricts() = default;
};
class DescribeEnsNetDistrictResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeEnsNetDistrictResponseBodyEnsNetDistricts> ensNetDistricts{};
  shared_ptr<string> requestId{};

  DescribeEnsNetDistrictResponseBody() {}

  explicit DescribeEnsNetDistrictResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (ensNetDistricts) {
      res["EnsNetDistricts"] = ensNetDistricts ? boost::any(ensNetDistricts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("EnsNetDistricts") != m.end() && !m["EnsNetDistricts"].empty()) {
      if (typeid(map<string, boost::any>) == m["EnsNetDistricts"].type()) {
        DescribeEnsNetDistrictResponseBodyEnsNetDistricts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EnsNetDistricts"]));
        ensNetDistricts = make_shared<DescribeEnsNetDistrictResponseBodyEnsNetDistricts>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEnsNetDistrictResponseBody() = default;
};
class DescribeEnsNetDistrictResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeEnsNetDistrictResponseBody> body{};

  DescribeEnsNetDistrictResponse() {}

  explicit DescribeEnsNetDistrictResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsNetDistrictResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsNetDistrictResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsNetDistrictResponse() = default;
};
class DescribeEnsNetLevelRequest : public Darabonba::Model {
public:
  shared_ptr<string> version{};

  DescribeEnsNetLevelRequest() {}

  explicit DescribeEnsNetLevelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeEnsNetLevelRequest() = default;
};
class DescribeEnsNetLevelResponseBodyEnsNetLevelsEnsNetLevel : public Darabonba::Model {
public:
  shared_ptr<string> ensNetLevelCode{};

  DescribeEnsNetLevelResponseBodyEnsNetLevelsEnsNetLevel() {}

  explicit DescribeEnsNetLevelResponseBodyEnsNetLevelsEnsNetLevel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensNetLevelCode) {
      res["EnsNetLevelCode"] = boost::any(*ensNetLevelCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsNetLevelCode") != m.end() && !m["EnsNetLevelCode"].empty()) {
      ensNetLevelCode = make_shared<string>(boost::any_cast<string>(m["EnsNetLevelCode"]));
    }
  }


  virtual ~DescribeEnsNetLevelResponseBodyEnsNetLevelsEnsNetLevel() = default;
};
class DescribeEnsNetLevelResponseBodyEnsNetLevels : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEnsNetLevelResponseBodyEnsNetLevelsEnsNetLevel>> ensNetLevel{};

  DescribeEnsNetLevelResponseBodyEnsNetLevels() {}

  explicit DescribeEnsNetLevelResponseBodyEnsNetLevels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensNetLevel) {
      vector<boost::any> temp1;
      for(auto item1:*ensNetLevel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnsNetLevel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsNetLevel") != m.end() && !m["EnsNetLevel"].empty()) {
      if (typeid(vector<boost::any>) == m["EnsNetLevel"].type()) {
        vector<DescribeEnsNetLevelResponseBodyEnsNetLevelsEnsNetLevel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnsNetLevel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsNetLevelResponseBodyEnsNetLevelsEnsNetLevel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ensNetLevel = make_shared<vector<DescribeEnsNetLevelResponseBodyEnsNetLevelsEnsNetLevel>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsNetLevelResponseBodyEnsNetLevels() = default;
};
class DescribeEnsNetLevelResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeEnsNetLevelResponseBodyEnsNetLevels> ensNetLevels{};
  shared_ptr<string> requestId{};

  DescribeEnsNetLevelResponseBody() {}

  explicit DescribeEnsNetLevelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (ensNetLevels) {
      res["EnsNetLevels"] = ensNetLevels ? boost::any(ensNetLevels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("EnsNetLevels") != m.end() && !m["EnsNetLevels"].empty()) {
      if (typeid(map<string, boost::any>) == m["EnsNetLevels"].type()) {
        DescribeEnsNetLevelResponseBodyEnsNetLevels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EnsNetLevels"]));
        ensNetLevels = make_shared<DescribeEnsNetLevelResponseBodyEnsNetLevels>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEnsNetLevelResponseBody() = default;
};
class DescribeEnsNetLevelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeEnsNetLevelResponseBody> body{};

  DescribeEnsNetLevelResponse() {}

  explicit DescribeEnsNetLevelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsNetLevelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsNetLevelResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsNetLevelResponse() = default;
};
class DescribeEnsNetSaleDistrictRequest : public Darabonba::Model {
public:
  shared_ptr<string> netDistrictCode{};
  shared_ptr<string> netLevelCode{};
  shared_ptr<string> version{};

  DescribeEnsNetSaleDistrictRequest() {}

  explicit DescribeEnsNetSaleDistrictRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (netDistrictCode) {
      res["NetDistrictCode"] = boost::any(*netDistrictCode);
    }
    if (netLevelCode) {
      res["NetLevelCode"] = boost::any(*netLevelCode);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetDistrictCode") != m.end() && !m["NetDistrictCode"].empty()) {
      netDistrictCode = make_shared<string>(boost::any_cast<string>(m["NetDistrictCode"]));
    }
    if (m.find("NetLevelCode") != m.end() && !m["NetLevelCode"].empty()) {
      netLevelCode = make_shared<string>(boost::any_cast<string>(m["NetLevelCode"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeEnsNetSaleDistrictRequest() = default;
};
class DescribeEnsNetSaleDistrictResponseBodyEnsNetDistrictsEnsNetDistrict : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionIdCount{};
  shared_ptr<string> instanceCount{};
  shared_ptr<string> netDistrictCode{};
  shared_ptr<string> netDistrictEnName{};
  shared_ptr<string> netDistrictFatherCode{};
  shared_ptr<string> netDistrictLevel{};
  shared_ptr<string> netDistrictName{};

  DescribeEnsNetSaleDistrictResponseBodyEnsNetDistrictsEnsNetDistrict() {}

  explicit DescribeEnsNetSaleDistrictResponseBodyEnsNetDistrictsEnsNetDistrict(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionIdCount) {
      res["EnsRegionIdCount"] = boost::any(*ensRegionIdCount);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (netDistrictCode) {
      res["NetDistrictCode"] = boost::any(*netDistrictCode);
    }
    if (netDistrictEnName) {
      res["NetDistrictEnName"] = boost::any(*netDistrictEnName);
    }
    if (netDistrictFatherCode) {
      res["NetDistrictFatherCode"] = boost::any(*netDistrictFatherCode);
    }
    if (netDistrictLevel) {
      res["NetDistrictLevel"] = boost::any(*netDistrictLevel);
    }
    if (netDistrictName) {
      res["NetDistrictName"] = boost::any(*netDistrictName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionIdCount") != m.end() && !m["EnsRegionIdCount"].empty()) {
      ensRegionIdCount = make_shared<string>(boost::any_cast<string>(m["EnsRegionIdCount"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<string>(boost::any_cast<string>(m["InstanceCount"]));
    }
    if (m.find("NetDistrictCode") != m.end() && !m["NetDistrictCode"].empty()) {
      netDistrictCode = make_shared<string>(boost::any_cast<string>(m["NetDistrictCode"]));
    }
    if (m.find("NetDistrictEnName") != m.end() && !m["NetDistrictEnName"].empty()) {
      netDistrictEnName = make_shared<string>(boost::any_cast<string>(m["NetDistrictEnName"]));
    }
    if (m.find("NetDistrictFatherCode") != m.end() && !m["NetDistrictFatherCode"].empty()) {
      netDistrictFatherCode = make_shared<string>(boost::any_cast<string>(m["NetDistrictFatherCode"]));
    }
    if (m.find("NetDistrictLevel") != m.end() && !m["NetDistrictLevel"].empty()) {
      netDistrictLevel = make_shared<string>(boost::any_cast<string>(m["NetDistrictLevel"]));
    }
    if (m.find("NetDistrictName") != m.end() && !m["NetDistrictName"].empty()) {
      netDistrictName = make_shared<string>(boost::any_cast<string>(m["NetDistrictName"]));
    }
  }


  virtual ~DescribeEnsNetSaleDistrictResponseBodyEnsNetDistrictsEnsNetDistrict() = default;
};
class DescribeEnsNetSaleDistrictResponseBodyEnsNetDistricts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEnsNetSaleDistrictResponseBodyEnsNetDistrictsEnsNetDistrict>> ensNetDistrict{};

  DescribeEnsNetSaleDistrictResponseBodyEnsNetDistricts() {}

  explicit DescribeEnsNetSaleDistrictResponseBodyEnsNetDistricts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensNetDistrict) {
      vector<boost::any> temp1;
      for(auto item1:*ensNetDistrict){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnsNetDistrict"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsNetDistrict") != m.end() && !m["EnsNetDistrict"].empty()) {
      if (typeid(vector<boost::any>) == m["EnsNetDistrict"].type()) {
        vector<DescribeEnsNetSaleDistrictResponseBodyEnsNetDistrictsEnsNetDistrict> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnsNetDistrict"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsNetSaleDistrictResponseBodyEnsNetDistrictsEnsNetDistrict model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ensNetDistrict = make_shared<vector<DescribeEnsNetSaleDistrictResponseBodyEnsNetDistrictsEnsNetDistrict>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsNetSaleDistrictResponseBodyEnsNetDistricts() = default;
};
class DescribeEnsNetSaleDistrictResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeEnsNetSaleDistrictResponseBodyEnsNetDistricts> ensNetDistricts{};
  shared_ptr<string> requestId{};

  DescribeEnsNetSaleDistrictResponseBody() {}

  explicit DescribeEnsNetSaleDistrictResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (ensNetDistricts) {
      res["EnsNetDistricts"] = ensNetDistricts ? boost::any(ensNetDistricts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("EnsNetDistricts") != m.end() && !m["EnsNetDistricts"].empty()) {
      if (typeid(map<string, boost::any>) == m["EnsNetDistricts"].type()) {
        DescribeEnsNetSaleDistrictResponseBodyEnsNetDistricts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EnsNetDistricts"]));
        ensNetDistricts = make_shared<DescribeEnsNetSaleDistrictResponseBodyEnsNetDistricts>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEnsNetSaleDistrictResponseBody() = default;
};
class DescribeEnsNetSaleDistrictResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeEnsNetSaleDistrictResponseBody> body{};

  DescribeEnsNetSaleDistrictResponse() {}

  explicit DescribeEnsNetSaleDistrictResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsNetSaleDistrictResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsNetSaleDistrictResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsNetSaleDistrictResponse() = default;
};
class DescribeEnsRegionIdIpv6InfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> version{};

  DescribeEnsRegionIdIpv6InfoRequest() {}

  explicit DescribeEnsRegionIdIpv6InfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeEnsRegionIdIpv6InfoRequest() = default;
};
class DescribeEnsRegionIdIpv6InfoResponseBodySupportIpv6Info : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<bool> supportIpv6{};

  DescribeEnsRegionIdIpv6InfoResponseBodySupportIpv6Info() {}

  explicit DescribeEnsRegionIdIpv6InfoResponseBodySupportIpv6Info(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (supportIpv6) {
      res["SupportIpv6"] = boost::any(*supportIpv6);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("SupportIpv6") != m.end() && !m["SupportIpv6"].empty()) {
      supportIpv6 = make_shared<bool>(boost::any_cast<bool>(m["SupportIpv6"]));
    }
  }


  virtual ~DescribeEnsRegionIdIpv6InfoResponseBodySupportIpv6Info() = default;
};
class DescribeEnsRegionIdIpv6InfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeEnsRegionIdIpv6InfoResponseBodySupportIpv6Info> supportIpv6Info{};

  DescribeEnsRegionIdIpv6InfoResponseBody() {}

  explicit DescribeEnsRegionIdIpv6InfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (supportIpv6Info) {
      res["SupportIpv6Info"] = supportIpv6Info ? boost::any(supportIpv6Info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SupportIpv6Info") != m.end() && !m["SupportIpv6Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportIpv6Info"].type()) {
        DescribeEnsRegionIdIpv6InfoResponseBodySupportIpv6Info model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportIpv6Info"]));
        supportIpv6Info = make_shared<DescribeEnsRegionIdIpv6InfoResponseBodySupportIpv6Info>(model1);
      }
    }
  }


  virtual ~DescribeEnsRegionIdIpv6InfoResponseBody() = default;
};
class DescribeEnsRegionIdIpv6InfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeEnsRegionIdIpv6InfoResponseBody> body{};

  DescribeEnsRegionIdIpv6InfoResponse() {}

  explicit DescribeEnsRegionIdIpv6InfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsRegionIdIpv6InfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsRegionIdIpv6InfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsRegionIdIpv6InfoResponse() = default;
};
class DescribeEnsRegionIdResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> isp{};
  shared_ptr<string> orderByParams{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> startTime{};

  DescribeEnsRegionIdResourceRequest() {}

  explicit DescribeEnsRegionIdResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (orderByParams) {
      res["OrderByParams"] = boost::any(*orderByParams);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("OrderByParams") != m.end() && !m["OrderByParams"].empty()) {
      orderByParams = make_shared<string>(boost::any_cast<string>(m["OrderByParams"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeEnsRegionIdResourceRequest() = default;
};
class DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResourcesEnsRegionIdResource : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> areaCode{};
  shared_ptr<string> bizDate{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> ensRegionIdName{};
  shared_ptr<long> instanceCount{};
  shared_ptr<long> internetBandwidth{};
  shared_ptr<string> isp{};
  shared_ptr<long> VCpu{};

  DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResourcesEnsRegionIdResource() {}

  explicit DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResourcesEnsRegionIdResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (areaCode) {
      res["AreaCode"] = boost::any(*areaCode);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionIdName) {
      res["EnsRegionIdName"] = boost::any(*ensRegionIdName);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (internetBandwidth) {
      res["InternetBandwidth"] = boost::any(*internetBandwidth);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (VCpu) {
      res["VCpu"] = boost::any(*VCpu);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("AreaCode") != m.end() && !m["AreaCode"].empty()) {
      areaCode = make_shared<string>(boost::any_cast<string>(m["AreaCode"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionIdName") != m.end() && !m["EnsRegionIdName"].empty()) {
      ensRegionIdName = make_shared<string>(boost::any_cast<string>(m["EnsRegionIdName"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("InternetBandwidth") != m.end() && !m["InternetBandwidth"].empty()) {
      internetBandwidth = make_shared<long>(boost::any_cast<long>(m["InternetBandwidth"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("VCpu") != m.end() && !m["VCpu"].empty()) {
      VCpu = make_shared<long>(boost::any_cast<long>(m["VCpu"]));
    }
  }


  virtual ~DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResourcesEnsRegionIdResource() = default;
};
class DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResourcesEnsRegionIdResource>> ensRegionIdResource{};

  DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResources() {}

  explicit DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionIdResource) {
      vector<boost::any> temp1;
      for(auto item1:*ensRegionIdResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnsRegionIdResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionIdResource") != m.end() && !m["EnsRegionIdResource"].empty()) {
      if (typeid(vector<boost::any>) == m["EnsRegionIdResource"].type()) {
        vector<DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResourcesEnsRegionIdResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnsRegionIdResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResourcesEnsRegionIdResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ensRegionIdResource = make_shared<vector<DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResourcesEnsRegionIdResource>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResources() = default;
};
class DescribeEnsRegionIdResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResources> ensRegionIdResources{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeEnsRegionIdResourceResponseBody() {}

  explicit DescribeEnsRegionIdResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionIdResources) {
      res["EnsRegionIdResources"] = ensRegionIdResources ? boost::any(ensRegionIdResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionIdResources") != m.end() && !m["EnsRegionIdResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["EnsRegionIdResources"].type()) {
        DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EnsRegionIdResources"]));
        ensRegionIdResources = make_shared<DescribeEnsRegionIdResourceResponseBodyEnsRegionIdResources>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeEnsRegionIdResourceResponseBody() = default;
};
class DescribeEnsRegionIdResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeEnsRegionIdResourceResponseBody> body{};

  DescribeEnsRegionIdResourceResponse() {}

  explicit DescribeEnsRegionIdResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsRegionIdResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsRegionIdResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsRegionIdResourceResponse() = default;
};
class DescribeEnsRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> version{};

  DescribeEnsRegionsRequest() {}

  explicit DescribeEnsRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeEnsRegionsRequest() = default;
};
class DescribeEnsRegionsResponseBodyEnsRegionsEnsRegions : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> enName{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> name{};
  shared_ptr<string> province{};

  DescribeEnsRegionsResponseBodyEnsRegionsEnsRegions() {}

  explicit DescribeEnsRegionsResponseBodyEnsRegionsEnsRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (enName) {
      res["EnName"] = boost::any(*enName);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("EnName") != m.end() && !m["EnName"].empty()) {
      enName = make_shared<string>(boost::any_cast<string>(m["EnName"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~DescribeEnsRegionsResponseBodyEnsRegionsEnsRegions() = default;
};
class DescribeEnsRegionsResponseBodyEnsRegions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEnsRegionsResponseBodyEnsRegionsEnsRegions>> ensRegions{};

  DescribeEnsRegionsResponseBodyEnsRegions() {}

  explicit DescribeEnsRegionsResponseBodyEnsRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegions) {
      vector<boost::any> temp1;
      for(auto item1:*ensRegions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnsRegions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegions") != m.end() && !m["EnsRegions"].empty()) {
      if (typeid(vector<boost::any>) == m["EnsRegions"].type()) {
        vector<DescribeEnsRegionsResponseBodyEnsRegionsEnsRegions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnsRegions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsRegionsResponseBodyEnsRegionsEnsRegions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ensRegions = make_shared<vector<DescribeEnsRegionsResponseBodyEnsRegionsEnsRegions>>(expect1);
      }
    }
  }


  virtual ~DescribeEnsRegionsResponseBodyEnsRegions() = default;
};
class DescribeEnsRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeEnsRegionsResponseBodyEnsRegions> ensRegions{};
  shared_ptr<string> requestId{};

  DescribeEnsRegionsResponseBody() {}

  explicit DescribeEnsRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (ensRegions) {
      res["EnsRegions"] = ensRegions ? boost::any(ensRegions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("EnsRegions") != m.end() && !m["EnsRegions"].empty()) {
      if (typeid(map<string, boost::any>) == m["EnsRegions"].type()) {
        DescribeEnsRegionsResponseBodyEnsRegions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EnsRegions"]));
        ensRegions = make_shared<DescribeEnsRegionsResponseBodyEnsRegions>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEnsRegionsResponseBody() = default;
};
class DescribeEnsRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeEnsRegionsResponseBody> body{};

  DescribeEnsRegionsResponse() {}

  explicit DescribeEnsRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsRegionsResponse() = default;
};
class DescribeEnsResourceUsageRequest : public Darabonba::Model {
public:
  shared_ptr<string> expiredEndTime{};
  shared_ptr<string> expiredStartTime{};

  DescribeEnsResourceUsageRequest() {}

  explicit DescribeEnsResourceUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expiredEndTime) {
      res["ExpiredEndTime"] = boost::any(*expiredEndTime);
    }
    if (expiredStartTime) {
      res["ExpiredStartTime"] = boost::any(*expiredStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpiredEndTime") != m.end() && !m["ExpiredEndTime"].empty()) {
      expiredEndTime = make_shared<string>(boost::any_cast<string>(m["ExpiredEndTime"]));
    }
    if (m.find("ExpiredStartTime") != m.end() && !m["ExpiredStartTime"].empty()) {
      expiredStartTime = make_shared<string>(boost::any_cast<string>(m["ExpiredStartTime"]));
    }
  }


  virtual ~DescribeEnsResourceUsageRequest() = default;
};
class DescribeEnsResourceUsageResponseBodyEnsResourceUsage : public Darabonba::Model {
public:
  shared_ptr<long> computeResourceCount{};
  shared_ptr<long> cpuSum{};
  shared_ptr<long> diskCount{};
  shared_ptr<long> downCount{};
  shared_ptr<long> expiredCount{};
  shared_ptr<long> expiringCount{};
  shared_ptr<long> gpuSum{};
  shared_ptr<long> instanceCount{};
  shared_ptr<long> runningCount{};
  shared_ptr<string> serviceType{};
  shared_ptr<long> storageSum{};

  DescribeEnsResourceUsageResponseBodyEnsResourceUsage() {}

  explicit DescribeEnsResourceUsageResponseBodyEnsResourceUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (computeResourceCount) {
      res["ComputeResourceCount"] = boost::any(*computeResourceCount);
    }
    if (cpuSum) {
      res["CpuSum"] = boost::any(*cpuSum);
    }
    if (diskCount) {
      res["DiskCount"] = boost::any(*diskCount);
    }
    if (downCount) {
      res["DownCount"] = boost::any(*downCount);
    }
    if (expiredCount) {
      res["ExpiredCount"] = boost::any(*expiredCount);
    }
    if (expiringCount) {
      res["ExpiringCount"] = boost::any(*expiringCount);
    }
    if (gpuSum) {
      res["GpuSum"] = boost::any(*gpuSum);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (runningCount) {
      res["RunningCount"] = boost::any(*runningCount);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (storageSum) {
      res["StorageSum"] = boost::any(*storageSum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComputeResourceCount") != m.end() && !m["ComputeResourceCount"].empty()) {
      computeResourceCount = make_shared<long>(boost::any_cast<long>(m["ComputeResourceCount"]));
    }
    if (m.find("CpuSum") != m.end() && !m["CpuSum"].empty()) {
      cpuSum = make_shared<long>(boost::any_cast<long>(m["CpuSum"]));
    }
    if (m.find("DiskCount") != m.end() && !m["DiskCount"].empty()) {
      diskCount = make_shared<long>(boost::any_cast<long>(m["DiskCount"]));
    }
    if (m.find("DownCount") != m.end() && !m["DownCount"].empty()) {
      downCount = make_shared<long>(boost::any_cast<long>(m["DownCount"]));
    }
    if (m.find("ExpiredCount") != m.end() && !m["ExpiredCount"].empty()) {
      expiredCount = make_shared<long>(boost::any_cast<long>(m["ExpiredCount"]));
    }
    if (m.find("ExpiringCount") != m.end() && !m["ExpiringCount"].empty()) {
      expiringCount = make_shared<long>(boost::any_cast<long>(m["ExpiringCount"]));
    }
    if (m.find("GpuSum") != m.end() && !m["GpuSum"].empty()) {
      gpuSum = make_shared<long>(boost::any_cast<long>(m["GpuSum"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("RunningCount") != m.end() && !m["RunningCount"].empty()) {
      runningCount = make_shared<long>(boost::any_cast<long>(m["RunningCount"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("StorageSum") != m.end() && !m["StorageSum"].empty()) {
      storageSum = make_shared<long>(boost::any_cast<long>(m["StorageSum"]));
    }
  }


  virtual ~DescribeEnsResourceUsageResponseBodyEnsResourceUsage() = default;
};
class DescribeEnsResourceUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEnsResourceUsageResponseBodyEnsResourceUsage>> ensResourceUsage{};
  shared_ptr<string> requestId{};

  DescribeEnsResourceUsageResponseBody() {}

  explicit DescribeEnsResourceUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensResourceUsage) {
      vector<boost::any> temp1;
      for(auto item1:*ensResourceUsage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnsResourceUsage"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsResourceUsage") != m.end() && !m["EnsResourceUsage"].empty()) {
      if (typeid(vector<boost::any>) == m["EnsResourceUsage"].type()) {
        vector<DescribeEnsResourceUsageResponseBodyEnsResourceUsage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnsResourceUsage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEnsResourceUsageResponseBodyEnsResourceUsage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ensResourceUsage = make_shared<vector<DescribeEnsResourceUsageResponseBodyEnsResourceUsage>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEnsResourceUsageResponseBody() = default;
};
class DescribeEnsResourceUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeEnsResourceUsageResponseBody> body{};

  DescribeEnsResourceUsageResponse() {}

  explicit DescribeEnsResourceUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEnsResourceUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEnsResourceUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEnsResourceUsageResponse() = default;
};
class DescribeEpnBandWidthDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> isp{};
  shared_ptr<string> networkingModel{};
  shared_ptr<string> period{};
  shared_ptr<string> startTime{};
  shared_ptr<string> version{};

  DescribeEpnBandWidthDataRequest() {}

  explicit DescribeEpnBandWidthDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (networkingModel) {
      res["NetworkingModel"] = boost::any(*networkingModel);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("NetworkingModel") != m.end() && !m["NetworkingModel"].empty()) {
      networkingModel = make_shared<string>(boost::any_cast<string>(m["NetworkingModel"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeEpnBandWidthDataRequest() = default;
};
class DescribeEpnBandWidthDataResponseBodyMonitorDataBandWidthMonitorData : public Darabonba::Model {
public:
  shared_ptr<long> downBandWidth{};
  shared_ptr<long> internetRX{};
  shared_ptr<long> internetTX{};
  shared_ptr<string> timeStamp{};
  shared_ptr<long> upBandWidth{};

  DescribeEpnBandWidthDataResponseBodyMonitorDataBandWidthMonitorData() {}

  explicit DescribeEpnBandWidthDataResponseBodyMonitorDataBandWidthMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downBandWidth) {
      res["DownBandWidth"] = boost::any(*downBandWidth);
    }
    if (internetRX) {
      res["InternetRX"] = boost::any(*internetRX);
    }
    if (internetTX) {
      res["InternetTX"] = boost::any(*internetTX);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (upBandWidth) {
      res["UpBandWidth"] = boost::any(*upBandWidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownBandWidth") != m.end() && !m["DownBandWidth"].empty()) {
      downBandWidth = make_shared<long>(boost::any_cast<long>(m["DownBandWidth"]));
    }
    if (m.find("InternetRX") != m.end() && !m["InternetRX"].empty()) {
      internetRX = make_shared<long>(boost::any_cast<long>(m["InternetRX"]));
    }
    if (m.find("InternetTX") != m.end() && !m["InternetTX"].empty()) {
      internetTX = make_shared<long>(boost::any_cast<long>(m["InternetTX"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("UpBandWidth") != m.end() && !m["UpBandWidth"].empty()) {
      upBandWidth = make_shared<long>(boost::any_cast<long>(m["UpBandWidth"]));
    }
  }


  virtual ~DescribeEpnBandWidthDataResponseBodyMonitorDataBandWidthMonitorData() = default;
};
class DescribeEpnBandWidthDataResponseBodyMonitorData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEpnBandWidthDataResponseBodyMonitorDataBandWidthMonitorData>> bandWidthMonitorData{};
  shared_ptr<long> maxDownBandWidth{};
  shared_ptr<long> maxUpBandWidth{};

  DescribeEpnBandWidthDataResponseBodyMonitorData() {}

  explicit DescribeEpnBandWidthDataResponseBodyMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidthMonitorData) {
      vector<boost::any> temp1;
      for(auto item1:*bandWidthMonitorData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BandWidthMonitorData"] = boost::any(temp1);
    }
    if (maxDownBandWidth) {
      res["MaxDownBandWidth"] = boost::any(*maxDownBandWidth);
    }
    if (maxUpBandWidth) {
      res["MaxUpBandWidth"] = boost::any(*maxUpBandWidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidthMonitorData") != m.end() && !m["BandWidthMonitorData"].empty()) {
      if (typeid(vector<boost::any>) == m["BandWidthMonitorData"].type()) {
        vector<DescribeEpnBandWidthDataResponseBodyMonitorDataBandWidthMonitorData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BandWidthMonitorData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEpnBandWidthDataResponseBodyMonitorDataBandWidthMonitorData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bandWidthMonitorData = make_shared<vector<DescribeEpnBandWidthDataResponseBodyMonitorDataBandWidthMonitorData>>(expect1);
      }
    }
    if (m.find("MaxDownBandWidth") != m.end() && !m["MaxDownBandWidth"].empty()) {
      maxDownBandWidth = make_shared<long>(boost::any_cast<long>(m["MaxDownBandWidth"]));
    }
    if (m.find("MaxUpBandWidth") != m.end() && !m["MaxUpBandWidth"].empty()) {
      maxUpBandWidth = make_shared<long>(boost::any_cast<long>(m["MaxUpBandWidth"]));
    }
  }


  virtual ~DescribeEpnBandWidthDataResponseBodyMonitorData() = default;
};
class DescribeEpnBandWidthDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeEpnBandWidthDataResponseBodyMonitorData> monitorData{};
  shared_ptr<string> requestId{};

  DescribeEpnBandWidthDataResponseBody() {}

  explicit DescribeEpnBandWidthDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorData) {
      res["MonitorData"] = monitorData ? boost::any(monitorData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorData") != m.end() && !m["MonitorData"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonitorData"].type()) {
        DescribeEpnBandWidthDataResponseBodyMonitorData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonitorData"]));
        monitorData = make_shared<DescribeEpnBandWidthDataResponseBodyMonitorData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEpnBandWidthDataResponseBody() = default;
};
class DescribeEpnBandWidthDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeEpnBandWidthDataResponseBody> body{};

  DescribeEpnBandWidthDataResponse() {}

  explicit DescribeEpnBandWidthDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEpnBandWidthDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEpnBandWidthDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEpnBandWidthDataResponse() = default;
};
class DescribeEpnBandwitdhByInternetChargeTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> isp{};
  shared_ptr<string> networkingModel{};
  shared_ptr<string> startTime{};
  shared_ptr<string> version{};

  DescribeEpnBandwitdhByInternetChargeTypeRequest() {}

  explicit DescribeEpnBandwitdhByInternetChargeTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (networkingModel) {
      res["NetworkingModel"] = boost::any(*networkingModel);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("NetworkingModel") != m.end() && !m["NetworkingModel"].empty()) {
      networkingModel = make_shared<string>(boost::any_cast<string>(m["NetworkingModel"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeEpnBandwitdhByInternetChargeTypeRequest() = default;
};
class DescribeEpnBandwitdhByInternetChargeTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> bandwidthValue{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> timeStamp{};

  DescribeEpnBandwitdhByInternetChargeTypeResponseBody() {}

  explicit DescribeEpnBandwitdhByInternetChargeTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthValue) {
      res["BandwidthValue"] = boost::any(*bandwidthValue);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthValue") != m.end() && !m["BandwidthValue"].empty()) {
      bandwidthValue = make_shared<long>(boost::any_cast<long>(m["BandwidthValue"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeEpnBandwitdhByInternetChargeTypeResponseBody() = default;
};
class DescribeEpnBandwitdhByInternetChargeTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeEpnBandwitdhByInternetChargeTypeResponseBody> body{};

  DescribeEpnBandwitdhByInternetChargeTypeResponse() {}

  explicit DescribeEpnBandwitdhByInternetChargeTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEpnBandwitdhByInternetChargeTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEpnBandwitdhByInternetChargeTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEpnBandwitdhByInternetChargeTypeResponse() = default;
};
class DescribeEpnInstanceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};

  DescribeEpnInstanceAttributeRequest() {}

  explicit DescribeEpnInstanceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
  }


  virtual ~DescribeEpnInstanceAttributeRequest() = default;
};
class DescribeEpnInstanceAttributeResponseBodyConfVersions : public Darabonba::Model {
public:
  shared_ptr<string> confVersion{};
  shared_ptr<string> ensRegionId{};

  DescribeEpnInstanceAttributeResponseBodyConfVersions() {}

  explicit DescribeEpnInstanceAttributeResponseBodyConfVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confVersion) {
      res["ConfVersion"] = boost::any(*confVersion);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfVersion") != m.end() && !m["ConfVersion"].empty()) {
      confVersion = make_shared<string>(boost::any_cast<string>(m["ConfVersion"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
  }


  virtual ~DescribeEpnInstanceAttributeResponseBodyConfVersions() = default;
};
class DescribeEpnInstanceAttributeResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> isp{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> publicIpAddress{};
  shared_ptr<string> status{};

  DescribeEpnInstanceAttributeResponseBodyInstances() {}

  explicit DescribeEpnInstanceAttributeResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (publicIpAddress) {
      res["PublicIpAddress"] = boost::any(*publicIpAddress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("PublicIpAddress") != m.end() && !m["PublicIpAddress"].empty()) {
      publicIpAddress = make_shared<string>(boost::any_cast<string>(m["PublicIpAddress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeEpnInstanceAttributeResponseBodyInstances() = default;
};
class DescribeEpnInstanceAttributeResponseBodyVSwitches : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vSwitchName{};

  DescribeEpnInstanceAttributeResponseBodyVSwitches() {}

  explicit DescribeEpnInstanceAttributeResponseBodyVSwitches(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
  }


  virtual ~DescribeEpnInstanceAttributeResponseBodyVSwitches() = default;
};
class DescribeEpnInstanceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEpnInstanceAttributeResponseBodyConfVersions>> confVersions{};
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> EPNInstanceName{};
  shared_ptr<vector<DescribeEpnInstanceAttributeResponseBodyInstances>> instances{};
  shared_ptr<string> networkingModel{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeEpnInstanceAttributeResponseBodyVSwitches>> vSwitches{};

  DescribeEpnInstanceAttributeResponseBody() {}

  explicit DescribeEpnInstanceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confVersions) {
      vector<boost::any> temp1;
      for(auto item1:*confVersions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfVersions"] = boost::any(temp1);
    }
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (EPNInstanceName) {
      res["EPNInstanceName"] = boost::any(*EPNInstanceName);
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (networkingModel) {
      res["NetworkingModel"] = boost::any(*networkingModel);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vSwitches) {
      vector<boost::any> temp1;
      for(auto item1:*vSwitches){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VSwitches"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfVersions") != m.end() && !m["ConfVersions"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfVersions"].type()) {
        vector<DescribeEpnInstanceAttributeResponseBodyConfVersions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfVersions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEpnInstanceAttributeResponseBodyConfVersions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        confVersions = make_shared<vector<DescribeEpnInstanceAttributeResponseBodyConfVersions>>(expect1);
      }
    }
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("EPNInstanceName") != m.end() && !m["EPNInstanceName"].empty()) {
      EPNInstanceName = make_shared<string>(boost::any_cast<string>(m["EPNInstanceName"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<DescribeEpnInstanceAttributeResponseBodyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEpnInstanceAttributeResponseBodyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<DescribeEpnInstanceAttributeResponseBodyInstances>>(expect1);
      }
    }
    if (m.find("NetworkingModel") != m.end() && !m["NetworkingModel"].empty()) {
      networkingModel = make_shared<string>(boost::any_cast<string>(m["NetworkingModel"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VSwitches") != m.end() && !m["VSwitches"].empty()) {
      if (typeid(vector<boost::any>) == m["VSwitches"].type()) {
        vector<DescribeEpnInstanceAttributeResponseBodyVSwitches> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VSwitches"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEpnInstanceAttributeResponseBodyVSwitches model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vSwitches = make_shared<vector<DescribeEpnInstanceAttributeResponseBodyVSwitches>>(expect1);
      }
    }
  }


  virtual ~DescribeEpnInstanceAttributeResponseBody() = default;
};
class DescribeEpnInstanceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeEpnInstanceAttributeResponseBody> body{};

  DescribeEpnInstanceAttributeResponse() {}

  explicit DescribeEpnInstanceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEpnInstanceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEpnInstanceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEpnInstanceAttributeResponse() = default;
};
class DescribeEpnInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> EPNInstanceName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeEpnInstancesRequest() {}

  explicit DescribeEpnInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (EPNInstanceName) {
      res["EPNInstanceName"] = boost::any(*EPNInstanceName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("EPNInstanceName") != m.end() && !m["EPNInstanceName"].empty()) {
      EPNInstanceName = make_shared<string>(boost::any_cast<string>(m["EPNInstanceName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeEpnInstancesRequest() = default;
};
class DescribeEpnInstancesResponseBodyEPNInstancesEPNInstance : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> EPNInstanceName{};
  shared_ptr<string> EPNInstanceType{};
  shared_ptr<string> endTime{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> networkingModel{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  DescribeEpnInstancesResponseBodyEPNInstancesEPNInstance() {}

  explicit DescribeEpnInstancesResponseBodyEPNInstancesEPNInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (EPNInstanceName) {
      res["EPNInstanceName"] = boost::any(*EPNInstanceName);
    }
    if (EPNInstanceType) {
      res["EPNInstanceType"] = boost::any(*EPNInstanceType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (networkingModel) {
      res["NetworkingModel"] = boost::any(*networkingModel);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("EPNInstanceName") != m.end() && !m["EPNInstanceName"].empty()) {
      EPNInstanceName = make_shared<string>(boost::any_cast<string>(m["EPNInstanceName"]));
    }
    if (m.find("EPNInstanceType") != m.end() && !m["EPNInstanceType"].empty()) {
      EPNInstanceType = make_shared<string>(boost::any_cast<string>(m["EPNInstanceType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("NetworkingModel") != m.end() && !m["NetworkingModel"].empty()) {
      networkingModel = make_shared<string>(boost::any_cast<string>(m["NetworkingModel"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeEpnInstancesResponseBodyEPNInstancesEPNInstance() = default;
};
class DescribeEpnInstancesResponseBodyEPNInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEpnInstancesResponseBodyEPNInstancesEPNInstance>> EPNInstance{};

  DescribeEpnInstancesResponseBodyEPNInstances() {}

  explicit DescribeEpnInstancesResponseBodyEPNInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstance) {
      vector<boost::any> temp1;
      for(auto item1:*EPNInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EPNInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstance") != m.end() && !m["EPNInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["EPNInstance"].type()) {
        vector<DescribeEpnInstancesResponseBodyEPNInstancesEPNInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EPNInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEpnInstancesResponseBodyEPNInstancesEPNInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        EPNInstance = make_shared<vector<DescribeEpnInstancesResponseBodyEPNInstancesEPNInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeEpnInstancesResponseBodyEPNInstances() = default;
};
class DescribeEpnInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeEpnInstancesResponseBodyEPNInstances> EPNInstances{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeEpnInstancesResponseBody() {}

  explicit DescribeEpnInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstances) {
      res["EPNInstances"] = EPNInstances ? boost::any(EPNInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstances") != m.end() && !m["EPNInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["EPNInstances"].type()) {
        DescribeEpnInstancesResponseBodyEPNInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EPNInstances"]));
        EPNInstances = make_shared<DescribeEpnInstancesResponseBodyEPNInstances>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeEpnInstancesResponseBody() = default;
};
class DescribeEpnInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeEpnInstancesResponseBody> body{};

  DescribeEpnInstancesResponse() {}

  explicit DescribeEpnInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEpnInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEpnInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEpnInstancesResponse() = default;
};
class DescribeEpnMeasurementDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<string> startDate{};
  shared_ptr<string> version{};

  DescribeEpnMeasurementDataRequest() {}

  explicit DescribeEpnMeasurementDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeEpnMeasurementDataRequest() = default;
};
class DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData : public Darabonba::Model {
public:
  shared_ptr<string> costCode{};
  shared_ptr<string> costName{};
  shared_ptr<string> costType{};
  shared_ptr<long> costVal{};
  shared_ptr<string> ispLine{};

  DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData() {}

  explicit DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costCode) {
      res["CostCode"] = boost::any(*costCode);
    }
    if (costName) {
      res["CostName"] = boost::any(*costName);
    }
    if (costType) {
      res["CostType"] = boost::any(*costType);
    }
    if (costVal) {
      res["CostVal"] = boost::any(*costVal);
    }
    if (ispLine) {
      res["IspLine"] = boost::any(*ispLine);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CostCode") != m.end() && !m["CostCode"].empty()) {
      costCode = make_shared<string>(boost::any_cast<string>(m["CostCode"]));
    }
    if (m.find("CostName") != m.end() && !m["CostName"].empty()) {
      costName = make_shared<string>(boost::any_cast<string>(m["CostName"]));
    }
    if (m.find("CostType") != m.end() && !m["CostType"].empty()) {
      costType = make_shared<string>(boost::any_cast<string>(m["CostType"]));
    }
    if (m.find("CostVal") != m.end() && !m["CostVal"].empty()) {
      costVal = make_shared<long>(boost::any_cast<long>(m["CostVal"]));
    }
    if (m.find("IspLine") != m.end() && !m["IspLine"].empty()) {
      ispLine = make_shared<string>(boost::any_cast<string>(m["IspLine"]));
    }
  }


  virtual ~DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData() = default;
};
class DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData>> bandWidthFeeData{};

  DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas() {}

  explicit DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidthFeeData) {
      vector<boost::any> temp1;
      for(auto item1:*bandWidthFeeData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BandWidthFeeData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidthFeeData") != m.end() && !m["BandWidthFeeData"].empty()) {
      if (typeid(vector<boost::any>) == m["BandWidthFeeData"].type()) {
        vector<DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BandWidthFeeData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bandWidthFeeData = make_shared<vector<DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData>>(expect1);
      }
    }
  }


  virtual ~DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas() = default;
};
class DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementData : public Darabonba::Model {
public:
  shared_ptr<DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas> bandWidthFeeDatas{};
  shared_ptr<string> chargeModel{};
  shared_ptr<string> costCycle{};
  shared_ptr<string> costEndTime{};
  shared_ptr<string> costStartTime{};

  DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementData() {}

  explicit DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidthFeeDatas) {
      res["BandWidthFeeDatas"] = bandWidthFeeDatas ? boost::any(bandWidthFeeDatas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (chargeModel) {
      res["ChargeModel"] = boost::any(*chargeModel);
    }
    if (costCycle) {
      res["CostCycle"] = boost::any(*costCycle);
    }
    if (costEndTime) {
      res["CostEndTime"] = boost::any(*costEndTime);
    }
    if (costStartTime) {
      res["CostStartTime"] = boost::any(*costStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidthFeeDatas") != m.end() && !m["BandWidthFeeDatas"].empty()) {
      if (typeid(map<string, boost::any>) == m["BandWidthFeeDatas"].type()) {
        DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BandWidthFeeDatas"]));
        bandWidthFeeDatas = make_shared<DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas>(model1);
      }
    }
    if (m.find("ChargeModel") != m.end() && !m["ChargeModel"].empty()) {
      chargeModel = make_shared<string>(boost::any_cast<string>(m["ChargeModel"]));
    }
    if (m.find("CostCycle") != m.end() && !m["CostCycle"].empty()) {
      costCycle = make_shared<string>(boost::any_cast<string>(m["CostCycle"]));
    }
    if (m.find("CostEndTime") != m.end() && !m["CostEndTime"].empty()) {
      costEndTime = make_shared<string>(boost::any_cast<string>(m["CostEndTime"]));
    }
    if (m.find("CostStartTime") != m.end() && !m["CostStartTime"].empty()) {
      costStartTime = make_shared<string>(boost::any_cast<string>(m["CostStartTime"]));
    }
  }


  virtual ~DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementData() = default;
};
class DescribeEpnMeasurementDataResponseBodyMeasurementDatas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementData>> measurementData{};

  DescribeEpnMeasurementDataResponseBodyMeasurementDatas() {}

  explicit DescribeEpnMeasurementDataResponseBodyMeasurementDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (measurementData) {
      vector<boost::any> temp1;
      for(auto item1:*measurementData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MeasurementData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MeasurementData") != m.end() && !m["MeasurementData"].empty()) {
      if (typeid(vector<boost::any>) == m["MeasurementData"].type()) {
        vector<DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MeasurementData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        measurementData = make_shared<vector<DescribeEpnMeasurementDataResponseBodyMeasurementDatasMeasurementData>>(expect1);
      }
    }
  }


  virtual ~DescribeEpnMeasurementDataResponseBodyMeasurementDatas() = default;
};
class DescribeEpnMeasurementDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeEpnMeasurementDataResponseBodyMeasurementDatas> measurementDatas{};
  shared_ptr<string> requestId{};

  DescribeEpnMeasurementDataResponseBody() {}

  explicit DescribeEpnMeasurementDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (measurementDatas) {
      res["MeasurementDatas"] = measurementDatas ? boost::any(measurementDatas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MeasurementDatas") != m.end() && !m["MeasurementDatas"].empty()) {
      if (typeid(map<string, boost::any>) == m["MeasurementDatas"].type()) {
        DescribeEpnMeasurementDataResponseBodyMeasurementDatas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MeasurementDatas"]));
        measurementDatas = make_shared<DescribeEpnMeasurementDataResponseBodyMeasurementDatas>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEpnMeasurementDataResponseBody() = default;
};
class DescribeEpnMeasurementDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeEpnMeasurementDataResponseBody> body{};

  DescribeEpnMeasurementDataResponse() {}

  explicit DescribeEpnMeasurementDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEpnMeasurementDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEpnMeasurementDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEpnMeasurementDataResponse() = default;
};
class DescribeExportImageInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeExportImageInfoRequest() {}

  explicit DescribeExportImageInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeExportImageInfoRequest() = default;
};
class DescribeExportImageInfoResponseBodyImagesImage : public Darabonba::Model {
public:
  shared_ptr<string> architecture{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> exportedImageURL{};
  shared_ptr<string> imageExportStatus{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> imageOwnerAlias{};
  shared_ptr<string> platform{};

  DescribeExportImageInfoResponseBodyImagesImage() {}

  explicit DescribeExportImageInfoResponseBodyImagesImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (exportedImageURL) {
      res["ExportedImageURL"] = boost::any(*exportedImageURL);
    }
    if (imageExportStatus) {
      res["ImageExportStatus"] = boost::any(*imageExportStatus);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (imageOwnerAlias) {
      res["ImageOwnerAlias"] = boost::any(*imageOwnerAlias);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("ExportedImageURL") != m.end() && !m["ExportedImageURL"].empty()) {
      exportedImageURL = make_shared<string>(boost::any_cast<string>(m["ExportedImageURL"]));
    }
    if (m.find("ImageExportStatus") != m.end() && !m["ImageExportStatus"].empty()) {
      imageExportStatus = make_shared<string>(boost::any_cast<string>(m["ImageExportStatus"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("ImageOwnerAlias") != m.end() && !m["ImageOwnerAlias"].empty()) {
      imageOwnerAlias = make_shared<string>(boost::any_cast<string>(m["ImageOwnerAlias"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
  }


  virtual ~DescribeExportImageInfoResponseBodyImagesImage() = default;
};
class DescribeExportImageInfoResponseBodyImages : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeExportImageInfoResponseBodyImagesImage>> image{};

  DescribeExportImageInfoResponseBodyImages() {}

  explicit DescribeExportImageInfoResponseBodyImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      vector<boost::any> temp1;
      for(auto item1:*image){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Image"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      if (typeid(vector<boost::any>) == m["Image"].type()) {
        vector<DescribeExportImageInfoResponseBodyImagesImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Image"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExportImageInfoResponseBodyImagesImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        image = make_shared<vector<DescribeExportImageInfoResponseBodyImagesImage>>(expect1);
      }
    }
  }


  virtual ~DescribeExportImageInfoResponseBodyImages() = default;
};
class DescribeExportImageInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeExportImageInfoResponseBodyImages> images{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeExportImageInfoResponseBody() {}

  explicit DescribeExportImageInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (images) {
      res["Images"] = images ? boost::any(images->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(map<string, boost::any>) == m["Images"].type()) {
        DescribeExportImageInfoResponseBodyImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Images"]));
        images = make_shared<DescribeExportImageInfoResponseBodyImages>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeExportImageInfoResponseBody() = default;
};
class DescribeExportImageInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeExportImageInfoResponseBody> body{};

  DescribeExportImageInfoResponse() {}

  explicit DescribeExportImageInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExportImageInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExportImageInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExportImageInfoResponse() = default;
};
class DescribeExportImageStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> version{};

  DescribeExportImageStatusRequest() {}

  explicit DescribeExportImageStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeExportImageStatusRequest() = default;
};
class DescribeExportImageStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> imageExportStatus{};
  shared_ptr<string> requestId{};

  DescribeExportImageStatusResponseBody() {}

  explicit DescribeExportImageStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageExportStatus) {
      res["ImageExportStatus"] = boost::any(*imageExportStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageExportStatus") != m.end() && !m["ImageExportStatus"].empty()) {
      imageExportStatus = make_shared<string>(boost::any_cast<string>(m["ImageExportStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeExportImageStatusResponseBody() = default;
};
class DescribeExportImageStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeExportImageStatusResponseBody> body{};

  DescribeExportImageStatusResponse() {}

  explicit DescribeExportImageStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExportImageStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExportImageStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExportImageStatusResponse() = default;
};
class DescribeImageInfosRequest : public Darabonba::Model {
public:
  shared_ptr<string> osType{};
  shared_ptr<string> version{};

  DescribeImageInfosRequest() {}

  explicit DescribeImageInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeImageInfosRequest() = default;
};
class DescribeImageInfosResponseBodyImagesImage : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageSize{};
  shared_ptr<string> imageVersion{};
  shared_ptr<string> OSName{};
  shared_ptr<string> OSType{};

  DescribeImageInfosResponseBodyImagesImage() {}

  explicit DescribeImageInfosResponseBodyImagesImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageSize) {
      res["ImageSize"] = boost::any(*imageSize);
    }
    if (imageVersion) {
      res["ImageVersion"] = boost::any(*imageVersion);
    }
    if (OSName) {
      res["OSName"] = boost::any(*OSName);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageSize") != m.end() && !m["ImageSize"].empty()) {
      imageSize = make_shared<string>(boost::any_cast<string>(m["ImageSize"]));
    }
    if (m.find("ImageVersion") != m.end() && !m["ImageVersion"].empty()) {
      imageVersion = make_shared<string>(boost::any_cast<string>(m["ImageVersion"]));
    }
    if (m.find("OSName") != m.end() && !m["OSName"].empty()) {
      OSName = make_shared<string>(boost::any_cast<string>(m["OSName"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
  }


  virtual ~DescribeImageInfosResponseBodyImagesImage() = default;
};
class DescribeImageInfosResponseBodyImages : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageInfosResponseBodyImagesImage>> image{};

  DescribeImageInfosResponseBodyImages() {}

  explicit DescribeImageInfosResponseBodyImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      vector<boost::any> temp1;
      for(auto item1:*image){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Image"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      if (typeid(vector<boost::any>) == m["Image"].type()) {
        vector<DescribeImageInfosResponseBodyImagesImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Image"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageInfosResponseBodyImagesImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        image = make_shared<vector<DescribeImageInfosResponseBodyImagesImage>>(expect1);
      }
    }
  }


  virtual ~DescribeImageInfosResponseBodyImages() = default;
};
class DescribeImageInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeImageInfosResponseBodyImages> images{};
  shared_ptr<string> requestId{};

  DescribeImageInfosResponseBody() {}

  explicit DescribeImageInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (images) {
      res["Images"] = images ? boost::any(images->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(map<string, boost::any>) == m["Images"].type()) {
        DescribeImageInfosResponseBodyImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Images"]));
        images = make_shared<DescribeImageInfosResponseBodyImages>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeImageInfosResponseBody() = default;
};
class DescribeImageInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeImageInfosResponseBody> body{};

  DescribeImageInfosResponse() {}

  explicit DescribeImageInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageInfosResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageInfosResponse() = default;
};
class DescribeImageSharePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<long> aliyunId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};

  DescribeImageSharePermissionRequest() {}

  explicit DescribeImageSharePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunId) {
      res["AliyunId"] = boost::any(*aliyunId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunId") != m.end() && !m["AliyunId"].empty()) {
      aliyunId = make_shared<long>(boost::any_cast<long>(m["AliyunId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
  }


  virtual ~DescribeImageSharePermissionRequest() = default;
};
class DescribeImageSharePermissionResponseBodyAccounts : public Darabonba::Model {
public:
  shared_ptr<vector<string>> account{};

  DescribeImageSharePermissionResponseBodyAccounts() {}

  explicit DescribeImageSharePermissionResponseBodyAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Account"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Account"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      account = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeImageSharePermissionResponseBodyAccounts() = default;
};
class DescribeImageSharePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeImageSharePermissionResponseBodyAccounts> accounts{};
  shared_ptr<string> imageId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeImageSharePermissionResponseBody() {}

  explicit DescribeImageSharePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accounts) {
      res["Accounts"] = accounts ? boost::any(accounts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Accounts") != m.end() && !m["Accounts"].empty()) {
      if (typeid(map<string, boost::any>) == m["Accounts"].type()) {
        DescribeImageSharePermissionResponseBodyAccounts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Accounts"]));
        accounts = make_shared<DescribeImageSharePermissionResponseBodyAccounts>(model1);
      }
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeImageSharePermissionResponseBody() = default;
};
class DescribeImageSharePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeImageSharePermissionResponseBody> body{};

  DescribeImageSharePermissionResponse() {}

  explicit DescribeImageSharePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageSharePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageSharePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageSharePermissionResponse() = default;
};
class DescribeImagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> status{};
  shared_ptr<string> version{};
  shared_ptr<string> product{};

  DescribeImagesRequest() {}

  explicit DescribeImagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (product) {
      res["product"] = boost::any(*product);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("product") != m.end() && !m["product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["product"]));
    }
  }


  virtual ~DescribeImagesRequest() = default;
};
class DescribeImagesResponseBodyImagesImage : public Darabonba::Model {
public:
  shared_ptr<string> architecture{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> imageOwnerAlias{};
  shared_ptr<string> imageSize{};
  shared_ptr<string> platform{};

  DescribeImagesResponseBodyImagesImage() {}

  explicit DescribeImagesResponseBodyImagesImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (architecture) {
      res["Architecture"] = boost::any(*architecture);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (imageOwnerAlias) {
      res["ImageOwnerAlias"] = boost::any(*imageOwnerAlias);
    }
    if (imageSize) {
      res["ImageSize"] = boost::any(*imageSize);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Architecture") != m.end() && !m["Architecture"].empty()) {
      architecture = make_shared<string>(boost::any_cast<string>(m["Architecture"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("ImageOwnerAlias") != m.end() && !m["ImageOwnerAlias"].empty()) {
      imageOwnerAlias = make_shared<string>(boost::any_cast<string>(m["ImageOwnerAlias"]));
    }
    if (m.find("ImageSize") != m.end() && !m["ImageSize"].empty()) {
      imageSize = make_shared<string>(boost::any_cast<string>(m["ImageSize"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
  }


  virtual ~DescribeImagesResponseBodyImagesImage() = default;
};
class DescribeImagesResponseBodyImages : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImagesResponseBodyImagesImage>> image{};

  DescribeImagesResponseBodyImages() {}

  explicit DescribeImagesResponseBodyImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      vector<boost::any> temp1;
      for(auto item1:*image){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Image"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      if (typeid(vector<boost::any>) == m["Image"].type()) {
        vector<DescribeImagesResponseBodyImagesImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Image"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImagesResponseBodyImagesImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        image = make_shared<vector<DescribeImagesResponseBodyImagesImage>>(expect1);
      }
    }
  }


  virtual ~DescribeImagesResponseBodyImages() = default;
};
class DescribeImagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeImagesResponseBodyImages> images{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeImagesResponseBody() {}

  explicit DescribeImagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (images) {
      res["Images"] = images ? boost::any(images->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(map<string, boost::any>) == m["Images"].type()) {
        DescribeImagesResponseBodyImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Images"]));
        images = make_shared<DescribeImagesResponseBodyImages>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeImagesResponseBody() = default;
};
class DescribeImagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeImagesResponseBody> body{};

  DescribeImagesResponse() {}

  explicit DescribeImagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImagesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImagesResponse() = default;
};
class DescribeInstanceAutoRenewAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIds{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> version{};

  DescribeInstanceAutoRenewAttributeRequest() {}

  explicit DescribeInstanceAutoRenewAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeInstanceAutoRenewAttributeRequest() = default;
};
class DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenewal{};
  shared_ptr<string> duration{};
  shared_ptr<string> instanceId{};

  DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute() {}

  explicit DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenewal) {
      res["AutoRenewal"] = boost::any(*autoRenewal);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenewal") != m.end() && !m["AutoRenewal"].empty()) {
      autoRenewal = make_shared<bool>(boost::any_cast<bool>(m["AutoRenewal"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute() = default;
};
class DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute>> instanceRenewAttribute{};

  DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes() {}

  explicit DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceRenewAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*instanceRenewAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceRenewAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceRenewAttribute") != m.end() && !m["InstanceRenewAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceRenewAttribute"].type()) {
        vector<DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceRenewAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceRenewAttribute = make_shared<vector<DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes() = default;
};
class DescribeInstanceAutoRenewAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes> instanceRenewAttributes{};
  shared_ptr<string> requestId{};

  DescribeInstanceAutoRenewAttributeResponseBody() {}

  explicit DescribeInstanceAutoRenewAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (instanceRenewAttributes) {
      res["InstanceRenewAttributes"] = instanceRenewAttributes ? boost::any(instanceRenewAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("InstanceRenewAttributes") != m.end() && !m["InstanceRenewAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceRenewAttributes"].type()) {
        DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceRenewAttributes"]));
        instanceRenewAttributes = make_shared<DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceAutoRenewAttributeResponseBody() = default;
};
class DescribeInstanceAutoRenewAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceAutoRenewAttributeResponseBody> body{};

  DescribeInstanceAutoRenewAttributeResponse() {}

  explicit DescribeInstanceAutoRenewAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceAutoRenewAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceAutoRenewAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceAutoRenewAttributeResponse() = default;
};
class DescribeInstanceMonitorDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> period{};
  shared_ptr<string> startTime{};
  shared_ptr<string> version{};

  DescribeInstanceMonitorDataRequest() {}

  explicit DescribeInstanceMonitorDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeInstanceMonitorDataRequest() = default;
};
class DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData : public Darabonba::Model {
public:
  shared_ptr<string> CPU{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> memory{};

  DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData() {}

  explicit DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (CPU) {
      res["CPU"] = boost::any(*CPU);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CPU") != m.end() && !m["CPU"].empty()) {
      CPU = make_shared<string>(boost::any_cast<string>(m["CPU"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<string>(boost::any_cast<string>(m["Memory"]));
    }
  }


  virtual ~DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData() = default;
};
class DescribeInstanceMonitorDataResponseBodyMonitorData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData>> instanceMonitorData{};

  DescribeInstanceMonitorDataResponseBodyMonitorData() {}

  explicit DescribeInstanceMonitorDataResponseBodyMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceMonitorData) {
      vector<boost::any> temp1;
      for(auto item1:*instanceMonitorData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceMonitorData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceMonitorData") != m.end() && !m["InstanceMonitorData"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceMonitorData"].type()) {
        vector<DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceMonitorData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceMonitorData = make_shared<vector<DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceMonitorDataResponseBodyMonitorData() = default;
};
class DescribeInstanceMonitorDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeInstanceMonitorDataResponseBodyMonitorData> monitorData{};
  shared_ptr<string> requestId{};

  DescribeInstanceMonitorDataResponseBody() {}

  explicit DescribeInstanceMonitorDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (monitorData) {
      res["MonitorData"] = monitorData ? boost::any(monitorData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("MonitorData") != m.end() && !m["MonitorData"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonitorData"].type()) {
        DescribeInstanceMonitorDataResponseBodyMonitorData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonitorData"]));
        monitorData = make_shared<DescribeInstanceMonitorDataResponseBodyMonitorData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceMonitorDataResponseBody() = default;
};
class DescribeInstanceMonitorDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceMonitorDataResponseBody> body{};

  DescribeInstanceMonitorDataResponse() {}

  explicit DescribeInstanceMonitorDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceMonitorDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceMonitorDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceMonitorDataResponse() = default;
};
class DescribeInstanceSpecRequest : public Darabonba::Model {
public:
  shared_ptr<string> version{};

  DescribeInstanceSpecRequest() {}

  explicit DescribeInstanceSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeInstanceSpecRequest() = default;
};
class DescribeInstanceSpecResponseBodyInstanceSpecsInstanceSpec : public Darabonba::Model {
public:
  shared_ptr<string> core{};
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> memory{};

  DescribeInstanceSpecResponseBodyInstanceSpecsInstanceSpec() {}

  explicit DescribeInstanceSpecResponseBodyInstanceSpecsInstanceSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (core) {
      res["Core"] = boost::any(*core);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Core") != m.end() && !m["Core"].empty()) {
      core = make_shared<string>(boost::any_cast<string>(m["Core"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<string>(boost::any_cast<string>(m["Memory"]));
    }
  }


  virtual ~DescribeInstanceSpecResponseBodyInstanceSpecsInstanceSpec() = default;
};
class DescribeInstanceSpecResponseBodyInstanceSpecs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceSpecResponseBodyInstanceSpecsInstanceSpec>> instanceSpec{};

  DescribeInstanceSpecResponseBodyInstanceSpecs() {}

  explicit DescribeInstanceSpecResponseBodyInstanceSpecs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceSpec) {
      vector<boost::any> temp1;
      for(auto item1:*instanceSpec){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceSpec"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceSpec") != m.end() && !m["InstanceSpec"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceSpec"].type()) {
        vector<DescribeInstanceSpecResponseBodyInstanceSpecsInstanceSpec> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceSpec"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceSpecResponseBodyInstanceSpecsInstanceSpec model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceSpec = make_shared<vector<DescribeInstanceSpecResponseBodyInstanceSpecsInstanceSpec>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceSpecResponseBodyInstanceSpecs() = default;
};
class DescribeInstanceSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> bandwidthLimit{};
  shared_ptr<long> code{};
  shared_ptr<long> dataDiskMaxSize{};
  shared_ptr<long> dataDiskMinSize{};
  shared_ptr<DescribeInstanceSpecResponseBodyInstanceSpecs> instanceSpecs{};
  shared_ptr<string> requestId{};
  shared_ptr<long> systemDiskMaxSize{};

  DescribeInstanceSpecResponseBody() {}

  explicit DescribeInstanceSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthLimit) {
      res["BandwidthLimit"] = boost::any(*bandwidthLimit);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dataDiskMaxSize) {
      res["DataDiskMaxSize"] = boost::any(*dataDiskMaxSize);
    }
    if (dataDiskMinSize) {
      res["DataDiskMinSize"] = boost::any(*dataDiskMinSize);
    }
    if (instanceSpecs) {
      res["InstanceSpecs"] = instanceSpecs ? boost::any(instanceSpecs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (systemDiskMaxSize) {
      res["SystemDiskMaxSize"] = boost::any(*systemDiskMaxSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthLimit") != m.end() && !m["BandwidthLimit"].empty()) {
      bandwidthLimit = make_shared<long>(boost::any_cast<long>(m["BandwidthLimit"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("DataDiskMaxSize") != m.end() && !m["DataDiskMaxSize"].empty()) {
      dataDiskMaxSize = make_shared<long>(boost::any_cast<long>(m["DataDiskMaxSize"]));
    }
    if (m.find("DataDiskMinSize") != m.end() && !m["DataDiskMinSize"].empty()) {
      dataDiskMinSize = make_shared<long>(boost::any_cast<long>(m["DataDiskMinSize"]));
    }
    if (m.find("InstanceSpecs") != m.end() && !m["InstanceSpecs"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceSpecs"].type()) {
        DescribeInstanceSpecResponseBodyInstanceSpecs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceSpecs"]));
        instanceSpecs = make_shared<DescribeInstanceSpecResponseBodyInstanceSpecs>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SystemDiskMaxSize") != m.end() && !m["SystemDiskMaxSize"].empty()) {
      systemDiskMaxSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskMaxSize"]));
    }
  }


  virtual ~DescribeInstanceSpecResponseBody() = default;
};
class DescribeInstanceSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceSpecResponseBody> body{};

  DescribeInstanceSpecResponse() {}

  explicit DescribeInstanceSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceSpecResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceSpecResponse() = default;
};
class DescribeInstanceTypesRequest : public Darabonba::Model {
public:
  shared_ptr<string> version{};

  DescribeInstanceTypesRequest() {}

  explicit DescribeInstanceTypesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeInstanceTypesRequest() = default;
};
class DescribeInstanceTypesResponseBodyInstanceTypesInstanceType : public Darabonba::Model {
public:
  shared_ptr<long> cpuCoreCount{};
  shared_ptr<string> instanceTypeId{};
  shared_ptr<string> instanceTypeName{};
  shared_ptr<long> memorySize{};

  DescribeInstanceTypesResponseBodyInstanceTypesInstanceType() {}

  explicit DescribeInstanceTypesResponseBodyInstanceTypesInstanceType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuCoreCount) {
      res["CpuCoreCount"] = boost::any(*cpuCoreCount);
    }
    if (instanceTypeId) {
      res["InstanceTypeId"] = boost::any(*instanceTypeId);
    }
    if (instanceTypeName) {
      res["InstanceTypeName"] = boost::any(*instanceTypeName);
    }
    if (memorySize) {
      res["MemorySize"] = boost::any(*memorySize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CpuCoreCount") != m.end() && !m["CpuCoreCount"].empty()) {
      cpuCoreCount = make_shared<long>(boost::any_cast<long>(m["CpuCoreCount"]));
    }
    if (m.find("InstanceTypeId") != m.end() && !m["InstanceTypeId"].empty()) {
      instanceTypeId = make_shared<string>(boost::any_cast<string>(m["InstanceTypeId"]));
    }
    if (m.find("InstanceTypeName") != m.end() && !m["InstanceTypeName"].empty()) {
      instanceTypeName = make_shared<string>(boost::any_cast<string>(m["InstanceTypeName"]));
    }
    if (m.find("MemorySize") != m.end() && !m["MemorySize"].empty()) {
      memorySize = make_shared<long>(boost::any_cast<long>(m["MemorySize"]));
    }
  }


  virtual ~DescribeInstanceTypesResponseBodyInstanceTypesInstanceType() = default;
};
class DescribeInstanceTypesResponseBodyInstanceTypes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceTypesResponseBodyInstanceTypesInstanceType>> instanceType{};

  DescribeInstanceTypesResponseBodyInstanceTypes() {}

  explicit DescribeInstanceTypesResponseBodyInstanceTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      vector<boost::any> temp1;
      for(auto item1:*instanceType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceType"].type()) {
        vector<DescribeInstanceTypesResponseBodyInstanceTypesInstanceType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceTypesResponseBodyInstanceTypesInstanceType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceType = make_shared<vector<DescribeInstanceTypesResponseBodyInstanceTypesInstanceType>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceTypesResponseBodyInstanceTypes() = default;
};
class DescribeInstanceTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeInstanceTypesResponseBodyInstanceTypes> instanceTypes{};
  shared_ptr<string> requestId{};

  DescribeInstanceTypesResponseBody() {}

  explicit DescribeInstanceTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = instanceTypes ? boost::any(instanceTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTypes"].type()) {
        DescribeInstanceTypesResponseBodyInstanceTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTypes"]));
        instanceTypes = make_shared<DescribeInstanceTypesResponseBodyInstanceTypes>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceTypesResponseBody() = default;
};
class DescribeInstanceTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceTypesResponseBody> body{};

  DescribeInstanceTypesResponse() {}

  explicit DescribeInstanceTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceTypesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceTypesResponse() = default;
};
class DescribeInstanceVncUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DescribeInstanceVncUrlRequest() {}

  explicit DescribeInstanceVncUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeInstanceVncUrlRequest() = default;
};
class DescribeInstanceVncUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vncUrl{};

  DescribeInstanceVncUrlResponseBody() {}

  explicit DescribeInstanceVncUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vncUrl) {
      res["VncUrl"] = boost::any(*vncUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VncUrl") != m.end() && !m["VncUrl"].empty()) {
      vncUrl = make_shared<string>(boost::any_cast<string>(m["VncUrl"]));
    }
  }


  virtual ~DescribeInstanceVncUrlResponseBody() = default;
};
class DescribeInstanceVncUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceVncUrlResponseBody> body{};

  DescribeInstanceVncUrlResponse() {}

  explicit DescribeInstanceVncUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceVncUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceVncUrlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceVncUrlResponse() = default;
};
class DescribeInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> ensRegionIds{};
  shared_ptr<string> ensServiceId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceResourceType{};
  shared_ptr<string> networkId{};
  shared_ptr<string> orderByParams{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> searchKey{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> status{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> version{};

  DescribeInstancesRequest() {}

  explicit DescribeInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (ensRegionIds) {
      res["EnsRegionIds"] = boost::any(*ensRegionIds);
    }
    if (ensServiceId) {
      res["EnsServiceId"] = boost::any(*ensServiceId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceResourceType) {
      res["InstanceResourceType"] = boost::any(*instanceResourceType);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (orderByParams) {
      res["OrderByParams"] = boost::any(*orderByParams);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("EnsRegionIds") != m.end() && !m["EnsRegionIds"].empty()) {
      ensRegionIds = make_shared<string>(boost::any_cast<string>(m["EnsRegionIds"]));
    }
    if (m.find("EnsServiceId") != m.end() && !m["EnsServiceId"].empty()) {
      ensServiceId = make_shared<string>(boost::any_cast<string>(m["EnsServiceId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceResourceType") != m.end() && !m["InstanceResourceType"].empty()) {
      instanceResourceType = make_shared<string>(boost::any_cast<string>(m["InstanceResourceType"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("OrderByParams") != m.end() && !m["OrderByParams"].empty()) {
      orderByParams = make_shared<string>(boost::any_cast<string>(m["OrderByParams"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeInstancesRequest() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceDataDiskDataDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> diskId{};
  shared_ptr<string> diskName{};
  shared_ptr<long> size{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> diskType{};
  shared_ptr<string> name{};
  shared_ptr<long> storage{};
  shared_ptr<string> uuid{};

  DescribeInstancesResponseBodyInstancesInstanceDataDiskDataDisk() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceDataDiskDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (deviceType) {
      res["device_type"] = boost::any(*deviceType);
    }
    if (diskType) {
      res["disk_type"] = boost::any(*diskType);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (storage) {
      res["storage"] = boost::any(*storage);
    }
    if (uuid) {
      res["uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("device_type") != m.end() && !m["device_type"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["device_type"]));
    }
    if (m.find("disk_type") != m.end() && !m["disk_type"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["disk_type"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("storage") != m.end() && !m["storage"].empty()) {
      storage = make_shared<long>(boost::any_cast<long>(m["storage"]));
    }
    if (m.find("uuid") != m.end() && !m["uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["uuid"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceDataDiskDataDisk() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceDataDisk : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstanceDataDiskDataDisk>> dataDisk{};

  DescribeInstancesResponseBodyInstancesInstanceDataDisk() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstanceDataDiskDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstanceDataDiskDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<DescribeInstancesResponseBodyInstancesInstanceDataDiskDataDisk>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceDataDisk() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ipAddress{};

  DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipAddress = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceNetworkAttributesPrivateIpAddress : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ipAddress{};

  DescribeInstancesResponseBodyInstancesInstanceNetworkAttributesPrivateIpAddress() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceNetworkAttributesPrivateIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipAddress = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceNetworkAttributesPrivateIpAddress() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceNetworkAttributes : public Darabonba::Model {
public:
  shared_ptr<string> networkId{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceNetworkAttributesPrivateIpAddress> privateIpAddress{};
  shared_ptr<string> vSwitchId{};

  DescribeInstancesResponseBodyInstancesInstanceNetworkAttributes() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceNetworkAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = privateIpAddress ? boost::any(privateIpAddress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivateIpAddress"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceNetworkAttributesPrivateIpAddress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivateIpAddress"]));
        privateIpAddress = make_shared<DescribeInstancesResponseBodyInstancesInstanceNetworkAttributesPrivateIpAddress>(model1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceNetworkAttributes() = default;
};
class DescribeInstancesResponseBodyInstancesInstancePrivateIpAddressesPrivateIpAddress : public Darabonba::Model {
public:
  shared_ptr<string> gateWay{};
  shared_ptr<string> ip{};
  shared_ptr<string> isp{};

  DescribeInstancesResponseBodyInstancesInstancePrivateIpAddressesPrivateIpAddress() {}

  explicit DescribeInstancesResponseBodyInstancesInstancePrivateIpAddressesPrivateIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gateWay) {
      res["GateWay"] = boost::any(*gateWay);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GateWay") != m.end() && !m["GateWay"].empty()) {
      gateWay = make_shared<string>(boost::any_cast<string>(m["GateWay"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstancePrivateIpAddressesPrivateIpAddress() = default;
};
class DescribeInstancesResponseBodyInstancesInstancePrivateIpAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstancePrivateIpAddressesPrivateIpAddress>> privateIpAddress{};

  DescribeInstancesResponseBodyInstancesInstancePrivateIpAddresses() {}

  explicit DescribeInstancesResponseBodyInstancesInstancePrivateIpAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateIpAddress) {
      vector<boost::any> temp1;
      for(auto item1:*privateIpAddress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrivateIpAddress"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      if (typeid(vector<boost::any>) == m["PrivateIpAddress"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstancePrivateIpAddressesPrivateIpAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrivateIpAddress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstancePrivateIpAddressesPrivateIpAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        privateIpAddress = make_shared<vector<DescribeInstancesResponseBodyInstancesInstancePrivateIpAddressesPrivateIpAddress>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstancePrivateIpAddresses() = default;
};
class DescribeInstancesResponseBodyInstancesInstancePublicIpAddress : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ipAddress{};

  DescribeInstancesResponseBodyInstancesInstancePublicIpAddress() {}

  explicit DescribeInstancesResponseBodyInstancesInstancePublicIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipAddress = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstancePublicIpAddress() = default;
};
class DescribeInstancesResponseBodyInstancesInstancePublicIpAddressesPublicIpAddress : public Darabonba::Model {
public:
  shared_ptr<string> gateWay{};
  shared_ptr<string> ip{};
  shared_ptr<string> isp{};

  DescribeInstancesResponseBodyInstancesInstancePublicIpAddressesPublicIpAddress() {}

  explicit DescribeInstancesResponseBodyInstancesInstancePublicIpAddressesPublicIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gateWay) {
      res["GateWay"] = boost::any(*gateWay);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GateWay") != m.end() && !m["GateWay"].empty()) {
      gateWay = make_shared<string>(boost::any_cast<string>(m["GateWay"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstancePublicIpAddressesPublicIpAddress() = default;
};
class DescribeInstancesResponseBodyInstancesInstancePublicIpAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstancePublicIpAddressesPublicIpAddress>> publicIpAddress{};

  DescribeInstancesResponseBodyInstancesInstancePublicIpAddresses() {}

  explicit DescribeInstancesResponseBodyInstancesInstancePublicIpAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (publicIpAddress) {
      vector<boost::any> temp1;
      for(auto item1:*publicIpAddress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PublicIpAddress"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PublicIpAddress") != m.end() && !m["PublicIpAddress"].empty()) {
      if (typeid(vector<boost::any>) == m["PublicIpAddress"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstancePublicIpAddressesPublicIpAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PublicIpAddress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstancePublicIpAddressesPublicIpAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        publicIpAddress = make_shared<vector<DescribeInstancesResponseBodyInstancesInstancePublicIpAddressesPublicIpAddress>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstancePublicIpAddresses() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> securityGroupId{};

  DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceSystemDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> diskId{};
  shared_ptr<string> diskName{};
  shared_ptr<long> size{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> diskType{};
  shared_ptr<string> name{};
  shared_ptr<long> storage{};
  shared_ptr<string> uuid{};

  DescribeInstancesResponseBodyInstancesInstanceSystemDisk() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (deviceType) {
      res["device_type"] = boost::any(*deviceType);
    }
    if (diskType) {
      res["disk_type"] = boost::any(*diskType);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (storage) {
      res["storage"] = boost::any(*storage);
    }
    if (uuid) {
      res["uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("device_type") != m.end() && !m["device_type"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["device_type"]));
    }
    if (m.find("disk_type") != m.end() && !m["disk_type"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["disk_type"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("storage") != m.end() && !m["storage"].empty()) {
      storage = make_shared<long>(boost::any_cast<long>(m["storage"]));
    }
    if (m.find("uuid") != m.end() && !m["uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["uuid"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceSystemDisk() = default;
};
class DescribeInstancesResponseBodyInstancesInstance : public Darabonba::Model {
public:
  shared_ptr<string> cpu{};
  shared_ptr<string> creationTime{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceDataDisk> dataDisk{};
  shared_ptr<long> disk{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> hostName{};
  shared_ptr<string> imageId{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress> innerIpAddress{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceResourceType{};
  shared_ptr<long> internetMaxBandwidthIn{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<long> memory{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceNetworkAttributes> networkAttributes{};
  shared_ptr<string> OSName{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstancePrivateIpAddresses> privateIpAddresses{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstancePublicIpAddress> publicIpAddress{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstancePublicIpAddresses> publicIpAddresses{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds> securityGroupIds{};
  shared_ptr<string> specName{};
  shared_ptr<string> status{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceSystemDisk> systemDisk{};

  DescribeInstancesResponseBodyInstancesInstance() {}

  explicit DescribeInstancesResponseBodyInstancesInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (dataDisk) {
      res["DataDisk"] = dataDisk ? boost::any(dataDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (disk) {
      res["Disk"] = boost::any(*disk);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (innerIpAddress) {
      res["InnerIpAddress"] = innerIpAddress ? boost::any(innerIpAddress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceResourceType) {
      res["InstanceResourceType"] = boost::any(*instanceResourceType);
    }
    if (internetMaxBandwidthIn) {
      res["InternetMaxBandwidthIn"] = boost::any(*internetMaxBandwidthIn);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (networkAttributes) {
      res["NetworkAttributes"] = networkAttributes ? boost::any(networkAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (OSName) {
      res["OSName"] = boost::any(*OSName);
    }
    if (privateIpAddresses) {
      res["PrivateIpAddresses"] = privateIpAddresses ? boost::any(privateIpAddresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (publicIpAddress) {
      res["PublicIpAddress"] = publicIpAddress ? boost::any(publicIpAddress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (publicIpAddresses) {
      res["PublicIpAddresses"] = publicIpAddresses ? boost::any(publicIpAddresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = securityGroupIds ? boost::any(securityGroupIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<string>(boost::any_cast<string>(m["Cpu"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataDisk"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceDataDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataDisk"]));
        dataDisk = make_shared<DescribeInstancesResponseBodyInstancesInstanceDataDisk>(model1);
      }
    }
    if (m.find("Disk") != m.end() && !m["Disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["Disk"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InnerIpAddress") != m.end() && !m["InnerIpAddress"].empty()) {
      if (typeid(map<string, boost::any>) == m["InnerIpAddress"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InnerIpAddress"]));
        innerIpAddress = make_shared<DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceResourceType") != m.end() && !m["InstanceResourceType"].empty()) {
      instanceResourceType = make_shared<string>(boost::any_cast<string>(m["InstanceResourceType"]));
    }
    if (m.find("InternetMaxBandwidthIn") != m.end() && !m["InternetMaxBandwidthIn"].empty()) {
      internetMaxBandwidthIn = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthIn"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("NetworkAttributes") != m.end() && !m["NetworkAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkAttributes"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceNetworkAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkAttributes"]));
        networkAttributes = make_shared<DescribeInstancesResponseBodyInstancesInstanceNetworkAttributes>(model1);
      }
    }
    if (m.find("OSName") != m.end() && !m["OSName"].empty()) {
      OSName = make_shared<string>(boost::any_cast<string>(m["OSName"]));
    }
    if (m.find("PrivateIpAddresses") != m.end() && !m["PrivateIpAddresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivateIpAddresses"].type()) {
        DescribeInstancesResponseBodyInstancesInstancePrivateIpAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivateIpAddresses"]));
        privateIpAddresses = make_shared<DescribeInstancesResponseBodyInstancesInstancePrivateIpAddresses>(model1);
      }
    }
    if (m.find("PublicIpAddress") != m.end() && !m["PublicIpAddress"].empty()) {
      if (typeid(map<string, boost::any>) == m["PublicIpAddress"].type()) {
        DescribeInstancesResponseBodyInstancesInstancePublicIpAddress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PublicIpAddress"]));
        publicIpAddress = make_shared<DescribeInstancesResponseBodyInstancesInstancePublicIpAddress>(model1);
      }
    }
    if (m.find("PublicIpAddresses") != m.end() && !m["PublicIpAddresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["PublicIpAddresses"].type()) {
        DescribeInstancesResponseBodyInstancesInstancePublicIpAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PublicIpAddresses"]));
        publicIpAddresses = make_shared<DescribeInstancesResponseBodyInstancesInstancePublicIpAddresses>(model1);
      }
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroupIds"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroupIds"]));
        securityGroupIds = make_shared<DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds>(model1);
      }
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<DescribeInstancesResponseBodyInstancesInstanceSystemDisk>(model1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstance() = default;
};
class DescribeInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstance>> instance{};

  DescribeInstancesResponseBodyInstances() {}

  explicit DescribeInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      vector<boost::any> temp1;
      for(auto item1:*instance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(vector<boost::any>) == m["Instance"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instance = make_shared<vector<DescribeInstancesResponseBodyInstancesInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstances() = default;
};
class DescribeInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeInstancesResponseBodyInstances> instances{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeInstancesResponseBody() {}

  explicit DescribeInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (instances) {
      res["Instances"] = instances ? boost::any(instances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instances"].type()) {
        DescribeInstancesResponseBodyInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instances"]));
        instances = make_shared<DescribeInstancesResponseBodyInstances>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeInstancesResponseBody() = default;
};
class DescribeInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstancesResponseBody> body{};

  DescribeInstancesResponse() {}

  explicit DescribeInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstancesResponse() = default;
};
class DescribeKeyPairsRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyPairName{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> version{};

  DescribeKeyPairsRequest() {}

  explicit DescribeKeyPairsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeKeyPairsRequest() = default;
};
class DescribeKeyPairsResponseBodyKeyPairsKeyPair : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> keyPairFingerPrint{};
  shared_ptr<string> keyPairName{};

  DescribeKeyPairsResponseBodyKeyPairsKeyPair() {}

  explicit DescribeKeyPairsResponseBodyKeyPairsKeyPair(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (keyPairFingerPrint) {
      res["KeyPairFingerPrint"] = boost::any(*keyPairFingerPrint);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("KeyPairFingerPrint") != m.end() && !m["KeyPairFingerPrint"].empty()) {
      keyPairFingerPrint = make_shared<string>(boost::any_cast<string>(m["KeyPairFingerPrint"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
  }


  virtual ~DescribeKeyPairsResponseBodyKeyPairsKeyPair() = default;
};
class DescribeKeyPairsResponseBodyKeyPairs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeKeyPairsResponseBodyKeyPairsKeyPair>> keyPair{};

  DescribeKeyPairsResponseBodyKeyPairs() {}

  explicit DescribeKeyPairsResponseBodyKeyPairs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPair) {
      vector<boost::any> temp1;
      for(auto item1:*keyPair){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["KeyPair"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPair") != m.end() && !m["KeyPair"].empty()) {
      if (typeid(vector<boost::any>) == m["KeyPair"].type()) {
        vector<DescribeKeyPairsResponseBodyKeyPairsKeyPair> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["KeyPair"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeKeyPairsResponseBodyKeyPairsKeyPair model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        keyPair = make_shared<vector<DescribeKeyPairsResponseBodyKeyPairsKeyPair>>(expect1);
      }
    }
  }


  virtual ~DescribeKeyPairsResponseBodyKeyPairs() = default;
};
class DescribeKeyPairsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeKeyPairsResponseBodyKeyPairs> keyPairs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeKeyPairsResponseBody() {}

  explicit DescribeKeyPairsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPairs) {
      res["KeyPairs"] = keyPairs ? boost::any(keyPairs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPairs") != m.end() && !m["KeyPairs"].empty()) {
      if (typeid(map<string, boost::any>) == m["KeyPairs"].type()) {
        DescribeKeyPairsResponseBodyKeyPairs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["KeyPairs"]));
        keyPairs = make_shared<DescribeKeyPairsResponseBodyKeyPairs>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeKeyPairsResponseBody() = default;
};
class DescribeKeyPairsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeKeyPairsResponseBody> body{};

  DescribeKeyPairsResponse() {}

  explicit DescribeKeyPairsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeKeyPairsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeKeyPairsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeKeyPairsResponse() = default;
};
class DescribeLoadBalancerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> loadBalancerId{};

  DescribeLoadBalancerAttributeRequest() {}

  explicit DescribeLoadBalancerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~DescribeLoadBalancerAttributeRequest() = default;
};
class DescribeLoadBalancerAttributeResponseBodyBackendServers : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<string> port{};
  shared_ptr<string> serverId{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  DescribeLoadBalancerAttributeResponseBodyBackendServers() {}

  explicit DescribeLoadBalancerAttributeResponseBodyBackendServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DescribeLoadBalancerAttributeResponseBodyBackendServers() = default;
};
class DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocols : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> forwardPort{};
  shared_ptr<string> listenerForward{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> listenerProtocol{};

  DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocols() {}

  explicit DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocols(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (forwardPort) {
      res["ForwardPort"] = boost::any(*forwardPort);
    }
    if (listenerForward) {
      res["ListenerForward"] = boost::any(*listenerForward);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (listenerProtocol) {
      res["ListenerProtocol"] = boost::any(*listenerProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ForwardPort") != m.end() && !m["ForwardPort"].empty()) {
      forwardPort = make_shared<long>(boost::any_cast<long>(m["ForwardPort"]));
    }
    if (m.find("ListenerForward") != m.end() && !m["ListenerForward"].empty()) {
      listenerForward = make_shared<string>(boost::any_cast<string>(m["ListenerForward"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("ListenerProtocol") != m.end() && !m["ListenerProtocol"].empty()) {
      listenerProtocol = make_shared<string>(boost::any_cast<string>(m["ListenerProtocol"]));
    }
  }


  virtual ~DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocols() = default;
};
class DescribeLoadBalancerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> addressIPVersion{};
  shared_ptr<vector<DescribeLoadBalancerAttributeResponseBodyBackendServers>> backendServers{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> createTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<vector<string>> listenerPorts{};
  shared_ptr<vector<DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocols>> listenerPortsAndProtocols{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> loadBalancerName{};
  shared_ptr<string> loadBalancerSpec{};
  shared_ptr<string> loadBalancerStatus{};
  shared_ptr<string> networkId{};
  shared_ptr<string> payType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vSwitchId{};

  DescribeLoadBalancerAttributeResponseBody() {}

  explicit DescribeLoadBalancerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (addressIPVersion) {
      res["AddressIPVersion"] = boost::any(*addressIPVersion);
    }
    if (backendServers) {
      vector<boost::any> temp1;
      for(auto item1:*backendServers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendServers"] = boost::any(temp1);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (listenerPorts) {
      res["ListenerPorts"] = boost::any(*listenerPorts);
    }
    if (listenerPortsAndProtocols) {
      vector<boost::any> temp1;
      for(auto item1:*listenerPortsAndProtocols){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ListenerPortsAndProtocols"] = boost::any(temp1);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (loadBalancerName) {
      res["LoadBalancerName"] = boost::any(*loadBalancerName);
    }
    if (loadBalancerSpec) {
      res["LoadBalancerSpec"] = boost::any(*loadBalancerSpec);
    }
    if (loadBalancerStatus) {
      res["LoadBalancerStatus"] = boost::any(*loadBalancerStatus);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AddressIPVersion") != m.end() && !m["AddressIPVersion"].empty()) {
      addressIPVersion = make_shared<string>(boost::any_cast<string>(m["AddressIPVersion"]));
    }
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendServers"].type()) {
        vector<DescribeLoadBalancerAttributeResponseBodyBackendServers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendServers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLoadBalancerAttributeResponseBodyBackendServers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendServers = make_shared<vector<DescribeLoadBalancerAttributeResponseBodyBackendServers>>(expect1);
      }
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("ListenerPorts") != m.end() && !m["ListenerPorts"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ListenerPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ListenerPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      listenerPorts = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ListenerPortsAndProtocols") != m.end() && !m["ListenerPortsAndProtocols"].empty()) {
      if (typeid(vector<boost::any>) == m["ListenerPortsAndProtocols"].type()) {
        vector<DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocols> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ListenerPortsAndProtocols"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocols model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        listenerPortsAndProtocols = make_shared<vector<DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocols>>(expect1);
      }
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("LoadBalancerName") != m.end() && !m["LoadBalancerName"].empty()) {
      loadBalancerName = make_shared<string>(boost::any_cast<string>(m["LoadBalancerName"]));
    }
    if (m.find("LoadBalancerSpec") != m.end() && !m["LoadBalancerSpec"].empty()) {
      loadBalancerSpec = make_shared<string>(boost::any_cast<string>(m["LoadBalancerSpec"]));
    }
    if (m.find("LoadBalancerStatus") != m.end() && !m["LoadBalancerStatus"].empty()) {
      loadBalancerStatus = make_shared<string>(boost::any_cast<string>(m["LoadBalancerStatus"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeLoadBalancerAttributeResponseBody() = default;
};
class DescribeLoadBalancerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeLoadBalancerAttributeResponseBody> body{};

  DescribeLoadBalancerAttributeResponse() {}

  explicit DescribeLoadBalancerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoadBalancerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoadBalancerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoadBalancerAttributeResponse() = default;
};
class DescribeLoadBalancerHTTPListenerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};

  DescribeLoadBalancerHTTPListenerAttributeRequest() {}

  explicit DescribeLoadBalancerHTTPListenerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~DescribeLoadBalancerHTTPListenerAttributeRequest() = default;
};
class DescribeLoadBalancerHTTPListenerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> description{};
  shared_ptr<long> forwardPort{};
  shared_ptr<string> healthCheck{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckMethod{};
  shared_ptr<long> healthCheckTimeout{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<string> listenerForward{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> requestId{};
  shared_ptr<long> requestTimeout{};
  shared_ptr<string> scheduler{};
  shared_ptr<string> serverCertificateId{};
  shared_ptr<string> status{};
  shared_ptr<long> unhealthyThreshold{};

  DescribeLoadBalancerHTTPListenerAttributeResponseBody() {}

  explicit DescribeLoadBalancerHTTPListenerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (forwardPort) {
      res["ForwardPort"] = boost::any(*forwardPort);
    }
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckMethod) {
      res["HealthCheckMethod"] = boost::any(*healthCheckMethod);
    }
    if (healthCheckTimeout) {
      res["HealthCheckTimeout"] = boost::any(*healthCheckTimeout);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (listenerForward) {
      res["ListenerForward"] = boost::any(*listenerForward);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestTimeout) {
      res["RequestTimeout"] = boost::any(*requestTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (serverCertificateId) {
      res["ServerCertificateId"] = boost::any(*serverCertificateId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ForwardPort") != m.end() && !m["ForwardPort"].empty()) {
      forwardPort = make_shared<long>(boost::any_cast<long>(m["ForwardPort"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckMethod") != m.end() && !m["HealthCheckMethod"].empty()) {
      healthCheckMethod = make_shared<string>(boost::any_cast<string>(m["HealthCheckMethod"]));
    }
    if (m.find("HealthCheckTimeout") != m.end() && !m["HealthCheckTimeout"].empty()) {
      healthCheckTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckTimeout"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("ListenerForward") != m.end() && !m["ListenerForward"].empty()) {
      listenerForward = make_shared<string>(boost::any_cast<string>(m["ListenerForward"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestTimeout") != m.end() && !m["RequestTimeout"].empty()) {
      requestTimeout = make_shared<long>(boost::any_cast<long>(m["RequestTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("ServerCertificateId") != m.end() && !m["ServerCertificateId"].empty()) {
      serverCertificateId = make_shared<string>(boost::any_cast<string>(m["ServerCertificateId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~DescribeLoadBalancerHTTPListenerAttributeResponseBody() = default;
};
class DescribeLoadBalancerHTTPListenerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeLoadBalancerHTTPListenerAttributeResponseBody> body{};

  DescribeLoadBalancerHTTPListenerAttributeResponse() {}

  explicit DescribeLoadBalancerHTTPListenerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoadBalancerHTTPListenerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoadBalancerHTTPListenerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoadBalancerHTTPListenerAttributeResponse() = default;
};
class DescribeLoadBalancerHTTPSListenerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};

  DescribeLoadBalancerHTTPSListenerAttributeRequest() {}

  explicit DescribeLoadBalancerHTTPSListenerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~DescribeLoadBalancerHTTPSListenerAttributeRequest() = default;
};
class DescribeLoadBalancerHTTPSListenerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> description{};
  shared_ptr<long> forwardPort{};
  shared_ptr<string> healthCheck{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckMethod{};
  shared_ptr<long> healthCheckTimeout{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<string> listenerForward{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> requestId{};
  shared_ptr<long> requestTimeout{};
  shared_ptr<string> scheduler{};
  shared_ptr<string> serverCertificateId{};
  shared_ptr<string> status{};
  shared_ptr<long> unhealthyThreshold{};

  DescribeLoadBalancerHTTPSListenerAttributeResponseBody() {}

  explicit DescribeLoadBalancerHTTPSListenerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (forwardPort) {
      res["ForwardPort"] = boost::any(*forwardPort);
    }
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckMethod) {
      res["HealthCheckMethod"] = boost::any(*healthCheckMethod);
    }
    if (healthCheckTimeout) {
      res["HealthCheckTimeout"] = boost::any(*healthCheckTimeout);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (listenerForward) {
      res["ListenerForward"] = boost::any(*listenerForward);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestTimeout) {
      res["RequestTimeout"] = boost::any(*requestTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (serverCertificateId) {
      res["ServerCertificateId"] = boost::any(*serverCertificateId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ForwardPort") != m.end() && !m["ForwardPort"].empty()) {
      forwardPort = make_shared<long>(boost::any_cast<long>(m["ForwardPort"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckMethod") != m.end() && !m["HealthCheckMethod"].empty()) {
      healthCheckMethod = make_shared<string>(boost::any_cast<string>(m["HealthCheckMethod"]));
    }
    if (m.find("HealthCheckTimeout") != m.end() && !m["HealthCheckTimeout"].empty()) {
      healthCheckTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckTimeout"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("ListenerForward") != m.end() && !m["ListenerForward"].empty()) {
      listenerForward = make_shared<string>(boost::any_cast<string>(m["ListenerForward"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestTimeout") != m.end() && !m["RequestTimeout"].empty()) {
      requestTimeout = make_shared<long>(boost::any_cast<long>(m["RequestTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("ServerCertificateId") != m.end() && !m["ServerCertificateId"].empty()) {
      serverCertificateId = make_shared<string>(boost::any_cast<string>(m["ServerCertificateId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~DescribeLoadBalancerHTTPSListenerAttributeResponseBody() = default;
};
class DescribeLoadBalancerHTTPSListenerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeLoadBalancerHTTPSListenerAttributeResponseBody> body{};

  DescribeLoadBalancerHTTPSListenerAttributeResponse() {}

  explicit DescribeLoadBalancerHTTPSListenerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoadBalancerHTTPSListenerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoadBalancerHTTPSListenerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoadBalancerHTTPSListenerAttributeResponse() = default;
};
class DescribeLoadBalancerSpecRequest : public Darabonba::Model {
public:
  shared_ptr<string> loadBalancerSpec{};

  DescribeLoadBalancerSpecRequest() {}

  explicit DescribeLoadBalancerSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerSpec) {
      res["LoadBalancerSpec"] = boost::any(*loadBalancerSpec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerSpec") != m.end() && !m["LoadBalancerSpec"].empty()) {
      loadBalancerSpec = make_shared<string>(boost::any_cast<string>(m["LoadBalancerSpec"]));
    }
  }


  virtual ~DescribeLoadBalancerSpecRequest() = default;
};
class DescribeLoadBalancerSpecResponseBodyLoadBalancerSpecs : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> loadBalancerSpec{};

  DescribeLoadBalancerSpecResponseBodyLoadBalancerSpecs() {}

  explicit DescribeLoadBalancerSpecResponseBodyLoadBalancerSpecs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (loadBalancerSpec) {
      res["LoadBalancerSpec"] = boost::any(*loadBalancerSpec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("LoadBalancerSpec") != m.end() && !m["LoadBalancerSpec"].empty()) {
      loadBalancerSpec = make_shared<string>(boost::any_cast<string>(m["LoadBalancerSpec"]));
    }
  }


  virtual ~DescribeLoadBalancerSpecResponseBodyLoadBalancerSpecs() = default;
};
class DescribeLoadBalancerSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLoadBalancerSpecResponseBodyLoadBalancerSpecs>> loadBalancerSpecs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeLoadBalancerSpecResponseBody() {}

  explicit DescribeLoadBalancerSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerSpecs) {
      vector<boost::any> temp1;
      for(auto item1:*loadBalancerSpecs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LoadBalancerSpecs"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerSpecs") != m.end() && !m["LoadBalancerSpecs"].empty()) {
      if (typeid(vector<boost::any>) == m["LoadBalancerSpecs"].type()) {
        vector<DescribeLoadBalancerSpecResponseBodyLoadBalancerSpecs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LoadBalancerSpecs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLoadBalancerSpecResponseBodyLoadBalancerSpecs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        loadBalancerSpecs = make_shared<vector<DescribeLoadBalancerSpecResponseBodyLoadBalancerSpecs>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeLoadBalancerSpecResponseBody() = default;
};
class DescribeLoadBalancerSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeLoadBalancerSpecResponseBody> body{};

  DescribeLoadBalancerSpecResponse() {}

  explicit DescribeLoadBalancerSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoadBalancerSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoadBalancerSpecResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoadBalancerSpecResponse() = default;
};
class DescribeLoadBalancerTCPListenerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};

  DescribeLoadBalancerTCPListenerAttributeRequest() {}

  explicit DescribeLoadBalancerTCPListenerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~DescribeLoadBalancerTCPListenerAttributeRequest() = default;
};
class DescribeLoadBalancerTCPListenerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> backendServerPort{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> description{};
  shared_ptr<string> eipTransmit{};
  shared_ptr<long> establishedTimeout{};
  shared_ptr<string> healthCheck{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<long> healthCheckConnectTimeout{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckType{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> listenerPort{};
  shared_ptr<long> persistenceTimeout{};
  shared_ptr<string> requestId{};
  shared_ptr<string> scheduler{};
  shared_ptr<string> status{};
  shared_ptr<long> unhealthyThreshold{};

  DescribeLoadBalancerTCPListenerAttributeResponseBody() {}

  explicit DescribeLoadBalancerTCPListenerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServerPort) {
      res["BackendServerPort"] = boost::any(*backendServerPort);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eipTransmit) {
      res["EipTransmit"] = boost::any(*eipTransmit);
    }
    if (establishedTimeout) {
      res["EstablishedTimeout"] = boost::any(*establishedTimeout);
    }
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckConnectTimeout) {
      res["HealthCheckConnectTimeout"] = boost::any(*healthCheckConnectTimeout);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckType) {
      res["HealthCheckType"] = boost::any(*healthCheckType);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (persistenceTimeout) {
      res["PersistenceTimeout"] = boost::any(*persistenceTimeout);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServerPort") != m.end() && !m["BackendServerPort"].empty()) {
      backendServerPort = make_shared<long>(boost::any_cast<long>(m["BackendServerPort"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EipTransmit") != m.end() && !m["EipTransmit"].empty()) {
      eipTransmit = make_shared<string>(boost::any_cast<string>(m["EipTransmit"]));
    }
    if (m.find("EstablishedTimeout") != m.end() && !m["EstablishedTimeout"].empty()) {
      establishedTimeout = make_shared<long>(boost::any_cast<long>(m["EstablishedTimeout"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckConnectTimeout") != m.end() && !m["HealthCheckConnectTimeout"].empty()) {
      healthCheckConnectTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectTimeout"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckType") != m.end() && !m["HealthCheckType"].empty()) {
      healthCheckType = make_shared<string>(boost::any_cast<string>(m["HealthCheckType"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("PersistenceTimeout") != m.end() && !m["PersistenceTimeout"].empty()) {
      persistenceTimeout = make_shared<long>(boost::any_cast<long>(m["PersistenceTimeout"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~DescribeLoadBalancerTCPListenerAttributeResponseBody() = default;
};
class DescribeLoadBalancerTCPListenerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeLoadBalancerTCPListenerAttributeResponseBody> body{};

  DescribeLoadBalancerTCPListenerAttributeResponse() {}

  explicit DescribeLoadBalancerTCPListenerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoadBalancerTCPListenerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoadBalancerTCPListenerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoadBalancerTCPListenerAttributeResponse() = default;
};
class DescribeLoadBalancerUDPListenerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};

  DescribeLoadBalancerUDPListenerAttributeRequest() {}

  explicit DescribeLoadBalancerUDPListenerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~DescribeLoadBalancerUDPListenerAttributeRequest() = default;
};
class DescribeLoadBalancerUDPListenerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> backendServerPort{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> description{};
  shared_ptr<string> eipTransmit{};
  shared_ptr<string> healthCheck{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<long> healthCheckConnectTimeout{};
  shared_ptr<string> healthCheckExp{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckReq{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> requestId{};
  shared_ptr<string> scheduler{};
  shared_ptr<string> status{};
  shared_ptr<long> unhealthyThreshold{};

  DescribeLoadBalancerUDPListenerAttributeResponseBody() {}

  explicit DescribeLoadBalancerUDPListenerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServerPort) {
      res["BackendServerPort"] = boost::any(*backendServerPort);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eipTransmit) {
      res["EipTransmit"] = boost::any(*eipTransmit);
    }
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckConnectTimeout) {
      res["HealthCheckConnectTimeout"] = boost::any(*healthCheckConnectTimeout);
    }
    if (healthCheckExp) {
      res["HealthCheckExp"] = boost::any(*healthCheckExp);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckReq) {
      res["HealthCheckReq"] = boost::any(*healthCheckReq);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServerPort") != m.end() && !m["BackendServerPort"].empty()) {
      backendServerPort = make_shared<long>(boost::any_cast<long>(m["BackendServerPort"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EipTransmit") != m.end() && !m["EipTransmit"].empty()) {
      eipTransmit = make_shared<string>(boost::any_cast<string>(m["EipTransmit"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckConnectTimeout") != m.end() && !m["HealthCheckConnectTimeout"].empty()) {
      healthCheckConnectTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectTimeout"]));
    }
    if (m.find("HealthCheckExp") != m.end() && !m["HealthCheckExp"].empty()) {
      healthCheckExp = make_shared<string>(boost::any_cast<string>(m["HealthCheckExp"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckReq") != m.end() && !m["HealthCheckReq"].empty()) {
      healthCheckReq = make_shared<string>(boost::any_cast<string>(m["HealthCheckReq"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~DescribeLoadBalancerUDPListenerAttributeResponseBody() = default;
};
class DescribeLoadBalancerUDPListenerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeLoadBalancerUDPListenerAttributeResponseBody> body{};

  DescribeLoadBalancerUDPListenerAttributeResponse() {}

  explicit DescribeLoadBalancerUDPListenerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoadBalancerUDPListenerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoadBalancerUDPListenerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoadBalancerUDPListenerAttributeResponse() = default;
};
class DescribeLoadBalancersRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> loadBalancerName{};
  shared_ptr<string> loadBalancerStatus{};
  shared_ptr<string> networkId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> serverId{};
  shared_ptr<string> vSwitchId{};

  DescribeLoadBalancersRequest() {}

  explicit DescribeLoadBalancersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (loadBalancerName) {
      res["LoadBalancerName"] = boost::any(*loadBalancerName);
    }
    if (loadBalancerStatus) {
      res["LoadBalancerStatus"] = boost::any(*loadBalancerStatus);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("LoadBalancerName") != m.end() && !m["LoadBalancerName"].empty()) {
      loadBalancerName = make_shared<string>(boost::any_cast<string>(m["LoadBalancerName"]));
    }
    if (m.find("LoadBalancerStatus") != m.end() && !m["LoadBalancerStatus"].empty()) {
      loadBalancerStatus = make_shared<string>(boost::any_cast<string>(m["LoadBalancerStatus"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeLoadBalancersRequest() = default;
};
class DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> addressIPVersion{};
  shared_ptr<string> createTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> loadBalancerName{};
  shared_ptr<string> loadBalancerStatus{};
  shared_ptr<string> networkId{};
  shared_ptr<string> payType{};
  shared_ptr<string> vSwitchId{};

  DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer() {}

  explicit DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (addressIPVersion) {
      res["AddressIPVersion"] = boost::any(*addressIPVersion);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (loadBalancerName) {
      res["LoadBalancerName"] = boost::any(*loadBalancerName);
    }
    if (loadBalancerStatus) {
      res["LoadBalancerStatus"] = boost::any(*loadBalancerStatus);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AddressIPVersion") != m.end() && !m["AddressIPVersion"].empty()) {
      addressIPVersion = make_shared<string>(boost::any_cast<string>(m["AddressIPVersion"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("LoadBalancerName") != m.end() && !m["LoadBalancerName"].empty()) {
      loadBalancerName = make_shared<string>(boost::any_cast<string>(m["LoadBalancerName"]));
    }
    if (m.find("LoadBalancerStatus") != m.end() && !m["LoadBalancerStatus"].empty()) {
      loadBalancerStatus = make_shared<string>(boost::any_cast<string>(m["LoadBalancerStatus"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer() = default;
};
class DescribeLoadBalancersResponseBodyLoadBalancers : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer>> loadBalancer{};

  DescribeLoadBalancersResponseBodyLoadBalancers() {}

  explicit DescribeLoadBalancersResponseBodyLoadBalancers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancer) {
      vector<boost::any> temp1;
      for(auto item1:*loadBalancer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LoadBalancer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancer") != m.end() && !m["LoadBalancer"].empty()) {
      if (typeid(vector<boost::any>) == m["LoadBalancer"].type()) {
        vector<DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LoadBalancer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        loadBalancer = make_shared<vector<DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer>>(expect1);
      }
    }
  }


  virtual ~DescribeLoadBalancersResponseBodyLoadBalancers() = default;
};
class DescribeLoadBalancersResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLoadBalancersResponseBodyLoadBalancers> loadBalancers{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeLoadBalancersResponseBody() {}

  explicit DescribeLoadBalancersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancers) {
      res["LoadBalancers"] = loadBalancers ? boost::any(loadBalancers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancers") != m.end() && !m["LoadBalancers"].empty()) {
      if (typeid(map<string, boost::any>) == m["LoadBalancers"].type()) {
        DescribeLoadBalancersResponseBodyLoadBalancers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LoadBalancers"]));
        loadBalancers = make_shared<DescribeLoadBalancersResponseBodyLoadBalancers>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeLoadBalancersResponseBody() = default;
};
class DescribeLoadBalancersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeLoadBalancersResponseBody> body{};

  DescribeLoadBalancersResponse() {}

  explicit DescribeLoadBalancersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoadBalancersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoadBalancersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoadBalancersResponse() = default;
};
class DescribeMeasurementDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<string> startDate{};
  shared_ptr<string> version{};

  DescribeMeasurementDataRequest() {}

  explicit DescribeMeasurementDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeMeasurementDataRequest() = default;
};
class DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData : public Darabonba::Model {
public:
  shared_ptr<string> costCode{};
  shared_ptr<string> costName{};
  shared_ptr<long> costVal{};

  DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData() {}

  explicit DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costCode) {
      res["CostCode"] = boost::any(*costCode);
    }
    if (costName) {
      res["CostName"] = boost::any(*costName);
    }
    if (costVal) {
      res["CostVal"] = boost::any(*costVal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CostCode") != m.end() && !m["CostCode"].empty()) {
      costCode = make_shared<string>(boost::any_cast<string>(m["CostCode"]));
    }
    if (m.find("CostName") != m.end() && !m["CostName"].empty()) {
      costName = make_shared<string>(boost::any_cast<string>(m["CostName"]));
    }
    if (m.find("CostVal") != m.end() && !m["CostVal"].empty()) {
      costVal = make_shared<long>(boost::any_cast<long>(m["CostVal"]));
    }
  }


  virtual ~DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData() = default;
};
class DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData>> bandWidthFeeData{};

  DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas() {}

  explicit DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidthFeeData) {
      vector<boost::any> temp1;
      for(auto item1:*bandWidthFeeData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BandWidthFeeData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidthFeeData") != m.end() && !m["BandWidthFeeData"].empty()) {
      if (typeid(vector<boost::any>) == m["BandWidthFeeData"].type()) {
        vector<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BandWidthFeeData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bandWidthFeeData = make_shared<vector<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatasBandWidthFeeData>>(expect1);
      }
    }
  }


  virtual ~DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas() = default;
};
class DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeData : public Darabonba::Model {
public:
  shared_ptr<long> memory{};
  shared_ptr<long> storage{};
  shared_ptr<long> vcpu{};

  DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeData() {}

  explicit DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (storage) {
      res["Storage"] = boost::any(*storage);
    }
    if (vcpu) {
      res["Vcpu"] = boost::any(*vcpu);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("Storage") != m.end() && !m["Storage"].empty()) {
      storage = make_shared<long>(boost::any_cast<long>(m["Storage"]));
    }
    if (m.find("Vcpu") != m.end() && !m["Vcpu"].empty()) {
      vcpu = make_shared<long>(boost::any_cast<long>(m["Vcpu"]));
    }
  }


  virtual ~DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeData() = default;
};
class DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetailsResourceFeeDataDetail : public Darabonba::Model {
public:
  shared_ptr<string> costCode{};
  shared_ptr<string> costName{};
  shared_ptr<long> costVal{};
  shared_ptr<string> resourceType{};

  DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetailsResourceFeeDataDetail() {}

  explicit DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetailsResourceFeeDataDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costCode) {
      res["CostCode"] = boost::any(*costCode);
    }
    if (costName) {
      res["CostName"] = boost::any(*costName);
    }
    if (costVal) {
      res["CostVal"] = boost::any(*costVal);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CostCode") != m.end() && !m["CostCode"].empty()) {
      costCode = make_shared<string>(boost::any_cast<string>(m["CostCode"]));
    }
    if (m.find("CostName") != m.end() && !m["CostName"].empty()) {
      costName = make_shared<string>(boost::any_cast<string>(m["CostName"]));
    }
    if (m.find("CostVal") != m.end() && !m["CostVal"].empty()) {
      costVal = make_shared<long>(boost::any_cast<long>(m["CostVal"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetailsResourceFeeDataDetail() = default;
};
class DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetailsResourceFeeDataDetail>> resourceFeeDataDetail{};

  DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetails() {}

  explicit DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceFeeDataDetail) {
      vector<boost::any> temp1;
      for(auto item1:*resourceFeeDataDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceFeeDataDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceFeeDataDetail") != m.end() && !m["ResourceFeeDataDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceFeeDataDetail"].type()) {
        vector<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetailsResourceFeeDataDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceFeeDataDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetailsResourceFeeDataDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceFeeDataDetail = make_shared<vector<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetailsResourceFeeDataDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetails() = default;
};
class DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementData : public Darabonba::Model {
public:
  shared_ptr<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas> bandWidthFeeDatas{};
  shared_ptr<string> chargeModel{};
  shared_ptr<string> costCycle{};
  shared_ptr<string> costEndTime{};
  shared_ptr<string> costStartTime{};
  shared_ptr<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeData> resourceFeeData{};
  shared_ptr<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetails> resourceFeeDataDetails{};

  DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementData() {}

  explicit DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidthFeeDatas) {
      res["BandWidthFeeDatas"] = bandWidthFeeDatas ? boost::any(bandWidthFeeDatas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (chargeModel) {
      res["ChargeModel"] = boost::any(*chargeModel);
    }
    if (costCycle) {
      res["CostCycle"] = boost::any(*costCycle);
    }
    if (costEndTime) {
      res["CostEndTime"] = boost::any(*costEndTime);
    }
    if (costStartTime) {
      res["CostStartTime"] = boost::any(*costStartTime);
    }
    if (resourceFeeData) {
      res["ResourceFeeData"] = resourceFeeData ? boost::any(resourceFeeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resourceFeeDataDetails) {
      res["ResourceFeeDataDetails"] = resourceFeeDataDetails ? boost::any(resourceFeeDataDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidthFeeDatas") != m.end() && !m["BandWidthFeeDatas"].empty()) {
      if (typeid(map<string, boost::any>) == m["BandWidthFeeDatas"].type()) {
        DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BandWidthFeeDatas"]));
        bandWidthFeeDatas = make_shared<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataBandWidthFeeDatas>(model1);
      }
    }
    if (m.find("ChargeModel") != m.end() && !m["ChargeModel"].empty()) {
      chargeModel = make_shared<string>(boost::any_cast<string>(m["ChargeModel"]));
    }
    if (m.find("CostCycle") != m.end() && !m["CostCycle"].empty()) {
      costCycle = make_shared<string>(boost::any_cast<string>(m["CostCycle"]));
    }
    if (m.find("CostEndTime") != m.end() && !m["CostEndTime"].empty()) {
      costEndTime = make_shared<string>(boost::any_cast<string>(m["CostEndTime"]));
    }
    if (m.find("CostStartTime") != m.end() && !m["CostStartTime"].empty()) {
      costStartTime = make_shared<string>(boost::any_cast<string>(m["CostStartTime"]));
    }
    if (m.find("ResourceFeeData") != m.end() && !m["ResourceFeeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceFeeData"].type()) {
        DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceFeeData"]));
        resourceFeeData = make_shared<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeData>(model1);
      }
    }
    if (m.find("ResourceFeeDataDetails") != m.end() && !m["ResourceFeeDataDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceFeeDataDetails"].type()) {
        DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceFeeDataDetails"]));
        resourceFeeDataDetails = make_shared<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementDataResourceFeeDataDetails>(model1);
      }
    }
  }


  virtual ~DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementData() = default;
};
class DescribeMeasurementDataResponseBodyMeasurementDatas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementData>> measurementData{};

  DescribeMeasurementDataResponseBodyMeasurementDatas() {}

  explicit DescribeMeasurementDataResponseBodyMeasurementDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (measurementData) {
      vector<boost::any> temp1;
      for(auto item1:*measurementData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MeasurementData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MeasurementData") != m.end() && !m["MeasurementData"].empty()) {
      if (typeid(vector<boost::any>) == m["MeasurementData"].type()) {
        vector<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MeasurementData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        measurementData = make_shared<vector<DescribeMeasurementDataResponseBodyMeasurementDatasMeasurementData>>(expect1);
      }
    }
  }


  virtual ~DescribeMeasurementDataResponseBodyMeasurementDatas() = default;
};
class DescribeMeasurementDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeMeasurementDataResponseBodyMeasurementDatas> measurementDatas{};
  shared_ptr<string> requestId{};

  DescribeMeasurementDataResponseBody() {}

  explicit DescribeMeasurementDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (measurementDatas) {
      res["MeasurementDatas"] = measurementDatas ? boost::any(measurementDatas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MeasurementDatas") != m.end() && !m["MeasurementDatas"].empty()) {
      if (typeid(map<string, boost::any>) == m["MeasurementDatas"].type()) {
        DescribeMeasurementDataResponseBodyMeasurementDatas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MeasurementDatas"]));
        measurementDatas = make_shared<DescribeMeasurementDataResponseBodyMeasurementDatas>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeasurementDataResponseBody() = default;
};
class DescribeMeasurementDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeMeasurementDataResponseBody> body{};

  DescribeMeasurementDataResponse() {}

  explicit DescribeMeasurementDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeasurementDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeasurementDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeasurementDataResponse() = default;
};
class DescribeNetworkAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> networkId{};

  DescribeNetworkAttributeRequest() {}

  explicit DescribeNetworkAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
  }


  virtual ~DescribeNetworkAttributeRequest() = default;
};
class DescribeNetworkAttributeResponseBodyCloudResourcesCloudResourceSetType : public Darabonba::Model {
public:
  shared_ptr<long> resourceCount{};
  shared_ptr<string> resourceType{};

  DescribeNetworkAttributeResponseBodyCloudResourcesCloudResourceSetType() {}

  explicit DescribeNetworkAttributeResponseBodyCloudResourcesCloudResourceSetType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceCount) {
      res["ResourceCount"] = boost::any(*resourceCount);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceCount") != m.end() && !m["ResourceCount"].empty()) {
      resourceCount = make_shared<long>(boost::any_cast<long>(m["ResourceCount"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribeNetworkAttributeResponseBodyCloudResourcesCloudResourceSetType() = default;
};
class DescribeNetworkAttributeResponseBodyCloudResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkAttributeResponseBodyCloudResourcesCloudResourceSetType>> cloudResourceSetType{};

  DescribeNetworkAttributeResponseBodyCloudResources() {}

  explicit DescribeNetworkAttributeResponseBodyCloudResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudResourceSetType) {
      vector<boost::any> temp1;
      for(auto item1:*cloudResourceSetType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CloudResourceSetType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudResourceSetType") != m.end() && !m["CloudResourceSetType"].empty()) {
      if (typeid(vector<boost::any>) == m["CloudResourceSetType"].type()) {
        vector<DescribeNetworkAttributeResponseBodyCloudResourcesCloudResourceSetType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CloudResourceSetType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkAttributeResponseBodyCloudResourcesCloudResourceSetType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cloudResourceSetType = make_shared<vector<DescribeNetworkAttributeResponseBodyCloudResourcesCloudResourceSetType>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkAttributeResponseBodyCloudResources() = default;
};
class DescribeNetworkAttributeResponseBodyVSwitchIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> vSwitchId{};

  DescribeNetworkAttributeResponseBodyVSwitchIds() {}

  explicit DescribeNetworkAttributeResponseBodyVSwitchIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworkAttributeResponseBodyVSwitchIds() = default;
};
class DescribeNetworkAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<DescribeNetworkAttributeResponseBodyCloudResources> cloudResources{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> networkId{};
  shared_ptr<string> networkName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<DescribeNetworkAttributeResponseBodyVSwitchIds> vSwitchIds{};

  DescribeNetworkAttributeResponseBody() {}

  explicit DescribeNetworkAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (cloudResources) {
      res["CloudResources"] = cloudResources ? boost::any(cloudResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (networkName) {
      res["NetworkName"] = boost::any(*networkName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = vSwitchIds ? boost::any(vSwitchIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("CloudResources") != m.end() && !m["CloudResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["CloudResources"].type()) {
        DescribeNetworkAttributeResponseBodyCloudResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CloudResources"]));
        cloudResources = make_shared<DescribeNetworkAttributeResponseBodyCloudResources>(model1);
      }
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("NetworkName") != m.end() && !m["NetworkName"].empty()) {
      networkName = make_shared<string>(boost::any_cast<string>(m["NetworkName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["VSwitchIds"].type()) {
        DescribeNetworkAttributeResponseBodyVSwitchIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VSwitchIds"]));
        vSwitchIds = make_shared<DescribeNetworkAttributeResponseBodyVSwitchIds>(model1);
      }
    }
  }


  virtual ~DescribeNetworkAttributeResponseBody() = default;
};
class DescribeNetworkAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeNetworkAttributeResponseBody> body{};

  DescribeNetworkAttributeResponse() {}

  explicit DescribeNetworkAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworkAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworkAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworkAttributeResponse() = default;
};
class DescribeNetworkInterfacesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> primaryIpAddress{};
  shared_ptr<string> vSwitchId{};

  DescribeNetworkInterfacesRequest() {}

  explicit DescribeNetworkInterfacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (primaryIpAddress) {
      res["PrimaryIpAddress"] = boost::any(*primaryIpAddress);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("PrimaryIpAddress") != m.end() && !m["PrimaryIpAddress"].empty()) {
      primaryIpAddress = make_shared<string>(boost::any_cast<string>(m["PrimaryIpAddress"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeNetworkInterfacesRequest() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> macAddress{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> primaryIp{};
  shared_ptr<string> primaryIpType{};
  shared_ptr<string> status{};
  shared_ptr<string> vSwitchId{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (macAddress) {
      res["MacAddress"] = boost::any(*macAddress);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (primaryIp) {
      res["PrimaryIp"] = boost::any(*primaryIp);
    }
    if (primaryIpType) {
      res["PrimaryIpType"] = boost::any(*primaryIpType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MacAddress") != m.end() && !m["MacAddress"].empty()) {
      macAddress = make_shared<string>(boost::any_cast<string>(m["MacAddress"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("PrimaryIp") != m.end() && !m["PrimaryIp"].empty()) {
      primaryIp = make_shared<string>(boost::any_cast<string>(m["PrimaryIp"]));
    }
    if (m.find("PrimaryIpType") != m.end() && !m["PrimaryIpType"].empty()) {
      primaryIpType = make_shared<string>(boost::any_cast<string>(m["PrimaryIpType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet() = default;
};
class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet>> networkInterfaceSet{};

  DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets() {}

  explicit DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceSet) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterfaceSet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterfaceSet"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceSet") != m.end() && !m["NetworkInterfaceSet"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterfaceSet"].type()) {
        vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterfaceSet"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterfaceSet = make_shared<vector<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets() = default;
};
class DescribeNetworkInterfacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets> networkInterfaceSets{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeNetworkInterfacesResponseBody() {}

  explicit DescribeNetworkInterfacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceSets) {
      res["NetworkInterfaceSets"] = networkInterfaceSets ? boost::any(networkInterfaceSets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceSets") != m.end() && !m["NetworkInterfaceSets"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkInterfaceSets"].type()) {
        DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkInterfaceSets"]));
        networkInterfaceSets = make_shared<DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeNetworkInterfacesResponseBody() = default;
};
class DescribeNetworkInterfacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeNetworkInterfacesResponseBody> body{};

  DescribeNetworkInterfacesResponse() {}

  explicit DescribeNetworkInterfacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworkInterfacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworkInterfacesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworkInterfacesResponse() = default;
};
class DescribeNetworksRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> networkId{};
  shared_ptr<string> networkName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeNetworksRequest() {}

  explicit DescribeNetworksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (networkName) {
      res["NetworkName"] = boost::any(*networkName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("NetworkName") != m.end() && !m["NetworkName"].empty()) {
      networkName = make_shared<string>(boost::any_cast<string>(m["NetworkName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeNetworksRequest() = default;
};
class DescribeNetworksResponseBodyNetworksNetworkVSwitchIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> vSwitchId{};

  DescribeNetworksResponseBodyNetworksNetworkVSwitchIds() {}

  explicit DescribeNetworksResponseBodyNetworksNetworkVSwitchIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNetworksResponseBodyNetworksNetworkVSwitchIds() = default;
};
class DescribeNetworksResponseBodyNetworksNetwork : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> networkId{};
  shared_ptr<string> networkName{};
  shared_ptr<string> status{};
  shared_ptr<DescribeNetworksResponseBodyNetworksNetworkVSwitchIds> vSwitchIds{};

  DescribeNetworksResponseBodyNetworksNetwork() {}

  explicit DescribeNetworksResponseBodyNetworksNetwork(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (networkName) {
      res["NetworkName"] = boost::any(*networkName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = vSwitchIds ? boost::any(vSwitchIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("NetworkName") != m.end() && !m["NetworkName"].empty()) {
      networkName = make_shared<string>(boost::any_cast<string>(m["NetworkName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["VSwitchIds"].type()) {
        DescribeNetworksResponseBodyNetworksNetworkVSwitchIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VSwitchIds"]));
        vSwitchIds = make_shared<DescribeNetworksResponseBodyNetworksNetworkVSwitchIds>(model1);
      }
    }
  }


  virtual ~DescribeNetworksResponseBodyNetworksNetwork() = default;
};
class DescribeNetworksResponseBodyNetworks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworksResponseBodyNetworksNetwork>> network{};

  DescribeNetworksResponseBodyNetworks() {}

  explicit DescribeNetworksResponseBodyNetworks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (network) {
      vector<boost::any> temp1;
      for(auto item1:*network){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Network"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Network") != m.end() && !m["Network"].empty()) {
      if (typeid(vector<boost::any>) == m["Network"].type()) {
        vector<DescribeNetworksResponseBodyNetworksNetwork> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Network"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworksResponseBodyNetworksNetwork model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        network = make_shared<vector<DescribeNetworksResponseBodyNetworksNetwork>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworksResponseBodyNetworks() = default;
};
class DescribeNetworksResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeNetworksResponseBodyNetworks> networks{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeNetworksResponseBody() {}

  explicit DescribeNetworksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networks) {
      res["Networks"] = networks ? boost::any(networks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Networks") != m.end() && !m["Networks"].empty()) {
      if (typeid(map<string, boost::any>) == m["Networks"].type()) {
        DescribeNetworksResponseBodyNetworks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Networks"]));
        networks = make_shared<DescribeNetworksResponseBodyNetworks>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeNetworksResponseBody() = default;
};
class DescribeNetworksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeNetworksResponseBody> body{};

  DescribeNetworksResponse() {}

  explicit DescribeNetworksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworksResponse() = default;
};
class DescribePrePaidInstanceStockRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataDiskSize{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceSpec{};
  shared_ptr<long> systemDiskSize{};
  shared_ptr<string> version{};

  DescribePrePaidInstanceStockRequest() {}

  explicit DescribePrePaidInstanceStockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceSpec) {
      res["InstanceSpec"] = boost::any(*instanceSpec);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<long>(boost::any_cast<long>(m["DataDiskSize"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceSpec") != m.end() && !m["InstanceSpec"].empty()) {
      instanceSpec = make_shared<string>(boost::any_cast<string>(m["InstanceSpec"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskSize"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribePrePaidInstanceStockRequest() = default;
};
class DescribePrePaidInstanceStockResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> avaliableCount{};
  shared_ptr<long> cores{};
  shared_ptr<long> dataDiskSize{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceSpec{};
  shared_ptr<long> memory{};
  shared_ptr<string> requestId{};
  shared_ptr<long> systemDiskSize{};

  DescribePrePaidInstanceStockResponseBody() {}

  explicit DescribePrePaidInstanceStockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avaliableCount) {
      res["AvaliableCount"] = boost::any(*avaliableCount);
    }
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceSpec) {
      res["InstanceSpec"] = boost::any(*instanceSpec);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvaliableCount") != m.end() && !m["AvaliableCount"].empty()) {
      avaliableCount = make_shared<long>(boost::any_cast<long>(m["AvaliableCount"]));
    }
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<long>(boost::any_cast<long>(m["DataDiskSize"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceSpec") != m.end() && !m["InstanceSpec"].empty()) {
      instanceSpec = make_shared<string>(boost::any_cast<string>(m["InstanceSpec"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskSize"]));
    }
  }


  virtual ~DescribePrePaidInstanceStockResponseBody() = default;
};
class DescribePrePaidInstanceStockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePrePaidInstanceStockResponseBody> body{};

  DescribePrePaidInstanceStockResponse() {}

  explicit DescribePrePaidInstanceStockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePrePaidInstanceStockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePrePaidInstanceStockResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePrePaidInstanceStockResponse() = default;
};
class DescribePriceRequestDataDisk : public Darabonba::Model {
public:
  shared_ptr<long> size{};

  DescribePriceRequestDataDisk() {}

  explicit DescribePriceRequestDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribePriceRequestDataDisk() = default;
};
class DescribePriceRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<long> size{};

  DescribePriceRequestSystemDisk() {}

  explicit DescribePriceRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribePriceRequestSystemDisk() = default;
};
class DescribePriceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePriceRequestDataDisk>> dataDisk{};
  shared_ptr<DescribePriceRequestSystemDisk> systemDisk{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> period{};
  shared_ptr<long> quantity{};
  shared_ptr<string> version{};

  DescribePriceRequest() {}

  explicit DescribePriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<DescribePriceRequestDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePriceRequestDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<DescribePriceRequestDataDisk>>(expect1);
      }
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        DescribePriceRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<DescribePriceRequestSystemDisk>(model1);
      }
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribePriceRequest() = default;
};
class DescribePriceResponseBodyPriceInfoPrice : public Darabonba::Model {
public:
  shared_ptr<string> currency{};
  shared_ptr<double> discountPrice{};
  shared_ptr<double> originalPrice{};
  shared_ptr<double> tradePrice{};

  DescribePriceResponseBodyPriceInfoPrice() {}

  explicit DescribePriceResponseBodyPriceInfoPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfoPrice() = default;
};
class DescribePriceResponseBodyPriceInfo : public Darabonba::Model {
public:
  shared_ptr<DescribePriceResponseBodyPriceInfoPrice> price{};

  DescribePriceResponseBodyPriceInfo() {}

  explicit DescribePriceResponseBodyPriceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (price) {
      res["Price"] = price ? boost::any(price->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      if (typeid(map<string, boost::any>) == m["Price"].type()) {
        DescribePriceResponseBodyPriceInfoPrice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Price"]));
        price = make_shared<DescribePriceResponseBodyPriceInfoPrice>(model1);
      }
    }
  }


  virtual ~DescribePriceResponseBodyPriceInfo() = default;
};
class DescribePriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePriceResponseBodyPriceInfo> priceInfo{};
  shared_ptr<string> requestId{};

  DescribePriceResponseBody() {}

  explicit DescribePriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (priceInfo) {
      res["PriceInfo"] = priceInfo ? boost::any(priceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PriceInfo") != m.end() && !m["PriceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PriceInfo"].type()) {
        DescribePriceResponseBodyPriceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PriceInfo"]));
        priceInfo = make_shared<DescribePriceResponseBodyPriceInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePriceResponseBody() = default;
};
class DescribePriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePriceResponseBody> body{};

  DescribePriceResponse() {}

  explicit DescribePriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePriceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePriceResponse() = default;
};
class DescribeRegionIspsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};

  DescribeRegionIspsRequest() {}

  explicit DescribeRegionIspsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
  }


  virtual ~DescribeRegionIspsRequest() = default;
};
class DescribeRegionIspsResponseBodyIsps : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};

  DescribeRegionIspsResponseBodyIsps() {}

  explicit DescribeRegionIspsResponseBodyIsps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeRegionIspsResponseBodyIsps() = default;
};
class DescribeRegionIspsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRegionIspsResponseBodyIsps>> isps{};
  shared_ptr<string> requestId{};

  DescribeRegionIspsResponseBody() {}

  explicit DescribeRegionIspsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isps) {
      vector<boost::any> temp1;
      for(auto item1:*isps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Isps"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Isps") != m.end() && !m["Isps"].empty()) {
      if (typeid(vector<boost::any>) == m["Isps"].type()) {
        vector<DescribeRegionIspsResponseBodyIsps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Isps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionIspsResponseBodyIsps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        isps = make_shared<vector<DescribeRegionIspsResponseBodyIsps>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRegionIspsResponseBody() = default;
};
class DescribeRegionIspsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRegionIspsResponseBody> body{};

  DescribeRegionIspsResponse() {}

  explicit DescribeRegionIspsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionIspsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionIspsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionIspsResponse() = default;
};
class DescribeReservedResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> version{};

  DescribeReservedResourceRequest() {}

  explicit DescribeReservedResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeReservedResourceRequest() = default;
};
class DescribeReservedResourceResponseBodyImagesImage : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};

  DescribeReservedResourceResponseBodyImagesImage() {}

  explicit DescribeReservedResourceResponseBodyImagesImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
  }


  virtual ~DescribeReservedResourceResponseBodyImagesImage() = default;
};
class DescribeReservedResourceResponseBodyImages : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeReservedResourceResponseBodyImagesImage>> image{};

  DescribeReservedResourceResponseBodyImages() {}

  explicit DescribeReservedResourceResponseBodyImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      vector<boost::any> temp1;
      for(auto item1:*image){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Image"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      if (typeid(vector<boost::any>) == m["Image"].type()) {
        vector<DescribeReservedResourceResponseBodyImagesImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Image"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservedResourceResponseBodyImagesImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        image = make_shared<vector<DescribeReservedResourceResponseBodyImagesImage>>(expect1);
      }
    }
  }


  virtual ~DescribeReservedResourceResponseBodyImages() = default;
};
class DescribeReservedResourceResponseBodySupportResourcesSupportResourceDataDiskSizes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dataDiskSize{};

  DescribeReservedResourceResponseBodySupportResourcesSupportResourceDataDiskSizes() {}

  explicit DescribeReservedResourceResponseBodySupportResourcesSupportResourceDataDiskSizes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DataDiskSize"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataDiskSize"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dataDiskSize = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeReservedResourceResponseBodySupportResourcesSupportResourceDataDiskSizes() = default;
};
class DescribeReservedResourceResponseBodySupportResourcesSupportResourceSystemDiskSizes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> systemDiskSize{};

  DescribeReservedResourceResponseBodySupportResourcesSupportResourceSystemDiskSizes() {}

  explicit DescribeReservedResourceResponseBodySupportResourcesSupportResourceSystemDiskSizes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SystemDiskSize"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SystemDiskSize"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      systemDiskSize = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeReservedResourceResponseBodySupportResourcesSupportResourceSystemDiskSizes() = default;
};
class DescribeReservedResourceResponseBodySupportResourcesSupportResource : public Darabonba::Model {
public:
  shared_ptr<DescribeReservedResourceResponseBodySupportResourcesSupportResourceDataDiskSizes> dataDiskSizes{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceSpec{};
  shared_ptr<string> supportResourcesCount{};
  shared_ptr<DescribeReservedResourceResponseBodySupportResourcesSupportResourceSystemDiskSizes> systemDiskSizes{};

  DescribeReservedResourceResponseBodySupportResourcesSupportResource() {}

  explicit DescribeReservedResourceResponseBodySupportResourcesSupportResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDiskSizes) {
      res["DataDiskSizes"] = dataDiskSizes ? boost::any(dataDiskSizes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceSpec) {
      res["InstanceSpec"] = boost::any(*instanceSpec);
    }
    if (supportResourcesCount) {
      res["SupportResourcesCount"] = boost::any(*supportResourcesCount);
    }
    if (systemDiskSizes) {
      res["SystemDiskSizes"] = systemDiskSizes ? boost::any(systemDiskSizes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDiskSizes") != m.end() && !m["DataDiskSizes"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataDiskSizes"].type()) {
        DescribeReservedResourceResponseBodySupportResourcesSupportResourceDataDiskSizes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataDiskSizes"]));
        dataDiskSizes = make_shared<DescribeReservedResourceResponseBodySupportResourcesSupportResourceDataDiskSizes>(model1);
      }
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceSpec") != m.end() && !m["InstanceSpec"].empty()) {
      instanceSpec = make_shared<string>(boost::any_cast<string>(m["InstanceSpec"]));
    }
    if (m.find("SupportResourcesCount") != m.end() && !m["SupportResourcesCount"].empty()) {
      supportResourcesCount = make_shared<string>(boost::any_cast<string>(m["SupportResourcesCount"]));
    }
    if (m.find("SystemDiskSizes") != m.end() && !m["SystemDiskSizes"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDiskSizes"].type()) {
        DescribeReservedResourceResponseBodySupportResourcesSupportResourceSystemDiskSizes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDiskSizes"]));
        systemDiskSizes = make_shared<DescribeReservedResourceResponseBodySupportResourcesSupportResourceSystemDiskSizes>(model1);
      }
    }
  }


  virtual ~DescribeReservedResourceResponseBodySupportResourcesSupportResource() = default;
};
class DescribeReservedResourceResponseBodySupportResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeReservedResourceResponseBodySupportResourcesSupportResource>> supportResource{};

  DescribeReservedResourceResponseBodySupportResources() {}

  explicit DescribeReservedResourceResponseBodySupportResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportResource) {
      vector<boost::any> temp1;
      for(auto item1:*supportResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportResource") != m.end() && !m["SupportResource"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportResource"].type()) {
        vector<DescribeReservedResourceResponseBodySupportResourcesSupportResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeReservedResourceResponseBodySupportResourcesSupportResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportResource = make_shared<vector<DescribeReservedResourceResponseBodySupportResourcesSupportResource>>(expect1);
      }
    }
  }


  virtual ~DescribeReservedResourceResponseBodySupportResources() = default;
};
class DescribeReservedResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeReservedResourceResponseBodyImages> images{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeReservedResourceResponseBodySupportResources> supportResources{};

  DescribeReservedResourceResponseBody() {}

  explicit DescribeReservedResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (images) {
      res["Images"] = images ? boost::any(images->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (supportResources) {
      res["SupportResources"] = supportResources ? boost::any(supportResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(map<string, boost::any>) == m["Images"].type()) {
        DescribeReservedResourceResponseBodyImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Images"]));
        images = make_shared<DescribeReservedResourceResponseBodyImages>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SupportResources") != m.end() && !m["SupportResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportResources"].type()) {
        DescribeReservedResourceResponseBodySupportResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportResources"]));
        supportResources = make_shared<DescribeReservedResourceResponseBodySupportResources>(model1);
      }
    }
  }


  virtual ~DescribeReservedResourceResponseBody() = default;
};
class DescribeReservedResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeReservedResourceResponseBody> body{};

  DescribeReservedResourceResponse() {}

  explicit DescribeReservedResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeReservedResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeReservedResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeReservedResourceResponse() = default;
};
class DescribeSecurityGroupAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityGroupId{};

  DescribeSecurityGroupAttributeRequest() {}

  explicit DescribeSecurityGroupAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~DescribeSecurityGroupAttributeRequest() = default;
};
class DescribeSecurityGroupAttributeResponseBodyPermissionsPermission : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> direction{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> sourcePortRange{};

  DescribeSecurityGroupAttributeResponseBodyPermissionsPermission() {}

  explicit DescribeSecurityGroupAttributeResponseBodyPermissionsPermission(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
  }


  virtual ~DescribeSecurityGroupAttributeResponseBodyPermissionsPermission() = default;
};
class DescribeSecurityGroupAttributeResponseBodyPermissions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSecurityGroupAttributeResponseBodyPermissionsPermission>> permission{};

  DescribeSecurityGroupAttributeResponseBodyPermissions() {}

  explicit DescribeSecurityGroupAttributeResponseBodyPermissions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (permission) {
      vector<boost::any> temp1;
      for(auto item1:*permission){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Permission"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Permission") != m.end() && !m["Permission"].empty()) {
      if (typeid(vector<boost::any>) == m["Permission"].type()) {
        vector<DescribeSecurityGroupAttributeResponseBodyPermissionsPermission> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Permission"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityGroupAttributeResponseBodyPermissionsPermission model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        permission = make_shared<vector<DescribeSecurityGroupAttributeResponseBodyPermissionsPermission>>(expect1);
      }
    }
  }


  virtual ~DescribeSecurityGroupAttributeResponseBodyPermissions() = default;
};
class DescribeSecurityGroupAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<DescribeSecurityGroupAttributeResponseBodyPermissions> permissions{};
  shared_ptr<string> requestId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupName{};

  DescribeSecurityGroupAttributeResponseBody() {}

  explicit DescribeSecurityGroupAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (permissions) {
      res["Permissions"] = permissions ? boost::any(permissions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Permissions") != m.end() && !m["Permissions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Permissions"].type()) {
        DescribeSecurityGroupAttributeResponseBodyPermissions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Permissions"]));
        permissions = make_shared<DescribeSecurityGroupAttributeResponseBodyPermissions>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
  }


  virtual ~DescribeSecurityGroupAttributeResponseBody() = default;
};
class DescribeSecurityGroupAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSecurityGroupAttributeResponseBody> body{};

  DescribeSecurityGroupAttributeResponse() {}

  explicit DescribeSecurityGroupAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityGroupAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityGroupAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityGroupAttributeResponse() = default;
};
class DescribeSecurityGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<string> version{};

  DescribeSecurityGroupsRequest() {}

  explicit DescribeSecurityGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeSecurityGroupsRequest() = default;
};
class DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<long> instanceCount{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupName{};

  DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup() {}

  explicit DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
  }


  virtual ~DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup() = default;
};
class DescribeSecurityGroupsResponseBodySecurityGroups : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup>> securityGroup{};

  DescribeSecurityGroupsResponseBodySecurityGroups() {}

  explicit DescribeSecurityGroupsResponseBodySecurityGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroup) {
      vector<boost::any> temp1;
      for(auto item1:*securityGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroup") != m.end() && !m["SecurityGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityGroup"].type()) {
        vector<DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityGroup = make_shared<vector<DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeSecurityGroupsResponseBodySecurityGroups() = default;
};
class DescribeSecurityGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSecurityGroupsResponseBodySecurityGroups> securityGroups{};
  shared_ptr<long> totalCount{};

  DescribeSecurityGroupsResponseBody() {}

  explicit DescribeSecurityGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityGroups) {
      res["SecurityGroups"] = securityGroups ? boost::any(securityGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityGroups") != m.end() && !m["SecurityGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroups"].type()) {
        DescribeSecurityGroupsResponseBodySecurityGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroups"]));
        securityGroups = make_shared<DescribeSecurityGroupsResponseBodySecurityGroups>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSecurityGroupsResponseBody() = default;
};
class DescribeSecurityGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSecurityGroupsResponseBody> body{};

  DescribeSecurityGroupsResponse() {}

  explicit DescribeSecurityGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityGroupsResponse() = default;
};
class DescribeServcieScheduleRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> podConfigName{};
  shared_ptr<string> uuid{};

  DescribeServcieScheduleRequest() {}

  explicit DescribeServcieScheduleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (podConfigName) {
      res["PodConfigName"] = boost::any(*podConfigName);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("PodConfigName") != m.end() && !m["PodConfigName"].empty()) {
      podConfigName = make_shared<string>(boost::any_cast<string>(m["PodConfigName"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeServcieScheduleRequest() = default;
};
class DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatusesContainerStatus : public Darabonba::Model {
public:
  shared_ptr<string> containerId{};
  shared_ptr<string> name{};

  DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatusesContainerStatus() {}

  explicit DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatusesContainerStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatusesContainerStatus() = default;
};
class DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatuses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatusesContainerStatus>> containerStatus{};

  DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatuses() {}

  explicit DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatuses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerStatus) {
      vector<boost::any> temp1;
      for(auto item1:*containerStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContainerStatus"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerStatus") != m.end() && !m["ContainerStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["ContainerStatus"].type()) {
        vector<DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatusesContainerStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContainerStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatusesContainerStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        containerStatus = make_shared<vector<DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatusesContainerStatus>>(expect1);
      }
    }
  }


  virtual ~DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatuses() = default;
};
class DescribeServcieScheduleResponseBodyPodAbstractInfo : public Darabonba::Model {
public:
  shared_ptr<bool> containerService{};
  shared_ptr<DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatuses> containerStatuses{};
  shared_ptr<bool> name{};
  shared_ptr<bool> namespace_{};
  shared_ptr<bool> resourceScope{};
  shared_ptr<bool> status{};

  DescribeServcieScheduleResponseBodyPodAbstractInfo() {}

  explicit DescribeServcieScheduleResponseBodyPodAbstractInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerService) {
      res["ContainerService"] = boost::any(*containerService);
    }
    if (containerStatuses) {
      res["ContainerStatuses"] = containerStatuses ? boost::any(containerStatuses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (resourceScope) {
      res["ResourceScope"] = boost::any(*resourceScope);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerService") != m.end() && !m["ContainerService"].empty()) {
      containerService = make_shared<bool>(boost::any_cast<bool>(m["ContainerService"]));
    }
    if (m.find("ContainerStatuses") != m.end() && !m["ContainerStatuses"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContainerStatuses"].type()) {
        DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatuses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContainerStatuses"]));
        containerStatuses = make_shared<DescribeServcieScheduleResponseBodyPodAbstractInfoContainerStatuses>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<bool>(boost::any_cast<bool>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<bool>(boost::any_cast<bool>(m["Namespace"]));
    }
    if (m.find("ResourceScope") != m.end() && !m["ResourceScope"].empty()) {
      resourceScope = make_shared<bool>(boost::any_cast<bool>(m["ResourceScope"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
  }


  virtual ~DescribeServcieScheduleResponseBodyPodAbstractInfo() = default;
};
class DescribeServcieScheduleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> index{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceIp{};
  shared_ptr<long> instancePort{};
  shared_ptr<DescribeServcieScheduleResponseBodyPodAbstractInfo> podAbstractInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> requestRepeated{};
  shared_ptr<string> tcpPorts{};

  DescribeServcieScheduleResponseBody() {}

  explicit DescribeServcieScheduleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceIp) {
      res["InstanceIp"] = boost::any(*instanceIp);
    }
    if (instancePort) {
      res["InstancePort"] = boost::any(*instancePort);
    }
    if (podAbstractInfo) {
      res["PodAbstractInfo"] = podAbstractInfo ? boost::any(podAbstractInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestRepeated) {
      res["RequestRepeated"] = boost::any(*requestRepeated);
    }
    if (tcpPorts) {
      res["TcpPorts"] = boost::any(*tcpPorts);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceIp") != m.end() && !m["InstanceIp"].empty()) {
      instanceIp = make_shared<string>(boost::any_cast<string>(m["InstanceIp"]));
    }
    if (m.find("InstancePort") != m.end() && !m["InstancePort"].empty()) {
      instancePort = make_shared<long>(boost::any_cast<long>(m["InstancePort"]));
    }
    if (m.find("PodAbstractInfo") != m.end() && !m["PodAbstractInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PodAbstractInfo"].type()) {
        DescribeServcieScheduleResponseBodyPodAbstractInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PodAbstractInfo"]));
        podAbstractInfo = make_shared<DescribeServcieScheduleResponseBodyPodAbstractInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestRepeated") != m.end() && !m["RequestRepeated"].empty()) {
      requestRepeated = make_shared<bool>(boost::any_cast<bool>(m["RequestRepeated"]));
    }
    if (m.find("TcpPorts") != m.end() && !m["TcpPorts"].empty()) {
      tcpPorts = make_shared<string>(boost::any_cast<string>(m["TcpPorts"]));
    }
  }


  virtual ~DescribeServcieScheduleResponseBody() = default;
};
class DescribeServcieScheduleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeServcieScheduleResponseBody> body{};

  DescribeServcieScheduleResponse() {}

  explicit DescribeServcieScheduleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeServcieScheduleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeServcieScheduleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeServcieScheduleResponse() = default;
};
class DescribeUserBandWidthDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> isp{};
  shared_ptr<string> period{};
  shared_ptr<string> startTime{};
  shared_ptr<string> version{};

  DescribeUserBandWidthDataRequest() {}

  explicit DescribeUserBandWidthDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeUserBandWidthDataRequest() = default;
};
class DescribeUserBandWidthDataResponseBodyMonitorDataBandWidthMonitorData : public Darabonba::Model {
public:
  shared_ptr<long> downBandWidth{};
  shared_ptr<long> internetRX{};
  shared_ptr<long> internetTX{};
  shared_ptr<string> timeStamp{};
  shared_ptr<long> upBandWidth{};

  DescribeUserBandWidthDataResponseBodyMonitorDataBandWidthMonitorData() {}

  explicit DescribeUserBandWidthDataResponseBodyMonitorDataBandWidthMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downBandWidth) {
      res["DownBandWidth"] = boost::any(*downBandWidth);
    }
    if (internetRX) {
      res["InternetRX"] = boost::any(*internetRX);
    }
    if (internetTX) {
      res["InternetTX"] = boost::any(*internetTX);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (upBandWidth) {
      res["UpBandWidth"] = boost::any(*upBandWidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownBandWidth") != m.end() && !m["DownBandWidth"].empty()) {
      downBandWidth = make_shared<long>(boost::any_cast<long>(m["DownBandWidth"]));
    }
    if (m.find("InternetRX") != m.end() && !m["InternetRX"].empty()) {
      internetRX = make_shared<long>(boost::any_cast<long>(m["InternetRX"]));
    }
    if (m.find("InternetTX") != m.end() && !m["InternetTX"].empty()) {
      internetTX = make_shared<long>(boost::any_cast<long>(m["InternetTX"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("UpBandWidth") != m.end() && !m["UpBandWidth"].empty()) {
      upBandWidth = make_shared<long>(boost::any_cast<long>(m["UpBandWidth"]));
    }
  }


  virtual ~DescribeUserBandWidthDataResponseBodyMonitorDataBandWidthMonitorData() = default;
};
class DescribeUserBandWidthDataResponseBodyMonitorData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUserBandWidthDataResponseBodyMonitorDataBandWidthMonitorData>> bandWidthMonitorData{};
  shared_ptr<string> maxDownBandWidth{};
  shared_ptr<string> maxUpBandWidth{};

  DescribeUserBandWidthDataResponseBodyMonitorData() {}

  explicit DescribeUserBandWidthDataResponseBodyMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidthMonitorData) {
      vector<boost::any> temp1;
      for(auto item1:*bandWidthMonitorData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BandWidthMonitorData"] = boost::any(temp1);
    }
    if (maxDownBandWidth) {
      res["MaxDownBandWidth"] = boost::any(*maxDownBandWidth);
    }
    if (maxUpBandWidth) {
      res["MaxUpBandWidth"] = boost::any(*maxUpBandWidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidthMonitorData") != m.end() && !m["BandWidthMonitorData"].empty()) {
      if (typeid(vector<boost::any>) == m["BandWidthMonitorData"].type()) {
        vector<DescribeUserBandWidthDataResponseBodyMonitorDataBandWidthMonitorData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BandWidthMonitorData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserBandWidthDataResponseBodyMonitorDataBandWidthMonitorData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bandWidthMonitorData = make_shared<vector<DescribeUserBandWidthDataResponseBodyMonitorDataBandWidthMonitorData>>(expect1);
      }
    }
    if (m.find("MaxDownBandWidth") != m.end() && !m["MaxDownBandWidth"].empty()) {
      maxDownBandWidth = make_shared<string>(boost::any_cast<string>(m["MaxDownBandWidth"]));
    }
    if (m.find("MaxUpBandWidth") != m.end() && !m["MaxUpBandWidth"].empty()) {
      maxUpBandWidth = make_shared<string>(boost::any_cast<string>(m["MaxUpBandWidth"]));
    }
  }


  virtual ~DescribeUserBandWidthDataResponseBodyMonitorData() = default;
};
class DescribeUserBandWidthDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeUserBandWidthDataResponseBodyMonitorData> monitorData{};
  shared_ptr<string> requestId{};

  DescribeUserBandWidthDataResponseBody() {}

  explicit DescribeUserBandWidthDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (monitorData) {
      res["MonitorData"] = monitorData ? boost::any(monitorData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("MonitorData") != m.end() && !m["MonitorData"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonitorData"].type()) {
        DescribeUserBandWidthDataResponseBodyMonitorData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonitorData"]));
        monitorData = make_shared<DescribeUserBandWidthDataResponseBodyMonitorData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserBandWidthDataResponseBody() = default;
};
class DescribeUserBandWidthDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeUserBandWidthDataResponseBody> body{};

  DescribeUserBandWidthDataResponse() {}

  explicit DescribeUserBandWidthDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserBandWidthDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserBandWidthDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserBandWidthDataResponse() = default;
};
class DescribeVSwitchesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> networkId{};
  shared_ptr<string> orderByParams{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vSwitchName{};
  shared_ptr<string> version{};

  DescribeVSwitchesRequest() {}

  explicit DescribeVSwitchesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (orderByParams) {
      res["OrderByParams"] = boost::any(*orderByParams);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("OrderByParams") != m.end() && !m["OrderByParams"].empty()) {
      orderByParams = make_shared<string>(boost::any_cast<string>(m["OrderByParams"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeVSwitchesRequest() = default;
};
class DescribeVSwitchesResponseBodyVSwitchesVSwitch : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<long> freeIpCount{};
  shared_ptr<string> networkId{};
  shared_ptr<string> status{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vSwitchName{};

  DescribeVSwitchesResponseBodyVSwitchesVSwitch() {}

  explicit DescribeVSwitchesResponseBodyVSwitchesVSwitch(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (freeIpCount) {
      res["FreeIpCount"] = boost::any(*freeIpCount);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("FreeIpCount") != m.end() && !m["FreeIpCount"].empty()) {
      freeIpCount = make_shared<long>(boost::any_cast<long>(m["FreeIpCount"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
  }


  virtual ~DescribeVSwitchesResponseBodyVSwitchesVSwitch() = default;
};
class DescribeVSwitchesResponseBodyVSwitches : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVSwitchesResponseBodyVSwitchesVSwitch>> vSwitch{};

  DescribeVSwitchesResponseBodyVSwitches() {}

  explicit DescribeVSwitchesResponseBodyVSwitches(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitch) {
      vector<boost::any> temp1;
      for(auto item1:*vSwitch){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VSwitch"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitch") != m.end() && !m["VSwitch"].empty()) {
      if (typeid(vector<boost::any>) == m["VSwitch"].type()) {
        vector<DescribeVSwitchesResponseBodyVSwitchesVSwitch> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VSwitch"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVSwitchesResponseBodyVSwitchesVSwitch model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vSwitch = make_shared<vector<DescribeVSwitchesResponseBodyVSwitchesVSwitch>>(expect1);
      }
    }
  }


  virtual ~DescribeVSwitchesResponseBodyVSwitches() = default;
};
class DescribeVSwitchesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeVSwitchesResponseBodyVSwitches> vSwitches{};

  DescribeVSwitchesResponseBody() {}

  explicit DescribeVSwitchesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vSwitches) {
      res["VSwitches"] = vSwitches ? boost::any(vSwitches->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VSwitches") != m.end() && !m["VSwitches"].empty()) {
      if (typeid(map<string, boost::any>) == m["VSwitches"].type()) {
        DescribeVSwitchesResponseBodyVSwitches model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VSwitches"]));
        vSwitches = make_shared<DescribeVSwitchesResponseBodyVSwitches>(model1);
      }
    }
  }


  virtual ~DescribeVSwitchesResponseBody() = default;
};
class DescribeVSwitchesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeVSwitchesResponseBody> body{};

  DescribeVSwitchesResponse() {}

  explicit DescribeVSwitchesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVSwitchesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVSwitchesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVSwitchesResponse() = default;
};
class DetachDiskRequest : public Darabonba::Model {
public:
  shared_ptr<string> diskId{};
  shared_ptr<string> instanceId{};

  DetachDiskRequest() {}

  explicit DetachDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DetachDiskRequest() = default;
};
class DetachDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  DetachDiskResponseBody() {}

  explicit DetachDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachDiskResponseBody() = default;
};
class DetachDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DetachDiskResponseBody> body{};

  DetachDiskResponse() {}

  explicit DetachDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachDiskResponseBody>(model1);
      }
    }
  }


  virtual ~DetachDiskResponse() = default;
};
class DistApplicationDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> data{};
  shared_ptr<string> distStrategy{};

  DistApplicationDataRequest() {}

  explicit DistApplicationDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (distStrategy) {
      res["DistStrategy"] = boost::any(*distStrategy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("DistStrategy") != m.end() && !m["DistStrategy"].empty()) {
      distStrategy = make_shared<string>(boost::any_cast<string>(m["DistStrategy"]));
    }
  }


  virtual ~DistApplicationDataRequest() = default;
};
class DistApplicationDataResponseBodyDistInstanceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distInstanceId{};

  DistApplicationDataResponseBodyDistInstanceIds() {}

  explicit DistApplicationDataResponseBodyDistInstanceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distInstanceId) {
      res["DistInstanceId"] = boost::any(*distInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistInstanceId") != m.end() && !m["DistInstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistInstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistInstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distInstanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DistApplicationDataResponseBodyDistInstanceIds() = default;
};
class DistApplicationDataResponseBodyDistResultsDistResult : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> resultCode{};
  shared_ptr<string> resultDescrip{};
  shared_ptr<string> version{};

  DistApplicationDataResponseBodyDistResultsDistResult() {}

  explicit DistApplicationDataResponseBodyDistResultsDistResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultDescrip) {
      res["ResultDescrip"] = boost::any(*resultDescrip);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<long>(boost::any_cast<long>(m["ResultCode"]));
    }
    if (m.find("ResultDescrip") != m.end() && !m["ResultDescrip"].empty()) {
      resultDescrip = make_shared<string>(boost::any_cast<string>(m["ResultDescrip"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DistApplicationDataResponseBodyDistResultsDistResult() = default;
};
class DistApplicationDataResponseBodyDistResults : public Darabonba::Model {
public:
  shared_ptr<vector<DistApplicationDataResponseBodyDistResultsDistResult>> distResult{};

  DistApplicationDataResponseBodyDistResults() {}

  explicit DistApplicationDataResponseBodyDistResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distResult) {
      vector<boost::any> temp1;
      for(auto item1:*distResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DistResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistResult") != m.end() && !m["DistResult"].empty()) {
      if (typeid(vector<boost::any>) == m["DistResult"].type()) {
        vector<DistApplicationDataResponseBodyDistResultsDistResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DistResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DistApplicationDataResponseBodyDistResultsDistResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        distResult = make_shared<vector<DistApplicationDataResponseBodyDistResultsDistResult>>(expect1);
      }
    }
  }


  virtual ~DistApplicationDataResponseBodyDistResults() = default;
};
class DistApplicationDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DistApplicationDataResponseBodyDistInstanceIds> distInstanceIds{};
  shared_ptr<long> distInstanceTotalCount{};
  shared_ptr<DistApplicationDataResponseBodyDistResults> distResults{};
  shared_ptr<string> requestId{};

  DistApplicationDataResponseBody() {}

  explicit DistApplicationDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distInstanceIds) {
      res["DistInstanceIds"] = distInstanceIds ? boost::any(distInstanceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (distInstanceTotalCount) {
      res["DistInstanceTotalCount"] = boost::any(*distInstanceTotalCount);
    }
    if (distResults) {
      res["DistResults"] = distResults ? boost::any(distResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistInstanceIds") != m.end() && !m["DistInstanceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DistInstanceIds"].type()) {
        DistApplicationDataResponseBodyDistInstanceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DistInstanceIds"]));
        distInstanceIds = make_shared<DistApplicationDataResponseBodyDistInstanceIds>(model1);
      }
    }
    if (m.find("DistInstanceTotalCount") != m.end() && !m["DistInstanceTotalCount"].empty()) {
      distInstanceTotalCount = make_shared<long>(boost::any_cast<long>(m["DistInstanceTotalCount"]));
    }
    if (m.find("DistResults") != m.end() && !m["DistResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["DistResults"].type()) {
        DistApplicationDataResponseBodyDistResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DistResults"]));
        distResults = make_shared<DistApplicationDataResponseBodyDistResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DistApplicationDataResponseBody() = default;
};
class DistApplicationDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DistApplicationDataResponseBody> body{};

  DistApplicationDataResponse() {}

  explicit DistApplicationDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DistApplicationDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DistApplicationDataResponseBody>(model1);
      }
    }
  }


  virtual ~DistApplicationDataResponse() = default;
};
class ExportBillDetailDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<string> startDate{};
  shared_ptr<string> version{};

  ExportBillDetailDataRequest() {}

  explicit ExportBillDetailDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ExportBillDetailDataRequest() = default;
};
class ExportBillDetailDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> filePath{};
  shared_ptr<string> requestId{};

  ExportBillDetailDataResponseBody() {}

  explicit ExportBillDetailDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExportBillDetailDataResponseBody() = default;
};
class ExportBillDetailDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ExportBillDetailDataResponseBody> body{};

  ExportBillDetailDataResponse() {}

  explicit ExportBillDetailDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportBillDetailDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportBillDetailDataResponseBody>(model1);
      }
    }
  }


  virtual ~ExportBillDetailDataResponse() = default;
};
class ExportImageRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> OSSBucket{};
  shared_ptr<string> OSSPrefix{};
  shared_ptr<string> OSSRegionId{};
  shared_ptr<string> roleName{};
  shared_ptr<string> version{};

  ExportImageRequest() {}

  explicit ExportImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (OSSBucket) {
      res["OSSBucket"] = boost::any(*OSSBucket);
    }
    if (OSSPrefix) {
      res["OSSPrefix"] = boost::any(*OSSPrefix);
    }
    if (OSSRegionId) {
      res["OSSRegionId"] = boost::any(*OSSRegionId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("OSSBucket") != m.end() && !m["OSSBucket"].empty()) {
      OSSBucket = make_shared<string>(boost::any_cast<string>(m["OSSBucket"]));
    }
    if (m.find("OSSPrefix") != m.end() && !m["OSSPrefix"].empty()) {
      OSSPrefix = make_shared<string>(boost::any_cast<string>(m["OSSPrefix"]));
    }
    if (m.find("OSSRegionId") != m.end() && !m["OSSRegionId"].empty()) {
      OSSRegionId = make_shared<string>(boost::any_cast<string>(m["OSSRegionId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ExportImageRequest() = default;
};
class ExportImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> exportedImageURL{};
  shared_ptr<string> requestId{};

  ExportImageResponseBody() {}

  explicit ExportImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exportedImageURL) {
      res["ExportedImageURL"] = boost::any(*exportedImageURL);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExportedImageURL") != m.end() && !m["ExportedImageURL"].empty()) {
      exportedImageURL = make_shared<string>(boost::any_cast<string>(m["ExportedImageURL"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExportImageResponseBody() = default;
};
class ExportImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ExportImageResponseBody> body{};

  ExportImageResponse() {}

  explicit ExportImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportImageResponseBody>(model1);
      }
    }
  }


  virtual ~ExportImageResponse() = default;
};
class ExportMeasurementDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<string> startDate{};
  shared_ptr<string> version{};

  ExportMeasurementDataRequest() {}

  explicit ExportMeasurementDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ExportMeasurementDataRequest() = default;
};
class ExportMeasurementDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> filePath{};
  shared_ptr<string> requestId{};

  ExportMeasurementDataResponseBody() {}

  explicit ExportMeasurementDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExportMeasurementDataResponseBody() = default;
};
class ExportMeasurementDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ExportMeasurementDataResponseBody> body{};

  ExportMeasurementDataResponse() {}

  explicit ExportMeasurementDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportMeasurementDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportMeasurementDataResponseBody>(model1);
      }
    }
  }


  virtual ~ExportMeasurementDataResponse() = default;
};
class GetDeviceInternetPortRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> natType{};
  shared_ptr<string> ruleId{};

  GetDeviceInternetPortRequest() {}

  explicit GetDeviceInternetPortRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (natType) {
      res["NatType"] = boost::any(*natType);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NatType") != m.end() && !m["NatType"].empty()) {
      natType = make_shared<string>(boost::any_cast<string>(m["NatType"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~GetDeviceInternetPortRequest() = default;
};
class GetDeviceInternetPortResponseBodyNetworkInfo : public Darabonba::Model {
public:
  shared_ptr<string> externalIp{};
  shared_ptr<string> externalPort{};
  shared_ptr<string> ISP{};
  shared_ptr<string> internalIp{};
  shared_ptr<string> internalPort{};
  shared_ptr<string> status{};

  GetDeviceInternetPortResponseBodyNetworkInfo() {}

  explicit GetDeviceInternetPortResponseBodyNetworkInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (externalIp) {
      res["ExternalIp"] = boost::any(*externalIp);
    }
    if (externalPort) {
      res["ExternalPort"] = boost::any(*externalPort);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (internalIp) {
      res["InternalIp"] = boost::any(*internalIp);
    }
    if (internalPort) {
      res["InternalPort"] = boost::any(*internalPort);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExternalIp") != m.end() && !m["ExternalIp"].empty()) {
      externalIp = make_shared<string>(boost::any_cast<string>(m["ExternalIp"]));
    }
    if (m.find("ExternalPort") != m.end() && !m["ExternalPort"].empty()) {
      externalPort = make_shared<string>(boost::any_cast<string>(m["ExternalPort"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("InternalIp") != m.end() && !m["InternalIp"].empty()) {
      internalIp = make_shared<string>(boost::any_cast<string>(m["InternalIp"]));
    }
    if (m.find("InternalPort") != m.end() && !m["InternalPort"].empty()) {
      internalPort = make_shared<string>(boost::any_cast<string>(m["InternalPort"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetDeviceInternetPortResponseBodyNetworkInfo() = default;
};
class GetDeviceInternetPortResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<GetDeviceInternetPortResponseBodyNetworkInfo>> networkInfo{};
  shared_ptr<string> requestId{};

  GetDeviceInternetPortResponseBody() {}

  explicit GetDeviceInternetPortResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkInfo) {
      vector<boost::any> temp1;
      for(auto item1:*networkInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInfo"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkInfo") != m.end() && !m["NetworkInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInfo"].type()) {
        vector<GetDeviceInternetPortResponseBodyNetworkInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDeviceInternetPortResponseBodyNetworkInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInfo = make_shared<vector<GetDeviceInternetPortResponseBodyNetworkInfo>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDeviceInternetPortResponseBody() = default;
};
class GetDeviceInternetPortResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetDeviceInternetPortResponseBody> body{};

  GetDeviceInternetPortResponse() {}

  explicit GetDeviceInternetPortResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeviceInternetPortResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeviceInternetPortResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeviceInternetPortResponse() = default;
};
class GetVmListRequest : public Darabonba::Model {
public:
  shared_ptr<long> aliUid{};
  shared_ptr<string> groupUuid{};
  shared_ptr<string> instanceUuid{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> workloadUuid{};

  GetVmListRequest() {}

  explicit GetVmListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (groupUuid) {
      res["GroupUuid"] = boost::any(*groupUuid);
    }
    if (instanceUuid) {
      res["InstanceUuid"] = boost::any(*instanceUuid);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (workloadUuid) {
      res["WorkloadUuid"] = boost::any(*workloadUuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("GroupUuid") != m.end() && !m["GroupUuid"].empty()) {
      groupUuid = make_shared<string>(boost::any_cast<string>(m["GroupUuid"]));
    }
    if (m.find("InstanceUuid") != m.end() && !m["InstanceUuid"].empty()) {
      instanceUuid = make_shared<string>(boost::any_cast<string>(m["InstanceUuid"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("WorkloadUuid") != m.end() && !m["WorkloadUuid"].empty()) {
      workloadUuid = make_shared<string>(boost::any_cast<string>(m["WorkloadUuid"]));
    }
  }


  virtual ~GetVmListRequest() = default;
};
class GetVmListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> desc{};
  shared_ptr<string> msg{};
  shared_ptr<string> requestId{};

  GetVmListResponseBody() {}

  explicit GetVmListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetVmListResponseBody() = default;
};
class GetVmListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetVmListResponseBody> body{};

  GetVmListResponse() {}

  explicit GetVmListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVmListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVmListResponseBody>(model1);
      }
    }
  }


  virtual ~GetVmListResponse() = default;
};
class ImportKeyPairRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyPairName{};
  shared_ptr<string> publicKeyBody{};
  shared_ptr<string> version{};

  ImportKeyPairRequest() {}

  explicit ImportKeyPairRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (publicKeyBody) {
      res["PublicKeyBody"] = boost::any(*publicKeyBody);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("PublicKeyBody") != m.end() && !m["PublicKeyBody"].empty()) {
      publicKeyBody = make_shared<string>(boost::any_cast<string>(m["PublicKeyBody"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ImportKeyPairRequest() = default;
};
class ImportKeyPairResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> keyPairFingerPrint{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> requestId{};

  ImportKeyPairResponseBody() {}

  explicit ImportKeyPairResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPairFingerPrint) {
      res["KeyPairFingerPrint"] = boost::any(*keyPairFingerPrint);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPairFingerPrint") != m.end() && !m["KeyPairFingerPrint"].empty()) {
      keyPairFingerPrint = make_shared<string>(boost::any_cast<string>(m["KeyPairFingerPrint"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ImportKeyPairResponseBody() = default;
};
class ImportKeyPairResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ImportKeyPairResponseBody> body{};

  ImportKeyPairResponse() {}

  explicit ImportKeyPairResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportKeyPairResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportKeyPairResponseBody>(model1);
      }
    }
  }


  virtual ~ImportKeyPairResponse() = default;
};
class JoinPublicIpsToEpnInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> instanceInfos{};

  JoinPublicIpsToEpnInstanceRequest() {}

  explicit JoinPublicIpsToEpnInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (instanceInfos) {
      res["InstanceInfos"] = boost::any(*instanceInfos);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("InstanceInfos") != m.end() && !m["InstanceInfos"].empty()) {
      instanceInfos = make_shared<string>(boost::any_cast<string>(m["InstanceInfos"]));
    }
  }


  virtual ~JoinPublicIpsToEpnInstanceRequest() = default;
};
class JoinPublicIpsToEpnInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  JoinPublicIpsToEpnInstanceResponseBody() {}

  explicit JoinPublicIpsToEpnInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~JoinPublicIpsToEpnInstanceResponseBody() = default;
};
class JoinPublicIpsToEpnInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<JoinPublicIpsToEpnInstanceResponseBody> body{};

  JoinPublicIpsToEpnInstanceResponse() {}

  explicit JoinPublicIpsToEpnInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        JoinPublicIpsToEpnInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<JoinPublicIpsToEpnInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~JoinPublicIpsToEpnInstanceResponse() = default;
};
class JoinSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> version{};

  JoinSecurityGroupRequest() {}

  explicit JoinSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~JoinSecurityGroupRequest() = default;
};
class JoinSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  JoinSecurityGroupResponseBody() {}

  explicit JoinSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~JoinSecurityGroupResponseBody() = default;
};
class JoinSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<JoinSecurityGroupResponseBody> body{};

  JoinSecurityGroupResponse() {}

  explicit JoinSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        JoinSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<JoinSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~JoinSecurityGroupResponse() = default;
};
class JoinVSwitchesToEpnInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> vSwitchesInfo{};

  JoinVSwitchesToEpnInstanceRequest() {}

  explicit JoinVSwitchesToEpnInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (vSwitchesInfo) {
      res["VSwitchesInfo"] = boost::any(*vSwitchesInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("VSwitchesInfo") != m.end() && !m["VSwitchesInfo"].empty()) {
      vSwitchesInfo = make_shared<string>(boost::any_cast<string>(m["VSwitchesInfo"]));
    }
  }


  virtual ~JoinVSwitchesToEpnInstanceRequest() = default;
};
class JoinVSwitchesToEpnInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  JoinVSwitchesToEpnInstanceResponseBody() {}

  explicit JoinVSwitchesToEpnInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~JoinVSwitchesToEpnInstanceResponseBody() = default;
};
class JoinVSwitchesToEpnInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<JoinVSwitchesToEpnInstanceResponseBody> body{};

  JoinVSwitchesToEpnInstanceResponse() {}

  explicit JoinVSwitchesToEpnInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        JoinVSwitchesToEpnInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<JoinVSwitchesToEpnInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~JoinVSwitchesToEpnInstanceResponse() = default;
};
class LeaveSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> version{};

  LeaveSecurityGroupRequest() {}

  explicit LeaveSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~LeaveSecurityGroupRequest() = default;
};
class LeaveSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  LeaveSecurityGroupResponseBody() {}

  explicit LeaveSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~LeaveSecurityGroupResponseBody() = default;
};
class LeaveSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<LeaveSecurityGroupResponseBody> body{};

  LeaveSecurityGroupResponse() {}

  explicit LeaveSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LeaveSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LeaveSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~LeaveSecurityGroupResponse() = default;
};
class ListApplicationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appVersions{};
  shared_ptr<string> clusterNames{};
  shared_ptr<string> level{};
  shared_ptr<string> maxDate{};
  shared_ptr<string> minDate{};
  shared_ptr<string> outAppInfoParams{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListApplicationsRequest() {}

  explicit ListApplicationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appVersions) {
      res["AppVersions"] = boost::any(*appVersions);
    }
    if (clusterNames) {
      res["ClusterNames"] = boost::any(*clusterNames);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (maxDate) {
      res["MaxDate"] = boost::any(*maxDate);
    }
    if (minDate) {
      res["MinDate"] = boost::any(*minDate);
    }
    if (outAppInfoParams) {
      res["OutAppInfoParams"] = boost::any(*outAppInfoParams);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppVersions") != m.end() && !m["AppVersions"].empty()) {
      appVersions = make_shared<string>(boost::any_cast<string>(m["AppVersions"]));
    }
    if (m.find("ClusterNames") != m.end() && !m["ClusterNames"].empty()) {
      clusterNames = make_shared<string>(boost::any_cast<string>(m["ClusterNames"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("MaxDate") != m.end() && !m["MaxDate"].empty()) {
      maxDate = make_shared<string>(boost::any_cast<string>(m["MaxDate"]));
    }
    if (m.find("MinDate") != m.end() && !m["MinDate"].empty()) {
      minDate = make_shared<string>(boost::any_cast<string>(m["MinDate"]));
    }
    if (m.find("OutAppInfoParams") != m.end() && !m["OutAppInfoParams"].empty()) {
      outAppInfoParams = make_shared<string>(boost::any_cast<string>(m["OutAppInfoParams"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListApplicationsRequest() = default;
};
class ListApplicationsResponseBodyApplicationsApplicationAppListApp : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appInfo{};

  ListApplicationsResponseBodyApplicationsApplicationAppListApp() {}

  explicit ListApplicationsResponseBodyApplicationsApplicationAppListApp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appInfo) {
      res["AppInfo"] = boost::any(*appInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppInfo") != m.end() && !m["AppInfo"].empty()) {
      appInfo = make_shared<string>(boost::any_cast<string>(m["AppInfo"]));
    }
  }


  virtual ~ListApplicationsResponseBodyApplicationsApplicationAppListApp() = default;
};
class ListApplicationsResponseBodyApplicationsApplicationAppList : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationsResponseBodyApplicationsApplicationAppListApp>> app{};

  ListApplicationsResponseBodyApplicationsApplicationAppList() {}

  explicit ListApplicationsResponseBodyApplicationsApplicationAppList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      vector<boost::any> temp1;
      for(auto item1:*app){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["App"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      if (typeid(vector<boost::any>) == m["App"].type()) {
        vector<ListApplicationsResponseBodyApplicationsApplicationAppListApp> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["App"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsResponseBodyApplicationsApplicationAppListApp model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        app = make_shared<vector<ListApplicationsResponseBodyApplicationsApplicationAppListApp>>(expect1);
      }
    }
  }


  virtual ~ListApplicationsResponseBodyApplicationsApplicationAppList() = default;
};
class ListApplicationsResponseBodyApplicationsApplication : public Darabonba::Model {
public:
  shared_ptr<ListApplicationsResponseBodyApplicationsApplicationAppList> appList{};
  shared_ptr<string> clusterName{};

  ListApplicationsResponseBodyApplicationsApplication() {}

  explicit ListApplicationsResponseBodyApplicationsApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appList) {
      res["AppList"] = appList ? boost::any(appList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppList") != m.end() && !m["AppList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppList"].type()) {
        ListApplicationsResponseBodyApplicationsApplicationAppList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppList"]));
        appList = make_shared<ListApplicationsResponseBodyApplicationsApplicationAppList>(model1);
      }
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
  }


  virtual ~ListApplicationsResponseBodyApplicationsApplication() = default;
};
class ListApplicationsResponseBodyApplications : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationsResponseBodyApplicationsApplication>> application{};

  ListApplicationsResponseBodyApplications() {}

  explicit ListApplicationsResponseBodyApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (application) {
      vector<boost::any> temp1;
      for(auto item1:*application){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Application"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      if (typeid(vector<boost::any>) == m["Application"].type()) {
        vector<ListApplicationsResponseBodyApplicationsApplication> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Application"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsResponseBodyApplicationsApplication model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        application = make_shared<vector<ListApplicationsResponseBodyApplicationsApplication>>(expect1);
      }
    }
  }


  virtual ~ListApplicationsResponseBodyApplications() = default;
};
class ListApplicationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListApplicationsResponseBodyApplications> applications{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListApplicationsResponseBody() {}

  explicit ListApplicationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applications) {
      res["Applications"] = applications ? boost::any(applications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Applications") != m.end() && !m["Applications"].empty()) {
      if (typeid(map<string, boost::any>) == m["Applications"].type()) {
        ListApplicationsResponseBodyApplications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Applications"]));
        applications = make_shared<ListApplicationsResponseBodyApplications>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListApplicationsResponseBody() = default;
};
class ListApplicationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListApplicationsResponseBody> body{};

  ListApplicationsResponse() {}

  explicit ListApplicationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationsResponse() = default;
};
class MigrateVmRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupUuid{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> instances{};
  shared_ptr<string> tenant{};

  MigrateVmRequest() {}

  explicit MigrateVmRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupUuid) {
      res["GroupUuid"] = boost::any(*groupUuid);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (instances) {
      res["Instances"] = boost::any(*instances);
    }
    if (tenant) {
      res["Tenant"] = boost::any(*tenant);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupUuid") != m.end() && !m["GroupUuid"].empty()) {
      groupUuid = make_shared<string>(boost::any_cast<string>(m["GroupUuid"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      instances = make_shared<string>(boost::any_cast<string>(m["Instances"]));
    }
    if (m.find("Tenant") != m.end() && !m["Tenant"].empty()) {
      tenant = make_shared<string>(boost::any_cast<string>(m["Tenant"]));
    }
  }


  virtual ~MigrateVmRequest() = default;
};
class MigrateVmResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> desc{};
  shared_ptr<string> msg{};
  shared_ptr<string> requestId{};

  MigrateVmResponseBody() {}

  explicit MigrateVmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MigrateVmResponseBody() = default;
};
class MigrateVmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<MigrateVmResponseBody> body{};

  MigrateVmResponse() {}

  explicit MigrateVmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MigrateVmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MigrateVmResponseBody>(model1);
      }
    }
  }


  virtual ~MigrateVmResponse() = default;
};
class ModifyEnsEipAddressAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};

  ModifyEnsEipAddressAttributeRequest() {}

  explicit ModifyEnsEipAddressAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ModifyEnsEipAddressAttributeRequest() = default;
};
class ModifyEnsEipAddressAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyEnsEipAddressAttributeResponseBody() {}

  explicit ModifyEnsEipAddressAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyEnsEipAddressAttributeResponseBody() = default;
};
class ModifyEnsEipAddressAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyEnsEipAddressAttributeResponseBody> body{};

  ModifyEnsEipAddressAttributeResponse() {}

  explicit ModifyEnsEipAddressAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyEnsEipAddressAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyEnsEipAddressAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyEnsEipAddressAttributeResponse() = default;
};
class ModifyEpnInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> EPNInstanceName{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> networkingModel{};

  ModifyEpnInstanceRequest() {}

  explicit ModifyEpnInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (EPNInstanceName) {
      res["EPNInstanceName"] = boost::any(*EPNInstanceName);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (networkingModel) {
      res["NetworkingModel"] = boost::any(*networkingModel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("EPNInstanceName") != m.end() && !m["EPNInstanceName"].empty()) {
      EPNInstanceName = make_shared<string>(boost::any_cast<string>(m["EPNInstanceName"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("NetworkingModel") != m.end() && !m["NetworkingModel"].empty()) {
      networkingModel = make_shared<string>(boost::any_cast<string>(m["NetworkingModel"]));
    }
  }


  virtual ~ModifyEpnInstanceRequest() = default;
};
class ModifyEpnInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyEpnInstanceResponseBody() {}

  explicit ModifyEpnInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyEpnInstanceResponseBody() = default;
};
class ModifyEpnInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyEpnInstanceResponseBody> body{};

  ModifyEpnInstanceResponse() {}

  explicit ModifyEpnInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyEpnInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyEpnInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyEpnInstanceResponse() = default;
};
class ModifyImageAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageId{};
  shared_ptr<string> imageName{};
  shared_ptr<string> version{};
  shared_ptr<string> product{};

  ModifyImageAttributeRequest() {}

  explicit ModifyImageAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (product) {
      res["product"] = boost::any(*product);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("product") != m.end() && !m["product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["product"]));
    }
  }


  virtual ~ModifyImageAttributeRequest() = default;
};
class ModifyImageAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  ModifyImageAttributeResponseBody() {}

  explicit ModifyImageAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyImageAttributeResponseBody() = default;
};
class ModifyImageAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyImageAttributeResponseBody> body{};

  ModifyImageAttributeResponse() {}

  explicit ModifyImageAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyImageAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyImageAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyImageAttributeResponse() = default;
};
class ModifyImageSharePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> addAccounts{};
  shared_ptr<string> imageId{};
  shared_ptr<string> removeAccounts{};

  ModifyImageSharePermissionRequest() {}

  explicit ModifyImageSharePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addAccounts) {
      res["AddAccounts"] = boost::any(*addAccounts);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (removeAccounts) {
      res["RemoveAccounts"] = boost::any(*removeAccounts);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddAccounts") != m.end() && !m["AddAccounts"].empty()) {
      addAccounts = make_shared<string>(boost::any_cast<string>(m["AddAccounts"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("RemoveAccounts") != m.end() && !m["RemoveAccounts"].empty()) {
      removeAccounts = make_shared<string>(boost::any_cast<string>(m["RemoveAccounts"]));
    }
  }


  virtual ~ModifyImageSharePermissionRequest() = default;
};
class ModifyImageSharePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyImageSharePermissionResponseBody() {}

  explicit ModifyImageSharePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyImageSharePermissionResponseBody() = default;
};
class ModifyImageSharePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyImageSharePermissionResponseBody> body{};

  ModifyImageSharePermissionResponse() {}

  explicit ModifyImageSharePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyImageSharePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyImageSharePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyImageSharePermissionResponse() = default;
};
class ModifyInstanceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> password{};
  shared_ptr<string> version{};

  ModifyInstanceAttributeRequest() {}

  explicit ModifyInstanceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ModifyInstanceAttributeRequest() = default;
};
class ModifyInstanceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  ModifyInstanceAttributeResponseBody() {}

  explicit ModifyInstanceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceAttributeResponseBody() = default;
};
class ModifyInstanceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyInstanceAttributeResponseBody> body{};

  ModifyInstanceAttributeResponse() {}

  explicit ModifyInstanceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceAttributeResponse() = default;
};
class ModifyInstanceAutoRenewAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> autoRenew{};
  shared_ptr<string> duration{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> renewalStatus{};

  ModifyInstanceAutoRenewAttributeRequest() {}

  explicit ModifyInstanceAutoRenewAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (renewalStatus) {
      res["RenewalStatus"] = boost::any(*renewalStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<string>(boost::any_cast<string>(m["AutoRenew"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RenewalStatus") != m.end() && !m["RenewalStatus"].empty()) {
      renewalStatus = make_shared<string>(boost::any_cast<string>(m["RenewalStatus"]));
    }
  }


  virtual ~ModifyInstanceAutoRenewAttributeRequest() = default;
};
class ModifyInstanceAutoRenewAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  ModifyInstanceAutoRenewAttributeResponseBody() {}

  explicit ModifyInstanceAutoRenewAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceAutoRenewAttributeResponseBody() = default;
};
class ModifyInstanceAutoRenewAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyInstanceAutoRenewAttributeResponseBody> body{};

  ModifyInstanceAutoRenewAttributeResponse() {}

  explicit ModifyInstanceAutoRenewAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceAutoRenewAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceAutoRenewAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceAutoRenewAttributeResponse() = default;
};
class ModifyLoadBalancerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> loadBalancerName{};

  ModifyLoadBalancerAttributeRequest() {}

  explicit ModifyLoadBalancerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (loadBalancerName) {
      res["LoadBalancerName"] = boost::any(*loadBalancerName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("LoadBalancerName") != m.end() && !m["LoadBalancerName"].empty()) {
      loadBalancerName = make_shared<string>(boost::any_cast<string>(m["LoadBalancerName"]));
    }
  }


  virtual ~ModifyLoadBalancerAttributeRequest() = default;
};
class ModifyLoadBalancerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyLoadBalancerAttributeResponseBody() {}

  explicit ModifyLoadBalancerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLoadBalancerAttributeResponseBody() = default;
};
class ModifyLoadBalancerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyLoadBalancerAttributeResponseBody> body{};

  ModifyLoadBalancerAttributeResponse() {}

  explicit ModifyLoadBalancerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLoadBalancerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLoadBalancerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLoadBalancerAttributeResponse() = default;
};
class ModifyNetworkAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> networkId{};
  shared_ptr<string> networkName{};

  ModifyNetworkAttributeRequest() {}

  explicit ModifyNetworkAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (networkName) {
      res["NetworkName"] = boost::any(*networkName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("NetworkName") != m.end() && !m["NetworkName"].empty()) {
      networkName = make_shared<string>(boost::any_cast<string>(m["NetworkName"]));
    }
  }


  virtual ~ModifyNetworkAttributeRequest() = default;
};
class ModifyNetworkAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyNetworkAttributeResponseBody() {}

  explicit ModifyNetworkAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyNetworkAttributeResponseBody() = default;
};
class ModifyNetworkAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyNetworkAttributeResponseBody> body{};

  ModifyNetworkAttributeResponse() {}

  explicit ModifyNetworkAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyNetworkAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyNetworkAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyNetworkAttributeResponse() = default;
};
class ModifySecurityGroupAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupName{};

  ModifySecurityGroupAttributeRequest() {}

  explicit ModifySecurityGroupAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
  }


  virtual ~ModifySecurityGroupAttributeRequest() = default;
};
class ModifySecurityGroupAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySecurityGroupAttributeResponseBody() {}

  explicit ModifySecurityGroupAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySecurityGroupAttributeResponseBody() = default;
};
class ModifySecurityGroupAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySecurityGroupAttributeResponseBody> body{};

  ModifySecurityGroupAttributeResponse() {}

  explicit ModifySecurityGroupAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySecurityGroupAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySecurityGroupAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySecurityGroupAttributeResponse() = default;
};
class ModifyVSwitchAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vSwitchName{};

  ModifyVSwitchAttributeRequest() {}

  explicit ModifyVSwitchAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
  }


  virtual ~ModifyVSwitchAttributeRequest() = default;
};
class ModifyVSwitchAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVSwitchAttributeResponseBody() {}

  explicit ModifyVSwitchAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVSwitchAttributeResponseBody() = default;
};
class ModifyVSwitchAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyVSwitchAttributeResponseBody> body{};

  ModifyVSwitchAttributeResponse() {}

  explicit ModifyVSwitchAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVSwitchAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVSwitchAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVSwitchAttributeResponse() = default;
};
class PreCreateEnsServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthType{};
  shared_ptr<string> buyResourcesDetail{};
  shared_ptr<string> dataDiskSize{};
  shared_ptr<string> ensServiceName{};
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceBandwithdLimit{};
  shared_ptr<string> instanceSpec{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> netLevel{};
  shared_ptr<string> password{};
  shared_ptr<string> schedulingPriceStrategy{};
  shared_ptr<string> schedulingStrategy{};
  shared_ptr<string> systemDiskSize{};
  shared_ptr<string> userData{};
  shared_ptr<string> version{};

  PreCreateEnsServiceRequest() {}

  explicit PreCreateEnsServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthType) {
      res["BandwidthType"] = boost::any(*bandwidthType);
    }
    if (buyResourcesDetail) {
      res["BuyResourcesDetail"] = boost::any(*buyResourcesDetail);
    }
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (ensServiceName) {
      res["EnsServiceName"] = boost::any(*ensServiceName);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceBandwithdLimit) {
      res["InstanceBandwithdLimit"] = boost::any(*instanceBandwithdLimit);
    }
    if (instanceSpec) {
      res["InstanceSpec"] = boost::any(*instanceSpec);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (netLevel) {
      res["NetLevel"] = boost::any(*netLevel);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (schedulingPriceStrategy) {
      res["SchedulingPriceStrategy"] = boost::any(*schedulingPriceStrategy);
    }
    if (schedulingStrategy) {
      res["SchedulingStrategy"] = boost::any(*schedulingStrategy);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthType") != m.end() && !m["BandwidthType"].empty()) {
      bandwidthType = make_shared<string>(boost::any_cast<string>(m["BandwidthType"]));
    }
    if (m.find("BuyResourcesDetail") != m.end() && !m["BuyResourcesDetail"].empty()) {
      buyResourcesDetail = make_shared<string>(boost::any_cast<string>(m["BuyResourcesDetail"]));
    }
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<string>(boost::any_cast<string>(m["DataDiskSize"]));
    }
    if (m.find("EnsServiceName") != m.end() && !m["EnsServiceName"].empty()) {
      ensServiceName = make_shared<string>(boost::any_cast<string>(m["EnsServiceName"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceBandwithdLimit") != m.end() && !m["InstanceBandwithdLimit"].empty()) {
      instanceBandwithdLimit = make_shared<string>(boost::any_cast<string>(m["InstanceBandwithdLimit"]));
    }
    if (m.find("InstanceSpec") != m.end() && !m["InstanceSpec"].empty()) {
      instanceSpec = make_shared<string>(boost::any_cast<string>(m["InstanceSpec"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("NetLevel") != m.end() && !m["NetLevel"].empty()) {
      netLevel = make_shared<string>(boost::any_cast<string>(m["NetLevel"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("SchedulingPriceStrategy") != m.end() && !m["SchedulingPriceStrategy"].empty()) {
      schedulingPriceStrategy = make_shared<string>(boost::any_cast<string>(m["SchedulingPriceStrategy"]));
    }
    if (m.find("SchedulingStrategy") != m.end() && !m["SchedulingStrategy"].empty()) {
      schedulingStrategy = make_shared<string>(boost::any_cast<string>(m["SchedulingStrategy"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<string>(boost::any_cast<string>(m["SystemDiskSize"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~PreCreateEnsServiceRequest() = default;
};
class PreCreateEnsServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> buyResourcesDetail{};
  shared_ptr<long> code{};
  shared_ptr<string> ensServiceId{};
  shared_ptr<string> netLevel{};
  shared_ptr<string> requestId{};

  PreCreateEnsServiceResponseBody() {}

  explicit PreCreateEnsServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buyResourcesDetail) {
      res["BuyResourcesDetail"] = boost::any(*buyResourcesDetail);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (ensServiceId) {
      res["EnsServiceId"] = boost::any(*ensServiceId);
    }
    if (netLevel) {
      res["NetLevel"] = boost::any(*netLevel);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuyResourcesDetail") != m.end() && !m["BuyResourcesDetail"].empty()) {
      buyResourcesDetail = make_shared<string>(boost::any_cast<string>(m["BuyResourcesDetail"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("EnsServiceId") != m.end() && !m["EnsServiceId"].empty()) {
      ensServiceId = make_shared<string>(boost::any_cast<string>(m["EnsServiceId"]));
    }
    if (m.find("NetLevel") != m.end() && !m["NetLevel"].empty()) {
      netLevel = make_shared<string>(boost::any_cast<string>(m["NetLevel"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PreCreateEnsServiceResponseBody() = default;
};
class PreCreateEnsServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PreCreateEnsServiceResponseBody> body{};

  PreCreateEnsServiceResponse() {}

  explicit PreCreateEnsServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PreCreateEnsServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PreCreateEnsServiceResponseBody>(model1);
      }
    }
  }


  virtual ~PreCreateEnsServiceResponse() = default;
};
class PushApplicationDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> data{};
  shared_ptr<string> pushStrategy{};
  shared_ptr<long> timeout{};

  PushApplicationDataRequest() {}

  explicit PushApplicationDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (pushStrategy) {
      res["PushStrategy"] = boost::any(*pushStrategy);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("PushStrategy") != m.end() && !m["PushStrategy"].empty()) {
      pushStrategy = make_shared<string>(boost::any_cast<string>(m["PushStrategy"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~PushApplicationDataRequest() = default;
};
class PushApplicationDataResponseBodyPushResultsPushResult : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> resultCode{};
  shared_ptr<string> resultDescrip{};
  shared_ptr<string> version{};

  PushApplicationDataResponseBodyPushResultsPushResult() {}

  explicit PushApplicationDataResponseBodyPushResultsPushResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultDescrip) {
      res["ResultDescrip"] = boost::any(*resultDescrip);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<long>(boost::any_cast<long>(m["ResultCode"]));
    }
    if (m.find("ResultDescrip") != m.end() && !m["ResultDescrip"].empty()) {
      resultDescrip = make_shared<string>(boost::any_cast<string>(m["ResultDescrip"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~PushApplicationDataResponseBodyPushResultsPushResult() = default;
};
class PushApplicationDataResponseBodyPushResults : public Darabonba::Model {
public:
  shared_ptr<vector<PushApplicationDataResponseBodyPushResultsPushResult>> pushResult{};

  PushApplicationDataResponseBodyPushResults() {}

  explicit PushApplicationDataResponseBodyPushResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushResult) {
      vector<boost::any> temp1;
      for(auto item1:*pushResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PushResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushResult") != m.end() && !m["PushResult"].empty()) {
      if (typeid(vector<boost::any>) == m["PushResult"].type()) {
        vector<PushApplicationDataResponseBodyPushResultsPushResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PushResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PushApplicationDataResponseBodyPushResultsPushResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pushResult = make_shared<vector<PushApplicationDataResponseBodyPushResultsPushResult>>(expect1);
      }
    }
  }


  virtual ~PushApplicationDataResponseBodyPushResults() = default;
};
class PushApplicationDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<PushApplicationDataResponseBodyPushResults> pushResults{};
  shared_ptr<string> requestId{};

  PushApplicationDataResponseBody() {}

  explicit PushApplicationDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushResults) {
      res["PushResults"] = pushResults ? boost::any(pushResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushResults") != m.end() && !m["PushResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["PushResults"].type()) {
        PushApplicationDataResponseBodyPushResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PushResults"]));
        pushResults = make_shared<PushApplicationDataResponseBodyPushResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PushApplicationDataResponseBody() = default;
};
class PushApplicationDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PushApplicationDataResponseBody> body{};

  PushApplicationDataResponse() {}

  explicit PushApplicationDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PushApplicationDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PushApplicationDataResponseBody>(model1);
      }
    }
  }


  virtual ~PushApplicationDataResponse() = default;
};
class ReInitDiskRequest : public Darabonba::Model {
public:
  shared_ptr<string> diskId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> version{};

  ReInitDiskRequest() {}

  explicit ReInitDiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ReInitDiskRequest() = default;
};
class ReInitDiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  ReInitDiskResponseBody() {}

  explicit ReInitDiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReInitDiskResponseBody() = default;
};
class ReInitDiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReInitDiskResponseBody> body{};

  ReInitDiskResponse() {}

  explicit ReInitDiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReInitDiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReInitDiskResponseBody>(model1);
      }
    }
  }


  virtual ~ReInitDiskResponse() = default;
};
class RebootInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> forceStop{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> version{};

  RebootInstanceRequest() {}

  explicit RebootInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forceStop) {
      res["ForceStop"] = boost::any(*forceStop);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForceStop") != m.end() && !m["ForceStop"].empty()) {
      forceStop = make_shared<string>(boost::any_cast<string>(m["ForceStop"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~RebootInstanceRequest() = default;
};
class RebootInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  RebootInstanceResponseBody() {}

  explicit RebootInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RebootInstanceResponseBody() = default;
};
class RebootInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RebootInstanceResponseBody> body{};

  RebootInstanceResponse() {}

  explicit RebootInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RebootInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RebootInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RebootInstanceResponse() = default;
};
class ReleaseEipAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> eips{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> version{};

  ReleaseEipAddressRequest() {}

  explicit ReleaseEipAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eips) {
      res["Eips"] = boost::any(*eips);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Eips") != m.end() && !m["Eips"].empty()) {
      eips = make_shared<string>(boost::any_cast<string>(m["Eips"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ReleaseEipAddressRequest() = default;
};
class ReleaseEipAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseEipAddressResponseBody() {}

  explicit ReleaseEipAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseEipAddressResponseBody() = default;
};
class ReleaseEipAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReleaseEipAddressResponseBody> body{};

  ReleaseEipAddressResponse() {}

  explicit ReleaseEipAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseEipAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseEipAddressResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseEipAddressResponse() = default;
};
class ReleaseInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ReleaseInstanceRequest() {}

  explicit ReleaseInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ReleaseInstanceRequest() = default;
};
class ReleaseInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseInstanceResponseBody() {}

  explicit ReleaseInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseInstanceResponseBody() = default;
};
class ReleaseInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReleaseInstanceResponseBody> body{};

  ReleaseInstanceResponse() {}

  explicit ReleaseInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseInstanceResponse() = default;
};
class ReleasePostPaidInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> version{};

  ReleasePostPaidInstanceRequest() {}

  explicit ReleasePostPaidInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ReleasePostPaidInstanceRequest() = default;
};
class ReleasePostPaidInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleasePostPaidInstanceResponseBody() {}

  explicit ReleasePostPaidInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleasePostPaidInstanceResponseBody() = default;
};
class ReleasePostPaidInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReleasePostPaidInstanceResponseBody> body{};

  ReleasePostPaidInstanceResponse() {}

  explicit ReleasePostPaidInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleasePostPaidInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleasePostPaidInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ReleasePostPaidInstanceResponse() = default;
};
class ReleasePrePaidInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> version{};

  ReleasePrePaidInstanceRequest() {}

  explicit ReleasePrePaidInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ReleasePrePaidInstanceRequest() = default;
};
class ReleasePrePaidInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleasePrePaidInstanceResponseBody() {}

  explicit ReleasePrePaidInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleasePrePaidInstanceResponseBody() = default;
};
class ReleasePrePaidInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReleasePrePaidInstanceResponseBody> body{};

  ReleasePrePaidInstanceResponse() {}

  explicit ReleasePrePaidInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleasePrePaidInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleasePrePaidInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ReleasePrePaidInstanceResponse() = default;
};
class RemoveBackendServersRequestBackendServers : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<long> port{};
  shared_ptr<string> serverId{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  RemoveBackendServersRequestBackendServers() {}

  explicit RemoveBackendServersRequestBackendServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~RemoveBackendServersRequestBackendServers() = default;
};
class RemoveBackendServersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<RemoveBackendServersRequestBackendServers>> backendServers{};
  shared_ptr<string> loadBalancerId{};

  RemoveBackendServersRequest() {}

  explicit RemoveBackendServersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServers) {
      vector<boost::any> temp1;
      for(auto item1:*backendServers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendServers"] = boost::any(temp1);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendServers"].type()) {
        vector<RemoveBackendServersRequestBackendServers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendServers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RemoveBackendServersRequestBackendServers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendServers = make_shared<vector<RemoveBackendServersRequestBackendServers>>(expect1);
      }
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~RemoveBackendServersRequest() = default;
};
class RemoveBackendServersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> backendServersShrink{};
  shared_ptr<string> loadBalancerId{};

  RemoveBackendServersShrinkRequest() {}

  explicit RemoveBackendServersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServersShrink) {
      res["BackendServers"] = boost::any(*backendServersShrink);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      backendServersShrink = make_shared<string>(boost::any_cast<string>(m["BackendServers"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~RemoveBackendServersShrinkRequest() = default;
};
class RemoveBackendServersResponseBodyBackendServersBackendServer : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<long> port{};
  shared_ptr<string> serverId{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  RemoveBackendServersResponseBodyBackendServersBackendServer() {}

  explicit RemoveBackendServersResponseBodyBackendServersBackendServer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~RemoveBackendServersResponseBodyBackendServersBackendServer() = default;
};
class RemoveBackendServersResponseBodyBackendServers : public Darabonba::Model {
public:
  shared_ptr<vector<RemoveBackendServersResponseBodyBackendServersBackendServer>> backendServer{};

  RemoveBackendServersResponseBodyBackendServers() {}

  explicit RemoveBackendServersResponseBodyBackendServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServer) {
      vector<boost::any> temp1;
      for(auto item1:*backendServer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendServer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServer") != m.end() && !m["BackendServer"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendServer"].type()) {
        vector<RemoveBackendServersResponseBodyBackendServersBackendServer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendServer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RemoveBackendServersResponseBodyBackendServersBackendServer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendServer = make_shared<vector<RemoveBackendServersResponseBodyBackendServersBackendServer>>(expect1);
      }
    }
  }


  virtual ~RemoveBackendServersResponseBodyBackendServers() = default;
};
class RemoveBackendServersResponseBody : public Darabonba::Model {
public:
  shared_ptr<RemoveBackendServersResponseBodyBackendServers> backendServers{};
  shared_ptr<string> requestId{};

  RemoveBackendServersResponseBody() {}

  explicit RemoveBackendServersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServers) {
      res["BackendServers"] = backendServers ? boost::any(backendServers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackendServers"].type()) {
        RemoveBackendServersResponseBodyBackendServers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackendServers"]));
        backendServers = make_shared<RemoveBackendServersResponseBodyBackendServers>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveBackendServersResponseBody() = default;
};
class RemoveBackendServersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemoveBackendServersResponseBody> body{};

  RemoveBackendServersResponse() {}

  explicit RemoveBackendServersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveBackendServersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveBackendServersResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveBackendServersResponse() = default;
};
class RemovePublicIpsFromEpnInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> instanceInfos{};

  RemovePublicIpsFromEpnInstanceRequest() {}

  explicit RemovePublicIpsFromEpnInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (instanceInfos) {
      res["InstanceInfos"] = boost::any(*instanceInfos);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("InstanceInfos") != m.end() && !m["InstanceInfos"].empty()) {
      instanceInfos = make_shared<string>(boost::any_cast<string>(m["InstanceInfos"]));
    }
  }


  virtual ~RemovePublicIpsFromEpnInstanceRequest() = default;
};
class RemovePublicIpsFromEpnInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemovePublicIpsFromEpnInstanceResponseBody() {}

  explicit RemovePublicIpsFromEpnInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemovePublicIpsFromEpnInstanceResponseBody() = default;
};
class RemovePublicIpsFromEpnInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemovePublicIpsFromEpnInstanceResponseBody> body{};

  RemovePublicIpsFromEpnInstanceResponse() {}

  explicit RemovePublicIpsFromEpnInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemovePublicIpsFromEpnInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemovePublicIpsFromEpnInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RemovePublicIpsFromEpnInstanceResponse() = default;
};
class RemoveVSwitchesFromEpnInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};
  shared_ptr<string> vSwitchesInfo{};

  RemoveVSwitchesFromEpnInstanceRequest() {}

  explicit RemoveVSwitchesFromEpnInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    if (vSwitchesInfo) {
      res["VSwitchesInfo"] = boost::any(*vSwitchesInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
    if (m.find("VSwitchesInfo") != m.end() && !m["VSwitchesInfo"].empty()) {
      vSwitchesInfo = make_shared<string>(boost::any_cast<string>(m["VSwitchesInfo"]));
    }
  }


  virtual ~RemoveVSwitchesFromEpnInstanceRequest() = default;
};
class RemoveVSwitchesFromEpnInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveVSwitchesFromEpnInstanceResponseBody() {}

  explicit RemoveVSwitchesFromEpnInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveVSwitchesFromEpnInstanceResponseBody() = default;
};
class RemoveVSwitchesFromEpnInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemoveVSwitchesFromEpnInstanceResponseBody> body{};

  RemoveVSwitchesFromEpnInstanceResponse() {}

  explicit RemoveVSwitchesFromEpnInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveVSwitchesFromEpnInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveVSwitchesFromEpnInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveVSwitchesFromEpnInstanceResponse() = default;
};
class RenewInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> period{};

  RenewInstanceRequest() {}

  explicit RenewInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
  }


  virtual ~RenewInstanceRequest() = default;
};
class RenewInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RenewInstanceResponseBody() {}

  explicit RenewInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RenewInstanceResponseBody() = default;
};
class RenewInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RenewInstanceResponseBody> body{};

  RenewInstanceResponse() {}

  explicit RenewInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenewInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenewInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RenewInstanceResponse() = default;
};
class RescaleApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> rescaleLevel{};
  shared_ptr<string> rescaleType{};
  shared_ptr<string> resourceSelector{};
  shared_ptr<long> timeout{};
  shared_ptr<string> toAppVersion{};

  RescaleApplicationRequest() {}

  explicit RescaleApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (rescaleLevel) {
      res["RescaleLevel"] = boost::any(*rescaleLevel);
    }
    if (rescaleType) {
      res["RescaleType"] = boost::any(*rescaleType);
    }
    if (resourceSelector) {
      res["ResourceSelector"] = boost::any(*resourceSelector);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (toAppVersion) {
      res["ToAppVersion"] = boost::any(*toAppVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RescaleLevel") != m.end() && !m["RescaleLevel"].empty()) {
      rescaleLevel = make_shared<string>(boost::any_cast<string>(m["RescaleLevel"]));
    }
    if (m.find("RescaleType") != m.end() && !m["RescaleType"].empty()) {
      rescaleType = make_shared<string>(boost::any_cast<string>(m["RescaleType"]));
    }
    if (m.find("ResourceSelector") != m.end() && !m["ResourceSelector"].empty()) {
      resourceSelector = make_shared<string>(boost::any_cast<string>(m["ResourceSelector"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("ToAppVersion") != m.end() && !m["ToAppVersion"].empty()) {
      toAppVersion = make_shared<string>(boost::any_cast<string>(m["ToAppVersion"]));
    }
  }


  virtual ~RescaleApplicationRequest() = default;
};
class RescaleApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RescaleApplicationResponseBody() {}

  explicit RescaleApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RescaleApplicationResponseBody() = default;
};
class RescaleApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RescaleApplicationResponseBody> body{};

  RescaleApplicationResponse() {}

  explicit RescaleApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RescaleApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RescaleApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~RescaleApplicationResponse() = default;
};
class RescaleDeviceServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> imageId{};
  shared_ptr<long> ipType{};
  shared_ptr<string> rescaleLevel{};
  shared_ptr<string> rescaleType{};
  shared_ptr<string> resourceInfo{};
  shared_ptr<string> resourceSelector{};
  shared_ptr<string> resourceSpec{};
  shared_ptr<string> serviceId{};
  shared_ptr<long> timeout{};

  RescaleDeviceServiceRequest() {}

  explicit RescaleDeviceServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (rescaleLevel) {
      res["RescaleLevel"] = boost::any(*rescaleLevel);
    }
    if (rescaleType) {
      res["RescaleType"] = boost::any(*rescaleType);
    }
    if (resourceInfo) {
      res["ResourceInfo"] = boost::any(*resourceInfo);
    }
    if (resourceSelector) {
      res["ResourceSelector"] = boost::any(*resourceSelector);
    }
    if (resourceSpec) {
      res["ResourceSpec"] = boost::any(*resourceSpec);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<long>(boost::any_cast<long>(m["IpType"]));
    }
    if (m.find("RescaleLevel") != m.end() && !m["RescaleLevel"].empty()) {
      rescaleLevel = make_shared<string>(boost::any_cast<string>(m["RescaleLevel"]));
    }
    if (m.find("RescaleType") != m.end() && !m["RescaleType"].empty()) {
      rescaleType = make_shared<string>(boost::any_cast<string>(m["RescaleType"]));
    }
    if (m.find("ResourceInfo") != m.end() && !m["ResourceInfo"].empty()) {
      resourceInfo = make_shared<string>(boost::any_cast<string>(m["ResourceInfo"]));
    }
    if (m.find("ResourceSelector") != m.end() && !m["ResourceSelector"].empty()) {
      resourceSelector = make_shared<string>(boost::any_cast<string>(m["ResourceSelector"]));
    }
    if (m.find("ResourceSpec") != m.end() && !m["ResourceSpec"].empty()) {
      resourceSpec = make_shared<string>(boost::any_cast<string>(m["ResourceSpec"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["ServiceId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~RescaleDeviceServiceRequest() = default;
};
class RescaleDeviceServiceResponseBodyResourceDetailInfos : public Darabonba::Model {
public:
  shared_ptr<string> ID{};
  shared_ptr<string> IP{};
  shared_ptr<string> ISP{};
  shared_ptr<string> mac{};
  shared_ptr<string> regionID{};
  shared_ptr<string> server{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  RescaleDeviceServiceResponseBodyResourceDetailInfos() {}

  explicit RescaleDeviceServiceResponseBodyResourceDetailInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ID) {
      res["ID"] = boost::any(*ID);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (mac) {
      res["Mac"] = boost::any(*mac);
    }
    if (regionID) {
      res["RegionID"] = boost::any(*regionID);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ID") != m.end() && !m["ID"].empty()) {
      ID = make_shared<string>(boost::any_cast<string>(m["ID"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("Mac") != m.end() && !m["Mac"].empty()) {
      mac = make_shared<string>(boost::any_cast<string>(m["Mac"]));
    }
    if (m.find("RegionID") != m.end() && !m["RegionID"].empty()) {
      regionID = make_shared<string>(boost::any_cast<string>(m["RegionID"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~RescaleDeviceServiceResponseBodyResourceDetailInfos() = default;
};
class RescaleDeviceServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deviceIds{};
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<RescaleDeviceServiceResponseBodyResourceDetailInfos>> resourceDetailInfos{};

  RescaleDeviceServiceResponseBody() {}

  explicit RescaleDeviceServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceIds) {
      res["DeviceIds"] = boost::any(*deviceIds);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceDetailInfos) {
      vector<boost::any> temp1;
      for(auto item1:*resourceDetailInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceDetailInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceIds") != m.end() && !m["DeviceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceDetailInfos") != m.end() && !m["ResourceDetailInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceDetailInfos"].type()) {
        vector<RescaleDeviceServiceResponseBodyResourceDetailInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceDetailInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RescaleDeviceServiceResponseBodyResourceDetailInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceDetailInfos = make_shared<vector<RescaleDeviceServiceResponseBodyResourceDetailInfos>>(expect1);
      }
    }
  }


  virtual ~RescaleDeviceServiceResponseBody() = default;
};
class RescaleDeviceServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RescaleDeviceServiceResponseBody> body{};

  RescaleDeviceServiceResponse() {}

  explicit RescaleDeviceServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RescaleDeviceServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RescaleDeviceServiceResponseBody>(model1);
      }
    }
  }


  virtual ~RescaleDeviceServiceResponse() = default;
};
class ResetDeviceInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceId{};

  ResetDeviceInstanceRequest() {}

  explicit ResetDeviceInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ResetDeviceInstanceRequest() = default;
};
class ResetDeviceInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResetDeviceInstanceResponseBody() {}

  explicit ResetDeviceInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetDeviceInstanceResponseBody() = default;
};
class ResetDeviceInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ResetDeviceInstanceResponseBody> body{};

  ResetDeviceInstanceResponse() {}

  explicit ResetDeviceInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetDeviceInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetDeviceInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ResetDeviceInstanceResponse() = default;
};
class RestartDeviceInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> instanceId{};

  RestartDeviceInstanceRequest() {}

  explicit RestartDeviceInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~RestartDeviceInstanceRequest() = default;
};
class RestartDeviceInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RestartDeviceInstanceResponseBody() {}

  explicit RestartDeviceInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RestartDeviceInstanceResponseBody() = default;
};
class RestartDeviceInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RestartDeviceInstanceResponseBody> body{};

  RestartDeviceInstanceResponse() {}

  explicit RestartDeviceInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartDeviceInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartDeviceInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RestartDeviceInstanceResponse() = default;
};
class RevokeSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> sourceCidrIp{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> version{};

  RevokeSecurityGroupRequest() {}

  explicit RevokeSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~RevokeSecurityGroupRequest() = default;
};
class RevokeSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeSecurityGroupResponseBody() {}

  explicit RevokeSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeSecurityGroupResponseBody() = default;
};
class RevokeSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RevokeSecurityGroupResponseBody> body{};

  RevokeSecurityGroupResponse() {}

  explicit RevokeSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeSecurityGroupResponse() = default;
};
class RevokeSecurityGroupEgressRequest : public Darabonba::Model {
public:
  shared_ptr<string> destCidrIp{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> policy{};
  shared_ptr<string> portRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> version{};

  RevokeSecurityGroupEgressRequest() {}

  explicit RevokeSecurityGroupEgressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destCidrIp) {
      res["DestCidrIp"] = boost::any(*destCidrIp);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestCidrIp") != m.end() && !m["DestCidrIp"].empty()) {
      destCidrIp = make_shared<string>(boost::any_cast<string>(m["DestCidrIp"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~RevokeSecurityGroupEgressRequest() = default;
};
class RevokeSecurityGroupEgressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeSecurityGroupEgressResponseBody() {}

  explicit RevokeSecurityGroupEgressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeSecurityGroupEgressResponseBody() = default;
};
class RevokeSecurityGroupEgressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RevokeSecurityGroupEgressResponseBody> body{};

  RevokeSecurityGroupEgressResponse() {}

  explicit RevokeSecurityGroupEgressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeSecurityGroupEgressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeSecurityGroupEgressResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeSecurityGroupEgressResponse() = default;
};
class RollbackApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> fromAppVersion{};
  shared_ptr<long> timeout{};
  shared_ptr<string> toAppVersion{};

  RollbackApplicationRequest() {}

  explicit RollbackApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (fromAppVersion) {
      res["FromAppVersion"] = boost::any(*fromAppVersion);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (toAppVersion) {
      res["ToAppVersion"] = boost::any(*toAppVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("FromAppVersion") != m.end() && !m["FromAppVersion"].empty()) {
      fromAppVersion = make_shared<string>(boost::any_cast<string>(m["FromAppVersion"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("ToAppVersion") != m.end() && !m["ToAppVersion"].empty()) {
      toAppVersion = make_shared<string>(boost::any_cast<string>(m["ToAppVersion"]));
    }
  }


  virtual ~RollbackApplicationRequest() = default;
};
class RollbackApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RollbackApplicationResponseBody() {}

  explicit RollbackApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RollbackApplicationResponseBody() = default;
};
class RollbackApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RollbackApplicationResponseBody> body{};

  RollbackApplicationResponse() {}

  explicit RollbackApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RollbackApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RollbackApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~RollbackApplicationResponse() = default;
};
class RunInstancesRequestDataDisk : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> size{};

  RunInstancesRequestDataDisk() {}

  explicit RunInstancesRequestDataDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~RunInstancesRequestDataDisk() = default;
};
class RunInstancesRequestSystemDisk : public Darabonba::Model {
public:
  shared_ptr<long> size{};

  RunInstancesRequestSystemDisk() {}

  explicit RunInstancesRequestSystemDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~RunInstancesRequestSystemDisk() = default;
};
class RunInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> carrier{};
  shared_ptr<vector<RunInstancesRequestDataDisk>> dataDisk{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> netDistrictCode{};
  shared_ptr<string> netWorkId{};
  shared_ptr<string> password{};
  shared_ptr<long> period{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> scheduleAreaLevel{};
  shared_ptr<string> schedulingPriceStrategy{};
  shared_ptr<string> schedulingStrategy{};
  shared_ptr<string> securityId{};
  shared_ptr<RunInstancesRequestSystemDisk> systemDisk{};
  shared_ptr<bool> uniqueSuffix{};
  shared_ptr<string> userData{};
  shared_ptr<string> vSwitchId{};

  RunInstancesRequest() {}

  explicit RunInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (carrier) {
      res["Carrier"] = boost::any(*carrier);
    }
    if (dataDisk) {
      vector<boost::any> temp1;
      for(auto item1:*dataDisk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDisk"] = boost::any(temp1);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (netDistrictCode) {
      res["NetDistrictCode"] = boost::any(*netDistrictCode);
    }
    if (netWorkId) {
      res["NetWorkId"] = boost::any(*netWorkId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (scheduleAreaLevel) {
      res["ScheduleAreaLevel"] = boost::any(*scheduleAreaLevel);
    }
    if (schedulingPriceStrategy) {
      res["SchedulingPriceStrategy"] = boost::any(*schedulingPriceStrategy);
    }
    if (schedulingStrategy) {
      res["SchedulingStrategy"] = boost::any(*schedulingStrategy);
    }
    if (securityId) {
      res["SecurityId"] = boost::any(*securityId);
    }
    if (systemDisk) {
      res["SystemDisk"] = systemDisk ? boost::any(systemDisk->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (uniqueSuffix) {
      res["UniqueSuffix"] = boost::any(*uniqueSuffix);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("Carrier") != m.end() && !m["Carrier"].empty()) {
      carrier = make_shared<string>(boost::any_cast<string>(m["Carrier"]));
    }
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDisk"].type()) {
        vector<RunInstancesRequestDataDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDisk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunInstancesRequestDataDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDisk = make_shared<vector<RunInstancesRequestDataDisk>>(expect1);
      }
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("NetDistrictCode") != m.end() && !m["NetDistrictCode"].empty()) {
      netDistrictCode = make_shared<string>(boost::any_cast<string>(m["NetDistrictCode"]));
    }
    if (m.find("NetWorkId") != m.end() && !m["NetWorkId"].empty()) {
      netWorkId = make_shared<string>(boost::any_cast<string>(m["NetWorkId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("ScheduleAreaLevel") != m.end() && !m["ScheduleAreaLevel"].empty()) {
      scheduleAreaLevel = make_shared<string>(boost::any_cast<string>(m["ScheduleAreaLevel"]));
    }
    if (m.find("SchedulingPriceStrategy") != m.end() && !m["SchedulingPriceStrategy"].empty()) {
      schedulingPriceStrategy = make_shared<string>(boost::any_cast<string>(m["SchedulingPriceStrategy"]));
    }
    if (m.find("SchedulingStrategy") != m.end() && !m["SchedulingStrategy"].empty()) {
      schedulingStrategy = make_shared<string>(boost::any_cast<string>(m["SchedulingStrategy"]));
    }
    if (m.find("SecurityId") != m.end() && !m["SecurityId"].empty()) {
      securityId = make_shared<string>(boost::any_cast<string>(m["SecurityId"]));
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemDisk"].type()) {
        RunInstancesRequestSystemDisk model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemDisk"]));
        systemDisk = make_shared<RunInstancesRequestSystemDisk>(model1);
      }
    }
    if (m.find("UniqueSuffix") != m.end() && !m["UniqueSuffix"].empty()) {
      uniqueSuffix = make_shared<bool>(boost::any_cast<bool>(m["UniqueSuffix"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~RunInstancesRequest() = default;
};
class RunInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> carrier{};
  shared_ptr<string> dataDiskShrink{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidthOut{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> netDistrictCode{};
  shared_ptr<string> netWorkId{};
  shared_ptr<string> password{};
  shared_ptr<long> period{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> scheduleAreaLevel{};
  shared_ptr<string> schedulingPriceStrategy{};
  shared_ptr<string> schedulingStrategy{};
  shared_ptr<string> securityId{};
  shared_ptr<string> systemDiskShrink{};
  shared_ptr<bool> uniqueSuffix{};
  shared_ptr<string> userData{};
  shared_ptr<string> vSwitchId{};

  RunInstancesShrinkRequest() {}

  explicit RunInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (carrier) {
      res["Carrier"] = boost::any(*carrier);
    }
    if (dataDiskShrink) {
      res["DataDisk"] = boost::any(*dataDiskShrink);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidthOut) {
      res["InternetMaxBandwidthOut"] = boost::any(*internetMaxBandwidthOut);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (netDistrictCode) {
      res["NetDistrictCode"] = boost::any(*netDistrictCode);
    }
    if (netWorkId) {
      res["NetWorkId"] = boost::any(*netWorkId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (scheduleAreaLevel) {
      res["ScheduleAreaLevel"] = boost::any(*scheduleAreaLevel);
    }
    if (schedulingPriceStrategy) {
      res["SchedulingPriceStrategy"] = boost::any(*schedulingPriceStrategy);
    }
    if (schedulingStrategy) {
      res["SchedulingStrategy"] = boost::any(*schedulingStrategy);
    }
    if (securityId) {
      res["SecurityId"] = boost::any(*securityId);
    }
    if (systemDiskShrink) {
      res["SystemDisk"] = boost::any(*systemDiskShrink);
    }
    if (uniqueSuffix) {
      res["UniqueSuffix"] = boost::any(*uniqueSuffix);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("Carrier") != m.end() && !m["Carrier"].empty()) {
      carrier = make_shared<string>(boost::any_cast<string>(m["Carrier"]));
    }
    if (m.find("DataDisk") != m.end() && !m["DataDisk"].empty()) {
      dataDiskShrink = make_shared<string>(boost::any_cast<string>(m["DataDisk"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidthOut") != m.end() && !m["InternetMaxBandwidthOut"].empty()) {
      internetMaxBandwidthOut = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidthOut"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("NetDistrictCode") != m.end() && !m["NetDistrictCode"].empty()) {
      netDistrictCode = make_shared<string>(boost::any_cast<string>(m["NetDistrictCode"]));
    }
    if (m.find("NetWorkId") != m.end() && !m["NetWorkId"].empty()) {
      netWorkId = make_shared<string>(boost::any_cast<string>(m["NetWorkId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("ScheduleAreaLevel") != m.end() && !m["ScheduleAreaLevel"].empty()) {
      scheduleAreaLevel = make_shared<string>(boost::any_cast<string>(m["ScheduleAreaLevel"]));
    }
    if (m.find("SchedulingPriceStrategy") != m.end() && !m["SchedulingPriceStrategy"].empty()) {
      schedulingPriceStrategy = make_shared<string>(boost::any_cast<string>(m["SchedulingPriceStrategy"]));
    }
    if (m.find("SchedulingStrategy") != m.end() && !m["SchedulingStrategy"].empty()) {
      schedulingStrategy = make_shared<string>(boost::any_cast<string>(m["SchedulingStrategy"]));
    }
    if (m.find("SecurityId") != m.end() && !m["SecurityId"].empty()) {
      securityId = make_shared<string>(boost::any_cast<string>(m["SecurityId"]));
    }
    if (m.find("SystemDisk") != m.end() && !m["SystemDisk"].empty()) {
      systemDiskShrink = make_shared<string>(boost::any_cast<string>(m["SystemDisk"]));
    }
    if (m.find("UniqueSuffix") != m.end() && !m["UniqueSuffix"].empty()) {
      uniqueSuffix = make_shared<bool>(boost::any_cast<bool>(m["UniqueSuffix"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~RunInstancesShrinkRequest() = default;
};
class RunInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  RunInstancesResponseBody() {}

  explicit RunInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunInstancesResponseBody() = default;
};
class RunInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RunInstancesResponseBody> body{};

  RunInstancesResponse() {}

  explicit RunInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~RunInstancesResponse() = default;
};
class RunServiceScheduleRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> directorys{};
  shared_ptr<string> podConfigName{};
  shared_ptr<long> preLockedTimeout{};
  shared_ptr<string> scheduleStrategy{};
  shared_ptr<string> serviceAction{};
  shared_ptr<string> serviceCommands{};
  shared_ptr<string> uuid{};

  RunServiceScheduleRequest() {}

  explicit RunServiceScheduleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (directorys) {
      res["Directorys"] = boost::any(*directorys);
    }
    if (podConfigName) {
      res["PodConfigName"] = boost::any(*podConfigName);
    }
    if (preLockedTimeout) {
      res["PreLockedTimeout"] = boost::any(*preLockedTimeout);
    }
    if (scheduleStrategy) {
      res["ScheduleStrategy"] = boost::any(*scheduleStrategy);
    }
    if (serviceAction) {
      res["ServiceAction"] = boost::any(*serviceAction);
    }
    if (serviceCommands) {
      res["ServiceCommands"] = boost::any(*serviceCommands);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("Directorys") != m.end() && !m["Directorys"].empty()) {
      directorys = make_shared<string>(boost::any_cast<string>(m["Directorys"]));
    }
    if (m.find("PodConfigName") != m.end() && !m["PodConfigName"].empty()) {
      podConfigName = make_shared<string>(boost::any_cast<string>(m["PodConfigName"]));
    }
    if (m.find("PreLockedTimeout") != m.end() && !m["PreLockedTimeout"].empty()) {
      preLockedTimeout = make_shared<long>(boost::any_cast<long>(m["PreLockedTimeout"]));
    }
    if (m.find("ScheduleStrategy") != m.end() && !m["ScheduleStrategy"].empty()) {
      scheduleStrategy = make_shared<string>(boost::any_cast<string>(m["ScheduleStrategy"]));
    }
    if (m.find("ServiceAction") != m.end() && !m["ServiceAction"].empty()) {
      serviceAction = make_shared<string>(boost::any_cast<string>(m["ServiceAction"]));
    }
    if (m.find("ServiceCommands") != m.end() && !m["ServiceCommands"].empty()) {
      serviceCommands = make_shared<string>(boost::any_cast<string>(m["ServiceCommands"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~RunServiceScheduleRequest() = default;
};
class RunServiceScheduleResponseBodyCommandResultsCommandResult : public Darabonba::Model {
public:
  shared_ptr<string> command{};
  shared_ptr<string> containerName{};
  shared_ptr<string> resultMsg{};

  RunServiceScheduleResponseBodyCommandResultsCommandResult() {}

  explicit RunServiceScheduleResponseBodyCommandResultsCommandResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (containerName) {
      res["ContainerName"] = boost::any(*containerName);
    }
    if (resultMsg) {
      res["ResultMsg"] = boost::any(*resultMsg);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("ContainerName") != m.end() && !m["ContainerName"].empty()) {
      containerName = make_shared<string>(boost::any_cast<string>(m["ContainerName"]));
    }
    if (m.find("ResultMsg") != m.end() && !m["ResultMsg"].empty()) {
      resultMsg = make_shared<string>(boost::any_cast<string>(m["ResultMsg"]));
    }
  }


  virtual ~RunServiceScheduleResponseBodyCommandResultsCommandResult() = default;
};
class RunServiceScheduleResponseBodyCommandResults : public Darabonba::Model {
public:
  shared_ptr<vector<RunServiceScheduleResponseBodyCommandResultsCommandResult>> commandResult{};

  RunServiceScheduleResponseBodyCommandResults() {}

  explicit RunServiceScheduleResponseBodyCommandResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commandResult) {
      vector<boost::any> temp1;
      for(auto item1:*commandResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CommandResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommandResult") != m.end() && !m["CommandResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CommandResult"].type()) {
        vector<RunServiceScheduleResponseBodyCommandResultsCommandResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CommandResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunServiceScheduleResponseBodyCommandResultsCommandResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        commandResult = make_shared<vector<RunServiceScheduleResponseBodyCommandResultsCommandResult>>(expect1);
      }
    }
  }


  virtual ~RunServiceScheduleResponseBodyCommandResults() = default;
};
class RunServiceScheduleResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunServiceScheduleResponseBodyCommandResults> commandResults{};
  shared_ptr<long> index{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceIp{};
  shared_ptr<long> instancePort{};
  shared_ptr<string> requestId{};
  shared_ptr<string> requestRepeated{};
  shared_ptr<bool> tcpPorts{};

  RunServiceScheduleResponseBody() {}

  explicit RunServiceScheduleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commandResults) {
      res["CommandResults"] = commandResults ? boost::any(commandResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceIp) {
      res["InstanceIp"] = boost::any(*instanceIp);
    }
    if (instancePort) {
      res["InstancePort"] = boost::any(*instancePort);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestRepeated) {
      res["RequestRepeated"] = boost::any(*requestRepeated);
    }
    if (tcpPorts) {
      res["TcpPorts"] = boost::any(*tcpPorts);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommandResults") != m.end() && !m["CommandResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommandResults"].type()) {
        RunServiceScheduleResponseBodyCommandResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommandResults"]));
        commandResults = make_shared<RunServiceScheduleResponseBodyCommandResults>(model1);
      }
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceIp") != m.end() && !m["InstanceIp"].empty()) {
      instanceIp = make_shared<string>(boost::any_cast<string>(m["InstanceIp"]));
    }
    if (m.find("InstancePort") != m.end() && !m["InstancePort"].empty()) {
      instancePort = make_shared<long>(boost::any_cast<long>(m["InstancePort"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestRepeated") != m.end() && !m["RequestRepeated"].empty()) {
      requestRepeated = make_shared<string>(boost::any_cast<string>(m["RequestRepeated"]));
    }
    if (m.find("TcpPorts") != m.end() && !m["TcpPorts"].empty()) {
      tcpPorts = make_shared<bool>(boost::any_cast<bool>(m["TcpPorts"]));
    }
  }


  virtual ~RunServiceScheduleResponseBody() = default;
};
class RunServiceScheduleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RunServiceScheduleResponseBody> body{};

  RunServiceScheduleResponse() {}

  explicit RunServiceScheduleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunServiceScheduleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunServiceScheduleResponseBody>(model1);
      }
    }
  }


  virtual ~RunServiceScheduleResponse() = default;
};
class SchedulePodRequest : public Darabonba::Model {
public:
  shared_ptr<long> aliUid{};
  shared_ptr<string> areaCodes{};
  shared_ptr<string> groupUuid{};
  shared_ptr<string> isps{};
  shared_ptr<string> labels{};
  shared_ptr<string> regions{};
  shared_ptr<string> requirements{};
  shared_ptr<string> resourceAttribute{};
  shared_ptr<string> tenant{};
  shared_ptr<string> workloadUuid{};

  SchedulePodRequest() {}

  explicit SchedulePodRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (areaCodes) {
      res["AreaCodes"] = boost::any(*areaCodes);
    }
    if (groupUuid) {
      res["GroupUuid"] = boost::any(*groupUuid);
    }
    if (isps) {
      res["Isps"] = boost::any(*isps);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (regions) {
      res["Regions"] = boost::any(*regions);
    }
    if (requirements) {
      res["Requirements"] = boost::any(*requirements);
    }
    if (resourceAttribute) {
      res["ResourceAttribute"] = boost::any(*resourceAttribute);
    }
    if (tenant) {
      res["Tenant"] = boost::any(*tenant);
    }
    if (workloadUuid) {
      res["WorkloadUuid"] = boost::any(*workloadUuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("AreaCodes") != m.end() && !m["AreaCodes"].empty()) {
      areaCodes = make_shared<string>(boost::any_cast<string>(m["AreaCodes"]));
    }
    if (m.find("GroupUuid") != m.end() && !m["GroupUuid"].empty()) {
      groupUuid = make_shared<string>(boost::any_cast<string>(m["GroupUuid"]));
    }
    if (m.find("Isps") != m.end() && !m["Isps"].empty()) {
      isps = make_shared<string>(boost::any_cast<string>(m["Isps"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      regions = make_shared<string>(boost::any_cast<string>(m["Regions"]));
    }
    if (m.find("Requirements") != m.end() && !m["Requirements"].empty()) {
      requirements = make_shared<string>(boost::any_cast<string>(m["Requirements"]));
    }
    if (m.find("ResourceAttribute") != m.end() && !m["ResourceAttribute"].empty()) {
      resourceAttribute = make_shared<string>(boost::any_cast<string>(m["ResourceAttribute"]));
    }
    if (m.find("Tenant") != m.end() && !m["Tenant"].empty()) {
      tenant = make_shared<string>(boost::any_cast<string>(m["Tenant"]));
    }
    if (m.find("WorkloadUuid") != m.end() && !m["WorkloadUuid"].empty()) {
      workloadUuid = make_shared<string>(boost::any_cast<string>(m["WorkloadUuid"]));
    }
  }


  virtual ~SchedulePodRequest() = default;
};
class SchedulePodResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> desc{};
  shared_ptr<string> msg{};
  shared_ptr<string> requestId{};

  SchedulePodResponseBody() {}

  explicit SchedulePodResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SchedulePodResponseBody() = default;
};
class SchedulePodResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SchedulePodResponseBody> body{};

  SchedulePodResponse() {}

  explicit SchedulePodResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SchedulePodResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SchedulePodResponseBody>(model1);
      }
    }
  }


  virtual ~SchedulePodResponse() = default;
};
class SetBackendServersRequestBackendServers : public Darabonba::Model {
public:
  shared_ptr<string> serverId{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  SetBackendServersRequestBackendServers() {}

  explicit SetBackendServersRequestBackendServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~SetBackendServersRequestBackendServers() = default;
};
class SetBackendServersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<SetBackendServersRequestBackendServers>> backendServers{};
  shared_ptr<string> loadBalancerId{};

  SetBackendServersRequest() {}

  explicit SetBackendServersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServers) {
      vector<boost::any> temp1;
      for(auto item1:*backendServers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendServers"] = boost::any(temp1);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendServers"].type()) {
        vector<SetBackendServersRequestBackendServers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendServers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetBackendServersRequestBackendServers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendServers = make_shared<vector<SetBackendServersRequestBackendServers>>(expect1);
      }
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~SetBackendServersRequest() = default;
};
class SetBackendServersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> backendServersShrink{};
  shared_ptr<string> loadBalancerId{};

  SetBackendServersShrinkRequest() {}

  explicit SetBackendServersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServersShrink) {
      res["BackendServers"] = boost::any(*backendServersShrink);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      backendServersShrink = make_shared<string>(boost::any_cast<string>(m["BackendServers"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~SetBackendServersShrinkRequest() = default;
};
class SetBackendServersResponseBodyBackendServersBackendServer : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<long> port{};
  shared_ptr<string> serverId{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  SetBackendServersResponseBodyBackendServersBackendServer() {}

  explicit SetBackendServersResponseBodyBackendServersBackendServer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~SetBackendServersResponseBodyBackendServersBackendServer() = default;
};
class SetBackendServersResponseBodyBackendServers : public Darabonba::Model {
public:
  shared_ptr<vector<SetBackendServersResponseBodyBackendServersBackendServer>> backendServer{};

  SetBackendServersResponseBodyBackendServers() {}

  explicit SetBackendServersResponseBodyBackendServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServer) {
      vector<boost::any> temp1;
      for(auto item1:*backendServer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendServer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServer") != m.end() && !m["BackendServer"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendServer"].type()) {
        vector<SetBackendServersResponseBodyBackendServersBackendServer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendServer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetBackendServersResponseBodyBackendServersBackendServer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendServer = make_shared<vector<SetBackendServersResponseBodyBackendServersBackendServer>>(expect1);
      }
    }
  }


  virtual ~SetBackendServersResponseBodyBackendServers() = default;
};
class SetBackendServersResponseBody : public Darabonba::Model {
public:
  shared_ptr<SetBackendServersResponseBodyBackendServers> backendServers{};
  shared_ptr<string> requestId{};

  SetBackendServersResponseBody() {}

  explicit SetBackendServersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServers) {
      res["BackendServers"] = backendServers ? boost::any(backendServers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackendServers"].type()) {
        SetBackendServersResponseBodyBackendServers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackendServers"]));
        backendServers = make_shared<SetBackendServersResponseBodyBackendServers>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetBackendServersResponseBody() = default;
};
class SetBackendServersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetBackendServersResponseBody> body{};

  SetBackendServersResponse() {}

  explicit SetBackendServersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetBackendServersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetBackendServersResponseBody>(model1);
      }
    }
  }


  virtual ~SetBackendServersResponse() = default;
};
class SetLoadBalancerHTTPListenerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> healthCheck{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckMethod{};
  shared_ptr<long> healthCheckTimeout{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<long> requestTimeout{};
  shared_ptr<string> scheduler{};
  shared_ptr<long> unhealthyThreshold{};

  SetLoadBalancerHTTPListenerAttributeRequest() {}

  explicit SetLoadBalancerHTTPListenerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckMethod) {
      res["HealthCheckMethod"] = boost::any(*healthCheckMethod);
    }
    if (healthCheckTimeout) {
      res["HealthCheckTimeout"] = boost::any(*healthCheckTimeout);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (requestTimeout) {
      res["RequestTimeout"] = boost::any(*requestTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckMethod") != m.end() && !m["HealthCheckMethod"].empty()) {
      healthCheckMethod = make_shared<string>(boost::any_cast<string>(m["HealthCheckMethod"]));
    }
    if (m.find("HealthCheckTimeout") != m.end() && !m["HealthCheckTimeout"].empty()) {
      healthCheckTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckTimeout"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("RequestTimeout") != m.end() && !m["RequestTimeout"].empty()) {
      requestTimeout = make_shared<long>(boost::any_cast<long>(m["RequestTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~SetLoadBalancerHTTPListenerAttributeRequest() = default;
};
class SetLoadBalancerHTTPListenerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLoadBalancerHTTPListenerAttributeResponseBody() {}

  explicit SetLoadBalancerHTTPListenerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLoadBalancerHTTPListenerAttributeResponseBody() = default;
};
class SetLoadBalancerHTTPListenerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetLoadBalancerHTTPListenerAttributeResponseBody> body{};

  SetLoadBalancerHTTPListenerAttributeResponse() {}

  explicit SetLoadBalancerHTTPListenerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLoadBalancerHTTPListenerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLoadBalancerHTTPListenerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~SetLoadBalancerHTTPListenerAttributeResponse() = default;
};
class SetLoadBalancerHTTPSListenerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> healthCheck{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckMethod{};
  shared_ptr<long> healthCheckTimeout{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> idleTimeout{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<long> requestTimeout{};
  shared_ptr<string> scheduler{};
  shared_ptr<string> serverCertificateId{};
  shared_ptr<long> unhealthyThreshold{};

  SetLoadBalancerHTTPSListenerAttributeRequest() {}

  explicit SetLoadBalancerHTTPSListenerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckMethod) {
      res["HealthCheckMethod"] = boost::any(*healthCheckMethod);
    }
    if (healthCheckTimeout) {
      res["HealthCheckTimeout"] = boost::any(*healthCheckTimeout);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (idleTimeout) {
      res["IdleTimeout"] = boost::any(*idleTimeout);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (requestTimeout) {
      res["RequestTimeout"] = boost::any(*requestTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (serverCertificateId) {
      res["ServerCertificateId"] = boost::any(*serverCertificateId);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckMethod") != m.end() && !m["HealthCheckMethod"].empty()) {
      healthCheckMethod = make_shared<string>(boost::any_cast<string>(m["HealthCheckMethod"]));
    }
    if (m.find("HealthCheckTimeout") != m.end() && !m["HealthCheckTimeout"].empty()) {
      healthCheckTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckTimeout"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("IdleTimeout") != m.end() && !m["IdleTimeout"].empty()) {
      idleTimeout = make_shared<long>(boost::any_cast<long>(m["IdleTimeout"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("RequestTimeout") != m.end() && !m["RequestTimeout"].empty()) {
      requestTimeout = make_shared<long>(boost::any_cast<long>(m["RequestTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("ServerCertificateId") != m.end() && !m["ServerCertificateId"].empty()) {
      serverCertificateId = make_shared<string>(boost::any_cast<string>(m["ServerCertificateId"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~SetLoadBalancerHTTPSListenerAttributeRequest() = default;
};
class SetLoadBalancerHTTPSListenerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLoadBalancerHTTPSListenerAttributeResponseBody() {}

  explicit SetLoadBalancerHTTPSListenerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLoadBalancerHTTPSListenerAttributeResponseBody() = default;
};
class SetLoadBalancerHTTPSListenerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetLoadBalancerHTTPSListenerAttributeResponseBody> body{};

  SetLoadBalancerHTTPSListenerAttributeResponse() {}

  explicit SetLoadBalancerHTTPSListenerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLoadBalancerHTTPSListenerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLoadBalancerHTTPSListenerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~SetLoadBalancerHTTPSListenerAttributeResponse() = default;
};
class SetLoadBalancerStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> loadBalancerStatus{};

  SetLoadBalancerStatusRequest() {}

  explicit SetLoadBalancerStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (loadBalancerStatus) {
      res["LoadBalancerStatus"] = boost::any(*loadBalancerStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("LoadBalancerStatus") != m.end() && !m["LoadBalancerStatus"].empty()) {
      loadBalancerStatus = make_shared<string>(boost::any_cast<string>(m["LoadBalancerStatus"]));
    }
  }


  virtual ~SetLoadBalancerStatusRequest() = default;
};
class SetLoadBalancerStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLoadBalancerStatusResponseBody() {}

  explicit SetLoadBalancerStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLoadBalancerStatusResponseBody() = default;
};
class SetLoadBalancerStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetLoadBalancerStatusResponseBody> body{};

  SetLoadBalancerStatusResponse() {}

  explicit SetLoadBalancerStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLoadBalancerStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLoadBalancerStatusResponseBody>(model1);
      }
    }
  }


  virtual ~SetLoadBalancerStatusResponse() = default;
};
class SetLoadBalancerTCPListenerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> eipTransmit{};
  shared_ptr<long> establishedTimeout{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<long> healthCheckConnectTimeout{};
  shared_ptr<string> healthCheckDomain{};
  shared_ptr<string> healthCheckHttpCode{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckType{};
  shared_ptr<string> healthCheckURI{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<long> persistenceTimeout{};
  shared_ptr<string> scheduler{};
  shared_ptr<long> unhealthyThreshold{};

  SetLoadBalancerTCPListenerAttributeRequest() {}

  explicit SetLoadBalancerTCPListenerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eipTransmit) {
      res["EipTransmit"] = boost::any(*eipTransmit);
    }
    if (establishedTimeout) {
      res["EstablishedTimeout"] = boost::any(*establishedTimeout);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckConnectTimeout) {
      res["HealthCheckConnectTimeout"] = boost::any(*healthCheckConnectTimeout);
    }
    if (healthCheckDomain) {
      res["HealthCheckDomain"] = boost::any(*healthCheckDomain);
    }
    if (healthCheckHttpCode) {
      res["HealthCheckHttpCode"] = boost::any(*healthCheckHttpCode);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckType) {
      res["HealthCheckType"] = boost::any(*healthCheckType);
    }
    if (healthCheckURI) {
      res["HealthCheckURI"] = boost::any(*healthCheckURI);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (persistenceTimeout) {
      res["PersistenceTimeout"] = boost::any(*persistenceTimeout);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EipTransmit") != m.end() && !m["EipTransmit"].empty()) {
      eipTransmit = make_shared<string>(boost::any_cast<string>(m["EipTransmit"]));
    }
    if (m.find("EstablishedTimeout") != m.end() && !m["EstablishedTimeout"].empty()) {
      establishedTimeout = make_shared<long>(boost::any_cast<long>(m["EstablishedTimeout"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckConnectTimeout") != m.end() && !m["HealthCheckConnectTimeout"].empty()) {
      healthCheckConnectTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectTimeout"]));
    }
    if (m.find("HealthCheckDomain") != m.end() && !m["HealthCheckDomain"].empty()) {
      healthCheckDomain = make_shared<string>(boost::any_cast<string>(m["HealthCheckDomain"]));
    }
    if (m.find("HealthCheckHttpCode") != m.end() && !m["HealthCheckHttpCode"].empty()) {
      healthCheckHttpCode = make_shared<string>(boost::any_cast<string>(m["HealthCheckHttpCode"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckType") != m.end() && !m["HealthCheckType"].empty()) {
      healthCheckType = make_shared<string>(boost::any_cast<string>(m["HealthCheckType"]));
    }
    if (m.find("HealthCheckURI") != m.end() && !m["HealthCheckURI"].empty()) {
      healthCheckURI = make_shared<string>(boost::any_cast<string>(m["HealthCheckURI"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("PersistenceTimeout") != m.end() && !m["PersistenceTimeout"].empty()) {
      persistenceTimeout = make_shared<long>(boost::any_cast<long>(m["PersistenceTimeout"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~SetLoadBalancerTCPListenerAttributeRequest() = default;
};
class SetLoadBalancerTCPListenerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLoadBalancerTCPListenerAttributeResponseBody() {}

  explicit SetLoadBalancerTCPListenerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLoadBalancerTCPListenerAttributeResponseBody() = default;
};
class SetLoadBalancerTCPListenerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetLoadBalancerTCPListenerAttributeResponseBody> body{};

  SetLoadBalancerTCPListenerAttributeResponse() {}

  explicit SetLoadBalancerTCPListenerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLoadBalancerTCPListenerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLoadBalancerTCPListenerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~SetLoadBalancerTCPListenerAttributeResponse() = default;
};
class SetLoadBalancerUDPListenerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> eipTransmit{};
  shared_ptr<long> healthCheckConnectPort{};
  shared_ptr<long> healthCheckConnectTimeout{};
  shared_ptr<string> healthCheckExp{};
  shared_ptr<long> healthCheckInterval{};
  shared_ptr<string> healthCheckReq{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};
  shared_ptr<string> scheduler{};
  shared_ptr<long> unhealthyThreshold{};

  SetLoadBalancerUDPListenerAttributeRequest() {}

  explicit SetLoadBalancerUDPListenerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eipTransmit) {
      res["EipTransmit"] = boost::any(*eipTransmit);
    }
    if (healthCheckConnectPort) {
      res["HealthCheckConnectPort"] = boost::any(*healthCheckConnectPort);
    }
    if (healthCheckConnectTimeout) {
      res["HealthCheckConnectTimeout"] = boost::any(*healthCheckConnectTimeout);
    }
    if (healthCheckExp) {
      res["HealthCheckExp"] = boost::any(*healthCheckExp);
    }
    if (healthCheckInterval) {
      res["HealthCheckInterval"] = boost::any(*healthCheckInterval);
    }
    if (healthCheckReq) {
      res["HealthCheckReq"] = boost::any(*healthCheckReq);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    if (scheduler) {
      res["Scheduler"] = boost::any(*scheduler);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EipTransmit") != m.end() && !m["EipTransmit"].empty()) {
      eipTransmit = make_shared<string>(boost::any_cast<string>(m["EipTransmit"]));
    }
    if (m.find("HealthCheckConnectPort") != m.end() && !m["HealthCheckConnectPort"].empty()) {
      healthCheckConnectPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectPort"]));
    }
    if (m.find("HealthCheckConnectTimeout") != m.end() && !m["HealthCheckConnectTimeout"].empty()) {
      healthCheckConnectTimeout = make_shared<long>(boost::any_cast<long>(m["HealthCheckConnectTimeout"]));
    }
    if (m.find("HealthCheckExp") != m.end() && !m["HealthCheckExp"].empty()) {
      healthCheckExp = make_shared<string>(boost::any_cast<string>(m["HealthCheckExp"]));
    }
    if (m.find("HealthCheckInterval") != m.end() && !m["HealthCheckInterval"].empty()) {
      healthCheckInterval = make_shared<long>(boost::any_cast<long>(m["HealthCheckInterval"]));
    }
    if (m.find("HealthCheckReq") != m.end() && !m["HealthCheckReq"].empty()) {
      healthCheckReq = make_shared<string>(boost::any_cast<string>(m["HealthCheckReq"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
    if (m.find("Scheduler") != m.end() && !m["Scheduler"].empty()) {
      scheduler = make_shared<string>(boost::any_cast<string>(m["Scheduler"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~SetLoadBalancerUDPListenerAttributeRequest() = default;
};
class SetLoadBalancerUDPListenerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLoadBalancerUDPListenerAttributeResponseBody() {}

  explicit SetLoadBalancerUDPListenerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLoadBalancerUDPListenerAttributeResponseBody() = default;
};
class SetLoadBalancerUDPListenerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetLoadBalancerUDPListenerAttributeResponseBody> body{};

  SetLoadBalancerUDPListenerAttributeResponse() {}

  explicit SetLoadBalancerUDPListenerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLoadBalancerUDPListenerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLoadBalancerUDPListenerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~SetLoadBalancerUDPListenerAttributeResponse() = default;
};
class StartEpnInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};

  StartEpnInstanceRequest() {}

  explicit StartEpnInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
  }


  virtual ~StartEpnInstanceRequest() = default;
};
class StartEpnInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartEpnInstanceResponseBody() {}

  explicit StartEpnInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartEpnInstanceResponseBody() = default;
};
class StartEpnInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartEpnInstanceResponseBody> body{};

  StartEpnInstanceResponse() {}

  explicit StartEpnInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartEpnInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartEpnInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StartEpnInstanceResponse() = default;
};
class StartInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> version{};

  StartInstanceRequest() {}

  explicit StartInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~StartInstanceRequest() = default;
};
class StartInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  StartInstanceResponseBody() {}

  explicit StartInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartInstanceResponseBody() = default;
};
class StartInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartInstanceResponseBody> body{};

  StartInstanceResponse() {}

  explicit StartInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StartInstanceResponse() = default;
};
class StartLoadBalancerListenerRequest : public Darabonba::Model {
public:
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};

  StartLoadBalancerListenerRequest() {}

  explicit StartLoadBalancerListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~StartLoadBalancerListenerRequest() = default;
};
class StartLoadBalancerListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartLoadBalancerListenerResponseBody() {}

  explicit StartLoadBalancerListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartLoadBalancerListenerResponseBody() = default;
};
class StartLoadBalancerListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartLoadBalancerListenerResponseBody> body{};

  StartLoadBalancerListenerResponse() {}

  explicit StartLoadBalancerListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartLoadBalancerListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartLoadBalancerListenerResponseBody>(model1);
      }
    }
  }


  virtual ~StartLoadBalancerListenerResponse() = default;
};
class StopEpnInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> EPNInstanceId{};

  StopEpnInstanceRequest() {}

  explicit StopEpnInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (EPNInstanceId) {
      res["EPNInstanceId"] = boost::any(*EPNInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EPNInstanceId") != m.end() && !m["EPNInstanceId"].empty()) {
      EPNInstanceId = make_shared<string>(boost::any_cast<string>(m["EPNInstanceId"]));
    }
  }


  virtual ~StopEpnInstanceRequest() = default;
};
class StopEpnInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopEpnInstanceResponseBody() {}

  explicit StopEpnInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopEpnInstanceResponseBody() = default;
};
class StopEpnInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StopEpnInstanceResponseBody> body{};

  StopEpnInstanceResponse() {}

  explicit StopEpnInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopEpnInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopEpnInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StopEpnInstanceResponse() = default;
};
class StopInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> forceStop{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> version{};

  StopInstanceRequest() {}

  explicit StopInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forceStop) {
      res["ForceStop"] = boost::any(*forceStop);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForceStop") != m.end() && !m["ForceStop"].empty()) {
      forceStop = make_shared<string>(boost::any_cast<string>(m["ForceStop"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~StopInstanceRequest() = default;
};
class StopInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};

  StopInstanceResponseBody() {}

  explicit StopInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopInstanceResponseBody() = default;
};
class StopInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StopInstanceResponseBody> body{};

  StopInstanceResponse() {}

  explicit StopInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StopInstanceResponse() = default;
};
class StopLoadBalancerListenerRequest : public Darabonba::Model {
public:
  shared_ptr<long> listenerPort{};
  shared_ptr<string> loadBalancerId{};

  StopLoadBalancerListenerRequest() {}

  explicit StopLoadBalancerListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    if (loadBalancerId) {
      res["LoadBalancerId"] = boost::any(*loadBalancerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
    if (m.find("LoadBalancerId") != m.end() && !m["LoadBalancerId"].empty()) {
      loadBalancerId = make_shared<string>(boost::any_cast<string>(m["LoadBalancerId"]));
    }
  }


  virtual ~StopLoadBalancerListenerRequest() = default;
};
class StopLoadBalancerListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopLoadBalancerListenerResponseBody() {}

  explicit StopLoadBalancerListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopLoadBalancerListenerResponseBody() = default;
};
class StopLoadBalancerListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StopLoadBalancerListenerResponseBody> body{};

  StopLoadBalancerListenerResponse() {}

  explicit StopLoadBalancerListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopLoadBalancerListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopLoadBalancerListenerResponseBody>(model1);
      }
    }
  }


  virtual ~StopLoadBalancerListenerResponse() = default;
};
class UnAssociateEnsEipAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};

  UnAssociateEnsEipAddressRequest() {}

  explicit UnAssociateEnsEipAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
  }


  virtual ~UnAssociateEnsEipAddressRequest() = default;
};
class UnAssociateEnsEipAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnAssociateEnsEipAddressResponseBody() {}

  explicit UnAssociateEnsEipAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnAssociateEnsEipAddressResponseBody() = default;
};
class UnAssociateEnsEipAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnAssociateEnsEipAddressResponseBody> body{};

  UnAssociateEnsEipAddressResponse() {}

  explicit UnAssociateEnsEipAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnAssociateEnsEipAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnAssociateEnsEipAddressResponseBody>(model1);
      }
    }
  }


  virtual ~UnAssociateEnsEipAddressResponse() = default;
};
class UnassociateEipAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> eip{};
  shared_ptr<string> ensRegionId{};
  shared_ptr<string> instanceIdInternetIp{};
  shared_ptr<string> version{};

  UnassociateEipAddressRequest() {}

  explicit UnassociateEipAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eip) {
      res["Eip"] = boost::any(*eip);
    }
    if (ensRegionId) {
      res["EnsRegionId"] = boost::any(*ensRegionId);
    }
    if (instanceIdInternetIp) {
      res["InstanceIdInternetIp"] = boost::any(*instanceIdInternetIp);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Eip") != m.end() && !m["Eip"].empty()) {
      eip = make_shared<string>(boost::any_cast<string>(m["Eip"]));
    }
    if (m.find("EnsRegionId") != m.end() && !m["EnsRegionId"].empty()) {
      ensRegionId = make_shared<string>(boost::any_cast<string>(m["EnsRegionId"]));
    }
    if (m.find("InstanceIdInternetIp") != m.end() && !m["InstanceIdInternetIp"].empty()) {
      instanceIdInternetIp = make_shared<string>(boost::any_cast<string>(m["InstanceIdInternetIp"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~UnassociateEipAddressRequest() = default;
};
class UnassociateEipAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnassociateEipAddressResponseBody() {}

  explicit UnassociateEipAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnassociateEipAddressResponseBody() = default;
};
class UnassociateEipAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnassociateEipAddressResponseBody> body{};

  UnassociateEipAddressResponse() {}

  explicit UnassociateEipAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnassociateEipAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnassociateEipAddressResponseBody>(model1);
      }
    }
  }


  virtual ~UnassociateEipAddressResponse() = default;
};
class UpgradeApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> template_{};
  shared_ptr<long> timeout{};

  UpgradeApplicationRequest() {}

  explicit UpgradeApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~UpgradeApplicationRequest() = default;
};
class UpgradeApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpgradeApplicationResponseBody() {}

  explicit UpgradeApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpgradeApplicationResponseBody() = default;
};
class UpgradeApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpgradeApplicationResponseBody> body{};

  UpgradeApplicationResponse() {}

  explicit UpgradeApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeApplicationResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddBackendServersResponse addBackendServersWithOptions(shared_ptr<AddBackendServersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddBackendServersResponse addBackendServers(shared_ptr<AddBackendServersRequest> request);
  AddDeviceInternetPortResponse addDeviceInternetPortWithOptions(shared_ptr<AddDeviceInternetPortRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDeviceInternetPortResponse addDeviceInternetPort(shared_ptr<AddDeviceInternetPortRequest> request);
  AddNetworkInterfaceToInstanceResponse addNetworkInterfaceToInstanceWithOptions(shared_ptr<AddNetworkInterfaceToInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddNetworkInterfaceToInstanceResponse addNetworkInterfaceToInstance(shared_ptr<AddNetworkInterfaceToInstanceRequest> request);
  AllocateEipAddressResponse allocateEipAddressWithOptions(shared_ptr<AllocateEipAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AllocateEipAddressResponse allocateEipAddress(shared_ptr<AllocateEipAddressRequest> request);
  AssociateEipAddressResponse associateEipAddressWithOptions(shared_ptr<AssociateEipAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateEipAddressResponse associateEipAddress(shared_ptr<AssociateEipAddressRequest> request);
  AssociateEnsEipAddressResponse associateEnsEipAddressWithOptions(shared_ptr<AssociateEnsEipAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateEnsEipAddressResponse associateEnsEipAddress(shared_ptr<AssociateEnsEipAddressRequest> request);
  AttachDiskResponse attachDiskWithOptions(shared_ptr<AttachDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachDiskResponse attachDisk(shared_ptr<AttachDiskRequest> request);
  AttachEnsInstancesResponse attachEnsInstancesWithOptions(shared_ptr<AttachEnsInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachEnsInstancesResponse attachEnsInstances(shared_ptr<AttachEnsInstancesRequest> request);
  AuthorizeSecurityGroupResponse authorizeSecurityGroupWithOptions(shared_ptr<AuthorizeSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AuthorizeSecurityGroupResponse authorizeSecurityGroup(shared_ptr<AuthorizeSecurityGroupRequest> request);
  AuthorizeSecurityGroupEgressResponse authorizeSecurityGroupEgressWithOptions(shared_ptr<AuthorizeSecurityGroupEgressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AuthorizeSecurityGroupEgressResponse authorizeSecurityGroupEgress(shared_ptr<AuthorizeSecurityGroupEgressRequest> request);
  CheckQuotaResponse checkQuotaWithOptions(shared_ptr<CheckQuotaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckQuotaResponse checkQuota(shared_ptr<CheckQuotaRequest> request);
  ConfigureSecurityGroupPermissionsResponse configureSecurityGroupPermissionsWithOptions(shared_ptr<ConfigureSecurityGroupPermissionsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigureSecurityGroupPermissionsResponse configureSecurityGroupPermissions(shared_ptr<ConfigureSecurityGroupPermissionsRequest> request);
  CreateApplicationResponse createApplicationWithOptions(shared_ptr<CreateApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApplicationResponse createApplication(shared_ptr<CreateApplicationRequest> request);
  CreateDiskResponse createDiskWithOptions(shared_ptr<CreateDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDiskResponse createDisk(shared_ptr<CreateDiskRequest> request);
  CreateDiskBuyOrderResponse createDiskBuyOrderWithOptions(shared_ptr<CreateDiskBuyOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDiskBuyOrderResponse createDiskBuyOrder(shared_ptr<CreateDiskBuyOrderRequest> request);
  CreateEPInstanceResponse createEPInstanceWithOptions(shared_ptr<CreateEPInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEPInstanceResponse createEPInstance(shared_ptr<CreateEPInstanceRequest> request);
  CreateEipInstanceResponse createEipInstanceWithOptions(shared_ptr<CreateEipInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEipInstanceResponse createEipInstance(shared_ptr<CreateEipInstanceRequest> request);
  CreateElbBuyOrderResponse createElbBuyOrderWithOptions(shared_ptr<CreateElbBuyOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateElbBuyOrderResponse createElbBuyOrder(shared_ptr<CreateElbBuyOrderRequest> request);
  CreateEnsServiceResponse createEnsServiceWithOptions(shared_ptr<CreateEnsServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEnsServiceResponse createEnsService(shared_ptr<CreateEnsServiceRequest> request);
  CreateEpnInstanceResponse createEpnInstanceWithOptions(shared_ptr<CreateEpnInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEpnInstanceResponse createEpnInstance(shared_ptr<CreateEpnInstanceRequest> request);
  CreateImageResponse createImageWithOptions(shared_ptr<CreateImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateImageResponse createImage(shared_ptr<CreateImageRequest> request);
  CreateInstanceResponse createInstanceWithOptions(shared_ptr<CreateInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateInstanceResponse createInstance(shared_ptr<CreateInstanceRequest> request);
  CreateKeyPairResponse createKeyPairWithOptions(shared_ptr<CreateKeyPairRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateKeyPairResponse createKeyPair(shared_ptr<CreateKeyPairRequest> request);
  CreateLoadBalancerResponse createLoadBalancerWithOptions(shared_ptr<CreateLoadBalancerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLoadBalancerResponse createLoadBalancer(shared_ptr<CreateLoadBalancerRequest> request);
  CreateLoadBalancerHTTPListenerResponse createLoadBalancerHTTPListenerWithOptions(shared_ptr<CreateLoadBalancerHTTPListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLoadBalancerHTTPListenerResponse createLoadBalancerHTTPListener(shared_ptr<CreateLoadBalancerHTTPListenerRequest> request);
  CreateLoadBalancerHTTPSListenerResponse createLoadBalancerHTTPSListenerWithOptions(shared_ptr<CreateLoadBalancerHTTPSListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLoadBalancerHTTPSListenerResponse createLoadBalancerHTTPSListener(shared_ptr<CreateLoadBalancerHTTPSListenerRequest> request);
  CreateLoadBalancerTCPListenerResponse createLoadBalancerTCPListenerWithOptions(shared_ptr<CreateLoadBalancerTCPListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLoadBalancerTCPListenerResponse createLoadBalancerTCPListener(shared_ptr<CreateLoadBalancerTCPListenerRequest> request);
  CreateLoadBalancerUDPListenerResponse createLoadBalancerUDPListenerWithOptions(shared_ptr<CreateLoadBalancerUDPListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLoadBalancerUDPListenerResponse createLoadBalancerUDPListener(shared_ptr<CreateLoadBalancerUDPListenerRequest> request);
  CreateNetworkResponse createNetworkWithOptions(shared_ptr<CreateNetworkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNetworkResponse createNetwork(shared_ptr<CreateNetworkRequest> request);
  CreateSecurityGroupResponse createSecurityGroupWithOptions(shared_ptr<CreateSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSecurityGroupResponse createSecurityGroup(shared_ptr<CreateSecurityGroupRequest> request);
  CreateVSwitchResponse createVSwitchWithOptions(shared_ptr<CreateVSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVSwitchResponse createVSwitch(shared_ptr<CreateVSwitchRequest> request);
  CreateVmAndSaveStockResponse createVmAndSaveStockWithOptions(shared_ptr<CreateVmAndSaveStockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVmAndSaveStockResponse createVmAndSaveStock(shared_ptr<CreateVmAndSaveStockRequest> request);
  DeleteApplicationResponse deleteApplicationWithOptions(shared_ptr<DeleteApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApplicationResponse deleteApplication(shared_ptr<DeleteApplicationRequest> request);
  DeleteDeviceInternetPortResponse deleteDeviceInternetPortWithOptions(shared_ptr<DeleteDeviceInternetPortRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceInternetPortResponse deleteDeviceInternetPort(shared_ptr<DeleteDeviceInternetPortRequest> request);
  DeleteEpnInstanceResponse deleteEpnInstanceWithOptions(shared_ptr<DeleteEpnInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEpnInstanceResponse deleteEpnInstance(shared_ptr<DeleteEpnInstanceRequest> request);
  DeleteKeyPairsResponse deleteKeyPairsWithOptions(shared_ptr<DeleteKeyPairsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteKeyPairsResponse deleteKeyPairs(shared_ptr<DeleteKeyPairsRequest> request);
  DeleteLoadBalancerListenerResponse deleteLoadBalancerListenerWithOptions(shared_ptr<DeleteLoadBalancerListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLoadBalancerListenerResponse deleteLoadBalancerListener(shared_ptr<DeleteLoadBalancerListenerRequest> request);
  DeleteNetworkResponse deleteNetworkWithOptions(shared_ptr<DeleteNetworkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNetworkResponse deleteNetwork(shared_ptr<DeleteNetworkRequest> request);
  DeleteSecurityGroupResponse deleteSecurityGroupWithOptions(shared_ptr<DeleteSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSecurityGroupResponse deleteSecurityGroup(shared_ptr<DeleteSecurityGroupRequest> request);
  DeleteVSwitchResponse deleteVSwitchWithOptions(shared_ptr<DeleteVSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVSwitchResponse deleteVSwitch(shared_ptr<DeleteVSwitchRequest> request);
  DeleteVmResponse deleteVmWithOptions(shared_ptr<DeleteVmRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVmResponse deleteVm(shared_ptr<DeleteVmRequest> request);
  DescribeApplicationResponse describeApplicationWithOptions(shared_ptr<DescribeApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApplicationResponse describeApplication(shared_ptr<DescribeApplicationRequest> request);
  DescribeApplicationResourceSummaryResponse describeApplicationResourceSummaryWithOptions(shared_ptr<DescribeApplicationResourceSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApplicationResourceSummaryResponse describeApplicationResourceSummary(shared_ptr<DescribeApplicationResourceSummaryRequest> request);
  DescribeAvailableResourceResponse describeAvailableResourceWithOptions(shared_ptr<DescribeAvailableResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAvailableResourceResponse describeAvailableResource(shared_ptr<DescribeAvailableResourceRequest> request);
  DescribeAvailableResourceInfoResponse describeAvailableResourceInfoWithOptions(shared_ptr<DescribeAvailableResourceInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAvailableResourceInfoResponse describeAvailableResourceInfo(shared_ptr<DescribeAvailableResourceInfoRequest> request);
  DescribeBandWithdChargeTypeResponse describeBandWithdChargeTypeWithOptions(shared_ptr<DescribeBandWithdChargeTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBandWithdChargeTypeResponse describeBandWithdChargeType(shared_ptr<DescribeBandWithdChargeTypeRequest> request);
  DescribeBandwitdhByInternetChargeTypeResponse describeBandwitdhByInternetChargeTypeWithOptions(shared_ptr<DescribeBandwitdhByInternetChargeTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBandwitdhByInternetChargeTypeResponse describeBandwitdhByInternetChargeType(shared_ptr<DescribeBandwitdhByInternetChargeTypeRequest> request);
  DescribeCloudDiskAvailableResourceInfoResponse describeCloudDiskAvailableResourceInfoWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudDiskAvailableResourceInfoResponse describeCloudDiskAvailableResourceInfo();
  DescribeCloudDiskTypesResponse describeCloudDiskTypesWithOptions(shared_ptr<DescribeCloudDiskTypesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudDiskTypesResponse describeCloudDiskTypes(shared_ptr<DescribeCloudDiskTypesRequest> request);
  DescribeCreatePrePaidInstanceResultResponse describeCreatePrePaidInstanceResultWithOptions(shared_ptr<DescribeCreatePrePaidInstanceResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCreatePrePaidInstanceResultResponse describeCreatePrePaidInstanceResult(shared_ptr<DescribeCreatePrePaidInstanceResultRequest> request);
  DescribeDataDistResultResponse describeDataDistResultWithOptions(shared_ptr<DescribeDataDistResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDataDistResultResponse describeDataDistResult(shared_ptr<DescribeDataDistResultRequest> request);
  DescribeDataDownloadURLResponse describeDataDownloadURLWithOptions(shared_ptr<DescribeDataDownloadURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDataDownloadURLResponse describeDataDownloadURL(shared_ptr<DescribeDataDownloadURLRequest> request);
  DescribeDataPushResultResponse describeDataPushResultWithOptions(shared_ptr<DescribeDataPushResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDataPushResultResponse describeDataPushResult(shared_ptr<DescribeDataPushResultRequest> request);
  DescribeDeviceServiceResponse describeDeviceServiceWithOptions(shared_ptr<DescribeDeviceServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeviceServiceResponse describeDeviceService(shared_ptr<DescribeDeviceServiceRequest> request);
  DescribeDisksResponse describeDisksWithOptions(shared_ptr<DescribeDisksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDisksResponse describeDisks(shared_ptr<DescribeDisksRequest> request);
  DescribeEipAddressesResponse describeEipAddressesWithOptions(shared_ptr<DescribeEipAddressesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEipAddressesResponse describeEipAddresses(shared_ptr<DescribeEipAddressesRequest> request);
  DescribeElbAvailableResourceInfoResponse describeElbAvailableResourceInfoWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeElbAvailableResourceInfoResponse describeElbAvailableResourceInfo();
  DescribeEnsEipAddressesResponse describeEnsEipAddressesWithOptions(shared_ptr<DescribeEnsEipAddressesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsEipAddressesResponse describeEnsEipAddresses(shared_ptr<DescribeEnsEipAddressesRequest> request);
  DescribeEnsNetDistrictResponse describeEnsNetDistrictWithOptions(shared_ptr<DescribeEnsNetDistrictRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsNetDistrictResponse describeEnsNetDistrict(shared_ptr<DescribeEnsNetDistrictRequest> request);
  DescribeEnsNetLevelResponse describeEnsNetLevelWithOptions(shared_ptr<DescribeEnsNetLevelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsNetLevelResponse describeEnsNetLevel(shared_ptr<DescribeEnsNetLevelRequest> request);
  DescribeEnsNetSaleDistrictResponse describeEnsNetSaleDistrictWithOptions(shared_ptr<DescribeEnsNetSaleDistrictRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsNetSaleDistrictResponse describeEnsNetSaleDistrict(shared_ptr<DescribeEnsNetSaleDistrictRequest> request);
  DescribeEnsRegionIdIpv6InfoResponse describeEnsRegionIdIpv6InfoWithOptions(shared_ptr<DescribeEnsRegionIdIpv6InfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsRegionIdIpv6InfoResponse describeEnsRegionIdIpv6Info(shared_ptr<DescribeEnsRegionIdIpv6InfoRequest> request);
  DescribeEnsRegionIdResourceResponse describeEnsRegionIdResourceWithOptions(shared_ptr<DescribeEnsRegionIdResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsRegionIdResourceResponse describeEnsRegionIdResource(shared_ptr<DescribeEnsRegionIdResourceRequest> request);
  DescribeEnsRegionsResponse describeEnsRegionsWithOptions(shared_ptr<DescribeEnsRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsRegionsResponse describeEnsRegions(shared_ptr<DescribeEnsRegionsRequest> request);
  DescribeEnsResourceUsageResponse describeEnsResourceUsageWithOptions(shared_ptr<DescribeEnsResourceUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEnsResourceUsageResponse describeEnsResourceUsage(shared_ptr<DescribeEnsResourceUsageRequest> request);
  DescribeEpnBandWidthDataResponse describeEpnBandWidthDataWithOptions(shared_ptr<DescribeEpnBandWidthDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEpnBandWidthDataResponse describeEpnBandWidthData(shared_ptr<DescribeEpnBandWidthDataRequest> request);
  DescribeEpnBandwitdhByInternetChargeTypeResponse describeEpnBandwitdhByInternetChargeTypeWithOptions(shared_ptr<DescribeEpnBandwitdhByInternetChargeTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEpnBandwitdhByInternetChargeTypeResponse describeEpnBandwitdhByInternetChargeType(shared_ptr<DescribeEpnBandwitdhByInternetChargeTypeRequest> request);
  DescribeEpnInstanceAttributeResponse describeEpnInstanceAttributeWithOptions(shared_ptr<DescribeEpnInstanceAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEpnInstanceAttributeResponse describeEpnInstanceAttribute(shared_ptr<DescribeEpnInstanceAttributeRequest> request);
  DescribeEpnInstancesResponse describeEpnInstancesWithOptions(shared_ptr<DescribeEpnInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEpnInstancesResponse describeEpnInstances(shared_ptr<DescribeEpnInstancesRequest> request);
  DescribeEpnMeasurementDataResponse describeEpnMeasurementDataWithOptions(shared_ptr<DescribeEpnMeasurementDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEpnMeasurementDataResponse describeEpnMeasurementData(shared_ptr<DescribeEpnMeasurementDataRequest> request);
  DescribeExportImageInfoResponse describeExportImageInfoWithOptions(shared_ptr<DescribeExportImageInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExportImageInfoResponse describeExportImageInfo(shared_ptr<DescribeExportImageInfoRequest> request);
  DescribeExportImageStatusResponse describeExportImageStatusWithOptions(shared_ptr<DescribeExportImageStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExportImageStatusResponse describeExportImageStatus(shared_ptr<DescribeExportImageStatusRequest> request);
  DescribeImageInfosResponse describeImageInfosWithOptions(shared_ptr<DescribeImageInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageInfosResponse describeImageInfos(shared_ptr<DescribeImageInfosRequest> request);
  DescribeImageSharePermissionResponse describeImageSharePermissionWithOptions(shared_ptr<DescribeImageSharePermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageSharePermissionResponse describeImageSharePermission(shared_ptr<DescribeImageSharePermissionRequest> request);
  DescribeImagesResponse describeImagesWithOptions(shared_ptr<DescribeImagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImagesResponse describeImages(shared_ptr<DescribeImagesRequest> request);
  DescribeInstanceAutoRenewAttributeResponse describeInstanceAutoRenewAttributeWithOptions(shared_ptr<DescribeInstanceAutoRenewAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceAutoRenewAttributeResponse describeInstanceAutoRenewAttribute(shared_ptr<DescribeInstanceAutoRenewAttributeRequest> request);
  DescribeInstanceMonitorDataResponse describeInstanceMonitorDataWithOptions(shared_ptr<DescribeInstanceMonitorDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceMonitorDataResponse describeInstanceMonitorData(shared_ptr<DescribeInstanceMonitorDataRequest> request);
  DescribeInstanceSpecResponse describeInstanceSpecWithOptions(shared_ptr<DescribeInstanceSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceSpecResponse describeInstanceSpec(shared_ptr<DescribeInstanceSpecRequest> request);
  DescribeInstanceTypesResponse describeInstanceTypesWithOptions(shared_ptr<DescribeInstanceTypesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceTypesResponse describeInstanceTypes(shared_ptr<DescribeInstanceTypesRequest> request);
  DescribeInstanceVncUrlResponse describeInstanceVncUrlWithOptions(shared_ptr<DescribeInstanceVncUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceVncUrlResponse describeInstanceVncUrl(shared_ptr<DescribeInstanceVncUrlRequest> request);
  DescribeInstancesResponse describeInstancesWithOptions(shared_ptr<DescribeInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstancesResponse describeInstances(shared_ptr<DescribeInstancesRequest> request);
  DescribeKeyPairsResponse describeKeyPairsWithOptions(shared_ptr<DescribeKeyPairsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeKeyPairsResponse describeKeyPairs(shared_ptr<DescribeKeyPairsRequest> request);
  DescribeLoadBalancerAttributeResponse describeLoadBalancerAttributeWithOptions(shared_ptr<DescribeLoadBalancerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoadBalancerAttributeResponse describeLoadBalancerAttribute(shared_ptr<DescribeLoadBalancerAttributeRequest> request);
  DescribeLoadBalancerHTTPListenerAttributeResponse describeLoadBalancerHTTPListenerAttributeWithOptions(shared_ptr<DescribeLoadBalancerHTTPListenerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoadBalancerHTTPListenerAttributeResponse describeLoadBalancerHTTPListenerAttribute(shared_ptr<DescribeLoadBalancerHTTPListenerAttributeRequest> request);
  DescribeLoadBalancerHTTPSListenerAttributeResponse describeLoadBalancerHTTPSListenerAttributeWithOptions(shared_ptr<DescribeLoadBalancerHTTPSListenerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoadBalancerHTTPSListenerAttributeResponse describeLoadBalancerHTTPSListenerAttribute(shared_ptr<DescribeLoadBalancerHTTPSListenerAttributeRequest> request);
  DescribeLoadBalancerSpecResponse describeLoadBalancerSpecWithOptions(shared_ptr<DescribeLoadBalancerSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoadBalancerSpecResponse describeLoadBalancerSpec(shared_ptr<DescribeLoadBalancerSpecRequest> request);
  DescribeLoadBalancerTCPListenerAttributeResponse describeLoadBalancerTCPListenerAttributeWithOptions(shared_ptr<DescribeLoadBalancerTCPListenerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoadBalancerTCPListenerAttributeResponse describeLoadBalancerTCPListenerAttribute(shared_ptr<DescribeLoadBalancerTCPListenerAttributeRequest> request);
  DescribeLoadBalancerUDPListenerAttributeResponse describeLoadBalancerUDPListenerAttributeWithOptions(shared_ptr<DescribeLoadBalancerUDPListenerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoadBalancerUDPListenerAttributeResponse describeLoadBalancerUDPListenerAttribute(shared_ptr<DescribeLoadBalancerUDPListenerAttributeRequest> request);
  DescribeLoadBalancersResponse describeLoadBalancersWithOptions(shared_ptr<DescribeLoadBalancersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoadBalancersResponse describeLoadBalancers(shared_ptr<DescribeLoadBalancersRequest> request);
  DescribeMeasurementDataResponse describeMeasurementDataWithOptions(shared_ptr<DescribeMeasurementDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeasurementDataResponse describeMeasurementData(shared_ptr<DescribeMeasurementDataRequest> request);
  DescribeNetworkAttributeResponse describeNetworkAttributeWithOptions(shared_ptr<DescribeNetworkAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworkAttributeResponse describeNetworkAttribute(shared_ptr<DescribeNetworkAttributeRequest> request);
  DescribeNetworkInterfacesResponse describeNetworkInterfacesWithOptions(shared_ptr<DescribeNetworkInterfacesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworkInterfacesResponse describeNetworkInterfaces(shared_ptr<DescribeNetworkInterfacesRequest> request);
  DescribeNetworksResponse describeNetworksWithOptions(shared_ptr<DescribeNetworksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworksResponse describeNetworks(shared_ptr<DescribeNetworksRequest> request);
  DescribePrePaidInstanceStockResponse describePrePaidInstanceStockWithOptions(shared_ptr<DescribePrePaidInstanceStockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePrePaidInstanceStockResponse describePrePaidInstanceStock(shared_ptr<DescribePrePaidInstanceStockRequest> request);
  DescribePriceResponse describePriceWithOptions(shared_ptr<DescribePriceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePriceResponse describePrice(shared_ptr<DescribePriceRequest> request);
  DescribeRegionIspsResponse describeRegionIspsWithOptions(shared_ptr<DescribeRegionIspsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionIspsResponse describeRegionIsps(shared_ptr<DescribeRegionIspsRequest> request);
  DescribeReservedResourceResponse describeReservedResourceWithOptions(shared_ptr<DescribeReservedResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeReservedResourceResponse describeReservedResource(shared_ptr<DescribeReservedResourceRequest> request);
  DescribeSecurityGroupAttributeResponse describeSecurityGroupAttributeWithOptions(shared_ptr<DescribeSecurityGroupAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityGroupAttributeResponse describeSecurityGroupAttribute(shared_ptr<DescribeSecurityGroupAttributeRequest> request);
  DescribeSecurityGroupsResponse describeSecurityGroupsWithOptions(shared_ptr<DescribeSecurityGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityGroupsResponse describeSecurityGroups(shared_ptr<DescribeSecurityGroupsRequest> request);
  DescribeServcieScheduleResponse describeServcieScheduleWithOptions(shared_ptr<DescribeServcieScheduleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeServcieScheduleResponse describeServcieSchedule(shared_ptr<DescribeServcieScheduleRequest> request);
  DescribeUserBandWidthDataResponse describeUserBandWidthDataWithOptions(shared_ptr<DescribeUserBandWidthDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserBandWidthDataResponse describeUserBandWidthData(shared_ptr<DescribeUserBandWidthDataRequest> request);
  DescribeVSwitchesResponse describeVSwitchesWithOptions(shared_ptr<DescribeVSwitchesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVSwitchesResponse describeVSwitches(shared_ptr<DescribeVSwitchesRequest> request);
  DetachDiskResponse detachDiskWithOptions(shared_ptr<DetachDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachDiskResponse detachDisk(shared_ptr<DetachDiskRequest> request);
  DistApplicationDataResponse distApplicationDataWithOptions(shared_ptr<DistApplicationDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DistApplicationDataResponse distApplicationData(shared_ptr<DistApplicationDataRequest> request);
  ExportBillDetailDataResponse exportBillDetailDataWithOptions(shared_ptr<ExportBillDetailDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportBillDetailDataResponse exportBillDetailData(shared_ptr<ExportBillDetailDataRequest> request);
  ExportImageResponse exportImageWithOptions(shared_ptr<ExportImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportImageResponse exportImage(shared_ptr<ExportImageRequest> request);
  ExportMeasurementDataResponse exportMeasurementDataWithOptions(shared_ptr<ExportMeasurementDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportMeasurementDataResponse exportMeasurementData(shared_ptr<ExportMeasurementDataRequest> request);
  GetDeviceInternetPortResponse getDeviceInternetPortWithOptions(shared_ptr<GetDeviceInternetPortRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceInternetPortResponse getDeviceInternetPort(shared_ptr<GetDeviceInternetPortRequest> request);
  GetVmListResponse getVmListWithOptions(shared_ptr<GetVmListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVmListResponse getVmList(shared_ptr<GetVmListRequest> request);
  ImportKeyPairResponse importKeyPairWithOptions(shared_ptr<ImportKeyPairRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportKeyPairResponse importKeyPair(shared_ptr<ImportKeyPairRequest> request);
  JoinPublicIpsToEpnInstanceResponse joinPublicIpsToEpnInstanceWithOptions(shared_ptr<JoinPublicIpsToEpnInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  JoinPublicIpsToEpnInstanceResponse joinPublicIpsToEpnInstance(shared_ptr<JoinPublicIpsToEpnInstanceRequest> request);
  JoinSecurityGroupResponse joinSecurityGroupWithOptions(shared_ptr<JoinSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  JoinSecurityGroupResponse joinSecurityGroup(shared_ptr<JoinSecurityGroupRequest> request);
  JoinVSwitchesToEpnInstanceResponse joinVSwitchesToEpnInstanceWithOptions(shared_ptr<JoinVSwitchesToEpnInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  JoinVSwitchesToEpnInstanceResponse joinVSwitchesToEpnInstance(shared_ptr<JoinVSwitchesToEpnInstanceRequest> request);
  LeaveSecurityGroupResponse leaveSecurityGroupWithOptions(shared_ptr<LeaveSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LeaveSecurityGroupResponse leaveSecurityGroup(shared_ptr<LeaveSecurityGroupRequest> request);
  ListApplicationsResponse listApplicationsWithOptions(shared_ptr<ListApplicationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationsResponse listApplications(shared_ptr<ListApplicationsRequest> request);
  MigrateVmResponse migrateVmWithOptions(shared_ptr<MigrateVmRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MigrateVmResponse migrateVm(shared_ptr<MigrateVmRequest> request);
  ModifyEnsEipAddressAttributeResponse modifyEnsEipAddressAttributeWithOptions(shared_ptr<ModifyEnsEipAddressAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyEnsEipAddressAttributeResponse modifyEnsEipAddressAttribute(shared_ptr<ModifyEnsEipAddressAttributeRequest> request);
  ModifyEpnInstanceResponse modifyEpnInstanceWithOptions(shared_ptr<ModifyEpnInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyEpnInstanceResponse modifyEpnInstance(shared_ptr<ModifyEpnInstanceRequest> request);
  ModifyImageAttributeResponse modifyImageAttributeWithOptions(shared_ptr<ModifyImageAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyImageAttributeResponse modifyImageAttribute(shared_ptr<ModifyImageAttributeRequest> request);
  ModifyImageSharePermissionResponse modifyImageSharePermissionWithOptions(shared_ptr<ModifyImageSharePermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyImageSharePermissionResponse modifyImageSharePermission(shared_ptr<ModifyImageSharePermissionRequest> request);
  ModifyInstanceAttributeResponse modifyInstanceAttributeWithOptions(shared_ptr<ModifyInstanceAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceAttributeResponse modifyInstanceAttribute(shared_ptr<ModifyInstanceAttributeRequest> request);
  ModifyInstanceAutoRenewAttributeResponse modifyInstanceAutoRenewAttributeWithOptions(shared_ptr<ModifyInstanceAutoRenewAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceAutoRenewAttributeResponse modifyInstanceAutoRenewAttribute(shared_ptr<ModifyInstanceAutoRenewAttributeRequest> request);
  ModifyLoadBalancerAttributeResponse modifyLoadBalancerAttributeWithOptions(shared_ptr<ModifyLoadBalancerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLoadBalancerAttributeResponse modifyLoadBalancerAttribute(shared_ptr<ModifyLoadBalancerAttributeRequest> request);
  ModifyNetworkAttributeResponse modifyNetworkAttributeWithOptions(shared_ptr<ModifyNetworkAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyNetworkAttributeResponse modifyNetworkAttribute(shared_ptr<ModifyNetworkAttributeRequest> request);
  ModifySecurityGroupAttributeResponse modifySecurityGroupAttributeWithOptions(shared_ptr<ModifySecurityGroupAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySecurityGroupAttributeResponse modifySecurityGroupAttribute(shared_ptr<ModifySecurityGroupAttributeRequest> request);
  ModifyVSwitchAttributeResponse modifyVSwitchAttributeWithOptions(shared_ptr<ModifyVSwitchAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVSwitchAttributeResponse modifyVSwitchAttribute(shared_ptr<ModifyVSwitchAttributeRequest> request);
  PreCreateEnsServiceResponse preCreateEnsServiceWithOptions(shared_ptr<PreCreateEnsServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PreCreateEnsServiceResponse preCreateEnsService(shared_ptr<PreCreateEnsServiceRequest> request);
  PushApplicationDataResponse pushApplicationDataWithOptions(shared_ptr<PushApplicationDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PushApplicationDataResponse pushApplicationData(shared_ptr<PushApplicationDataRequest> request);
  ReInitDiskResponse reInitDiskWithOptions(shared_ptr<ReInitDiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReInitDiskResponse reInitDisk(shared_ptr<ReInitDiskRequest> request);
  RebootInstanceResponse rebootInstanceWithOptions(shared_ptr<RebootInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RebootInstanceResponse rebootInstance(shared_ptr<RebootInstanceRequest> request);
  ReleaseEipAddressResponse releaseEipAddressWithOptions(shared_ptr<ReleaseEipAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseEipAddressResponse releaseEipAddress(shared_ptr<ReleaseEipAddressRequest> request);
  ReleaseInstanceResponse releaseInstanceWithOptions(shared_ptr<ReleaseInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseInstanceResponse releaseInstance(shared_ptr<ReleaseInstanceRequest> request);
  ReleasePostPaidInstanceResponse releasePostPaidInstanceWithOptions(shared_ptr<ReleasePostPaidInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleasePostPaidInstanceResponse releasePostPaidInstance(shared_ptr<ReleasePostPaidInstanceRequest> request);
  ReleasePrePaidInstanceResponse releasePrePaidInstanceWithOptions(shared_ptr<ReleasePrePaidInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleasePrePaidInstanceResponse releasePrePaidInstance(shared_ptr<ReleasePrePaidInstanceRequest> request);
  RemoveBackendServersResponse removeBackendServersWithOptions(shared_ptr<RemoveBackendServersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveBackendServersResponse removeBackendServers(shared_ptr<RemoveBackendServersRequest> request);
  RemovePublicIpsFromEpnInstanceResponse removePublicIpsFromEpnInstanceWithOptions(shared_ptr<RemovePublicIpsFromEpnInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemovePublicIpsFromEpnInstanceResponse removePublicIpsFromEpnInstance(shared_ptr<RemovePublicIpsFromEpnInstanceRequest> request);
  RemoveVSwitchesFromEpnInstanceResponse removeVSwitchesFromEpnInstanceWithOptions(shared_ptr<RemoveVSwitchesFromEpnInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveVSwitchesFromEpnInstanceResponse removeVSwitchesFromEpnInstance(shared_ptr<RemoveVSwitchesFromEpnInstanceRequest> request);
  RenewInstanceResponse renewInstanceWithOptions(shared_ptr<RenewInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenewInstanceResponse renewInstance(shared_ptr<RenewInstanceRequest> request);
  RescaleApplicationResponse rescaleApplicationWithOptions(shared_ptr<RescaleApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RescaleApplicationResponse rescaleApplication(shared_ptr<RescaleApplicationRequest> request);
  RescaleDeviceServiceResponse rescaleDeviceServiceWithOptions(shared_ptr<RescaleDeviceServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RescaleDeviceServiceResponse rescaleDeviceService(shared_ptr<RescaleDeviceServiceRequest> request);
  ResetDeviceInstanceResponse resetDeviceInstanceWithOptions(shared_ptr<ResetDeviceInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetDeviceInstanceResponse resetDeviceInstance(shared_ptr<ResetDeviceInstanceRequest> request);
  RestartDeviceInstanceResponse restartDeviceInstanceWithOptions(shared_ptr<RestartDeviceInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartDeviceInstanceResponse restartDeviceInstance(shared_ptr<RestartDeviceInstanceRequest> request);
  RevokeSecurityGroupResponse revokeSecurityGroupWithOptions(shared_ptr<RevokeSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeSecurityGroupResponse revokeSecurityGroup(shared_ptr<RevokeSecurityGroupRequest> request);
  RevokeSecurityGroupEgressResponse revokeSecurityGroupEgressWithOptions(shared_ptr<RevokeSecurityGroupEgressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeSecurityGroupEgressResponse revokeSecurityGroupEgress(shared_ptr<RevokeSecurityGroupEgressRequest> request);
  RollbackApplicationResponse rollbackApplicationWithOptions(shared_ptr<RollbackApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RollbackApplicationResponse rollbackApplication(shared_ptr<RollbackApplicationRequest> request);
  RunInstancesResponse runInstancesWithOptions(shared_ptr<RunInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunInstancesResponse runInstances(shared_ptr<RunInstancesRequest> request);
  RunServiceScheduleResponse runServiceScheduleWithOptions(shared_ptr<RunServiceScheduleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunServiceScheduleResponse runServiceSchedule(shared_ptr<RunServiceScheduleRequest> request);
  SchedulePodResponse schedulePodWithOptions(shared_ptr<SchedulePodRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SchedulePodResponse schedulePod(shared_ptr<SchedulePodRequest> request);
  SetBackendServersResponse setBackendServersWithOptions(shared_ptr<SetBackendServersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetBackendServersResponse setBackendServers(shared_ptr<SetBackendServersRequest> request);
  SetLoadBalancerHTTPListenerAttributeResponse setLoadBalancerHTTPListenerAttributeWithOptions(shared_ptr<SetLoadBalancerHTTPListenerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLoadBalancerHTTPListenerAttributeResponse setLoadBalancerHTTPListenerAttribute(shared_ptr<SetLoadBalancerHTTPListenerAttributeRequest> request);
  SetLoadBalancerHTTPSListenerAttributeResponse setLoadBalancerHTTPSListenerAttributeWithOptions(shared_ptr<SetLoadBalancerHTTPSListenerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLoadBalancerHTTPSListenerAttributeResponse setLoadBalancerHTTPSListenerAttribute(shared_ptr<SetLoadBalancerHTTPSListenerAttributeRequest> request);
  SetLoadBalancerStatusResponse setLoadBalancerStatusWithOptions(shared_ptr<SetLoadBalancerStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLoadBalancerStatusResponse setLoadBalancerStatus(shared_ptr<SetLoadBalancerStatusRequest> request);
  SetLoadBalancerTCPListenerAttributeResponse setLoadBalancerTCPListenerAttributeWithOptions(shared_ptr<SetLoadBalancerTCPListenerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLoadBalancerTCPListenerAttributeResponse setLoadBalancerTCPListenerAttribute(shared_ptr<SetLoadBalancerTCPListenerAttributeRequest> request);
  SetLoadBalancerUDPListenerAttributeResponse setLoadBalancerUDPListenerAttributeWithOptions(shared_ptr<SetLoadBalancerUDPListenerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLoadBalancerUDPListenerAttributeResponse setLoadBalancerUDPListenerAttribute(shared_ptr<SetLoadBalancerUDPListenerAttributeRequest> request);
  StartEpnInstanceResponse startEpnInstanceWithOptions(shared_ptr<StartEpnInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartEpnInstanceResponse startEpnInstance(shared_ptr<StartEpnInstanceRequest> request);
  StartInstanceResponse startInstanceWithOptions(shared_ptr<StartInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartInstanceResponse startInstance(shared_ptr<StartInstanceRequest> request);
  StartLoadBalancerListenerResponse startLoadBalancerListenerWithOptions(shared_ptr<StartLoadBalancerListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartLoadBalancerListenerResponse startLoadBalancerListener(shared_ptr<StartLoadBalancerListenerRequest> request);
  StopEpnInstanceResponse stopEpnInstanceWithOptions(shared_ptr<StopEpnInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopEpnInstanceResponse stopEpnInstance(shared_ptr<StopEpnInstanceRequest> request);
  StopInstanceResponse stopInstanceWithOptions(shared_ptr<StopInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopInstanceResponse stopInstance(shared_ptr<StopInstanceRequest> request);
  StopLoadBalancerListenerResponse stopLoadBalancerListenerWithOptions(shared_ptr<StopLoadBalancerListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopLoadBalancerListenerResponse stopLoadBalancerListener(shared_ptr<StopLoadBalancerListenerRequest> request);
  UnAssociateEnsEipAddressResponse unAssociateEnsEipAddressWithOptions(shared_ptr<UnAssociateEnsEipAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnAssociateEnsEipAddressResponse unAssociateEnsEipAddress(shared_ptr<UnAssociateEnsEipAddressRequest> request);
  UnassociateEipAddressResponse unassociateEipAddressWithOptions(shared_ptr<UnassociateEipAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnassociateEipAddressResponse unassociateEipAddress(shared_ptr<UnassociateEipAddressRequest> request);
  UpgradeApplicationResponse upgradeApplicationWithOptions(shared_ptr<UpgradeApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeApplicationResponse upgradeApplication(shared_ptr<UpgradeApplicationRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Ens20171110

#endif
