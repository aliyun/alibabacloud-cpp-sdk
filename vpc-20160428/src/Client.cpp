#include <darabonba/Core.hpp>
#include <alibabacloud/Vpc20160428.hpp>
#include <alibabacloud/Utils.hpp>
#include <alibabacloud/Openapi.hpp>
#include <map>
#include <darabonba/Runtime.hpp>
using namespace std;
using namespace Darabonba;
using json = nlohmann::json;
using namespace AlibabaCloud::OpenApi;
using namespace AlibabaCloud::Vpc20160428::Models;
using OpenApiClient = AlibabaCloud::OpenApi::Client;
using namespace AlibabaCloud::OpenApi::Utils::Models;
namespace AlibabaCloud
{
namespace Vpc20160428
{

AlibabaCloud::Vpc20160428::Client::Client(Config &config): OpenApiClient(config){
  this->_endpointRule = "regional";
  this->_endpointMap = json({
    {"cn-hangzhou" , "vpc.aliyuncs.com"},
    {"cn-shanghai-finance-1" , "vpc.aliyuncs.com"},
    {"cn-shenzhen-finance-1" , "vpc.aliyuncs.com"},
    {"cn-north-2-gov-1" , "vpc.aliyuncs.com"},
    {"ap-northeast-2-pop" , "vpc.aliyuncs.com"},
    {"cn-beijing-finance-pop" , "vpc.aliyuncs.com"},
    {"cn-beijing-gov-1" , "vpc.aliyuncs.com"},
    {"cn-beijing-nu16-b01" , "vpc.aliyuncs.com"},
    {"cn-edge-1" , "vpc-nebula.cn-qingdao-nebula.aliyuncs.com"},
    {"cn-fujian" , "vpc.aliyuncs.com"},
    {"cn-haidian-cm12-c01" , "vpc.aliyuncs.com"},
    {"cn-hangzhou-bj-b01" , "vpc.aliyuncs.com"},
    {"cn-hangzhou-finance" , "vpc.aliyuncs.com"},
    {"cn-hangzhou-internal-prod-1" , "vpc.aliyuncs.com"},
    {"cn-hangzhou-internal-test-1" , "vpc-pre.cn-hangzhou.aliyuncs.com"},
    {"cn-hangzhou-internal-test-2" , "vpc-inner-pre.cn-hangzhou.aliyuncs.com"},
    {"cn-hangzhou-internal-test-3" , "vpc-pre.cn-hangzhou.aliyuncs.com"},
    {"cn-hangzhou-test-306" , "vpc-pre.cn-hangzhou.aliyuncs.com"},
    {"cn-hongkong-finance-pop" , "vpc.aliyuncs.com"},
    {"cn-huhehaote-nebula-1" , "vpc-nebula.cn-qingdao-nebula.aliyuncs.com"},
    {"cn-qingdao-nebula" , "vpc-nebula.cn-qingdao-nebula.aliyuncs.com"},
    {"cn-shanghai-et15-b01" , "vpc-pre.cn-hangzhou.aliyuncs.com"},
    {"cn-shanghai-et2-b01" , "vpc.aliyuncs.com"},
    {"cn-shanghai-inner" , "vpc.aliyuncs.com"},
    {"cn-shanghai-internal-test-1" , "vpc-pre.cn-hangzhou.aliyuncs.com"},
    {"cn-shenzhen-inner" , "vpc.aliyuncs.com"},
    {"cn-shenzhen-st4-d01" , "vpc.aliyuncs.com"},
    {"cn-shenzhen-su18-b01" , "vpc.aliyuncs.com"},
    {"cn-wuhan" , "vpc.aliyuncs.com"},
    {"cn-yushanfang" , "vpc.aliyuncs.com"},
    {"cn-zhangbei" , "vpc.aliyuncs.com"},
    {"cn-zhangbei-na61-b01" , "vpc.aliyuncs.com"},
    {"cn-zhangjiakou-na62-a01" , "vpc.cn-zhangjiakou.aliyuncs.com"},
    {"cn-zhengzhou-nebula-1" , "vpc-nebula.cn-qingdao-nebula.aliyuncs.com"},
    {"eu-west-1-oxs" , "vpc-nebula.cn-shenzhen-cloudstone.aliyuncs.com"},
    {"rus-west-1-pop" , "vpc.aliyuncs.com"}
  }).get<map<string, string>>();
  checkConfig(config);
  this->_endpoint = getEndpoint("vpc", _regionId, _endpointRule, _network, _suffix, _endpointMap, _endpoint);
}


string Client::getEndpoint(const string &productId, const string &regionId, const string &endpointRule, const string &network, const string &suffix, const map<string, string> &endpointMap, const string &endpoint) {
  if (!Darabonba::isNull(endpoint)) {
    return endpoint;
  }

  if (!Darabonba::isNull(endpointMap) && !Darabonba::isNull(endpointMap.at(regionId))) {
    return endpointMap.at(regionId);
  }

  return Utils::Utils::getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

/**
 * @summary Activates a router interface that is in the Inactive state.
 *
 * @description After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, it enters the **Active** state.
 * >  You cannot activate a router interface that has overdue payments.
 *
 * @param request ActivateRouterInterfaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ActivateRouterInterfaceResponse
 */
ActivateRouterInterfaceResponse Client::activateRouterInterfaceWithOptions(const ActivateRouterInterfaceRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouterInterfaceId()) {
    query["RouterInterfaceId"] = request.routerInterfaceId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ActivateRouterInterface"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ActivateRouterInterfaceResponse>();
}

/**
 * @summary Activates a router interface that is in the Inactive state.
 *
 * @description After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, it enters the **Active** state.
 * >  You cannot activate a router interface that has overdue payments.
 *
 * @param request ActivateRouterInterfaceRequest
 * @return ActivateRouterInterfaceResponse
 */
ActivateRouterInterfaceResponse Client::activateRouterInterface(const ActivateRouterInterfaceRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return activateRouterInterfaceWithOptions(request, runtime);
}

/**
 * @summary Enables a flow log. After the flow log is enabled, traffic information about a resource is captured.
 *
 * @description *   The **ActiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
 *     *   If the flow log is in the **Activating** state, the flow log is being started.
 *     *   If the flow log is in the **Active** state, the flow log is started.
 * *   You cannot repeatedly call the **ActiveFlowLog** operation to start a flow log within the specified period of time.
 *
 * @param request ActiveFlowLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ActiveFlowLogResponse
 */
ActiveFlowLogResponse Client::activeFlowLogWithOptions(const ActiveFlowLogRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFlowLogId()) {
    query["FlowLogId"] = request.flowLogId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ActiveFlowLog"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ActiveFlowLogResponse>();
}

/**
 * @summary Enables a flow log. After the flow log is enabled, traffic information about a resource is captured.
 *
 * @description *   The **ActiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
 *     *   If the flow log is in the **Activating** state, the flow log is being started.
 *     *   If the flow log is in the **Active** state, the flow log is started.
 * *   You cannot repeatedly call the **ActiveFlowLog** operation to start a flow log within the specified period of time.
 *
 * @param request ActiveFlowLogRequest
 * @return ActiveFlowLogResponse
 */
ActiveFlowLogResponse Client::activeFlowLog(const ActiveFlowLogRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return activeFlowLogWithOptions(request, runtime);
}

/**
 * @summary Advertises a Border Gateway Protocol (BGP) network.
 *
 * @param request AddBgpNetworkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddBgpNetworkResponse
 */
AddBgpNetworkResponse Client::addBgpNetworkWithOptions(const AddBgpNetworkRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDstCidrBlock()) {
    query["DstCidrBlock"] = request.dstCidrBlock();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouterId()) {
    query["RouterId"] = request.routerId();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddBgpNetwork"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddBgpNetworkResponse>();
}

/**
 * @summary Advertises a Border Gateway Protocol (BGP) network.
 *
 * @param request AddBgpNetworkRequest
 * @return AddBgpNetworkResponse
 */
AddBgpNetworkResponse Client::addBgpNetwork(const AddBgpNetworkRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addBgpNetworkWithOptions(request, runtime);
}

/**
 * @summary Associates an elastic IP address (EIP) with an Internet Shared Bandwidth instance.
 *
 * @description Before you call this operation, take note of the following items:
 * *   When you call this operation to associate an EIP with an Internet Shared Bandwidth instance, make sure that the EIP meets the following requirements:
 *     *   The EIP uses the pay-as-you-go billing method.
 *     *   The EIP and the Internet Shared Bandwidth instance belong to the same region.
 *     *   The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
 * *   **AddCommonBandwidthPackageIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the operation.
 *     *   If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
 *     *   If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
 *
 * @param request AddCommonBandwidthPackageIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddCommonBandwidthPackageIpResponse
 */
AddCommonBandwidthPackageIpResponse Client::addCommonBandwidthPackageIpWithOptions(const AddCommonBandwidthPackageIpRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidthPackageId()) {
    query["BandwidthPackageId"] = request.bandwidthPackageId();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasIpInstanceId()) {
    query["IpInstanceId"] = request.ipInstanceId();
  }

  if (!!request.hasIpType()) {
    query["IpType"] = request.ipType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddCommonBandwidthPackageIp"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddCommonBandwidthPackageIpResponse>();
}

/**
 * @summary Associates an elastic IP address (EIP) with an Internet Shared Bandwidth instance.
 *
 * @description Before you call this operation, take note of the following items:
 * *   When you call this operation to associate an EIP with an Internet Shared Bandwidth instance, make sure that the EIP meets the following requirements:
 *     *   The EIP uses the pay-as-you-go billing method.
 *     *   The EIP and the Internet Shared Bandwidth instance belong to the same region.
 *     *   The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
 * *   **AddCommonBandwidthPackageIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the operation.
 *     *   If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
 *     *   If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
 *
 * @param request AddCommonBandwidthPackageIpRequest
 * @return AddCommonBandwidthPackageIpResponse
 */
AddCommonBandwidthPackageIpResponse Client::addCommonBandwidthPackageIp(const AddCommonBandwidthPackageIpRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addCommonBandwidthPackageIpWithOptions(request, runtime);
}

/**
 * @summary Associates multiple elastic IP addresses (EIPs) with an Internet Shared Bandwidth instance.
 *
 * @description *   When you call this operation to associate EIPs with an Internet Shared Bandwidth instance, make sure that the EIPs meet the following requirements:
 *     *   The EIPs use the pay-as-you-go billing method.
 *     *   The EIP and the Internet Shared Bandwidth instance belong to the same region.
 *     *   The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
 * *   **AddCommonBandwidthPackageIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](~~DescribeCommonBandwidthPackages~~) operation to query the status of the task.
 *     *   If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
 *     *   If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
 *
 * @param request AddCommonBandwidthPackageIpsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddCommonBandwidthPackageIpsResponse
 */
AddCommonBandwidthPackageIpsResponse Client::addCommonBandwidthPackageIpsWithOptions(const AddCommonBandwidthPackageIpsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidthPackageId()) {
    query["BandwidthPackageId"] = request.bandwidthPackageId();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasIpInstanceIds()) {
    query["IpInstanceIds"] = request.ipInstanceIds();
  }

  if (!!request.hasIpType()) {
    query["IpType"] = request.ipType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddCommonBandwidthPackageIps"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddCommonBandwidthPackageIpsResponse>();
}

/**
 * @summary Associates multiple elastic IP addresses (EIPs) with an Internet Shared Bandwidth instance.
 *
 * @description *   When you call this operation to associate EIPs with an Internet Shared Bandwidth instance, make sure that the EIPs meet the following requirements:
 *     *   The EIPs use the pay-as-you-go billing method.
 *     *   The EIP and the Internet Shared Bandwidth instance belong to the same region.
 *     *   The line type of the EIPs is the same as that of the Internet Shared Bandwidth instance.
 * *   **AddCommonBandwidthPackageIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](~~DescribeCommonBandwidthPackages~~) operation to query the status of the task.
 *     *   If the Internet Shared Bandwidth instance is in the **BINDING** state, the EIP is being associated with the Internet Shared Bandwidth instance. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
 *     *   If the Internet Shared Bandwidth instance is in the **BINDED** state, the EIP is associated with the Internet Shared Bandwidth instance.
 *
 * @param request AddCommonBandwidthPackageIpsRequest
 * @return AddCommonBandwidthPackageIpsResponse
 */
AddCommonBandwidthPackageIpsResponse Client::addCommonBandwidthPackageIps(const AddCommonBandwidthPackageIpsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addCommonBandwidthPackageIpsWithOptions(request, runtime);
}

/**
 * @summary Associates an elastic IP address (EIP) with a shared-bandwidth Global Accelerator (GA) instance.
 *
 * @param request AddGlobalAccelerationInstanceIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddGlobalAccelerationInstanceIpResponse
 */
AddGlobalAccelerationInstanceIpResponse Client::addGlobalAccelerationInstanceIpWithOptions(const AddGlobalAccelerationInstanceIpRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasGlobalAccelerationInstanceId()) {
    query["GlobalAccelerationInstanceId"] = request.globalAccelerationInstanceId();
  }

  if (!!request.hasIpInstanceId()) {
    query["IpInstanceId"] = request.ipInstanceId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddGlobalAccelerationInstanceIp"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddGlobalAccelerationInstanceIpResponse>();
}

/**
 * @summary Associates an elastic IP address (EIP) with a shared-bandwidth Global Accelerator (GA) instance.
 *
 * @param request AddGlobalAccelerationInstanceIpRequest
 * @return AddGlobalAccelerationInstanceIpResponse
 */
AddGlobalAccelerationInstanceIpResponse Client::addGlobalAccelerationInstanceIp(const AddGlobalAccelerationInstanceIpRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addGlobalAccelerationInstanceIpWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI AddIPv6TranslatorAclListEntry is deprecated
 *
 * @summary Adds an IP entry to an access control list (ACL).
 *
 * @param request AddIPv6TranslatorAclListEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddIPv6TranslatorAclListEntryResponse
 */
AddIPv6TranslatorAclListEntryResponse Client::addIPv6TranslatorAclListEntryWithOptions(const AddIPv6TranslatorAclListEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAclEntryComment()) {
    query["AclEntryComment"] = request.aclEntryComment();
  }

  if (!!request.hasAclEntryIp()) {
    query["AclEntryIp"] = request.aclEntryIp();
  }

  if (!!request.hasAclId()) {
    query["AclId"] = request.aclId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddIPv6TranslatorAclListEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddIPv6TranslatorAclListEntryResponse>();
}

/**
 * @deprecated OpenAPI AddIPv6TranslatorAclListEntry is deprecated
 *
 * @summary Adds an IP entry to an access control list (ACL).
 *
 * @param request AddIPv6TranslatorAclListEntryRequest
 * @return AddIPv6TranslatorAclListEntryResponse
 */
AddIPv6TranslatorAclListEntryResponse Client::addIPv6TranslatorAclListEntry(const AddIPv6TranslatorAclListEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addIPv6TranslatorAclListEntryWithOptions(request, runtime);
}

/**
 * @summary Adds a CIDR block to an IP address pool.
 *
 * @description Before you call this operation, take note of the following limits:
 * *   The CIDR block and the IP address pool must belong to the same region.
 * *   The CIDR block and the IP address pool must use the same line type.
 * *   **AddPublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
 *     *   If the CIDR block is in the **Modifying** state, the CIDR block is being added. In this state, you can only query the CIDR block and cannot perform other operations.
 *     *   If the CIDR block is in the **Created** state, the CIDR block is added.
 * *   You cannot repeatedly call the **AddPublicIpAddressPoolCidrBlock** operation to add a CIDR block to an IP address pool within the specified period of time.
 *
 * @param request AddPublicIpAddressPoolCidrBlockRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddPublicIpAddressPoolCidrBlockResponse
 */
AddPublicIpAddressPoolCidrBlockResponse Client::addPublicIpAddressPoolCidrBlockWithOptions(const AddPublicIpAddressPoolCidrBlockRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCidrBlock()) {
    query["CidrBlock"] = request.cidrBlock();
  }

  if (!!request.hasCidrMask()) {
    query["CidrMask"] = request.cidrMask();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPublicIpAddressPoolId()) {
    query["PublicIpAddressPoolId"] = request.publicIpAddressPoolId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddPublicIpAddressPoolCidrBlock"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddPublicIpAddressPoolCidrBlockResponse>();
}

/**
 * @summary Adds a CIDR block to an IP address pool.
 *
 * @description Before you call this operation, take note of the following limits:
 * *   The CIDR block and the IP address pool must belong to the same region.
 * *   The CIDR block and the IP address pool must use the same line type.
 * *   **AddPublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
 *     *   If the CIDR block is in the **Modifying** state, the CIDR block is being added. In this state, you can only query the CIDR block and cannot perform other operations.
 *     *   If the CIDR block is in the **Created** state, the CIDR block is added.
 * *   You cannot repeatedly call the **AddPublicIpAddressPoolCidrBlock** operation to add a CIDR block to an IP address pool within the specified period of time.
 *
 * @param request AddPublicIpAddressPoolCidrBlockRequest
 * @return AddPublicIpAddressPoolCidrBlockResponse
 */
AddPublicIpAddressPoolCidrBlockResponse Client::addPublicIpAddressPoolCidrBlock(const AddPublicIpAddressPoolCidrBlockRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addPublicIpAddressPoolCidrBlockWithOptions(request, runtime);
}

/**
 * @summary Adds a traffic mirror source to a traffic mirror session.
 *
 * @description *   **AddSourcesToTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
 *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being added to the traffic mirror session.
 *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is added to the traffic mirror session.
 * *   You cannot repeatedly call the **AddSourcesToTrafficMirrorSession** operation to add a traffic mirror source to a traffic mirror session within the specified period of time.
 *
 * @param request AddSourcesToTrafficMirrorSessionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddSourcesToTrafficMirrorSessionResponse
 */
AddSourcesToTrafficMirrorSessionResponse Client::addSourcesToTrafficMirrorSessionWithOptions(const AddSourcesToTrafficMirrorSessionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTrafficMirrorSessionId()) {
    query["TrafficMirrorSessionId"] = request.trafficMirrorSessionId();
  }

  if (!!request.hasTrafficMirrorSourceIds()) {
    query["TrafficMirrorSourceIds"] = request.trafficMirrorSourceIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddSourcesToTrafficMirrorSession"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddSourcesToTrafficMirrorSessionResponse>();
}

/**
 * @summary Adds a traffic mirror source to a traffic mirror session.
 *
 * @description *   **AddSourcesToTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
 *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being added to the traffic mirror session.
 *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is added to the traffic mirror session.
 * *   You cannot repeatedly call the **AddSourcesToTrafficMirrorSession** operation to add a traffic mirror source to a traffic mirror session within the specified period of time.
 *
 * @param request AddSourcesToTrafficMirrorSessionRequest
 * @return AddSourcesToTrafficMirrorSessionResponse
 */
AddSourcesToTrafficMirrorSessionResponse Client::addSourcesToTrafficMirrorSession(const AddSourcesToTrafficMirrorSessionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addSourcesToTrafficMirrorSessionWithOptions(request, runtime);
}

/**
 * @summary Applies for an elastic IP address (EIP).
 *
 * @description Before you call this operation, make sure that you are familiar with the billing methods and pricing of EIPs. For more information, see [Billing overview](https://help.aliyun.com/document_detail/122035.html).
 * After you call this operation, the system randomly allocates an EIP that is in the **Available** state in the specified region. EIPs support only the ICMP, TCP, and UDP transport layer protocols. The IGMP and SCTP protocols are not supported.
 *
 * @param request AllocateEipAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AllocateEipAddressResponse
 */
AllocateEipAddressResponse Client::allocateEipAddressWithOptions(const AllocateEipAddressRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasActivityId()) {
    query["ActivityId"] = request.activityId();
  }

  if (!!request.hasAutoPay()) {
    query["AutoPay"] = request.autoPay();
  }

  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasISP()) {
    query["ISP"] = request.ISP();
  }

  if (!!request.hasInstanceChargeType()) {
    query["InstanceChargeType"] = request.instanceChargeType();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasInternetChargeType()) {
    query["InternetChargeType"] = request.internetChargeType();
  }

  if (!!request.hasIpAddress()) {
    query["IpAddress"] = request.ipAddress();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasNetmode()) {
    query["Netmode"] = request.netmode();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPeriod()) {
    query["Period"] = request.period();
  }

  if (!!request.hasPricingCycle()) {
    query["PricingCycle"] = request.pricingCycle();
  }

  if (!!request.hasPublicIpAddressPoolId()) {
    query["PublicIpAddressPoolId"] = request.publicIpAddressPoolId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSecurityProtectionTypes()) {
    query["SecurityProtectionTypes"] = request.securityProtectionTypes();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasZone()) {
    query["Zone"] = request.zone();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AllocateEipAddress"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AllocateEipAddressResponse>();
}

/**
 * @summary Applies for an elastic IP address (EIP).
 *
 * @description Before you call this operation, make sure that you are familiar with the billing methods and pricing of EIPs. For more information, see [Billing overview](https://help.aliyun.com/document_detail/122035.html).
 * After you call this operation, the system randomly allocates an EIP that is in the **Available** state in the specified region. EIPs support only the ICMP, TCP, and UDP transport layer protocols. The IGMP and SCTP protocols are not supported.
 *
 * @param request AllocateEipAddressRequest
 * @return AllocateEipAddressResponse
 */
AllocateEipAddressResponse Client::allocateEipAddress(const AllocateEipAddressRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return allocateEipAddressWithOptions(request, runtime);
}

/**
 * @summary Requests a specified elastic IP address (EIP).
 *
 * @param request AllocateEipAddressProRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AllocateEipAddressProResponse
 */
AllocateEipAddressProResponse Client::allocateEipAddressProWithOptions(const AllocateEipAddressProRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAutoPay()) {
    query["AutoPay"] = request.autoPay();
  }

  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasISP()) {
    query["ISP"] = request.ISP();
  }

  if (!!request.hasInstanceChargeType()) {
    query["InstanceChargeType"] = request.instanceChargeType();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasInternetChargeType()) {
    query["InternetChargeType"] = request.internetChargeType();
  }

  if (!!request.hasIpAddress()) {
    query["IpAddress"] = request.ipAddress();
  }

  if (!!request.hasNetmode()) {
    query["Netmode"] = request.netmode();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPeriod()) {
    query["Period"] = request.period();
  }

  if (!!request.hasPricingCycle()) {
    query["PricingCycle"] = request.pricingCycle();
  }

  if (!!request.hasPublicIpAddressPoolId()) {
    query["PublicIpAddressPoolId"] = request.publicIpAddressPoolId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSecurityProtectionTypes()) {
    query["SecurityProtectionTypes"] = request.securityProtectionTypes();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AllocateEipAddressPro"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AllocateEipAddressProResponse>();
}

/**
 * @summary Requests a specified elastic IP address (EIP).
 *
 * @param request AllocateEipAddressProRequest
 * @return AllocateEipAddressProResponse
 */
AllocateEipAddressProResponse Client::allocateEipAddressPro(const AllocateEipAddressProRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return allocateEipAddressProWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI AllocateEipSegmentAddress is deprecated
 *
 * @summary Applies for contiguous elastic IP addresses (EIPs).
 *
 * @description **AllocateEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns the ID of a contiguous EIP group and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
 * *   If the contiguous EIP group is in the **Allocating** state, the EIPs are being allocated. In this case, you can only perform the query operation and cannot perform other operations.
 * *   If the contiguous EIP group is in the **Allocated** state, the EIPs are allocated.
 *
 * @param request AllocateEipSegmentAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AllocateEipSegmentAddressResponse
 */
AllocateEipSegmentAddressResponse Client::allocateEipSegmentAddressWithOptions(const AllocateEipSegmentAddressRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasEipMask()) {
    query["EipMask"] = request.eipMask();
  }

  if (!!request.hasInternetChargeType()) {
    query["InternetChargeType"] = request.internetChargeType();
  }

  if (!!request.hasIsp()) {
    query["Isp"] = request.isp();
  }

  if (!!request.hasNetmode()) {
    query["Netmode"] = request.netmode();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasZone()) {
    query["Zone"] = request.zone();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AllocateEipSegmentAddress"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AllocateEipSegmentAddressResponse>();
}

/**
 * @deprecated OpenAPI AllocateEipSegmentAddress is deprecated
 *
 * @summary Applies for contiguous elastic IP addresses (EIPs).
 *
 * @description **AllocateEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns the ID of a contiguous EIP group and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
 * *   If the contiguous EIP group is in the **Allocating** state, the EIPs are being allocated. In this case, you can only perform the query operation and cannot perform other operations.
 * *   If the contiguous EIP group is in the **Allocated** state, the EIPs are allocated.
 *
 * @param request AllocateEipSegmentAddressRequest
 * @return AllocateEipSegmentAddressResponse
 */
AllocateEipSegmentAddressResponse Client::allocateEipSegmentAddress(const AllocateEipSegmentAddressRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return allocateEipSegmentAddressWithOptions(request, runtime);
}

/**
 * @summary Assigns an IPv6 address.
 *
 * @param request AllocateIpv6AddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AllocateIpv6AddressResponse
 */
AllocateIpv6AddressResponse Client::allocateIpv6AddressWithOptions(const AllocateIpv6AddressRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAddressType()) {
    query["AddressType"] = request.addressType();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIpv6Address()) {
    query["Ipv6Address"] = request.ipv6Address();
  }

  if (!!request.hasIpv6AddressDescription()) {
    query["Ipv6AddressDescription"] = request.ipv6AddressDescription();
  }

  if (!!request.hasIpv6AddressName()) {
    query["Ipv6AddressName"] = request.ipv6AddressName();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasVSwitchId()) {
    query["VSwitchId"] = request.vSwitchId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AllocateIpv6Address"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AllocateIpv6AddressResponse>();
}

/**
 * @summary Assigns an IPv6 address.
 *
 * @param request AllocateIpv6AddressRequest
 * @return AllocateIpv6AddressResponse
 */
AllocateIpv6AddressResponse Client::allocateIpv6Address(const AllocateIpv6AddressRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return allocateIpv6AddressWithOptions(request, runtime);
}

/**
 * @summary Default IPv6 gateways support only private communication. You can call the AllocateIpv6InternetBandwidth operation to purchase Internet bandwidth resources for an IPv6 address. This way, ECS instances in a VPC can access the Internet through the IPv6 address. IPv6 clients can also access the ECS instances over the Internet.
 *
 * @description *   Before you call this operation, make sure that an ECS instance that supports IPv6 is created in a VPC that has an IPv6 CIDR block. For more information, see [Create a VPC with an IPv6 CIDR block](https://help.aliyun.com/document_detail/100540.html).
 * *   You cannot repeatedly call **AllocateIpv6InternetBandwidth** within the specified period of time.
 *
 * @param request AllocateIpv6InternetBandwidthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AllocateIpv6InternetBandwidthResponse
 */
AllocateIpv6InternetBandwidthResponse Client::allocateIpv6InternetBandwidthWithOptions(const AllocateIpv6InternetBandwidthRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasInternetChargeType()) {
    query["InternetChargeType"] = request.internetChargeType();
  }

  if (!!request.hasIpv6AddressId()) {
    query["Ipv6AddressId"] = request.ipv6AddressId();
  }

  if (!!request.hasIpv6GatewayId()) {
    query["Ipv6GatewayId"] = request.ipv6GatewayId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AllocateIpv6InternetBandwidth"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AllocateIpv6InternetBandwidthResponse>();
}

/**
 * @summary Default IPv6 gateways support only private communication. You can call the AllocateIpv6InternetBandwidth operation to purchase Internet bandwidth resources for an IPv6 address. This way, ECS instances in a VPC can access the Internet through the IPv6 address. IPv6 clients can also access the ECS instances over the Internet.
 *
 * @description *   Before you call this operation, make sure that an ECS instance that supports IPv6 is created in a VPC that has an IPv6 CIDR block. For more information, see [Create a VPC with an IPv6 CIDR block](https://help.aliyun.com/document_detail/100540.html).
 * *   You cannot repeatedly call **AllocateIpv6InternetBandwidth** within the specified period of time.
 *
 * @param request AllocateIpv6InternetBandwidthRequest
 * @return AllocateIpv6InternetBandwidthResponse
 */
AllocateIpv6InternetBandwidthResponse Client::allocateIpv6InternetBandwidth(const AllocateIpv6InternetBandwidthRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return allocateIpv6InternetBandwidthWithOptions(request, runtime);
}

/**
 * @summary Reserves an IPv6 CIDR block.
 *
 * @description # [](#)
 * The following section describes how to allocate an IPv6 CIDR block to a virtual private cloud (VPC):
 * 1.  Call the AllocateVpcIpv6Cidr operation to reserve the IPv6 CIDR block.
 * 2.  To allocate an IPv6 CIDR block to an existing VPC, call the [AssociateVpcCidrBlock](https://help.aliyun.com/document_detail/146745.html) operation. Set **RegionId**, **VpcId**, and **IPv6CidrBlock** to the IPv6 CIDR bock, and set **IpVersion** to **ipv6**. To allocate an IPv6 CIDR block when you create a VPC, call the [CreateVpc](https://help.aliyun.com/document_detail/35737.html) operation. Set **RegionId** and **Ipv6CidrBlock** to the IPv6 CIDR block, and set **EnableIpv6** to **true**.
 *
 * @param request AllocateVpcIpv6CidrRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AllocateVpcIpv6CidrResponse
 */
AllocateVpcIpv6CidrResponse Client::allocateVpcIpv6CidrWithOptions(const AllocateVpcIpv6CidrRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAddressPoolType()) {
    query["AddressPoolType"] = request.addressPoolType();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasIpv6CidrBlock()) {
    query["Ipv6CidrBlock"] = request.ipv6CidrBlock();
  }

  if (!!request.hasIpv6Isp()) {
    query["Ipv6Isp"] = request.ipv6Isp();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AllocateVpcIpv6Cidr"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AllocateVpcIpv6CidrResponse>();
}

/**
 * @summary Reserves an IPv6 CIDR block.
 *
 * @description # [](#)
 * The following section describes how to allocate an IPv6 CIDR block to a virtual private cloud (VPC):
 * 1.  Call the AllocateVpcIpv6Cidr operation to reserve the IPv6 CIDR block.
 * 2.  To allocate an IPv6 CIDR block to an existing VPC, call the [AssociateVpcCidrBlock](https://help.aliyun.com/document_detail/146745.html) operation. Set **RegionId**, **VpcId**, and **IPv6CidrBlock** to the IPv6 CIDR bock, and set **IpVersion** to **ipv6**. To allocate an IPv6 CIDR block when you create a VPC, call the [CreateVpc](https://help.aliyun.com/document_detail/35737.html) operation. Set **RegionId** and **Ipv6CidrBlock** to the IPv6 CIDR block, and set **EnableIpv6** to **true**.
 *
 * @param request AllocateVpcIpv6CidrRequest
 * @return AllocateVpcIpv6CidrResponse
 */
AllocateVpcIpv6CidrResponse Client::allocateVpcIpv6Cidr(const AllocateVpcIpv6CidrRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return allocateVpcIpv6CidrWithOptions(request, runtime);
}

/**
 * @summary Applies for a Letter of Authorization (LOA) for an Express Connect circuit.
 *
 * @param request ApplyPhysicalConnectionLOARequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ApplyPhysicalConnectionLOAResponse
 */
ApplyPhysicalConnectionLOAResponse Client::applyPhysicalConnectionLOAWithOptions(const ApplyPhysicalConnectionLOARequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasCompanyName()) {
    query["CompanyName"] = request.companyName();
  }

  if (!!request.hasConstructionTime()) {
    query["ConstructionTime"] = request.constructionTime();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasLineType()) {
    query["LineType"] = request.lineType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPMInfo()) {
    query["PMInfo"] = request.PMInfo();
  }

  if (!!request.hasPeerLocation()) {
    query["PeerLocation"] = request.peerLocation();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSi()) {
    query["Si"] = request.si();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ApplyPhysicalConnectionLOA"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ApplyPhysicalConnectionLOAResponse>();
}

/**
 * @summary Applies for a Letter of Authorization (LOA) for an Express Connect circuit.
 *
 * @param request ApplyPhysicalConnectionLOARequest
 * @return ApplyPhysicalConnectionLOAResponse
 */
ApplyPhysicalConnectionLOAResponse Client::applyPhysicalConnectionLOA(const ApplyPhysicalConnectionLOARequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return applyPhysicalConnectionLOAWithOptions(request, runtime);
}

/**
 * @summary Associates an elastic IP address (EIP) with an instance in the same region.
 *
 * @description *   You can associate an EIP with an Elastic Compute Service (ECS) instance, a Classic Load Balancer (CLB) instance, a secondary elastic network interface (ENI), a NAT gateway, or a high-availability virtual IP address (HAVIP) in the same region. The ECS instance and CLB instance must be deployed in a virtual private cloud (VPC).
 * *   **AssociateEipAddress** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
 *     *   If the EIP is in the **Associating** state, the EIP is being associated. In this state, you can only query the EIP and cannot perform other operations.
 *     *   If the EIP is in the **InUse** state, the EIP is associated.
 * *   You cannot call the **AssociateEipAddress** operation to associate an EIP with multiple instances at a time.
 *
 * @param request AssociateEipAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateEipAddressResponse
 */
AssociateEipAddressResponse Client::associateEipAddressWithOptions(const AssociateEipAddressRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAllocationId()) {
    query["AllocationId"] = request.allocationId();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasInstanceRegionId()) {
    query["InstanceRegionId"] = request.instanceRegionId();
  }

  if (!!request.hasInstanceType()) {
    query["InstanceType"] = request.instanceType();
  }

  if (!!request.hasMode()) {
    query["Mode"] = request.mode();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPrivateIpAddress()) {
    query["PrivateIpAddress"] = request.privateIpAddress();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AssociateEipAddress"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AssociateEipAddressResponse>();
}

/**
 * @summary Associates an elastic IP address (EIP) with an instance in the same region.
 *
 * @description *   You can associate an EIP with an Elastic Compute Service (ECS) instance, a Classic Load Balancer (CLB) instance, a secondary elastic network interface (ENI), a NAT gateway, or a high-availability virtual IP address (HAVIP) in the same region. The ECS instance and CLB instance must be deployed in a virtual private cloud (VPC).
 * *   **AssociateEipAddress** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
 *     *   If the EIP is in the **Associating** state, the EIP is being associated. In this state, you can only query the EIP and cannot perform other operations.
 *     *   If the EIP is in the **InUse** state, the EIP is associated.
 * *   You cannot call the **AssociateEipAddress** operation to associate an EIP with multiple instances at a time.
 *
 * @param request AssociateEipAddressRequest
 * @return AssociateEipAddressResponse
 */
AssociateEipAddressResponse Client::associateEipAddress(const AssociateEipAddressRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return associateEipAddressWithOptions(request, runtime);
}

/**
 * @summary Associates multiple elastic IP addresses (EIPs) with an instance in the same region.
 *
 * @description *   You can call the **AssociateEipAddressBatch** operation to associate EIPs with an instance in the same region. The instance must be a NAT gateway or a secondary elastic network interface (ENI). For more information about how to associate EIPs with other instances, see [AssociateEipAddress](https://help.aliyun.com/document_detail/120195.html).
 * *   **AssociateEipAddressBatch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
 *     *   If the EIP is in the **Associating** state, the EIP is being associated. You can only query the EIP and cannot perform other operations.
 *     *   If the EIP is in the **InUse** state, the EIP is associated.
 * *   You cannot call the **AssociateEipAddressBatch** operation to associate an EIP with multiple instances at a time.
 *
 * @param request AssociateEipAddressBatchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateEipAddressBatchResponse
 */
AssociateEipAddressBatchResponse Client::associateEipAddressBatchWithOptions(const AssociateEipAddressBatchRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBindedInstanceId()) {
    query["BindedInstanceId"] = request.bindedInstanceId();
  }

  if (!!request.hasBindedInstanceType()) {
    query["BindedInstanceType"] = request.bindedInstanceType();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasInstanceIds()) {
    query["InstanceIds"] = request.instanceIds();
  }

  if (!!request.hasMode()) {
    query["Mode"] = request.mode();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AssociateEipAddressBatch"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AssociateEipAddressBatchResponse>();
}

/**
 * @summary Associates multiple elastic IP addresses (EIPs) with an instance in the same region.
 *
 * @description *   You can call the **AssociateEipAddressBatch** operation to associate EIPs with an instance in the same region. The instance must be a NAT gateway or a secondary elastic network interface (ENI). For more information about how to associate EIPs with other instances, see [AssociateEipAddress](https://help.aliyun.com/document_detail/120195.html).
 * *   **AssociateEipAddressBatch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
 *     *   If the EIP is in the **Associating** state, the EIP is being associated. You can only query the EIP and cannot perform other operations.
 *     *   If the EIP is in the **InUse** state, the EIP is associated.
 * *   You cannot call the **AssociateEipAddressBatch** operation to associate an EIP with multiple instances at a time.
 *
 * @param request AssociateEipAddressBatchRequest
 * @return AssociateEipAddressBatchResponse
 */
AssociateEipAddressBatchResponse Client::associateEipAddressBatch(const AssociateEipAddressBatchRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return associateEipAddressBatchWithOptions(request, runtime);
}

/**
 * @summary Associates a high-availability virtual IP address (HaVip) with an Elastic Compute Service (ECS) instance or an elastic network interface (ENI).
 *
 * @description When you call this operation, take note of the following limits:
 * *   An HaVip immediately takes effect after it is associated. You do not need to restart the ECS instance. However, you must associate the HaVip with the ENI of the ECS instance.
 * *   The HaVip and ECS instance must belong to the same vSwitch.
 * *   You can associate an HaVip with at most two ECS instances.
 * *   The ECS instance must be in the **Running** or **Stopped** state.
 * *   The HaVip must be in the **Available** or **InUse** state.
 * *   The **AssociateHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
 *     *   If the HaVip is in the **Associating** state, the HaVip is being associated.
 *     *   If the HaVip is in the **InUse** state, the HaVip is associated.
 * *   You cannot repeatedly call the **AssociateHaVip** operation to associate an HaVip within the specified period of time.
 *
 * @param request AssociateHaVipRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateHaVipResponse
 */
AssociateHaVipResponse Client::associateHaVipWithOptions(const AssociateHaVipRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasHaVipId()) {
    query["HaVipId"] = request.haVipId();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasInstanceType()) {
    query["InstanceType"] = request.instanceType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AssociateHaVip"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AssociateHaVipResponse>();
}

/**
 * @summary Associates a high-availability virtual IP address (HaVip) with an Elastic Compute Service (ECS) instance or an elastic network interface (ENI).
 *
 * @description When you call this operation, take note of the following limits:
 * *   An HaVip immediately takes effect after it is associated. You do not need to restart the ECS instance. However, you must associate the HaVip with the ENI of the ECS instance.
 * *   The HaVip and ECS instance must belong to the same vSwitch.
 * *   You can associate an HaVip with at most two ECS instances.
 * *   The ECS instance must be in the **Running** or **Stopped** state.
 * *   The HaVip must be in the **Available** or **InUse** state.
 * *   The **AssociateHaVip** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
 *     *   If the HaVip is in the **Associating** state, the HaVip is being associated.
 *     *   If the HaVip is in the **InUse** state, the HaVip is associated.
 * *   You cannot repeatedly call the **AssociateHaVip** operation to associate an HaVip within the specified period of time.
 *
 * @param request AssociateHaVipRequest
 * @return AssociateHaVipResponse
 */
AssociateHaVipResponse Client::associateHaVip(const AssociateHaVipRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return associateHaVipWithOptions(request, runtime);
}

/**
 * @summary Associates a network access control list (ACL) with a vSwitch.
 *
 * @description ## [](#)Description
 * *   **AssociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
 *     *   If the network ACL is in the **BINDING** state, the network ACL is being associated.
 *     *   If the network ACL is in the **BINDED** state, the network ACL is associated.
 * *   You cannot repeatedly call the **AssociateNetworkAcl** operation to associate a network ACL within the specified period of time.
 *
 * @param request AssociateNetworkAclRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateNetworkAclResponse
 */
AssociateNetworkAclResponse Client::associateNetworkAclWithOptions(const AssociateNetworkAclRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasNetworkAclId()) {
    query["NetworkAclId"] = request.networkAclId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResource()) {
    query["Resource"] = request.resource();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AssociateNetworkAcl"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AssociateNetworkAclResponse>();
}

/**
 * @summary Associates a network access control list (ACL) with a vSwitch.
 *
 * @description ## [](#)Description
 * *   **AssociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
 *     *   If the network ACL is in the **BINDING** state, the network ACL is being associated.
 *     *   If the network ACL is in the **BINDED** state, the network ACL is associated.
 * *   You cannot repeatedly call the **AssociateNetworkAcl** operation to associate a network ACL within the specified period of time.
 *
 * @param request AssociateNetworkAclRequest
 * @return AssociateNetworkAclResponse
 */
AssociateNetworkAclResponse Client::associateNetworkAcl(const AssociateNetworkAclRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return associateNetworkAclWithOptions(request, runtime);
}

/**
 * @summary Associates a virtual border router (VBR) with a specified Express Connect circuit.
 *
 * @param request AssociatePhysicalConnectionToVirtualBorderRouterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociatePhysicalConnectionToVirtualBorderRouterResponse
 */
AssociatePhysicalConnectionToVirtualBorderRouterResponse Client::associatePhysicalConnectionToVirtualBorderRouterWithOptions(const AssociatePhysicalConnectionToVirtualBorderRouterRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCircuitCode()) {
    query["CircuitCode"] = request.circuitCode();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasEnableIpv6()) {
    query["EnableIpv6"] = request.enableIpv6();
  }

  if (!!request.hasLocalGatewayIp()) {
    query["LocalGatewayIp"] = request.localGatewayIp();
  }

  if (!!request.hasLocalIpv6GatewayIp()) {
    query["LocalIpv6GatewayIp"] = request.localIpv6GatewayIp();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPeerGatewayIp()) {
    query["PeerGatewayIp"] = request.peerGatewayIp();
  }

  if (!!request.hasPeerIpv6GatewayIp()) {
    query["PeerIpv6GatewayIp"] = request.peerIpv6GatewayIp();
  }

  if (!!request.hasPeeringIpv6SubnetMask()) {
    query["PeeringIpv6SubnetMask"] = request.peeringIpv6SubnetMask();
  }

  if (!!request.hasPeeringSubnetMask()) {
    query["PeeringSubnetMask"] = request.peeringSubnetMask();
  }

  if (!!request.hasPhysicalConnectionId()) {
    query["PhysicalConnectionId"] = request.physicalConnectionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVbrId()) {
    query["VbrId"] = request.vbrId();
  }

  if (!!request.hasVlanId()) {
    query["VlanId"] = request.vlanId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AssociatePhysicalConnectionToVirtualBorderRouter"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AssociatePhysicalConnectionToVirtualBorderRouterResponse>();
}

/**
 * @summary Associates a virtual border router (VBR) with a specified Express Connect circuit.
 *
 * @param request AssociatePhysicalConnectionToVirtualBorderRouterRequest
 * @return AssociatePhysicalConnectionToVirtualBorderRouterResponse
 */
AssociatePhysicalConnectionToVirtualBorderRouterResponse Client::associatePhysicalConnectionToVirtualBorderRouter(const AssociatePhysicalConnectionToVirtualBorderRouterRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return associatePhysicalConnectionToVirtualBorderRouterWithOptions(request, runtime);
}

/**
 * @summary Associates a custom route table with a vSwitch in the same VPC.
 *
 * @description **AssociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
 * *   If the vSwitch is in the **Pending** state, the route table is being associated with the vSwitch.
 * *   If the vSwitch is in the **Available** state, the route table is associated with the vSwitch.
 *
 * @param request AssociateRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateRouteTableResponse
 */
AssociateRouteTableResponse Client::associateRouteTableWithOptions(const AssociateRouteTableRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteTableId()) {
    query["RouteTableId"] = request.routeTableId();
  }

  if (!!request.hasVSwitchId()) {
    query["VSwitchId"] = request.vSwitchId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AssociateRouteTable"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AssociateRouteTableResponse>();
}

/**
 * @summary Associates a custom route table with a vSwitch in the same VPC.
 *
 * @description **AssociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
 * *   If the vSwitch is in the **Pending** state, the route table is being associated with the vSwitch.
 * *   If the vSwitch is in the **Available** state, the route table is associated with the vSwitch.
 *
 * @param request AssociateRouteTableRequest
 * @return AssociateRouteTableResponse
 */
AssociateRouteTableResponse Client::associateRouteTable(const AssociateRouteTableRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return associateRouteTableWithOptions(request, runtime);
}

/**
 * @summary Associates a gateway route table with an IPv4 gateway in the same virtual private cloud (VPC).
 *
 * @param request AssociateRouteTableWithGatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateRouteTableWithGatewayResponse
 */
AssociateRouteTableWithGatewayResponse Client::associateRouteTableWithGatewayWithOptions(const AssociateRouteTableWithGatewayRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasGatewayId()) {
    query["GatewayId"] = request.gatewayId();
  }

  if (!!request.hasGatewayType()) {
    query["GatewayType"] = request.gatewayType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteTableId()) {
    query["RouteTableId"] = request.routeTableId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AssociateRouteTableWithGateway"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AssociateRouteTableWithGatewayResponse>();
}

/**
 * @summary Associates a gateway route table with an IPv4 gateway in the same virtual private cloud (VPC).
 *
 * @param request AssociateRouteTableWithGatewayRequest
 * @return AssociateRouteTableWithGatewayResponse
 */
AssociateRouteTableWithGatewayResponse Client::associateRouteTableWithGateway(const AssociateRouteTableWithGatewayRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return associateRouteTableWithGatewayWithOptions(request, runtime);
}

/**
 * @summary Associates a route table with a gateway endpoint.
 *
 * @description When you call this operation, take note of the following limits:
 * *   The gateway endpoint to be associated with the route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
 * *   The route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
 * *   The gateway endpoint and route table must belong to the same virtual private cloud (VPC).
 * *   The route table cannot be shared.
 * *   You cannot associate a gateway endpoint with a virtual border router (VBR) route table.
 * *   You can associate a gateway endpoint with at most 20 route tables at a time.
 * *   **AssociateRouteTablesWithVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query whether a route table is associated with a gateway endpoint.
 *     *   If the **Associating** status is returned, the route table is being associated with the gateway endpoint.
 *     *   If the **Created** status is returned, the route table is associated with the gateway endpoint.
 * *   You cannot repeatedly call the **AssociateRouteTablesWithVpcGatewayEndpoint** operation within a specific period of time.
 *
 * @param request AssociateRouteTablesWithVpcGatewayEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateRouteTablesWithVpcGatewayEndpointResponse
 */
AssociateRouteTablesWithVpcGatewayEndpointResponse Client::associateRouteTablesWithVpcGatewayEndpointWithOptions(const AssociateRouteTablesWithVpcGatewayEndpointRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEndpointId()) {
    query["EndpointId"] = request.endpointId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteTableIds()) {
    query["RouteTableIds"] = request.routeTableIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AssociateRouteTablesWithVpcGatewayEndpoint"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AssociateRouteTablesWithVpcGatewayEndpointResponse>();
}

/**
 * @summary Associates a route table with a gateway endpoint.
 *
 * @description When you call this operation, take note of the following limits:
 * *   The gateway endpoint to be associated with the route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
 * *   The route table cannot be in one of the following states: **Creating**, **Modifying**, **Associating**, **Dissociating**, or **Deleting**.
 * *   The gateway endpoint and route table must belong to the same virtual private cloud (VPC).
 * *   The route table cannot be shared.
 * *   You cannot associate a gateway endpoint with a virtual border router (VBR) route table.
 * *   You can associate a gateway endpoint with at most 20 route tables at a time.
 * *   **AssociateRouteTablesWithVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query whether a route table is associated with a gateway endpoint.
 *     *   If the **Associating** status is returned, the route table is being associated with the gateway endpoint.
 *     *   If the **Created** status is returned, the route table is associated with the gateway endpoint.
 * *   You cannot repeatedly call the **AssociateRouteTablesWithVpcGatewayEndpoint** operation within a specific period of time.
 *
 * @param request AssociateRouteTablesWithVpcGatewayEndpointRequest
 * @return AssociateRouteTablesWithVpcGatewayEndpointResponse
 */
AssociateRouteTablesWithVpcGatewayEndpointResponse Client::associateRouteTablesWithVpcGatewayEndpoint(const AssociateRouteTablesWithVpcGatewayEndpointRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return associateRouteTablesWithVpcGatewayEndpointWithOptions(request, runtime);
}

/**
 * @summary Adds a secondary CIDR block to a virtual private cloud (VPC).
 *
 * @description ## [](#)
 * *   Take note of the following limits:
 *     *   Each VPC can contain up to five secondary IPv4 CIDR blocks.
 *     *   Each VPC can contain up to five secondary IPv6 CIDR blocks.
 * *   You cannot repeatedly call the **AssociateVpcCidrBlock** operation to add secondary CIDR blocks to a VPC within the specified period of time.
 *
 * @param request AssociateVpcCidrBlockRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateVpcCidrBlockResponse
 */
AssociateVpcCidrBlockResponse Client::associateVpcCidrBlockWithOptions(const AssociateVpcCidrBlockRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIPv6CidrBlock()) {
    query["IPv6CidrBlock"] = request.IPv6CidrBlock();
  }

  if (!!request.hasIpVersion()) {
    query["IpVersion"] = request.ipVersion();
  }

  if (!!request.hasIpamPoolId()) {
    query["IpamPoolId"] = request.ipamPoolId();
  }

  if (!!request.hasIpv6CidrMask()) {
    query["Ipv6CidrMask"] = request.ipv6CidrMask();
  }

  if (!!request.hasIpv6Isp()) {
    query["Ipv6Isp"] = request.ipv6Isp();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSecondaryCidrBlock()) {
    query["SecondaryCidrBlock"] = request.secondaryCidrBlock();
  }

  if (!!request.hasSecondaryCidrMask()) {
    query["SecondaryCidrMask"] = request.secondaryCidrMask();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AssociateVpcCidrBlock"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AssociateVpcCidrBlockResponse>();
}

/**
 * @summary Adds a secondary CIDR block to a virtual private cloud (VPC).
 *
 * @description ## [](#)
 * *   Take note of the following limits:
 *     *   Each VPC can contain up to five secondary IPv4 CIDR blocks.
 *     *   Each VPC can contain up to five secondary IPv6 CIDR blocks.
 * *   You cannot repeatedly call the **AssociateVpcCidrBlock** operation to add secondary CIDR blocks to a VPC within the specified period of time.
 *
 * @param request AssociateVpcCidrBlockRequest
 * @return AssociateVpcCidrBlockResponse
 */
AssociateVpcCidrBlockResponse Client::associateVpcCidrBlock(const AssociateVpcCidrBlockRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return associateVpcCidrBlockWithOptions(request, runtime);
}

/**
 * @summary Associates a VPN gateway with a certificate.
 *
 * @description Before you associate a VPN gateway with an SSL certificate, take note of the following items:
 * *   You can associate only VPN gateways of the ShangMi (SM) type with SSL certificates. You need to associate a VPN gateway of the SM type with two SSL certificates, one as the encryption certificate and the other as the signature certificate.
 * *   The SSL certificates must use the SM algorithm.
 * *   You cannot specify one SSL certificate as both the encryption certificate and signature certificate for one VPN gateway.
 * *   **AssociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being associated.
 *     *   If the VPN gateway is in the **active** state, the SSL certificate is being associated.
 * *   You cannot call **AssociateVpnGatewayWithCertificate** within a specific period of time.
 * ### [](#)Prerequisites
 * Make sure that you have two SSL certificates that use the SM algorithm in the Certificate Management Service console. For more information about SSL certificates, see [What is Certificate Management Service?](https://help.aliyun.com/document_detail/28535.html).
 *
 * @param request AssociateVpnGatewayWithCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateVpnGatewayWithCertificateResponse
 */
AssociateVpnGatewayWithCertificateResponse Client::associateVpnGatewayWithCertificateWithOptions(const AssociateVpnGatewayWithCertificateRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCertificateId()) {
    query["CertificateId"] = request.certificateId();
  }

  if (!!request.hasCertificateType()) {
    query["CertificateType"] = request.certificateType();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AssociateVpnGatewayWithCertificate"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AssociateVpnGatewayWithCertificateResponse>();
}

/**
 * @summary Associates a VPN gateway with a certificate.
 *
 * @description Before you associate a VPN gateway with an SSL certificate, take note of the following items:
 * *   You can associate only VPN gateways of the ShangMi (SM) type with SSL certificates. You need to associate a VPN gateway of the SM type with two SSL certificates, one as the encryption certificate and the other as the signature certificate.
 * *   The SSL certificates must use the SM algorithm.
 * *   You cannot specify one SSL certificate as both the encryption certificate and signature certificate for one VPN gateway.
 * *   **AssociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being associated.
 *     *   If the VPN gateway is in the **active** state, the SSL certificate is being associated.
 * *   You cannot call **AssociateVpnGatewayWithCertificate** within a specific period of time.
 * ### [](#)Prerequisites
 * Make sure that you have two SSL certificates that use the SM algorithm in the Certificate Management Service console. For more information about SSL certificates, see [What is Certificate Management Service?](https://help.aliyun.com/document_detail/28535.html).
 *
 * @param request AssociateVpnGatewayWithCertificateRequest
 * @return AssociateVpnGatewayWithCertificateResponse
 */
AssociateVpnGatewayWithCertificateResponse Client::associateVpnGatewayWithCertificate(const AssociateVpnGatewayWithCertificateRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return associateVpnGatewayWithCertificateWithOptions(request, runtime);
}

/**
 * @description *   The **AttachDhcpOptionsSetToVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
 *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being associated.
 *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is associated.
 * *   You cannot repeatedly call the **AttachDhcpOptionsSetToVpc** operation to associate DHCP options sets with a VPC within the specified period of time.
 *
 * @param request AttachDhcpOptionsSetToVpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachDhcpOptionsSetToVpcResponse
 */
AttachDhcpOptionsSetToVpcResponse Client::attachDhcpOptionsSetToVpcWithOptions(const AttachDhcpOptionsSetToVpcRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDhcpOptionsSetId()) {
    query["DhcpOptionsSetId"] = request.dhcpOptionsSetId();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AttachDhcpOptionsSetToVpc"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AttachDhcpOptionsSetToVpcResponse>();
}

/**
 * @description *   The **AttachDhcpOptionsSetToVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
 *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being associated.
 *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is associated.
 * *   You cannot repeatedly call the **AttachDhcpOptionsSetToVpc** operation to associate DHCP options sets with a VPC within the specified period of time.
 *
 * @param request AttachDhcpOptionsSetToVpcRequest
 * @return AttachDhcpOptionsSetToVpcResponse
 */
AttachDhcpOptionsSetToVpcResponse Client::attachDhcpOptionsSetToVpc(const AttachDhcpOptionsSetToVpcRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return attachDhcpOptionsSetToVpcWithOptions(request, runtime);
}

/**
 * @summary Associates a virtual border router (VBR) with a hosted connection.
 *
 * @param request AttachVbrToVpconnRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachVbrToVpconnResponse
 */
AttachVbrToVpconnResponse Client::attachVbrToVpconnWithOptions(const AttachVbrToVpconnRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasToken()) {
    query["Token"] = request.token();
  }

  if (!!request.hasVbrId()) {
    query["VbrId"] = request.vbrId();
  }

  if (!!request.hasVpconnId()) {
    query["VpconnId"] = request.vpconnId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AttachVbrToVpconn"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AttachVbrToVpconnResponse>();
}

/**
 * @summary Associates a virtual border router (VBR) with a hosted connection.
 *
 * @param request AttachVbrToVpconnRequest
 * @return AttachVbrToVpconnResponse
 */
AttachVbrToVpconnResponse Client::attachVbrToVpconn(const AttachVbrToVpconnRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return attachVbrToVpconnWithOptions(request, runtime);
}

/**
 * @summary Cancels the maximum bandwidth configured for an elastic IP address (EIP) that is associated with an Internet Shared Bandwidth instance.
 *
 * @description Before you call this operation, take note of the following items:
 * *   After this operation is performed, the maximum bandwidth of the EIP equals that of the Internet Shared Bandwidth instance.
 * *   You cannot repeatedly call the **CancelCommonBandwidthPackageIpBandwidth** operation within a specific time period.
 *
 * @param request CancelCommonBandwidthPackageIpBandwidthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelCommonBandwidthPackageIpBandwidthResponse
 */
CancelCommonBandwidthPackageIpBandwidthResponse Client::cancelCommonBandwidthPackageIpBandwidthWithOptions(const CancelCommonBandwidthPackageIpBandwidthRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidthPackageId()) {
    query["BandwidthPackageId"] = request.bandwidthPackageId();
  }

  if (!!request.hasEipId()) {
    query["EipId"] = request.eipId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CancelCommonBandwidthPackageIpBandwidth"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CancelCommonBandwidthPackageIpBandwidthResponse>();
}

/**
 * @summary Cancels the maximum bandwidth configured for an elastic IP address (EIP) that is associated with an Internet Shared Bandwidth instance.
 *
 * @description Before you call this operation, take note of the following items:
 * *   After this operation is performed, the maximum bandwidth of the EIP equals that of the Internet Shared Bandwidth instance.
 * *   You cannot repeatedly call the **CancelCommonBandwidthPackageIpBandwidth** operation within a specific time period.
 *
 * @param request CancelCommonBandwidthPackageIpBandwidthRequest
 * @return CancelCommonBandwidthPackageIpBandwidthResponse
 */
CancelCommonBandwidthPackageIpBandwidthResponse Client::cancelCommonBandwidthPackageIpBandwidth(const CancelCommonBandwidthPackageIpBandwidthRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return cancelCommonBandwidthPackageIpBandwidthWithOptions(request, runtime);
}

/**
 * @summary Cancels an Express Connect circuit before it is enabled. After you perform this operation, the Express Connect circuit enters the Canceled state.
 *
 * @description You can cancel only an Express Connect circuit that is in the **Initial**, **Approved**, **Allocated**, or **Confirmed** state.
 *
 * @param request CancelPhysicalConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelPhysicalConnectionResponse
 */
CancelPhysicalConnectionResponse Client::cancelPhysicalConnectionWithOptions(const CancelPhysicalConnectionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPhysicalConnectionId()) {
    query["PhysicalConnectionId"] = request.physicalConnectionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CancelPhysicalConnection"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CancelPhysicalConnectionResponse>();
}

/**
 * @summary Cancels an Express Connect circuit before it is enabled. After you perform this operation, the Express Connect circuit enters the Canceled state.
 *
 * @description You can cancel only an Express Connect circuit that is in the **Initial**, **Approved**, **Allocated**, or **Confirmed** state.
 *
 * @param request CancelPhysicalConnectionRequest
 * @return CancelPhysicalConnectionResponse
 */
CancelPhysicalConnectionResponse Client::cancelPhysicalConnection(const CancelPhysicalConnectionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return cancelPhysicalConnectionWithOptions(request, runtime);
}

/**
 * @summary Moves an Express Connect circuit to a new resource group.
 *
 * @description ## [](#)
 * You cannot repeatedly call the **ChangeResourceGroup** operation to modify the resource group of the same Express Connect circuit.
 *
 * @param request ChangeResourceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeResourceGroupResponse
 */
ChangeResourceGroupResponse Client::changeResourceGroupWithOptions(const ChangeResourceGroupRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasNewResourceGroupId()) {
    query["NewResourceGroupId"] = request.newResourceGroupId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceId()) {
    query["ResourceId"] = request.resourceId();
  }

  if (!!request.hasResourceType()) {
    query["ResourceType"] = request.resourceType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ChangeResourceGroup"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ChangeResourceGroupResponse>();
}

/**
 * @summary Moves an Express Connect circuit to a new resource group.
 *
 * @description ## [](#)
 * You cannot repeatedly call the **ChangeResourceGroup** operation to modify the resource group of the same Express Connect circuit.
 *
 * @param request ChangeResourceGroupRequest
 * @return ChangeResourceGroupResponse
 */
ChangeResourceGroupResponse Client::changeResourceGroup(const ChangeResourceGroupRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return changeResourceGroupWithOptions(request, runtime);
}

/**
 * @summary Checks whether a private IP address in a specified vSwitch is available.
 *
 * @param request CheckCanAllocateVpcPrivateIpAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckCanAllocateVpcPrivateIpAddressResponse
 */
CheckCanAllocateVpcPrivateIpAddressResponse Client::checkCanAllocateVpcPrivateIpAddressWithOptions(const CheckCanAllocateVpcPrivateIpAddressRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIpVersion()) {
    query["IpVersion"] = request.ipVersion();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPrivateIpAddress()) {
    query["PrivateIpAddress"] = request.privateIpAddress();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVSwitchId()) {
    query["VSwitchId"] = request.vSwitchId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CheckCanAllocateVpcPrivateIpAddress"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CheckCanAllocateVpcPrivateIpAddressResponse>();
}

/**
 * @summary Checks whether a private IP address in a specified vSwitch is available.
 *
 * @param request CheckCanAllocateVpcPrivateIpAddressRequest
 * @return CheckCanAllocateVpcPrivateIpAddressResponse
 */
CheckCanAllocateVpcPrivateIpAddressResponse Client::checkCanAllocateVpcPrivateIpAddress(const CheckCanAllocateVpcPrivateIpAddressRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return checkCanAllocateVpcPrivateIpAddressWithOptions(request, runtime);
}

/**
 * @summary Checks whether the region of an IPsec-VPN connection supports BGP.
 *
 * @param request CheckVpnBgpEnabledRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckVpnBgpEnabledResponse
 */
CheckVpnBgpEnabledResponse Client::checkVpnBgpEnabledWithOptions(const CheckVpnBgpEnabledRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CheckVpnBgpEnabled"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CheckVpnBgpEnabledResponse>();
}

/**
 * @summary Checks whether the region of an IPsec-VPN connection supports BGP.
 *
 * @param request CheckVpnBgpEnabledRequest
 * @return CheckVpnBgpEnabledResponse
 */
CheckVpnBgpEnabledResponse Client::checkVpnBgpEnabled(const CheckVpnBgpEnabledRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return checkVpnBgpEnabledWithOptions(request, runtime);
}

/**
 * @summary Generates a report for an installed Express Connect circuit.
 *
 * @param request CompletePhysicalConnectionLOARequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CompletePhysicalConnectionLOAResponse
 */
CompletePhysicalConnectionLOAResponse Client::completePhysicalConnectionLOAWithOptions(const CompletePhysicalConnectionLOARequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasFinishWork()) {
    query["FinishWork"] = request.finishWork();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasLineCode()) {
    query["LineCode"] = request.lineCode();
  }

  if (!!request.hasLineLabel()) {
    query["LineLabel"] = request.lineLabel();
  }

  if (!!request.hasLineSPContactInfo()) {
    query["LineSPContactInfo"] = request.lineSPContactInfo();
  }

  if (!!request.hasLineServiceProvider()) {
    query["LineServiceProvider"] = request.lineServiceProvider();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CompletePhysicalConnectionLOA"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CompletePhysicalConnectionLOAResponse>();
}

/**
 * @summary Generates a report for an installed Express Connect circuit.
 *
 * @param request CompletePhysicalConnectionLOARequest
 * @return CompletePhysicalConnectionLOAResponse
 */
CompletePhysicalConnectionLOAResponse Client::completePhysicalConnectionLOA(const CompletePhysicalConnectionLOARequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return completePhysicalConnectionLOAWithOptions(request, runtime);
}

/**
 * @summary Changes the status of an Express Connect circuit to Confirmed.
 *
 * @param request ConfirmPhysicalConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfirmPhysicalConnectionResponse
 */
ConfirmPhysicalConnectionResponse Client::confirmPhysicalConnectionWithOptions(const ConfirmPhysicalConnectionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPhysicalConnectionId()) {
    query["PhysicalConnectionId"] = request.physicalConnectionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ConfirmPhysicalConnection"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ConfirmPhysicalConnectionResponse>();
}

/**
 * @summary Changes the status of an Express Connect circuit to Confirmed.
 *
 * @param request ConfirmPhysicalConnectionRequest
 * @return ConfirmPhysicalConnectionResponse
 */
ConfirmPhysicalConnectionResponse Client::confirmPhysicalConnection(const ConfirmPhysicalConnectionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return confirmPhysicalConnectionWithOptions(request, runtime);
}

/**
 * @summary Initiates a connection from the router interface of an initiator to the router interface of an accepter.
 *
 * @description After you call this operation, the router interface enters the **Connecting** state. When the connection is established, it enters the **Active** state.
 * When you call this operation, take note of the following items:
 * *   Only an initiator router interface in the **Idle** state can initiate a connection.
 * *   You can create only one pair of connected router interfaces between two routers.
 * *   You cannot initiate a connection if your Alibaba Cloud account has a router interface with overdue payments.
 *
 * @param request ConnectRouterInterfaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConnectRouterInterfaceResponse
 */
ConnectRouterInterfaceResponse Client::connectRouterInterfaceWithOptions(const ConnectRouterInterfaceRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouterInterfaceId()) {
    query["RouterInterfaceId"] = request.routerInterfaceId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ConnectRouterInterface"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ConnectRouterInterfaceResponse>();
}

/**
 * @summary Initiates a connection from the router interface of an initiator to the router interface of an accepter.
 *
 * @description After you call this operation, the router interface enters the **Connecting** state. When the connection is established, it enters the **Active** state.
 * When you call this operation, take note of the following items:
 * *   Only an initiator router interface in the **Idle** state can initiate a connection.
 * *   You can create only one pair of connected router interfaces between two routers.
 * *   You cannot initiate a connection if your Alibaba Cloud account has a router interface with overdue payments.
 *
 * @param request ConnectRouterInterfaceRequest
 * @return ConnectRouterInterfaceResponse
 */
ConnectRouterInterfaceResponse Client::connectRouterInterface(const ConnectRouterInterfaceRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return connectRouterInterfaceWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI ConvertBandwidthPackage is deprecated
 *
 * @summary Converts a NAT service plan to an Internet Shared Bandwidth instance.
 *
 * @description Before you convert a NAT service plan to an Internet Shared Bandwidth instance, take note of the following limits:
 * *   You are not charged for the conversion.
 * *   When you convert a NAT service plan to an Internet Shared Bandwidth instance, you can continue to use the SNAT and DNAT features of the NAT gateway, and your workloads are not affected. However, we recommend that you convert your NAT service plan during off-peak hours.
 * *   After the NAT service plan is converted to an Internet Shared Bandwidth instance, the public IP addresses in the NAT service plan are converted to elastic IP addresses (EIPs). The maximum bandwidth and billing method of the Internet Shared Bandwidth instance are the same as those of the NAT service plan.
 *
 * @param request ConvertBandwidthPackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConvertBandwidthPackageResponse
 */
ConvertBandwidthPackageResponse Client::convertBandwidthPackageWithOptions(const ConvertBandwidthPackageRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidthPackageId()) {
    query["BandwidthPackageId"] = request.bandwidthPackageId();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ConvertBandwidthPackage"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ConvertBandwidthPackageResponse>();
}

/**
 * @deprecated OpenAPI ConvertBandwidthPackage is deprecated
 *
 * @summary Converts a NAT service plan to an Internet Shared Bandwidth instance.
 *
 * @description Before you convert a NAT service plan to an Internet Shared Bandwidth instance, take note of the following limits:
 * *   You are not charged for the conversion.
 * *   When you convert a NAT service plan to an Internet Shared Bandwidth instance, you can continue to use the SNAT and DNAT features of the NAT gateway, and your workloads are not affected. However, we recommend that you convert your NAT service plan during off-peak hours.
 * *   After the NAT service plan is converted to an Internet Shared Bandwidth instance, the public IP addresses in the NAT service plan are converted to elastic IP addresses (EIPs). The maximum bandwidth and billing method of the Internet Shared Bandwidth instance are the same as those of the NAT service plan.
 *
 * @param request ConvertBandwidthPackageRequest
 * @return ConvertBandwidthPackageResponse
 */
ConvertBandwidthPackageResponse Client::convertBandwidthPackage(const ConvertBandwidthPackageRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return convertBandwidthPackageWithOptions(request, runtime);
}

/**
 * @summary Copies rules of a network access control list (ACL).
 *
 * @description ## [](#)Description
 * *   **CopyNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
 *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being copied.
 *     *   If the network ACL is in the **Available** state, the rules of the network ACL are copied.
 * *   You cannot repeatedly call the **CopyNetworkAclEntries** operation within the specified period of time.
 *
 * @param request CopyNetworkAclEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CopyNetworkAclEntriesResponse
 */
CopyNetworkAclEntriesResponse Client::copyNetworkAclEntriesWithOptions(const CopyNetworkAclEntriesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasNetworkAclId()) {
    query["NetworkAclId"] = request.networkAclId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceNetworkAclId()) {
    query["SourceNetworkAclId"] = request.sourceNetworkAclId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CopyNetworkAclEntries"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CopyNetworkAclEntriesResponse>();
}

/**
 * @summary Copies rules of a network access control list (ACL).
 *
 * @description ## [](#)Description
 * *   **CopyNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
 *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being copied.
 *     *   If the network ACL is in the **Available** state, the rules of the network ACL are copied.
 * *   You cannot repeatedly call the **CopyNetworkAclEntries** operation within the specified period of time.
 *
 * @param request CopyNetworkAclEntriesRequest
 * @return CopyNetworkAclEntriesResponse
 */
CopyNetworkAclEntriesResponse Client::copyNetworkAclEntries(const CopyNetworkAclEntriesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return copyNetworkAclEntriesWithOptions(request, runtime);
}

/**
 * @summary Creates a BGP group for a virtual border router (VBR).
 *
 * @description You can connect a VBR to a data center through BGP. Each BGP group is associated with a VBR. You can add a BGP peer that needs to communicate with a VBR to a BGP group and advertise the BGP network in the VBR.
 * BGP groups are used to simplify BGP configurations. You can add BGP peers that use the same configurations to one BGP group. Before you start, you must create a BGP group with the requested autonomous system number (ASN).
 * When you call this operation, take note of the following limits:
 * *   You can specify only the data center that is connected to the VBR through an Express Connect circuit as a BGP peer.
 * *   VBRs support only BGP-4.
 * *   You can create at most eight BGP peers for each VBR.
 * *   Each BGP peer supports at most 110 dynamic routes.
 * *   The ASN of Alibaba Cloud is 45104. You can specify a 2-byte or 4-byte ASN for the data center.
 *
 * @param request CreateBgpGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBgpGroupResponse
 */
CreateBgpGroupResponse Client::createBgpGroupWithOptions(const CreateBgpGroupRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAuthKey()) {
    query["AuthKey"] = request.authKey();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasIpVersion()) {
    query["IpVersion"] = request.ipVersion();
  }

  if (!!request.hasIsFakeAsn()) {
    query["IsFakeAsn"] = request.isFakeAsn();
  }

  if (!!request.hasLocalAsn()) {
    query["LocalAsn"] = request.localAsn();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPeerAsn()) {
    query["PeerAsn"] = request.peerAsn();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteQuota()) {
    query["RouteQuota"] = request.routeQuota();
  }

  if (!!request.hasRouterId()) {
    query["RouterId"] = request.routerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateBgpGroup"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateBgpGroupResponse>();
}

/**
 * @summary Creates a BGP group for a virtual border router (VBR).
 *
 * @description You can connect a VBR to a data center through BGP. Each BGP group is associated with a VBR. You can add a BGP peer that needs to communicate with a VBR to a BGP group and advertise the BGP network in the VBR.
 * BGP groups are used to simplify BGP configurations. You can add BGP peers that use the same configurations to one BGP group. Before you start, you must create a BGP group with the requested autonomous system number (ASN).
 * When you call this operation, take note of the following limits:
 * *   You can specify only the data center that is connected to the VBR through an Express Connect circuit as a BGP peer.
 * *   VBRs support only BGP-4.
 * *   You can create at most eight BGP peers for each VBR.
 * *   Each BGP peer supports at most 110 dynamic routes.
 * *   The ASN of Alibaba Cloud is 45104. You can specify a 2-byte or 4-byte ASN for the data center.
 *
 * @param request CreateBgpGroupRequest
 * @return CreateBgpGroupResponse
 */
CreateBgpGroupResponse Client::createBgpGroup(const CreateBgpGroupRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createBgpGroupWithOptions(request, runtime);
}

/**
 * @summary Adds a Border Gateway Protocol (BGP) peer to a BGP group.
 *
 * @param request CreateBgpPeerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBgpPeerResponse
 */
CreateBgpPeerResponse Client::createBgpPeerWithOptions(const CreateBgpPeerRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBfdMultiHop()) {
    query["BfdMultiHop"] = request.bfdMultiHop();
  }

  if (!!request.hasBgpGroupId()) {
    query["BgpGroupId"] = request.bgpGroupId();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasEnableBfd()) {
    query["EnableBfd"] = request.enableBfd();
  }

  if (!!request.hasIpVersion()) {
    query["IpVersion"] = request.ipVersion();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPeerIpAddress()) {
    query["PeerIpAddress"] = request.peerIpAddress();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateBgpPeer"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateBgpPeerResponse>();
}

/**
 * @summary Adds a Border Gateway Protocol (BGP) peer to a BGP group.
 *
 * @param request CreateBgpPeerRequest
 * @return CreateBgpPeerResponse
 */
CreateBgpPeerResponse Client::createBgpPeer(const CreateBgpPeerRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createBgpPeerWithOptions(request, runtime);
}

/**
 * @summary Creates an Internet Shared Bandwidth instance.
 *
 * @param request CreateCommonBandwidthPackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCommonBandwidthPackageResponse
 */
CreateCommonBandwidthPackageResponse Client::createCommonBandwidthPackageWithOptions(const CreateCommonBandwidthPackageRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasISP()) {
    query["ISP"] = request.ISP();
  }

  if (!!request.hasInternetChargeType()) {
    query["InternetChargeType"] = request.internetChargeType();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRatio()) {
    query["Ratio"] = request.ratio();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSecurityProtectionTypes()) {
    query["SecurityProtectionTypes"] = request.securityProtectionTypes();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasZone()) {
    query["Zone"] = request.zone();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateCommonBandwidthPackage"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateCommonBandwidthPackageResponse>();
}

/**
 * @summary Creates an Internet Shared Bandwidth instance.
 *
 * @param request CreateCommonBandwidthPackageRequest
 * @return CreateCommonBandwidthPackageResponse
 */
CreateCommonBandwidthPackageResponse Client::createCommonBandwidthPackage(const CreateCommonBandwidthPackageRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createCommonBandwidthPackageWithOptions(request, runtime);
}

/**
 * @summary Creates a customer gateway.
 *
 * @param request CreateCustomerGatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCustomerGatewayResponse
 */
CreateCustomerGatewayResponse Client::createCustomerGatewayWithOptions(const CreateCustomerGatewayRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAsn()) {
    query["Asn"] = request.asn();
  }

  if (!!request.hasAuthKey()) {
    query["AuthKey"] = request.authKey();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasIpAddress()) {
    query["IpAddress"] = request.ipAddress();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateCustomerGateway"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateCustomerGatewayResponse>();
}

/**
 * @summary Creates a customer gateway.
 *
 * @param request CreateCustomerGatewayRequest
 * @return CreateCustomerGatewayResponse
 */
CreateCustomerGatewayResponse Client::createCustomerGateway(const CreateCustomerGatewayRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createCustomerGatewayWithOptions(request, runtime);
}

/**
 * @summary Creates a default vSwitch.
 *
 * @description When you call this operation, take note of the following limits:
 * *   The first IP address and last three IP addresses of a vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
 * *   The number of instances in the default vSwitch cannot exceed the remaining number of instances supported by the VPC (15,000 minus the number of existing instances).
 * *   Default vSwitches do not support multicasting or broadcasting.
 * *   After you create a default vSwitch, you cannot modify its CIDR block.
 * *   **CreateDefaultVSwitch** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of a default vSwitch:
 *     *   If a default vSwitch is in the **Pending** state, it is being configured.
 *     *   If a default vSwitch is in the **Available** state, it is available.
 * *   If a default vSwitch already exists in a region, you cannot call this operation to create a default vSwitch in this region.
 * *   Before you create a default vSwitch, make sure that a default VPC is created. You can call the [CreateDefaultVpc](https://help.aliyun.com/document_detail/609152.html) operation to create a default VPC.
 *
 * @param request CreateDefaultVSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDefaultVSwitchResponse
 */
CreateDefaultVSwitchResponse Client::createDefaultVSwitchWithOptions(const CreateDefaultVSwitchRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasIpv6CidrBlock()) {
    query["Ipv6CidrBlock"] = request.ipv6CidrBlock();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasZoneId()) {
    query["ZoneId"] = request.zoneId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateDefaultVSwitch"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateDefaultVSwitchResponse>();
}

/**
 * @summary Creates a default vSwitch.
 *
 * @description When you call this operation, take note of the following limits:
 * *   The first IP address and last three IP addresses of a vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
 * *   The number of instances in the default vSwitch cannot exceed the remaining number of instances supported by the VPC (15,000 minus the number of existing instances).
 * *   Default vSwitches do not support multicasting or broadcasting.
 * *   After you create a default vSwitch, you cannot modify its CIDR block.
 * *   **CreateDefaultVSwitch** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of a default vSwitch:
 *     *   If a default vSwitch is in the **Pending** state, it is being configured.
 *     *   If a default vSwitch is in the **Available** state, it is available.
 * *   If a default vSwitch already exists in a region, you cannot call this operation to create a default vSwitch in this region.
 * *   Before you create a default vSwitch, make sure that a default VPC is created. You can call the [CreateDefaultVpc](https://help.aliyun.com/document_detail/609152.html) operation to create a default VPC.
 *
 * @param request CreateDefaultVSwitchRequest
 * @return CreateDefaultVSwitchResponse
 */
CreateDefaultVSwitchResponse Client::createDefaultVSwitch(const CreateDefaultVSwitchRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createDefaultVSwitchWithOptions(request, runtime);
}

/**
 * @summary Creates a default virtual private cloud (VPC).
 *
 * @description ## Usage notes
 * When you call this operation, take note of the following items:
 * *   After you create a default VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to it.
 * *   In each default VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
 * *   After you create a default VPC, a vRouter and a route table are automatically created for the VPC.
 * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
 * *   **CreateDefaultVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
 *     *   If the default VPC is in the **Pending** state, the VPC is being configured.
 *     *   If the default VPC is in the **Available** state, the VPC is available.
 * *   You cannot repeatedly call the **CreateDefaultVpc** operation within a specific time period.
 * *   You can create only one default VPC in each region.
 *
 * @param request CreateDefaultVpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDefaultVpcResponse
 */
CreateDefaultVpcResponse Client::createDefaultVpcWithOptions(const CreateDefaultVpcRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasEnableIpv6()) {
    query["EnableIpv6"] = request.enableIpv6();
  }

  if (!!request.hasIpv6CidrBlock()) {
    query["Ipv6CidrBlock"] = request.ipv6CidrBlock();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateDefaultVpc"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateDefaultVpcResponse>();
}

/**
 * @summary Creates a default virtual private cloud (VPC).
 *
 * @description ## Usage notes
 * When you call this operation, take note of the following items:
 * *   After you create a default VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to it.
 * *   In each default VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
 * *   After you create a default VPC, a vRouter and a route table are automatically created for the VPC.
 * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
 * *   **CreateDefaultVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
 *     *   If the default VPC is in the **Pending** state, the VPC is being configured.
 *     *   If the default VPC is in the **Available** state, the VPC is available.
 * *   You cannot repeatedly call the **CreateDefaultVpc** operation within a specific time period.
 * *   You can create only one default VPC in each region.
 *
 * @param request CreateDefaultVpcRequest
 * @return CreateDefaultVpcResponse
 */
CreateDefaultVpcResponse Client::createDefaultVpc(const CreateDefaultVpcRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createDefaultVpcWithOptions(request, runtime);
}

/**
 * @summary Creates a DHCP options set.
 *
 * @description *   **CreateDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/448820.html) to query the status of the task.
 *     *   If the vSwitch is in the **Pending** state, the DHCP options set is being configured.
 *     *   If the vSwitch is in the **Available** state, the DHCP options set is available.
 *
 * @param request CreateDhcpOptionsSetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDhcpOptionsSetResponse
 */
CreateDhcpOptionsSetResponse Client::createDhcpOptionsSetWithOptions(const CreateDhcpOptionsSetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDhcpOptionsSetDescription()) {
    query["DhcpOptionsSetDescription"] = request.dhcpOptionsSetDescription();
  }

  if (!!request.hasDhcpOptionsSetName()) {
    query["DhcpOptionsSetName"] = request.dhcpOptionsSetName();
  }

  if (!!request.hasDomainName()) {
    query["DomainName"] = request.domainName();
  }

  if (!!request.hasDomainNameServers()) {
    query["DomainNameServers"] = request.domainNameServers();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIpv6LeaseTime()) {
    query["Ipv6LeaseTime"] = request.ipv6LeaseTime();
  }

  if (!!request.hasLeaseTime()) {
    query["LeaseTime"] = request.leaseTime();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateDhcpOptionsSet"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateDhcpOptionsSetResponse>();
}

/**
 * @summary Creates a DHCP options set.
 *
 * @description *   **CreateDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/448820.html) to query the status of the task.
 *     *   If the vSwitch is in the **Pending** state, the DHCP options set is being configured.
 *     *   If the vSwitch is in the **Available** state, the DHCP options set is available.
 *
 * @param request CreateDhcpOptionsSetRequest
 * @return CreateDhcpOptionsSetResponse
 */
CreateDhcpOptionsSetResponse Client::createDhcpOptionsSet(const CreateDhcpOptionsSetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createDhcpOptionsSetWithOptions(request, runtime);
}

/**
 * @summary Creates an Express Cloud Connect (ECC) instance.
 *
 * @param request CreateExpressCloudConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateExpressCloudConnectionResponse
 */
CreateExpressCloudConnectionResponse Client::createExpressCloudConnectionWithOptions(const CreateExpressCloudConnectionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasContactMail()) {
    query["ContactMail"] = request.contactMail();
  }

  if (!!request.hasContactTel()) {
    query["ContactTel"] = request.contactTel();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasIDCardNo()) {
    query["IDCardNo"] = request.IDCardNo();
  }

  if (!!request.hasIdcSP()) {
    query["IdcSP"] = request.idcSP();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPeerCity()) {
    query["PeerCity"] = request.peerCity();
  }

  if (!!request.hasPeerLocation()) {
    query["PeerLocation"] = request.peerLocation();
  }

  if (!!request.hasPortType()) {
    query["PortType"] = request.portType();
  }

  if (!!request.hasRedundantEccId()) {
    query["RedundantEccId"] = request.redundantEccId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateExpressCloudConnection"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateExpressCloudConnectionResponse>();
}

/**
 * @summary Creates an Express Cloud Connect (ECC) instance.
 *
 * @param request CreateExpressCloudConnectionRequest
 * @return CreateExpressCloudConnectionResponse
 */
CreateExpressCloudConnectionResponse Client::createExpressCloudConnection(const CreateExpressCloudConnectionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createExpressCloudConnectionWithOptions(request, runtime);
}

/**
 * @summary Creates a quality of service (QoS) policy.
 *
 * @param request CreateExpressConnectTrafficQosRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateExpressConnectTrafficQosResponse
 */
CreateExpressConnectTrafficQosResponse Client::createExpressConnectTrafficQosWithOptions(const CreateExpressConnectTrafficQosRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasQosDescription()) {
    query["QosDescription"] = request.qosDescription();
  }

  if (!!request.hasQosName()) {
    query["QosName"] = request.qosName();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateExpressConnectTrafficQos"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateExpressConnectTrafficQosResponse>();
}

/**
 * @summary Creates a quality of service (QoS) policy.
 *
 * @param request CreateExpressConnectTrafficQosRequest
 * @return CreateExpressConnectTrafficQosResponse
 */
CreateExpressConnectTrafficQosResponse Client::createExpressConnectTrafficQos(const CreateExpressConnectTrafficQosRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createExpressConnectTrafficQosWithOptions(request, runtime);
}

/**
 * @summary Creates a quality of service (QoS) queue.
 *
 * @param request CreateExpressConnectTrafficQosQueueRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateExpressConnectTrafficQosQueueResponse
 */
CreateExpressConnectTrafficQosQueueResponse Client::createExpressConnectTrafficQosQueueWithOptions(const CreateExpressConnectTrafficQosQueueRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidthPercent()) {
    query["BandwidthPercent"] = request.bandwidthPercent();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasQosId()) {
    query["QosId"] = request.qosId();
  }

  if (!!request.hasQueueDescription()) {
    query["QueueDescription"] = request.queueDescription();
  }

  if (!!request.hasQueueName()) {
    query["QueueName"] = request.queueName();
  }

  if (!!request.hasQueueType()) {
    query["QueueType"] = request.queueType();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateExpressConnectTrafficQosQueue"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateExpressConnectTrafficQosQueueResponse>();
}

/**
 * @summary Creates a quality of service (QoS) queue.
 *
 * @param request CreateExpressConnectTrafficQosQueueRequest
 * @return CreateExpressConnectTrafficQosQueueResponse
 */
CreateExpressConnectTrafficQosQueueResponse Client::createExpressConnectTrafficQosQueue(const CreateExpressConnectTrafficQosQueueRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createExpressConnectTrafficQosQueueWithOptions(request, runtime);
}

/**
 * @summary Creates a quality of service (QoS) rule.
 *
 * @param request CreateExpressConnectTrafficQosRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateExpressConnectTrafficQosRuleResponse
 */
CreateExpressConnectTrafficQosRuleResponse Client::createExpressConnectTrafficQosRuleWithOptions(const CreateExpressConnectTrafficQosRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDstCidr()) {
    query["DstCidr"] = request.dstCidr();
  }

  if (!!request.hasDstIPv6Cidr()) {
    query["DstIPv6Cidr"] = request.dstIPv6Cidr();
  }

  if (!!request.hasDstPortRange()) {
    query["DstPortRange"] = request.dstPortRange();
  }

  if (!!request.hasMatchDscp()) {
    query["MatchDscp"] = request.matchDscp();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPriority()) {
    query["Priority"] = request.priority();
  }

  if (!!request.hasProtocol()) {
    query["Protocol"] = request.protocol();
  }

  if (!!request.hasQosId()) {
    query["QosId"] = request.qosId();
  }

  if (!!request.hasQueueId()) {
    query["QueueId"] = request.queueId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRemarkingDscp()) {
    query["RemarkingDscp"] = request.remarkingDscp();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasRuleDescription()) {
    query["RuleDescription"] = request.ruleDescription();
  }

  if (!!request.hasRuleName()) {
    query["RuleName"] = request.ruleName();
  }

  if (!!request.hasSrcCidr()) {
    query["SrcCidr"] = request.srcCidr();
  }

  if (!!request.hasSrcIPv6Cidr()) {
    query["SrcIPv6Cidr"] = request.srcIPv6Cidr();
  }

  if (!!request.hasSrcPortRange()) {
    query["SrcPortRange"] = request.srcPortRange();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateExpressConnectTrafficQosRule"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateExpressConnectTrafficQosRuleResponse>();
}

/**
 * @summary Creates a quality of service (QoS) rule.
 *
 * @param request CreateExpressConnectTrafficQosRuleRequest
 * @return CreateExpressConnectTrafficQosRuleResponse
 */
CreateExpressConnectTrafficQosRuleResponse Client::createExpressConnectTrafficQosRule(const CreateExpressConnectTrafficQosRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createExpressConnectTrafficQosRuleWithOptions(request, runtime);
}

/**
 * @summary Creates a failover test.
 *
 * @description You cannot create a failover test in the following scenarios:
 * *   You have created a failover test in the region and its type is StartNow.
 * *   The Express Connect circuit or hosted connection has pending orders or overdue payments.
 * *   A failover test is already performed on the Express Connect circuit or hosted connection.
 * *   More than one hosted connection is created over the Express Connect circuit.
 * *   More than one cross-account VBR is created on the Express Connect circuit.
 * *   No VBR is associated with the hosted connection.
 * *   The VLAN ID of the hosted connection is set to 0.
 *
 * @param request CreateFailoverTestJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFailoverTestJobResponse
 */
CreateFailoverTestJobResponse Client::createFailoverTestJobWithOptions(const CreateFailoverTestJobRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasJobDuration()) {
    query["JobDuration"] = request.jobDuration();
  }

  if (!!request.hasJobType()) {
    query["JobType"] = request.jobType();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceId()) {
    query["ResourceId"] = request.resourceId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceType()) {
    query["ResourceType"] = request.resourceType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateFailoverTestJob"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateFailoverTestJobResponse>();
}

/**
 * @summary Creates a failover test.
 *
 * @description You cannot create a failover test in the following scenarios:
 * *   You have created a failover test in the region and its type is StartNow.
 * *   The Express Connect circuit or hosted connection has pending orders or overdue payments.
 * *   A failover test is already performed on the Express Connect circuit or hosted connection.
 * *   More than one hosted connection is created over the Express Connect circuit.
 * *   More than one cross-account VBR is created on the Express Connect circuit.
 * *   No VBR is associated with the hosted connection.
 * *   The VLAN ID of the hosted connection is set to 0.
 *
 * @param request CreateFailoverTestJobRequest
 * @return CreateFailoverTestJobResponse
 */
CreateFailoverTestJobResponse Client::createFailoverTestJob(const CreateFailoverTestJobRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createFailoverTestJobWithOptions(request, runtime);
}

/**
 * @summary Creates a flow log.
 *
 * @description **CreateFlowLog** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of the flow log.
 * *   If the flow log is in the **Activating** state, the flow log is being created.
 * *   If the flow log is in the **Active** state, the flow log is created and started.
 *
 * @param request CreateFlowLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFlowLogResponse
 */
CreateFlowLogResponse Client::createFlowLogWithOptions(const CreateFlowLogRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAggregationInterval()) {
    query["AggregationInterval"] = request.aggregationInterval();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasFlowLogName()) {
    query["FlowLogName"] = request.flowLogName();
  }

  if (!!request.hasIpVersion()) {
    query["IpVersion"] = request.ipVersion();
  }

  if (!!request.hasLogStoreName()) {
    query["LogStoreName"] = request.logStoreName();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasProjectName()) {
    query["ProjectName"] = request.projectName();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceId()) {
    query["ResourceId"] = request.resourceId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasResourceType()) {
    query["ResourceType"] = request.resourceType();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasTrafficPath()) {
    query["TrafficPath"] = request.trafficPath();
  }

  if (!!request.hasTrafficType()) {
    query["TrafficType"] = request.trafficType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateFlowLog"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateFlowLogResponse>();
}

/**
 * @summary Creates a flow log.
 *
 * @description **CreateFlowLog** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of the flow log.
 * *   If the flow log is in the **Activating** state, the flow log is being created.
 * *   If the flow log is in the **Active** state, the flow log is created and started.
 *
 * @param request CreateFlowLogRequest
 * @return CreateFlowLogResponse
 */
CreateFlowLogResponse Client::createFlowLog(const CreateFlowLogRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createFlowLogWithOptions(request, runtime);
}

/**
 * @summary Adds a DNAT entry to a DNAT table.
 *
 * @description ## [](#)
 * Each DNAT entry consists of the following parameters: **ExternalIp**, **ExternalPort**, **IpProtocol**, **InternalIp**, and **InternalPort**. After you add a DNAT entry, the NAT gateway forwards packets over the specified protocol from **ExternalIp:ExternalPort** to **InternalIp:InternalPort** and sends responses back through the same route.
 * When you call this operation, take note of the following limits:
 * *   **CreateForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
 *     *   If the DNAT entry is in the **Pending** state, the system is adding the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
 *     *   If the DNAT entry is in the **Available** state, the DNAT entry is added.
 * *   You cannot repeatedly call the **CreateForwardEntry** operation to add a DNAT entry within a specific period of time.
 * *   All combinations of **ExternalIp**, **ExternalPort**, and **IpProtocol** used in DNAT entries must be unique. You cannot distribute requests to more than one Elastic Compute Service (ECS) instance if these requests are initiated from the same source IP address, received on the same port, and use the same protocol.
 * *   The combinations of **IpProtocol**, **InternalIp**, and **InternalPort** must be unique.
 * *   If one or more DNAT entries in the DNAT table are in the **Pending** or **Modifying** state, you cannot add DNAT entries to the DNAT table.
 * *   You can add at most 100 DNAT entries to a DNAT table.
 * *   For an elastic IP address (EIP) used by an Internet NAT gateway or a NAT IP address used by a Virtual Private Cloud (VPC) NAT gateway, take note of the following limit: If the IP address has IP mapping enabled and is specified in a DNAT entry, the IP address cannot be used by another DNAT or SNAT entry.
 *
 * @param request CreateForwardEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateForwardEntryResponse
 */
CreateForwardEntryResponse Client::createForwardEntryWithOptions(const CreateForwardEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasExternalIp()) {
    query["ExternalIp"] = request.externalIp();
  }

  if (!!request.hasExternalPort()) {
    query["ExternalPort"] = request.externalPort();
  }

  if (!!request.hasForwardEntryName()) {
    query["ForwardEntryName"] = request.forwardEntryName();
  }

  if (!!request.hasForwardTableId()) {
    query["ForwardTableId"] = request.forwardTableId();
  }

  if (!!request.hasInternalIp()) {
    query["InternalIp"] = request.internalIp();
  }

  if (!!request.hasInternalPort()) {
    query["InternalPort"] = request.internalPort();
  }

  if (!!request.hasIpProtocol()) {
    query["IpProtocol"] = request.ipProtocol();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPortBreak()) {
    query["PortBreak"] = request.portBreak();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateForwardEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateForwardEntryResponse>();
}

/**
 * @summary Adds a DNAT entry to a DNAT table.
 *
 * @description ## [](#)
 * Each DNAT entry consists of the following parameters: **ExternalIp**, **ExternalPort**, **IpProtocol**, **InternalIp**, and **InternalPort**. After you add a DNAT entry, the NAT gateway forwards packets over the specified protocol from **ExternalIp:ExternalPort** to **InternalIp:InternalPort** and sends responses back through the same route.
 * When you call this operation, take note of the following limits:
 * *   **CreateForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
 *     *   If the DNAT entry is in the **Pending** state, the system is adding the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
 *     *   If the DNAT entry is in the **Available** state, the DNAT entry is added.
 * *   You cannot repeatedly call the **CreateForwardEntry** operation to add a DNAT entry within a specific period of time.
 * *   All combinations of **ExternalIp**, **ExternalPort**, and **IpProtocol** used in DNAT entries must be unique. You cannot distribute requests to more than one Elastic Compute Service (ECS) instance if these requests are initiated from the same source IP address, received on the same port, and use the same protocol.
 * *   The combinations of **IpProtocol**, **InternalIp**, and **InternalPort** must be unique.
 * *   If one or more DNAT entries in the DNAT table are in the **Pending** or **Modifying** state, you cannot add DNAT entries to the DNAT table.
 * *   You can add at most 100 DNAT entries to a DNAT table.
 * *   For an elastic IP address (EIP) used by an Internet NAT gateway or a NAT IP address used by a Virtual Private Cloud (VPC) NAT gateway, take note of the following limit: If the IP address has IP mapping enabled and is specified in a DNAT entry, the IP address cannot be used by another DNAT or SNAT entry.
 *
 * @param request CreateForwardEntryRequest
 * @return CreateForwardEntryResponse
 */
CreateForwardEntryResponse Client::createForwardEntry(const CreateForwardEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createForwardEntryWithOptions(request, runtime);
}

/**
 * @summary Adds a FULLNAT entry to the FULLNAT table.
 *
 * @description *   **CreateFullNatEntry** is an asynchronous operation. After you send a request to call this operation, the system returns a FULLNAT entry and the FULLNAT entry is being added in the backend. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
 *     *   If the FULLNAT entry is in the **Creating** state, the system is adding the FULLNAT entry. You can only query the status of the FULLNAT entry, but cannot perform other operations.
 *     *   If the FULLNAT entry is in the **Available** state, the FULLNAT entry is added.
 * *   You cannot repeatedly call the **CreateFullNatEntry** operation for the same VPN gateway within the specified period of time.
 *
 * @param request CreateFullNatEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFullNatEntryResponse
 */
CreateFullNatEntryResponse Client::createFullNatEntryWithOptions(const CreateFullNatEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAccessIp()) {
    query["AccessIp"] = request.accessIp();
  }

  if (!!request.hasAccessPort()) {
    query["AccessPort"] = request.accessPort();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasFullNatEntryDescription()) {
    query["FullNatEntryDescription"] = request.fullNatEntryDescription();
  }

  if (!!request.hasFullNatEntryName()) {
    query["FullNatEntryName"] = request.fullNatEntryName();
  }

  if (!!request.hasFullNatTableId()) {
    query["FullNatTableId"] = request.fullNatTableId();
  }

  if (!!request.hasIpProtocol()) {
    query["IpProtocol"] = request.ipProtocol();
  }

  if (!!request.hasNatIp()) {
    query["NatIp"] = request.natIp();
  }

  if (!!request.hasNatIpPort()) {
    query["NatIpPort"] = request.natIpPort();
  }

  if (!!request.hasNetworkInterfaceId()) {
    query["NetworkInterfaceId"] = request.networkInterfaceId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateFullNatEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateFullNatEntryResponse>();
}

/**
 * @summary Adds a FULLNAT entry to the FULLNAT table.
 *
 * @description *   **CreateFullNatEntry** is an asynchronous operation. After you send a request to call this operation, the system returns a FULLNAT entry and the FULLNAT entry is being added in the backend. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
 *     *   If the FULLNAT entry is in the **Creating** state, the system is adding the FULLNAT entry. You can only query the status of the FULLNAT entry, but cannot perform other operations.
 *     *   If the FULLNAT entry is in the **Available** state, the FULLNAT entry is added.
 * *   You cannot repeatedly call the **CreateFullNatEntry** operation for the same VPN gateway within the specified period of time.
 *
 * @param request CreateFullNatEntryRequest
 * @return CreateFullNatEntryResponse
 */
CreateFullNatEntryResponse Client::createFullNatEntry(const CreateFullNatEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createFullNatEntryWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI CreateGlobalAccelerationInstance is deprecated
 *
 * @summary Creates a Global Accelerator (GA) instance.
 *
 * @description ## Usage notes
 * You can call this operation to create only pay-as-you-go GA instances.
 *
 * @param request CreateGlobalAccelerationInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateGlobalAccelerationInstanceResponse
 */
CreateGlobalAccelerationInstanceResponse Client::createGlobalAccelerationInstanceWithOptions(const CreateGlobalAccelerationInstanceRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasBandwidthType()) {
    query["BandwidthType"] = request.bandwidthType();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasServiceLocation()) {
    query["ServiceLocation"] = request.serviceLocation();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateGlobalAccelerationInstance"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateGlobalAccelerationInstanceResponse>();
}

/**
 * @deprecated OpenAPI CreateGlobalAccelerationInstance is deprecated
 *
 * @summary Creates a Global Accelerator (GA) instance.
 *
 * @description ## Usage notes
 * You can call this operation to create only pay-as-you-go GA instances.
 *
 * @param request CreateGlobalAccelerationInstanceRequest
 * @return CreateGlobalAccelerationInstanceResponse
 */
CreateGlobalAccelerationInstanceResponse Client::createGlobalAccelerationInstance(const CreateGlobalAccelerationInstanceRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createGlobalAccelerationInstanceWithOptions(request, runtime);
}

/**
 * @summary Creates a high-availability virtual IP address (HaVip).
 *
 * @description **CreateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of the task:
 * *   If the HaVip is in the **Creating** state, the HaVip is being created.
 * *   If the HaVip is in the **Available** state, the HaVip is created.
 *
 * @param request CreateHaVipRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateHaVipResponse
 */
CreateHaVipResponse Client::createHaVipWithOptions(const CreateHaVipRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasIpAddress()) {
    query["IpAddress"] = request.ipAddress();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasVSwitchId()) {
    query["VSwitchId"] = request.vSwitchId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateHaVip"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateHaVipResponse>();
}

/**
 * @summary Creates a high-availability virtual IP address (HaVip).
 *
 * @description **CreateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of the task:
 * *   If the HaVip is in the **Creating** state, the HaVip is being created.
 * *   If the HaVip is in the **Available** state, the HaVip is created.
 *
 * @param request CreateHaVipRequest
 * @return CreateHaVipResponse
 */
CreateHaVipResponse Client::createHaVip(const CreateHaVipRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createHaVipWithOptions(request, runtime);
}

/**
 * @summary Creates Express Connect circuits in high reliability mode. This improves the stability of multiple Express Connect circuits and prevents service interruptions caused by single points of failures (SPOFs).
 *
 * @param request CreateHighReliablePhysicalConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateHighReliablePhysicalConnectionResponse
 */
CreateHighReliablePhysicalConnectionResponse Client::createHighReliablePhysicalConnectionWithOptions(const CreateHighReliablePhysicalConnectionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAcceptLanguage()) {
    query["AcceptLanguage"] = request.acceptLanguage();
  }

  if (!!request.hasApList()) {
    query["ApList"] = request.apList();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDeviceAdvancedCapacity()) {
    query["DeviceAdvancedCapacity"] = request.deviceAdvancedCapacity();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasHighReliableType()) {
    query["HighReliableType"] = request.highReliableType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPortType()) {
    query["PortType"] = request.portType();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateHighReliablePhysicalConnection"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateHighReliablePhysicalConnectionResponse>();
}

/**
 * @summary Creates Express Connect circuits in high reliability mode. This improves the stability of multiple Express Connect circuits and prevents service interruptions caused by single points of failures (SPOFs).
 *
 * @param request CreateHighReliablePhysicalConnectionRequest
 * @return CreateHighReliablePhysicalConnectionResponse
 */
CreateHighReliablePhysicalConnectionResponse Client::createHighReliablePhysicalConnection(const CreateHighReliablePhysicalConnectionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createHighReliablePhysicalConnectionWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI CreateIPv6Translator is deprecated
 *
 * @summary Creates an IPv6 Translation Service instance.
 *
 * @param request CreateIPv6TranslatorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIPv6TranslatorResponse
 */
CreateIPv6TranslatorResponse Client::createIPv6TranslatorWithOptions(const CreateIPv6TranslatorRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAutoPay()) {
    query["AutoPay"] = request.autoPay();
  }

  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDuration()) {
    query["Duration"] = request.duration();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPayType()) {
    query["PayType"] = request.payType();
  }

  if (!!request.hasPricingCycle()) {
    query["PricingCycle"] = request.pricingCycle();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSpec()) {
    query["Spec"] = request.spec();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateIPv6Translator"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateIPv6TranslatorResponse>();
}

/**
 * @deprecated OpenAPI CreateIPv6Translator is deprecated
 *
 * @summary Creates an IPv6 Translation Service instance.
 *
 * @param request CreateIPv6TranslatorRequest
 * @return CreateIPv6TranslatorResponse
 */
CreateIPv6TranslatorResponse Client::createIPv6Translator(const CreateIPv6TranslatorRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createIPv6TranslatorWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI CreateIPv6TranslatorAclList is deprecated
 *
 * @summary Creates an access control list (ACL).
 *
 * @param request CreateIPv6TranslatorAclListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIPv6TranslatorAclListResponse
 */
CreateIPv6TranslatorAclListResponse Client::createIPv6TranslatorAclListWithOptions(const CreateIPv6TranslatorAclListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAclName()) {
    query["AclName"] = request.aclName();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateIPv6TranslatorAclList"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateIPv6TranslatorAclListResponse>();
}

/**
 * @deprecated OpenAPI CreateIPv6TranslatorAclList is deprecated
 *
 * @summary Creates an access control list (ACL).
 *
 * @param request CreateIPv6TranslatorAclListRequest
 * @return CreateIPv6TranslatorAclListResponse
 */
CreateIPv6TranslatorAclListResponse Client::createIPv6TranslatorAclList(const CreateIPv6TranslatorAclListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createIPv6TranslatorAclListWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI CreateIPv6TranslatorEntry is deprecated
 *
 * @summary Adds an IPv6 mapping entry to an IPv6 Translation Service instance.
 *
 * @param request CreateIPv6TranslatorEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIPv6TranslatorEntryResponse
 */
CreateIPv6TranslatorEntryResponse Client::createIPv6TranslatorEntryWithOptions(const CreateIPv6TranslatorEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAclId()) {
    query["AclId"] = request.aclId();
  }

  if (!!request.hasAclStatus()) {
    query["AclStatus"] = request.aclStatus();
  }

  if (!!request.hasAclType()) {
    query["AclType"] = request.aclType();
  }

  if (!!request.hasAllocateIpv6Port()) {
    query["AllocateIpv6Port"] = request.allocateIpv6Port();
  }

  if (!!request.hasBackendIpv4Addr()) {
    query["BackendIpv4Addr"] = request.backendIpv4Addr();
  }

  if (!!request.hasBackendIpv4Port()) {
    query["BackendIpv4Port"] = request.backendIpv4Port();
  }

  if (!!request.hasEntryBandwidth()) {
    query["EntryBandwidth"] = request.entryBandwidth();
  }

  if (!!request.hasEntryDescription()) {
    query["EntryDescription"] = request.entryDescription();
  }

  if (!!request.hasEntryName()) {
    query["EntryName"] = request.entryName();
  }

  if (!!request.hasIpv6TranslatorId()) {
    query["Ipv6TranslatorId"] = request.ipv6TranslatorId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTransProtocol()) {
    query["TransProtocol"] = request.transProtocol();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateIPv6TranslatorEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateIPv6TranslatorEntryResponse>();
}

/**
 * @deprecated OpenAPI CreateIPv6TranslatorEntry is deprecated
 *
 * @summary Adds an IPv6 mapping entry to an IPv6 Translation Service instance.
 *
 * @param request CreateIPv6TranslatorEntryRequest
 * @return CreateIPv6TranslatorEntryResponse
 */
CreateIPv6TranslatorEntryResponse Client::createIPv6TranslatorEntry(const CreateIPv6TranslatorEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createIPv6TranslatorEntryWithOptions(request, runtime);
}

/**
 * @summary Creates an IPsec server.
 *
 * @description *   Before you create an IPsec server, you must create a VPN gateway and enable the SSL-VPN feature for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
 * *   Before you create an IPsec server, make sure that no IPsec-VPN connection exists on the VPN gateway. For more information, see [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
 * *   **CreateIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the IPsec server is being created.
 *     *   If the VPN gateway is in the **active** state, the IPsec server is created.
 * *   You cannot repeatedly call **CreateIpsecServer** within the specified period of time.
 *
 * @param request CreateIpsecServerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIpsecServerResponse
 */
CreateIpsecServerResponse Client::createIpsecServerWithOptions(const CreateIpsecServerRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientIpPool()) {
    query["ClientIpPool"] = request.clientIpPool();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEffectImmediately()) {
    query["EffectImmediately"] = request.effectImmediately();
  }

  if (!!request.hasIkeConfig()) {
    query["IkeConfig"] = request.ikeConfig();
  }

  if (!!request.hasIpSecServerName()) {
    query["IpSecServerName"] = request.ipSecServerName();
  }

  if (!!request.hasIpsecConfig()) {
    query["IpsecConfig"] = request.ipsecConfig();
  }

  if (!!request.hasLocalSubnet()) {
    query["LocalSubnet"] = request.localSubnet();
  }

  if (!!request.hasPsk()) {
    query["Psk"] = request.psk();
  }

  if (!!request.hasPskEnabled()) {
    query["PskEnabled"] = request.pskEnabled();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateIpsecServer"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateIpsecServerResponse>();
}

/**
 * @summary Creates an IPsec server.
 *
 * @description *   Before you create an IPsec server, you must create a VPN gateway and enable the SSL-VPN feature for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
 * *   Before you create an IPsec server, make sure that no IPsec-VPN connection exists on the VPN gateway. For more information, see [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
 * *   **CreateIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the IPsec server is being created.
 *     *   If the VPN gateway is in the **active** state, the IPsec server is created.
 * *   You cannot repeatedly call **CreateIpsecServer** within the specified period of time.
 *
 * @param request CreateIpsecServerRequest
 * @return CreateIpsecServerResponse
 */
CreateIpsecServerResponse Client::createIpsecServer(const CreateIpsecServerRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createIpsecServerWithOptions(request, runtime);
}

/**
 * @summary 创建IPv4网关。
 *
 * @description *   **CreateIpv4Gateway** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway:
 *     *   If the IPv4 gateway is in the **Creating** state, the IPv4 gateway is being created.
 *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is created.
 * *   You cannot repeatedly call the **CreateIpv4Gateway** operation to create IPv4 gateways in a virtual private cloud (VPC) within the specified period of time.
 *
 * @param request CreateIpv4GatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIpv4GatewayResponse
 */
CreateIpv4GatewayResponse Client::createIpv4GatewayWithOptions(const CreateIpv4GatewayRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIpv4GatewayDescription()) {
    query["Ipv4GatewayDescription"] = request.ipv4GatewayDescription();
  }

  if (!!request.hasIpv4GatewayName()) {
    query["Ipv4GatewayName"] = request.ipv4GatewayName();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateIpv4Gateway"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateIpv4GatewayResponse>();
}

/**
 * @summary 创建IPv4网关。
 *
 * @description *   **CreateIpv4Gateway** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway:
 *     *   If the IPv4 gateway is in the **Creating** state, the IPv4 gateway is being created.
 *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is created.
 * *   You cannot repeatedly call the **CreateIpv4Gateway** operation to create IPv4 gateways in a virtual private cloud (VPC) within the specified period of time.
 *
 * @param request CreateIpv4GatewayRequest
 * @return CreateIpv4GatewayResponse
 */
CreateIpv4GatewayResponse Client::createIpv4Gateway(const CreateIpv4GatewayRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createIpv4GatewayWithOptions(request, runtime);
}

/**
 * @summary You can call CreateIpv6EgressOnlyRule to create egress-only rules to enable ECS instances in VPCs that have IPv6 enabled to access IPv6 clients. However, IPv6 clients cannot access the ECS instances over the Internet.
 *
 * @description *   **CreateIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and creates the rule in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
 *     *   If the egress-only rule is in the **Creating** state, the egress-only rule is being created.
 *     *   If the egress-only rule is in the **Created** state, the egress-only rule is created.
 * *   You cannot repeatedly call the **CreateIpv6EgressOnlyRule** operation to add egress-only rules for an IPv6 address within the specified period of time.
 *
 * @param request CreateIpv6EgressOnlyRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIpv6EgressOnlyRuleResponse
 */
CreateIpv6EgressOnlyRuleResponse Client::createIpv6EgressOnlyRuleWithOptions(const CreateIpv6EgressOnlyRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasInstanceType()) {
    query["InstanceType"] = request.instanceType();
  }

  if (!!request.hasIpv6GatewayId()) {
    query["Ipv6GatewayId"] = request.ipv6GatewayId();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateIpv6EgressOnlyRule"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateIpv6EgressOnlyRuleResponse>();
}

/**
 * @summary You can call CreateIpv6EgressOnlyRule to create egress-only rules to enable ECS instances in VPCs that have IPv6 enabled to access IPv6 clients. However, IPv6 clients cannot access the ECS instances over the Internet.
 *
 * @description *   **CreateIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and creates the rule in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
 *     *   If the egress-only rule is in the **Creating** state, the egress-only rule is being created.
 *     *   If the egress-only rule is in the **Created** state, the egress-only rule is created.
 * *   You cannot repeatedly call the **CreateIpv6EgressOnlyRule** operation to add egress-only rules for an IPv6 address within the specified period of time.
 *
 * @param request CreateIpv6EgressOnlyRuleRequest
 * @return CreateIpv6EgressOnlyRuleResponse
 */
CreateIpv6EgressOnlyRuleResponse Client::createIpv6EgressOnlyRule(const CreateIpv6EgressOnlyRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createIpv6EgressOnlyRuleWithOptions(request, runtime);
}

/**
 * @summary IPv6 gateways are used to control the IPv6 traffic of virtual private clouds (VPCs). You can call the CreateIpv6Gateway operation to create IPv6 gateways.
 *
 * @description *   **CreateIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task.
 *     *   If the IPv6 gateway is in the **Creating** state, the IPv6 gateway is being created.
 *     *   If the IPv6 gateway is in the **Created** state, the IPv6 gateway is created.
 * *   You cannot repeatedly call the **CreateIpv6Gateway** operation within a specific time period.
 *
 * @param request CreateIpv6GatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIpv6GatewayResponse
 */
CreateIpv6GatewayResponse Client::createIpv6GatewayWithOptions(const CreateIpv6GatewayRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateIpv6Gateway"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateIpv6GatewayResponse>();
}

/**
 * @summary IPv6 gateways are used to control the IPv6 traffic of virtual private clouds (VPCs). You can call the CreateIpv6Gateway operation to create IPv6 gateways.
 *
 * @description *   **CreateIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task.
 *     *   If the IPv6 gateway is in the **Creating** state, the IPv6 gateway is being created.
 *     *   If the IPv6 gateway is in the **Created** state, the IPv6 gateway is created.
 * *   You cannot repeatedly call the **CreateIpv6Gateway** operation within a specific time period.
 *
 * @param request CreateIpv6GatewayRequest
 * @return CreateIpv6GatewayResponse
 */
CreateIpv6GatewayResponse Client::createIpv6Gateway(const CreateIpv6GatewayRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createIpv6GatewayWithOptions(request, runtime);
}

/**
 * @summary Creates an enhanced Internet NAT gateway or a Virtual Private Cloud (VPC) NAT gateway.
 *
 * @description ## Usage notes
 * Before you call this operation, take note of the following items:
 * *   When you create an enhanced NAT gateway for the first time, the system automatically creates the service-linked role AliyunServiceRoleForNatgw. Then, the system attaches the permission policy AliyunServiceRolePolicyForNatgw to the role. This allows the NAT gateway to access other resources on Alibaba Cloud. For more information, see [Service-linked roles](https://help.aliyun.com/document_detail/174251.html).
 * *   After you create an enhanced Internet NAT gateway, a route entry is automatically added to the route table of the VPC. The destination CIDR block of the route entry is 0.0.0.0/0 and the next hop is the NAT gateway. This ensures that traffic is routed to the NAT gateway.
 * *   **CreateNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) operation to query the status of the task.
 *     *   If a NAT gateway is in the **Creating** state, the NAT gateway is being created. In this case, you can query the NAT gateway but cannot perform other operations.
 *     *   If a NAT gateway is in the **Available** state, the NAT gateway is created.
 * It takes 1 to 3 minutes to create a NAT gateway.
 *
 * @param tmpReq CreateNatGatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNatGatewayResponse
 */
CreateNatGatewayResponse Client::createNatGatewayWithOptions(const CreateNatGatewayRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  CreateNatGatewayShrinkRequest request = CreateNatGatewayShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasAccessMode()) {
    request.setAccessModeShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.accessMode(), "AccessMode", "json"));
  }

  json query = {};
  if (!!request.hasAccessModeShrink()) {
    query["AccessMode"] = request.accessModeShrink();
  }

  if (!!request.hasAutoPay()) {
    query["AutoPay"] = request.autoPay();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDuration()) {
    query["Duration"] = request.duration();
  }

  if (!!request.hasEipBindMode()) {
    query["EipBindMode"] = request.eipBindMode();
  }

  if (!!request.hasIcmpReplyEnabled()) {
    query["IcmpReplyEnabled"] = request.icmpReplyEnabled();
  }

  if (!!request.hasInstanceChargeType()) {
    query["InstanceChargeType"] = request.instanceChargeType();
  }

  if (!!request.hasInternetChargeType()) {
    query["InternetChargeType"] = request.internetChargeType();
  }

  if (!!request.hasIpv4Prefix()) {
    query["Ipv4Prefix"] = request.ipv4Prefix();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasNatIp()) {
    query["NatIp"] = request.natIp();
  }

  if (!!request.hasNatType()) {
    query["NatType"] = request.natType();
  }

  if (!!request.hasNetworkType()) {
    query["NetworkType"] = request.networkType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPricingCycle()) {
    query["PricingCycle"] = request.pricingCycle();
  }

  if (!!request.hasPrivateLinkEnabled()) {
    query["PrivateLinkEnabled"] = request.privateLinkEnabled();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSecurityProtectionEnabled()) {
    query["SecurityProtectionEnabled"] = request.securityProtectionEnabled();
  }

  if (!!request.hasSpec()) {
    query["Spec"] = request.spec();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasVSwitchId()) {
    query["VSwitchId"] = request.vSwitchId();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateNatGateway"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateNatGatewayResponse>();
}

/**
 * @summary Creates an enhanced Internet NAT gateway or a Virtual Private Cloud (VPC) NAT gateway.
 *
 * @description ## Usage notes
 * Before you call this operation, take note of the following items:
 * *   When you create an enhanced NAT gateway for the first time, the system automatically creates the service-linked role AliyunServiceRoleForNatgw. Then, the system attaches the permission policy AliyunServiceRolePolicyForNatgw to the role. This allows the NAT gateway to access other resources on Alibaba Cloud. For more information, see [Service-linked roles](https://help.aliyun.com/document_detail/174251.html).
 * *   After you create an enhanced Internet NAT gateway, a route entry is automatically added to the route table of the VPC. The destination CIDR block of the route entry is 0.0.0.0/0 and the next hop is the NAT gateway. This ensures that traffic is routed to the NAT gateway.
 * *   **CreateNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) operation to query the status of the task.
 *     *   If a NAT gateway is in the **Creating** state, the NAT gateway is being created. In this case, you can query the NAT gateway but cannot perform other operations.
 *     *   If a NAT gateway is in the **Available** state, the NAT gateway is created.
 * It takes 1 to 3 minutes to create a NAT gateway.
 *
 * @param request CreateNatGatewayRequest
 * @return CreateNatGatewayResponse
 */
CreateNatGatewayResponse Client::createNatGateway(const CreateNatGatewayRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createNatGatewayWithOptions(request, runtime);
}

/**
 * @summary Creates a NAT IP address.
 *
 * @description ## [](#)
 * **CreateNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/287000.html) operation to query the status of the task.
 * *   If a NAT IP address is in the **Creating** state, the NAT IP address is being created. In this case, you can only query the NAT IP address and cannot perform other operations.
 * *   If a NAT IP address is in the **Available** state, the NAT IP address is created.
 * You cannot repeatedly call the **CreateNatIp** operation to create a NAT IP address within a specific period of time.
 *
 * @param request CreateNatIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNatIpResponse
 */
CreateNatIpResponse Client::createNatIpWithOptions(const CreateNatIpRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIpv4Prefix()) {
    query["Ipv4Prefix"] = request.ipv4Prefix();
  }

  if (!!request.hasIpv4PrefixCount()) {
    query["Ipv4PrefixCount"] = request.ipv4PrefixCount();
  }

  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasNatIp()) {
    query["NatIp"] = request.natIp();
  }

  if (!!request.hasNatIpCidr()) {
    query["NatIpCidr"] = request.natIpCidr();
  }

  if (!!request.hasNatIpDescription()) {
    query["NatIpDescription"] = request.natIpDescription();
  }

  if (!!request.hasNatIpName()) {
    query["NatIpName"] = request.natIpName();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateNatIp"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateNatIpResponse>();
}

/**
 * @summary Creates a NAT IP address.
 *
 * @description ## [](#)
 * **CreateNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/287000.html) operation to query the status of the task.
 * *   If a NAT IP address is in the **Creating** state, the NAT IP address is being created. In this case, you can only query the NAT IP address and cannot perform other operations.
 * *   If a NAT IP address is in the **Available** state, the NAT IP address is created.
 * You cannot repeatedly call the **CreateNatIp** operation to create a NAT IP address within a specific period of time.
 *
 * @param request CreateNatIpRequest
 * @return CreateNatIpResponse
 */
CreateNatIpResponse Client::createNatIp(const CreateNatIpRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createNatIpWithOptions(request, runtime);
}

/**
 * @summary Creates a NAT CIDR block.
 *
 * @description ## [](#)Description
 * You cannot repeatedly call the **CreateNatIpCidr** operation to create a NAT CIDR block within the specified period of time.
 *
 * @param request CreateNatIpCidrRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNatIpCidrResponse
 */
CreateNatIpCidrResponse Client::createNatIpCidrWithOptions(const CreateNatIpCidrRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasNatIpCidr()) {
    query["NatIpCidr"] = request.natIpCidr();
  }

  if (!!request.hasNatIpCidrDescription()) {
    query["NatIpCidrDescription"] = request.natIpCidrDescription();
  }

  if (!!request.hasNatIpCidrName()) {
    query["NatIpCidrName"] = request.natIpCidrName();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateNatIpCidr"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateNatIpCidrResponse>();
}

/**
 * @summary Creates a NAT CIDR block.
 *
 * @description ## [](#)Description
 * You cannot repeatedly call the **CreateNatIpCidr** operation to create a NAT CIDR block within the specified period of time.
 *
 * @param request CreateNatIpCidrRequest
 * @return CreateNatIpCidrResponse
 */
CreateNatIpCidrResponse Client::createNatIpCidr(const CreateNatIpCidrRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createNatIpCidrWithOptions(request, runtime);
}

/**
 * @summary Creates a network ACL.
 *
 * @param request CreateNetworkAclRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNetworkAclResponse
 */
CreateNetworkAclResponse Client::createNetworkAclWithOptions(const CreateNetworkAclRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasNetworkAclName()) {
    query["NetworkAclName"] = request.networkAclName();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateNetworkAcl"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateNetworkAclResponse>();
}

/**
 * @summary Creates a network ACL.
 *
 * @param request CreateNetworkAclRequest
 * @return CreateNetworkAclResponse
 */
CreateNetworkAclResponse Client::createNetworkAcl(const CreateNetworkAclRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createNetworkAclWithOptions(request, runtime);
}

/**
 * @summary Applies for an Express Connect circuit.
 *
 * @description You can apply for a dedicated Express Connect circuit for yourself or create a hosted connection for a tenant. After your application is approved, the Express Connect circuit changes to the **Initial** state. You can contact the connectivity provider to start construction.
 * When you call this operation, take note of the following limits:
 * *   If your Alibaba Cloud account has more than five Express Connect circuits that are not in the **Enabled** state, you cannot apply for another Express Connect circuit.
 * *   If your Alibaba Cloud account has an Express Connect circuit with overdue payments, you cannot apply for another Express Connect circuit.
 *
 * @param request CreatePhysicalConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePhysicalConnectionResponse
 */
CreatePhysicalConnectionResponse Client::createPhysicalConnectionWithOptions(const CreatePhysicalConnectionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAccessPointId()) {
    query["AccessPointId"] = request.accessPointId();
  }

  if (!!request.hasCircuitCode()) {
    query["CircuitCode"] = request.circuitCode();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDeviceAdvancedCapacity()) {
    query["DeviceAdvancedCapacity"] = request.deviceAdvancedCapacity();
  }

  if (!!request.hasLineOperator()) {
    query["LineOperator"] = request.lineOperator();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPeerLocation()) {
    query["PeerLocation"] = request.peerLocation();
  }

  if (!!request.hasPortType()) {
    query["PortType"] = request.portType();
  }

  if (!!request.hasRedundantPhysicalConnectionId()) {
    query["RedundantPhysicalConnectionId"] = request.redundantPhysicalConnectionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasBandwidth()) {
    query["bandwidth"] = request.bandwidth();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreatePhysicalConnection"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreatePhysicalConnectionResponse>();
}

/**
 * @summary Applies for an Express Connect circuit.
 *
 * @description You can apply for a dedicated Express Connect circuit for yourself or create a hosted connection for a tenant. After your application is approved, the Express Connect circuit changes to the **Initial** state. You can contact the connectivity provider to start construction.
 * When you call this operation, take note of the following limits:
 * *   If your Alibaba Cloud account has more than five Express Connect circuits that are not in the **Enabled** state, you cannot apply for another Express Connect circuit.
 * *   If your Alibaba Cloud account has an Express Connect circuit with overdue payments, you cannot apply for another Express Connect circuit.
 *
 * @param request CreatePhysicalConnectionRequest
 * @return CreatePhysicalConnectionResponse
 */
CreatePhysicalConnectionResponse Client::createPhysicalConnection(const CreatePhysicalConnectionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createPhysicalConnectionWithOptions(request, runtime);
}

/**
 * @summary Creates an order for resource occupation of an Express Connect circuit.
 *
 * @description >  You can call this operation only when the Express Connect circuit is in the **Complete** state.
 *
 * @param request CreatePhysicalConnectionOccupancyOrderRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePhysicalConnectionOccupancyOrderResponse
 */
CreatePhysicalConnectionOccupancyOrderResponse Client::createPhysicalConnectionOccupancyOrderWithOptions(const CreatePhysicalConnectionOccupancyOrderRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAutoPay()) {
    query["AutoPay"] = request.autoPay();
  }

  if (!!request.hasAutoRenew()) {
    query["AutoRenew"] = request.autoRenew();
  }

  if (!!request.hasAutoRenewDuration()) {
    query["AutoRenewDuration"] = request.autoRenewDuration();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasInstanceChargeType()) {
    query["InstanceChargeType"] = request.instanceChargeType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPeriod()) {
    query["Period"] = request.period();
  }

  if (!!request.hasPhysicalConnectionId()) {
    query["PhysicalConnectionId"] = request.physicalConnectionId();
  }

  if (!!request.hasPricingCycle()) {
    query["PricingCycle"] = request.pricingCycle();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreatePhysicalConnectionOccupancyOrder"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreatePhysicalConnectionOccupancyOrderResponse>();
}

/**
 * @summary Creates an order for resource occupation of an Express Connect circuit.
 *
 * @description >  You can call this operation only when the Express Connect circuit is in the **Complete** state.
 *
 * @param request CreatePhysicalConnectionOccupancyOrderRequest
 * @return CreatePhysicalConnectionOccupancyOrderResponse
 */
CreatePhysicalConnectionOccupancyOrderResponse Client::createPhysicalConnectionOccupancyOrder(const CreatePhysicalConnectionOccupancyOrderRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createPhysicalConnectionOccupancyOrderWithOptions(request, runtime);
}

/**
 * @summary Creates an order for initial installation of an Express Connect circuit.
 *
 * @param request CreatePhysicalConnectionSetupOrderRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePhysicalConnectionSetupOrderResponse
 */
CreatePhysicalConnectionSetupOrderResponse Client::createPhysicalConnectionSetupOrderWithOptions(const CreatePhysicalConnectionSetupOrderRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAccessPointId()) {
    query["AccessPointId"] = request.accessPointId();
  }

  if (!!request.hasAutoPay()) {
    query["AutoPay"] = request.autoPay();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasLineOperator()) {
    query["LineOperator"] = request.lineOperator();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPortType()) {
    query["PortType"] = request.portType();
  }

  if (!!request.hasRedundantPhysicalConnectionId()) {
    query["RedundantPhysicalConnectionId"] = request.redundantPhysicalConnectionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreatePhysicalConnectionSetupOrder"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreatePhysicalConnectionSetupOrderResponse>();
}

/**
 * @summary Creates an order for initial installation of an Express Connect circuit.
 *
 * @param request CreatePhysicalConnectionSetupOrderRequest
 * @return CreatePhysicalConnectionSetupOrderResponse
 */
CreatePhysicalConnectionSetupOrderResponse Client::createPhysicalConnectionSetupOrder(const CreatePhysicalConnectionSetupOrderRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createPhysicalConnectionSetupOrderWithOptions(request, runtime);
}

/**
 * @summary Creates an IP address pool.
 *
 * @description By default, the IP address pool feature is unavailable. You can apply for the privilege to use the **IP address pool feature** in the Quota Center console. For more information, see the "Request a quota increase in the Quota Center console" section in the [Manage EIP quotas](https://help.aliyun.com/document_detail/108213.html) topic.
 *
 * @param request CreatePublicIpAddressPoolRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePublicIpAddressPoolResponse
 */
CreatePublicIpAddressPoolResponse Client::createPublicIpAddressPoolWithOptions(const CreatePublicIpAddressPoolRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBizType()) {
    query["BizType"] = request.bizType();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIsp()) {
    query["Isp"] = request.isp();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSecurityProtectionTypes()) {
    query["SecurityProtectionTypes"] = request.securityProtectionTypes();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasZones()) {
    query["Zones"] = request.zones();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreatePublicIpAddressPool"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreatePublicIpAddressPoolResponse>();
}

/**
 * @summary Creates an IP address pool.
 *
 * @description By default, the IP address pool feature is unavailable. You can apply for the privilege to use the **IP address pool feature** in the Quota Center console. For more information, see the "Request a quota increase in the Quota Center console" section in the [Manage EIP quotas](https://help.aliyun.com/document_detail/108213.html) topic.
 *
 * @param request CreatePublicIpAddressPoolRequest
 * @return CreatePublicIpAddressPoolResponse
 */
CreatePublicIpAddressPoolResponse Client::createPublicIpAddressPool(const CreatePublicIpAddressPoolRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createPublicIpAddressPoolWithOptions(request, runtime);
}

/**
 * @summary Adds custom route entries to the route table of a vRouter in a virtual private cloud (VPC).
 *
 * @description ## [](#)References
 * *   **CreateRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
 *     *   If the route entry is in the **Creating** state, the route entry is being created.
 *     *   If the route entry is in the **Created** state, the route entry is created.
 * *   You cannot repeatedly call the **CreateRouteEntries** operation to create the same route entry within the specified period of time.
 * **When you call this operation to add custom route entries to the route table of a vRouter, take note of the following items:**
 * *   A route table can contain up to 200 custom route entries.
 * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be the same as or overlap with the CIDR block of a vSwitch in the VPC.
 * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or its subnets.
 * *   The destination CIDR blocks (**DstCidrBlock**) of route entries in the same route table must be unique.
 * *   If you do not include the mask length when you specify the destination CIDR block (**DstCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
 * *   Multiple custom route entries can point to the same next hop (**NextHop**).
 * *   The next hop (**NextHop**) of a custom route entry must belong to the same VPC as the route table.
 *
 * @param request CreateRouteEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRouteEntriesResponse
 */
CreateRouteEntriesResponse Client::createRouteEntriesWithOptions(const CreateRouteEntriesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteEntries()) {
    query["RouteEntries"] = request.routeEntries();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateRouteEntries"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateRouteEntriesResponse>();
}

/**
 * @summary Adds custom route entries to the route table of a vRouter in a virtual private cloud (VPC).
 *
 * @description ## [](#)References
 * *   **CreateRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
 *     *   If the route entry is in the **Creating** state, the route entry is being created.
 *     *   If the route entry is in the **Created** state, the route entry is created.
 * *   You cannot repeatedly call the **CreateRouteEntries** operation to create the same route entry within the specified period of time.
 * **When you call this operation to add custom route entries to the route table of a vRouter, take note of the following items:**
 * *   A route table can contain up to 200 custom route entries.
 * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be the same as or overlap with the CIDR block of a vSwitch in the VPC.
 * *   The destination CIDR block (**DstCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or its subnets.
 * *   The destination CIDR blocks (**DstCidrBlock**) of route entries in the same route table must be unique.
 * *   If you do not include the mask length when you specify the destination CIDR block (**DstCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
 * *   Multiple custom route entries can point to the same next hop (**NextHop**).
 * *   The next hop (**NextHop**) of a custom route entry must belong to the same VPC as the route table.
 *
 * @param request CreateRouteEntriesRequest
 * @return CreateRouteEntriesResponse
 */
CreateRouteEntriesResponse Client::createRouteEntries(const CreateRouteEntriesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createRouteEntriesWithOptions(request, runtime);
}

/**
 * @summary Creates a custom route entry in the route table of a VRouter or virtual border router (VBR).
 *
 * @description *   **CreateRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task:
 *     *   If a route is in the **Creating** state, the route is being added.
 *     *   If a route is in the **Created** state, the route is added.
 * *   You cannot repeatedly call **CreateRouteEntry** within a specific period of time.
 * **When you call this operation to add a custom route entry to the route table of a vRouter, take note of the following limits:**
 * >  When you add a route entry from a prefix list, the quota usage is calculated by adding the number of existing route entries and the maximum number of route entries of the prefix list.
 * *   A route table can contain up to 200 custom route entries.
 * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be the same as or be a subset of the CIDR block of a vSwitch in the virtual private cloud (VPC). The destination CIDR block can contain the CIDR block of a vSwitch.
 * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
 * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
 * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
 * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
 * *   The next hop (**NextHopId**) of a custom route entry must in the same VPC as the route table.
 * *   Equal-cost multi-path (ECMP) routing can be configured by specifying the **NextHopList** parameter.
 *     *   When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you must not specify **NextHopList**.
 *     *   When you add route entries for ECMP routing, you must specify **DestinationCidrBlock** and **NextHopList**, and you must not specify **NextHopType** or **NextHopId**.
 * **When you call this operation to add a custom route entry to the route table of a VBR, take note of the following limits:**
 * *   A route table can contain up to 200 custom route entries.
 * *   **NextHopList** is not supported.
 * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
 * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
 * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
 * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
 * *   The next hop (**NextHopId**) of a custom route entry must be a router interface associated with the VBR.
 * *   You can add route entries only when the VBR is in the **Active** state, and the Express Connect circuit associated with the VBR is in the **Enabled** state and is not locked due to overdue payments.
 * *   Only non-ECMP route entries are supported. When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you cannot specify **NextHopList**.
 *
 * @param request CreateRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRouteEntryResponse
 */
CreateRouteEntryResponse Client::createRouteEntryWithOptions(const CreateRouteEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDestinationCidrBlock()) {
    query["DestinationCidrBlock"] = request.destinationCidrBlock();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasNextHopId()) {
    query["NextHopId"] = request.nextHopId();
  }

  if (!!request.hasNextHopList()) {
    query["NextHopList"] = request.nextHopList();
  }

  if (!!request.hasNextHopType()) {
    query["NextHopType"] = request.nextHopType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteEntryName()) {
    query["RouteEntryName"] = request.routeEntryName();
  }

  if (!!request.hasRouteTableId()) {
    query["RouteTableId"] = request.routeTableId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateRouteEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateRouteEntryResponse>();
}

/**
 * @summary Creates a custom route entry in the route table of a VRouter or virtual border router (VBR).
 *
 * @description *   **CreateRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task:
 *     *   If a route is in the **Creating** state, the route is being added.
 *     *   If a route is in the **Created** state, the route is added.
 * *   You cannot repeatedly call **CreateRouteEntry** within a specific period of time.
 * **When you call this operation to add a custom route entry to the route table of a vRouter, take note of the following limits:**
 * >  When you add a route entry from a prefix list, the quota usage is calculated by adding the number of existing route entries and the maximum number of route entries of the prefix list.
 * *   A route table can contain up to 200 custom route entries.
 * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be the same as or be a subset of the CIDR block of a vSwitch in the virtual private cloud (VPC). The destination CIDR block can contain the CIDR block of a vSwitch.
 * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
 * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
 * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
 * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
 * *   The next hop (**NextHopId**) of a custom route entry must in the same VPC as the route table.
 * *   Equal-cost multi-path (ECMP) routing can be configured by specifying the **NextHopList** parameter.
 *     *   When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you must not specify **NextHopList**.
 *     *   When you add route entries for ECMP routing, you must specify **DestinationCidrBlock** and **NextHopList**, and you must not specify **NextHopType** or **NextHopId**.
 * **When you call this operation to add a custom route entry to the route table of a VBR, take note of the following limits:**
 * *   A route table can contain up to 200 custom route entries.
 * *   **NextHopList** is not supported.
 * *   The destination CIDR block (**DestinationCidrBlock**) of a custom route entry cannot be 100.64.0.0/10 or a subset of it.
 * *   The destination CIDR blocks (**DestinationCidrBlock**) of route entries in the same route table must be unique.
 * *   If you do not include the mask length when you specify the destination CIDR block (**DestinationCidrBlock**), the destination CIDR block is considered a host IP address whose mask length is 32 bits.
 * *   Multiple custom route entries can point to the same next hop (**NextHopId**).
 * *   The next hop (**NextHopId**) of a custom route entry must be a router interface associated with the VBR.
 * *   You can add route entries only when the VBR is in the **Active** state, and the Express Connect circuit associated with the VBR is in the **Enabled** state and is not locked due to overdue payments.
 * *   Only non-ECMP route entries are supported. When you add non-ECMP route entries, you must specify **DestinationCidrBlock**, **NextHopType**, and **NextHopId**, and you cannot specify **NextHopList**.
 *
 * @param request CreateRouteEntryRequest
 * @return CreateRouteEntryResponse
 */
CreateRouteEntryResponse Client::createRouteEntry(const CreateRouteEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createRouteEntryWithOptions(request, runtime);
}

/**
 * @summary Creates a custom route table.
 *
 * @description *   **CreateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the operation in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
 *     *   If the custom route table is in the **Creating** state, the custom route table is being created.
 *     *   If the custom route table is in the **Created** state, the custom route table is created.
 * *   You cannot repeatedly call the **CreateRouteTable** operation within the specified period of time.
 *
 * @param request CreateRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRouteTableResponse
 */
CreateRouteTableResponse Client::createRouteTableWithOptions(const CreateRouteTableRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAssociateType()) {
    query["AssociateType"] = request.associateType();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteTableName()) {
    query["RouteTableName"] = request.routeTableName();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateRouteTable"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateRouteTableResponse>();
}

/**
 * @summary Creates a custom route table.
 *
 * @description *   **CreateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the operation in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
 *     *   If the custom route table is in the **Creating** state, the custom route table is being created.
 *     *   If the custom route table is in the **Created** state, the custom route table is created.
 * *   You cannot repeatedly call the **CreateRouteTable** operation within the specified period of time.
 *
 * @param request CreateRouteTableRequest
 * @return CreateRouteTableResponse
 */
CreateRouteTableResponse Client::createRouteTable(const CreateRouteTableRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createRouteTableWithOptions(request, runtime);
}

/**
 * @summary Creates a router interface.
 *
 * @description When you call this operation, take note of the following limits:
 * *   You can create only one pair of interfaces to be connected between two routers.
 * *   You can create a maximum of five router interfaces for a router.
 * *   If your Alibaba Cloud account has a router interface with overdue payments, you cannot create new router interfaces.
 * *   Each destination CIDR block of route entries in the same route table must be unique.
 * *   A virtual border router (VBR) can serve only as a requester. The VBR must be in the Activated state.
 * *   You can call this operation to create subscription and pay-as-you-go router interfaces.
 *
 * @param request CreateRouterInterfaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRouterInterfaceResponse
 */
CreateRouterInterfaceResponse Client::createRouterInterfaceWithOptions(const CreateRouterInterfaceRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAccessPointId()) {
    query["AccessPointId"] = request.accessPointId();
  }

  if (!!request.hasAutoPay()) {
    query["AutoPay"] = request.autoPay();
  }

  if (!!request.hasAutoRenew()) {
    query["AutoRenew"] = request.autoRenew();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasFastLinkMode()) {
    query["FastLinkMode"] = request.fastLinkMode();
  }

  if (!!request.hasHealthCheckSourceIp()) {
    query["HealthCheckSourceIp"] = request.healthCheckSourceIp();
  }

  if (!!request.hasHealthCheckTargetIp()) {
    query["HealthCheckTargetIp"] = request.healthCheckTargetIp();
  }

  if (!!request.hasInstanceChargeType()) {
    query["InstanceChargeType"] = request.instanceChargeType();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOppositeAccessPointId()) {
    query["OppositeAccessPointId"] = request.oppositeAccessPointId();
  }

  if (!!request.hasOppositeInterfaceId()) {
    query["OppositeInterfaceId"] = request.oppositeInterfaceId();
  }

  if (!!request.hasOppositeInterfaceOwnerId()) {
    query["OppositeInterfaceOwnerId"] = request.oppositeInterfaceOwnerId();
  }

  if (!!request.hasOppositeRegionId()) {
    query["OppositeRegionId"] = request.oppositeRegionId();
  }

  if (!!request.hasOppositeRouterId()) {
    query["OppositeRouterId"] = request.oppositeRouterId();
  }

  if (!!request.hasOppositeRouterType()) {
    query["OppositeRouterType"] = request.oppositeRouterType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPeriod()) {
    query["Period"] = request.period();
  }

  if (!!request.hasPricingCycle()) {
    query["PricingCycle"] = request.pricingCycle();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRole()) {
    query["Role"] = request.role();
  }

  if (!!request.hasRouterId()) {
    query["RouterId"] = request.routerId();
  }

  if (!!request.hasRouterType()) {
    query["RouterType"] = request.routerType();
  }

  if (!!request.hasSpec()) {
    query["Spec"] = request.spec();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateRouterInterface"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateRouterInterfaceResponse>();
}

/**
 * @summary Creates a router interface.
 *
 * @description When you call this operation, take note of the following limits:
 * *   You can create only one pair of interfaces to be connected between two routers.
 * *   You can create a maximum of five router interfaces for a router.
 * *   If your Alibaba Cloud account has a router interface with overdue payments, you cannot create new router interfaces.
 * *   Each destination CIDR block of route entries in the same route table must be unique.
 * *   A virtual border router (VBR) can serve only as a requester. The VBR must be in the Activated state.
 * *   You can call this operation to create subscription and pay-as-you-go router interfaces.
 *
 * @param request CreateRouterInterfaceRequest
 * @return CreateRouterInterfaceResponse
 */
CreateRouterInterfaceResponse Client::createRouterInterface(const CreateRouterInterfaceRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createRouterInterfaceWithOptions(request, runtime);
}

/**
 * @summary Adds an SNAT entry to an SNAT table.
 *
 * @description You can call this operation to add SNAT entries to Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways. In this topic, a **NAT** gateway refers to both gateway types.
 * Before you call this operation, take note of the following limits:
 * *   **CreateSnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
 *     *   If the SNAT entry is in the **Pending** state, the system is adding the SNAT entry. You can only query the status of the SNAT entry, and cannot perform other operations.
 *     *   If the SNAT entry is in the **Available** state, the SNAT entry is added.
 * *   You cannot repeatedly call the **CreateSnatEntry** operation to add an SNAT entry to an SNAT table within the specified period of time.
 * *   The vSwitch and Elastic Compute Service (ECS) instance specified in an SNAT entry must be created in the VPC where the NAT gateway is deployed.
 * *   Each vSwitch or ECS instance can be specified in only one SNAT entry.
 * *   If a high-availability virtual IP address (HAVIP) exists in a vSwitch, you cannot create SNAT entries.
 *
 * @param request CreateSnatEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSnatEntryResponse
 */
CreateSnatEntryResponse Client::createSnatEntryWithOptions(const CreateSnatEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEipAffinity()) {
    query["EipAffinity"] = request.eipAffinity();
  }

  if (!!request.hasNetworkInterfaceId()) {
    query["NetworkInterfaceId"] = request.networkInterfaceId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSnatEntryName()) {
    query["SnatEntryName"] = request.snatEntryName();
  }

  if (!!request.hasSnatIp()) {
    query["SnatIp"] = request.snatIp();
  }

  if (!!request.hasSnatTableId()) {
    query["SnatTableId"] = request.snatTableId();
  }

  if (!!request.hasSourceCIDR()) {
    query["SourceCIDR"] = request.sourceCIDR();
  }

  if (!!request.hasSourceVSwitchId()) {
    query["SourceVSwitchId"] = request.sourceVSwitchId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateSnatEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateSnatEntryResponse>();
}

/**
 * @summary Adds an SNAT entry to an SNAT table.
 *
 * @description You can call this operation to add SNAT entries to Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways. In this topic, a **NAT** gateway refers to both gateway types.
 * Before you call this operation, take note of the following limits:
 * *   **CreateSnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
 *     *   If the SNAT entry is in the **Pending** state, the system is adding the SNAT entry. You can only query the status of the SNAT entry, and cannot perform other operations.
 *     *   If the SNAT entry is in the **Available** state, the SNAT entry is added.
 * *   You cannot repeatedly call the **CreateSnatEntry** operation to add an SNAT entry to an SNAT table within the specified period of time.
 * *   The vSwitch and Elastic Compute Service (ECS) instance specified in an SNAT entry must be created in the VPC where the NAT gateway is deployed.
 * *   Each vSwitch or ECS instance can be specified in only one SNAT entry.
 * *   If a high-availability virtual IP address (HAVIP) exists in a vSwitch, you cannot create SNAT entries.
 *
 * @param request CreateSnatEntryRequest
 * @return CreateSnatEntryResponse
 */
CreateSnatEntryResponse Client::createSnatEntry(const CreateSnatEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createSnatEntryWithOptions(request, runtime);
}

/**
 * @summary Creates an SSL client certificate.
 *
 * @description Before you create an SSL client certificate, make sure that an SSL server is created on the VPN gateway. For more information, see [CreateSslVpnServer](https://help.aliyun.com/document_detail/2794075.html).
 *
 * @param request CreateSslVpnClientCertRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSslVpnClientCertResponse
 */
CreateSslVpnClientCertResponse Client::createSslVpnClientCertWithOptions(const CreateSslVpnClientCertRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSslVpnServerId()) {
    query["SslVpnServerId"] = request.sslVpnServerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateSslVpnClientCert"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateSslVpnClientCertResponse>();
}

/**
 * @summary Creates an SSL client certificate.
 *
 * @description Before you create an SSL client certificate, make sure that an SSL server is created on the VPN gateway. For more information, see [CreateSslVpnServer](https://help.aliyun.com/document_detail/2794075.html).
 *
 * @param request CreateSslVpnClientCertRequest
 * @return CreateSslVpnClientCertResponse
 */
CreateSslVpnClientCertResponse Client::createSslVpnClientCert(const CreateSslVpnClientCertRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createSslVpnClientCertWithOptions(request, runtime);
}

/**
 * @summary Creates an SSL server.
 *
 * @description *   **CreateSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the SSL server is being created.
 *     *   If the VPN gateway is in the **active** state, the SSL server is created.
 * *   You cannot repeatedly call the **CreateSslVpnServer** operation within the specified period of time.
 * ### [](#)Prerequisite
 * *   A VPN gateway is created, and the SSL-VPN feature is enabled for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
 * *   If you want to enable two-factor authentication for the SSL server, make sure that the VPN gateway supports two-factor authentication. You may need to upgrade the VPN gateway. For more information, see [Two-factor authentication supports IDaaS EIAM 2.0](https://help.aliyun.com/document_detail/2785320.html).
 *
 * @param request CreateSslVpnServerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSslVpnServerResponse
 */
CreateSslVpnServerResponse Client::createSslVpnServerWithOptions(const CreateSslVpnServerRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCipher()) {
    query["Cipher"] = request.cipher();
  }

  if (!!request.hasClientIpPool()) {
    query["ClientIpPool"] = request.clientIpPool();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasCompress()) {
    query["Compress"] = request.compress();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEnableMultiFactorAuth()) {
    query["EnableMultiFactorAuth"] = request.enableMultiFactorAuth();
  }

  if (!!request.hasIDaaSApplicationId()) {
    query["IDaaSApplicationId"] = request.IDaaSApplicationId();
  }

  if (!!request.hasIDaaSInstanceId()) {
    query["IDaaSInstanceId"] = request.IDaaSInstanceId();
  }

  if (!!request.hasIDaaSRegionId()) {
    query["IDaaSRegionId"] = request.IDaaSRegionId();
  }

  if (!!request.hasLocalSubnet()) {
    query["LocalSubnet"] = request.localSubnet();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPort()) {
    query["Port"] = request.port();
  }

  if (!!request.hasProto()) {
    query["Proto"] = request.proto();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateSslVpnServer"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateSslVpnServerResponse>();
}

/**
 * @summary Creates an SSL server.
 *
 * @description *   **CreateSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the SSL server is being created.
 *     *   If the VPN gateway is in the **active** state, the SSL server is created.
 * *   You cannot repeatedly call the **CreateSslVpnServer** operation within the specified period of time.
 * ### [](#)Prerequisite
 * *   A VPN gateway is created, and the SSL-VPN feature is enabled for the VPN gateway. For more information, see [CreateVpnGateway](https://help.aliyun.com/document_detail/2794049.html).
 * *   If you want to enable two-factor authentication for the SSL server, make sure that the VPN gateway supports two-factor authentication. You may need to upgrade the VPN gateway. For more information, see [Two-factor authentication supports IDaaS EIAM 2.0](https://help.aliyun.com/document_detail/2785320.html).
 *
 * @param request CreateSslVpnServerRequest
 * @return CreateSslVpnServerResponse
 */
CreateSslVpnServerResponse Client::createSslVpnServer(const CreateSslVpnServerRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createSslVpnServerWithOptions(request, runtime);
}

/**
 * @summary Creates a filter for traffic mirror.
 *
 * @description **CreateTrafficMirrorFilter** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of the task.
 * *   If the filter is in the **Creating** state, the filter is being created.
 * *   If the filter is in the **Created** state, the filter is created.
 *
 * @param request CreateTrafficMirrorFilterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTrafficMirrorFilterResponse
 */
CreateTrafficMirrorFilterResponse Client::createTrafficMirrorFilterWithOptions(const CreateTrafficMirrorFilterRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEgressRules()) {
    query["EgressRules"] = request.egressRules();
  }

  if (!!request.hasIngressRules()) {
    query["IngressRules"] = request.ingressRules();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasTrafficMirrorFilterDescription()) {
    query["TrafficMirrorFilterDescription"] = request.trafficMirrorFilterDescription();
  }

  if (!!request.hasTrafficMirrorFilterName()) {
    query["TrafficMirrorFilterName"] = request.trafficMirrorFilterName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateTrafficMirrorFilter"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateTrafficMirrorFilterResponse>();
}

/**
 * @summary Creates a filter for traffic mirror.
 *
 * @description **CreateTrafficMirrorFilter** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of the task.
 * *   If the filter is in the **Creating** state, the filter is being created.
 * *   If the filter is in the **Created** state, the filter is created.
 *
 * @param request CreateTrafficMirrorFilterRequest
 * @return CreateTrafficMirrorFilterResponse
 */
CreateTrafficMirrorFilterResponse Client::createTrafficMirrorFilter(const CreateTrafficMirrorFilterRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createTrafficMirrorFilterWithOptions(request, runtime);
}

/**
 * @summary Creates an inbound or outbound rule for traffic mirror.
 *
 * @description *   **CreateTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
 *     *   If the inbound or outbound rule is in the **Creating** state, the rule is being created.
 *     *   If the inbound or outbound rule is in the **Created** state, the rule is created.
 * *   You cannot call **CreateTrafficMirrorFilterRules** within the specified period of time.
 *
 * @param request CreateTrafficMirrorFilterRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTrafficMirrorFilterRulesResponse
 */
CreateTrafficMirrorFilterRulesResponse Client::createTrafficMirrorFilterRulesWithOptions(const CreateTrafficMirrorFilterRulesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEgressRules()) {
    query["EgressRules"] = request.egressRules();
  }

  if (!!request.hasIngressRules()) {
    query["IngressRules"] = request.ingressRules();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTrafficMirrorFilterId()) {
    query["TrafficMirrorFilterId"] = request.trafficMirrorFilterId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateTrafficMirrorFilterRules"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateTrafficMirrorFilterRulesResponse>();
}

/**
 * @summary Creates an inbound or outbound rule for traffic mirror.
 *
 * @description *   **CreateTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
 *     *   If the inbound or outbound rule is in the **Creating** state, the rule is being created.
 *     *   If the inbound or outbound rule is in the **Created** state, the rule is created.
 * *   You cannot call **CreateTrafficMirrorFilterRules** within the specified period of time.
 *
 * @param request CreateTrafficMirrorFilterRulesRequest
 * @return CreateTrafficMirrorFilterRulesResponse
 */
CreateTrafficMirrorFilterRulesResponse Client::createTrafficMirrorFilterRules(const CreateTrafficMirrorFilterRulesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createTrafficMirrorFilterRulesWithOptions(request, runtime);
}

/**
 * @summary Creates a traffic mirror session.
 *
 * @description **CreateTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) to query the status of the task.
 * *   If the traffic mirror session is in the **Creating** state, it is being created.
 * *   If the traffic mirror session is in the **Created** state, it is created.
 *
 * @param request CreateTrafficMirrorSessionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTrafficMirrorSessionResponse
 */
CreateTrafficMirrorSessionResponse Client::createTrafficMirrorSessionWithOptions(const CreateTrafficMirrorSessionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEnabled()) {
    query["Enabled"] = request.enabled();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPacketLength()) {
    query["PacketLength"] = request.packetLength();
  }

  if (!!request.hasPriority()) {
    query["Priority"] = request.priority();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasTrafficMirrorFilterId()) {
    query["TrafficMirrorFilterId"] = request.trafficMirrorFilterId();
  }

  if (!!request.hasTrafficMirrorSessionDescription()) {
    query["TrafficMirrorSessionDescription"] = request.trafficMirrorSessionDescription();
  }

  if (!!request.hasTrafficMirrorSessionName()) {
    query["TrafficMirrorSessionName"] = request.trafficMirrorSessionName();
  }

  if (!!request.hasTrafficMirrorSourceIds()) {
    query["TrafficMirrorSourceIds"] = request.trafficMirrorSourceIds();
  }

  if (!!request.hasTrafficMirrorTargetId()) {
    query["TrafficMirrorTargetId"] = request.trafficMirrorTargetId();
  }

  if (!!request.hasTrafficMirrorTargetType()) {
    query["TrafficMirrorTargetType"] = request.trafficMirrorTargetType();
  }

  if (!!request.hasVirtualNetworkId()) {
    query["VirtualNetworkId"] = request.virtualNetworkId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateTrafficMirrorSession"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateTrafficMirrorSessionResponse>();
}

/**
 * @summary Creates a traffic mirror session.
 *
 * @description **CreateTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) to query the status of the task.
 * *   If the traffic mirror session is in the **Creating** state, it is being created.
 * *   If the traffic mirror session is in the **Created** state, it is created.
 *
 * @param request CreateTrafficMirrorSessionRequest
 * @return CreateTrafficMirrorSessionResponse
 */
CreateTrafficMirrorSessionResponse Client::createTrafficMirrorSession(const CreateTrafficMirrorSessionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createTrafficMirrorSessionWithOptions(request, runtime);
}

/**
 * @summary 创建交换机。
 *
 * @description When you call this operation, take note of the following limits:
 * *   You can create at most 150 vSwitches in a virtual private cloud (VPC).
 * *   The first IP address and last three IP addresses of each vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
 * *   The number of instances in a vSwitch cannot exceed the remaining capacity of the VPC. The remaining capacity is the difference between 15,000 and the current number of instances.
 * *   Each instance can belong to only one vSwitch.
 * *   vSwitches do not support multicast or broadcast.
 * *   After you create a vSwitch, you cannot modify its CIDR block.
 * *   **CreateVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) to query the status of the task.
 *     *   If the vSwitch is in the **Pending** state, the vSwitch is being configured.
 *     *   If the vSwitch is in the **Available** state, the vSwitch is available.
 * *   You cannot repeatedly call the **CreateVSwitch** operation to create a vSwitch in a VPC within the specified period of time.
 *
 * @param request CreateVSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVSwitchResponse
 */
CreateVSwitchResponse Client::createVSwitchWithOptions(const CreateVSwitchRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCidrBlock()) {
    query["CidrBlock"] = request.cidrBlock();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasIpv6CidrBlock()) {
    query["Ipv6CidrBlock"] = request.ipv6CidrBlock();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasVSwitchName()) {
    query["VSwitchName"] = request.vSwitchName();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  if (!!request.hasVpcIpv6CidrBlock()) {
    query["VpcIpv6CidrBlock"] = request.vpcIpv6CidrBlock();
  }

  if (!!request.hasZoneId()) {
    query["ZoneId"] = request.zoneId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateVSwitch"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateVSwitchResponse>();
}

/**
 * @summary 创建交换机。
 *
 * @description When you call this operation, take note of the following limits:
 * *   You can create at most 150 vSwitches in a virtual private cloud (VPC).
 * *   The first IP address and last three IP addresses of each vSwitch CIDR block are reserved. For example, if the CIDR block of a vSwitch is 192.168.1.0/24, the IP addresses 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255 are reserved.
 * *   The number of instances in a vSwitch cannot exceed the remaining capacity of the VPC. The remaining capacity is the difference between 15,000 and the current number of instances.
 * *   Each instance can belong to only one vSwitch.
 * *   vSwitches do not support multicast or broadcast.
 * *   After you create a vSwitch, you cannot modify its CIDR block.
 * *   **CreateVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) to query the status of the task.
 *     *   If the vSwitch is in the **Pending** state, the vSwitch is being configured.
 *     *   If the vSwitch is in the **Available** state, the vSwitch is available.
 * *   You cannot repeatedly call the **CreateVSwitch** operation to create a vSwitch in a VPC within the specified period of time.
 *
 * @param request CreateVSwitchRequest
 * @return CreateVSwitchResponse
 */
CreateVSwitchResponse Client::createVSwitch(const CreateVSwitchRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createVSwitchWithOptions(request, runtime);
}

/**
 * @summary Creates a reserved CIDR block for a vSwitch.
 *
 * @description ## [](#)Description
 * Take note of the following items:
 * *   You can create at most 10 reserved IPv4 CIDR blocks and 10 reserved IPv6 CIDR blocks for each vSwitch in a virtual private cloud (VPC).
 * *   After you create a reserved CIDR block for a vSwitch, the CIDR block cannot contain the IP address of the subnet gateway of the VPC to which the vSwitch belongs.
 * *   **CreateVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
 *     *   If the vSwitch is in the **Assigning** state, the reserved CIDR block is being created.
 *     *   If the vSwitch is in the **Assigned** state, the reserved CIDR block is created.
 * *   When you create a reserved IPv4 CIDR block for a vSwitch, the first IP address and the last three IP addresses of the vSwitch are reserved by the system. The four IP addresses will not be allocated.
 * *   When you create a reserved IPv6 CIDR block for a vSwitch, the first IP address and the last nine IP addresses of the vSwitch are reserved by the system. The 10 IP addresses will not be allocated. For example, if you create a reserved IPv4 CIDR block for a vSwitch whose CIDR block is 192.168.1.0/24, the reserved CIDR block cannot contain the following IP addresses: 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255.
 *
 * @param request CreateVSwitchCidrReservationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVSwitchCidrReservationResponse
 */
CreateVSwitchCidrReservationResponse Client::createVSwitchCidrReservationWithOptions(const CreateVSwitchCidrReservationRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIpVersion()) {
    query["IpVersion"] = request.ipVersion();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasVSwitchCidrReservationCidr()) {
    query["VSwitchCidrReservationCidr"] = request.vSwitchCidrReservationCidr();
  }

  if (!!request.hasVSwitchCidrReservationDescription()) {
    query["VSwitchCidrReservationDescription"] = request.vSwitchCidrReservationDescription();
  }

  if (!!request.hasVSwitchCidrReservationMask()) {
    query["VSwitchCidrReservationMask"] = request.vSwitchCidrReservationMask();
  }

  if (!!request.hasVSwitchCidrReservationName()) {
    query["VSwitchCidrReservationName"] = request.vSwitchCidrReservationName();
  }

  if (!!request.hasVSwitchCidrReservationType()) {
    query["VSwitchCidrReservationType"] = request.vSwitchCidrReservationType();
  }

  if (!!request.hasVSwitchId()) {
    query["VSwitchId"] = request.vSwitchId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateVSwitchCidrReservation"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateVSwitchCidrReservationResponse>();
}

/**
 * @summary Creates a reserved CIDR block for a vSwitch.
 *
 * @description ## [](#)Description
 * Take note of the following items:
 * *   You can create at most 10 reserved IPv4 CIDR blocks and 10 reserved IPv6 CIDR blocks for each vSwitch in a virtual private cloud (VPC).
 * *   After you create a reserved CIDR block for a vSwitch, the CIDR block cannot contain the IP address of the subnet gateway of the VPC to which the vSwitch belongs.
 * *   **CreateVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
 *     *   If the vSwitch is in the **Assigning** state, the reserved CIDR block is being created.
 *     *   If the vSwitch is in the **Assigned** state, the reserved CIDR block is created.
 * *   When you create a reserved IPv4 CIDR block for a vSwitch, the first IP address and the last three IP addresses of the vSwitch are reserved by the system. The four IP addresses will not be allocated.
 * *   When you create a reserved IPv6 CIDR block for a vSwitch, the first IP address and the last nine IP addresses of the vSwitch are reserved by the system. The 10 IP addresses will not be allocated. For example, if you create a reserved IPv4 CIDR block for a vSwitch whose CIDR block is 192.168.1.0/24, the reserved CIDR block cannot contain the following IP addresses: 192.168.1.0, 192.168.1.253, 192.168.1.254, and 192.168.1.255.
 *
 * @param request CreateVSwitchCidrReservationRequest
 * @return CreateVSwitchCidrReservationResponse
 */
CreateVSwitchCidrReservationResponse Client::createVSwitchCidrReservation(const CreateVSwitchCidrReservationRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createVSwitchCidrReservationWithOptions(request, runtime);
}

/**
 * @summary Creates a virtual border router (VBR) failover group.
 *
 * @param request CreateVbrHaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVbrHaResponse
 */
CreateVbrHaResponse Client::createVbrHaWithOptions(const CreateVbrHaRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPeerVbrId()) {
    query["PeerVbrId"] = request.peerVbrId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVbrId()) {
    query["VbrId"] = request.vbrId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateVbrHa"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateVbrHaResponse>();
}

/**
 * @summary Creates a virtual border router (VBR) failover group.
 *
 * @param request CreateVbrHaRequest
 * @return CreateVbrHaResponse
 */
CreateVbrHaResponse Client::createVbrHa(const CreateVbrHaRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createVbrHaWithOptions(request, runtime);
}

/**
 * @summary Adds a destination-based route for an IPsec-VPN connection.
 *
 * @description *   The IPsec-VPN connection must be associated with a transit router. For more information, see [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468249.html).
 * *   You cannot create a destination-based route whose destination CIDR block is 0.0.0.0/0.
 * *   Do not add a destination-based route whose destination CIDR block is 100.64.0.0/10, or a CIDR block that contains 100.64.0.0/10 or belongs to 100.64.0.0/10. Such a route will make the console fail to display the status of the IPsec-VPN connection or cause IPsec negotiation failures.
 * *   **CreateVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) to query the status of the task.
 *     *   If the IPsec-VPN connection is in the **updating** state, the destination-based route is being created.
 *     *   If the IPsec-VPN connection is in the **attached** state, the destination-based route is created.
 * *   You cannot repeatedly call **CreateVcoRouteEntry** within the specified period of time.
 *
 * @param request CreateVcoRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVcoRouteEntryResponse
 */
CreateVcoRouteEntryResponse Client::createVcoRouteEntryWithOptions(const CreateVcoRouteEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasNextHop()) {
    query["NextHop"] = request.nextHop();
  }

  if (!!request.hasOverlayMode()) {
    query["OverlayMode"] = request.overlayMode();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteDest()) {
    query["RouteDest"] = request.routeDest();
  }

  if (!!request.hasVpnConnectionId()) {
    query["VpnConnectionId"] = request.vpnConnectionId();
  }

  if (!!request.hasWeight()) {
    query["Weight"] = request.weight();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateVcoRouteEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateVcoRouteEntryResponse>();
}

/**
 * @summary Adds a destination-based route for an IPsec-VPN connection.
 *
 * @description *   The IPsec-VPN connection must be associated with a transit router. For more information, see [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468249.html).
 * *   You cannot create a destination-based route whose destination CIDR block is 0.0.0.0/0.
 * *   Do not add a destination-based route whose destination CIDR block is 100.64.0.0/10, or a CIDR block that contains 100.64.0.0/10 or belongs to 100.64.0.0/10. Such a route will make the console fail to display the status of the IPsec-VPN connection or cause IPsec negotiation failures.
 * *   **CreateVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) to query the status of the task.
 *     *   If the IPsec-VPN connection is in the **updating** state, the destination-based route is being created.
 *     *   If the IPsec-VPN connection is in the **attached** state, the destination-based route is created.
 * *   You cannot repeatedly call **CreateVcoRouteEntry** within the specified period of time.
 *
 * @param request CreateVcoRouteEntryRequest
 * @return CreateVcoRouteEntryResponse
 */
CreateVcoRouteEntryResponse Client::createVcoRouteEntry(const CreateVcoRouteEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createVcoRouteEntryWithOptions(request, runtime);
}

/**
 * @summary Creates a virtual border router (VBR).
 *
 * @description After you create a VBR, the VBR is in the **active** state.
 *
 * @param request CreateVirtualBorderRouterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVirtualBorderRouterResponse
 */
CreateVirtualBorderRouterResponse Client::createVirtualBorderRouterWithOptions(const CreateVirtualBorderRouterRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasCircuitCode()) {
    query["CircuitCode"] = request.circuitCode();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasEnableIpv6()) {
    query["EnableIpv6"] = request.enableIpv6();
  }

  if (!!request.hasLocalGatewayIp()) {
    query["LocalGatewayIp"] = request.localGatewayIp();
  }

  if (!!request.hasLocalIpv6GatewayIp()) {
    query["LocalIpv6GatewayIp"] = request.localIpv6GatewayIp();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPeerGatewayIp()) {
    query["PeerGatewayIp"] = request.peerGatewayIp();
  }

  if (!!request.hasPeerIpv6GatewayIp()) {
    query["PeerIpv6GatewayIp"] = request.peerIpv6GatewayIp();
  }

  if (!!request.hasPeeringIpv6SubnetMask()) {
    query["PeeringIpv6SubnetMask"] = request.peeringIpv6SubnetMask();
  }

  if (!!request.hasPeeringSubnetMask()) {
    query["PeeringSubnetMask"] = request.peeringSubnetMask();
  }

  if (!!request.hasPhysicalConnectionId()) {
    query["PhysicalConnectionId"] = request.physicalConnectionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  if (!!request.hasVbrOwnerId()) {
    query["VbrOwnerId"] = request.vbrOwnerId();
  }

  if (!!request.hasVlanId()) {
    query["VlanId"] = request.vlanId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateVirtualBorderRouter"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateVirtualBorderRouterResponse>();
}

/**
 * @summary Creates a virtual border router (VBR).
 *
 * @description After you create a VBR, the VBR is in the **active** state.
 *
 * @param request CreateVirtualBorderRouterRequest
 * @return CreateVirtualBorderRouterResponse
 */
CreateVirtualBorderRouterResponse Client::createVirtualBorderRouter(const CreateVirtualBorderRouterRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createVirtualBorderRouterWithOptions(request, runtime);
}

/**
 * @summary Creates a hosted connection over Express Connect circuit.
 *
 * @description # [](#)Description
 * Before you call this operation, we recommend that you learn about the workflow for creating a hosted connection and the environment requirements. For more information, see [Overview of hosted connections](https://help.aliyun.com/document_detail/146571.html) and [Operations performed by Express Connect partners](https://help.aliyun.com/document_detail/155987.html).
 *
 * @param request CreateVirtualPhysicalConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVirtualPhysicalConnectionResponse
 */
CreateVirtualPhysicalConnectionResponse Client::createVirtualPhysicalConnectionWithOptions(const CreateVirtualPhysicalConnectionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOrderMode()) {
    query["OrderMode"] = request.orderMode();
  }

  if (!!request.hasPhysicalConnectionId()) {
    query["PhysicalConnectionId"] = request.physicalConnectionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasSpec()) {
    query["Spec"] = request.spec();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasToken()) {
    query["Token"] = request.token();
  }

  if (!!request.hasVlanId()) {
    query["VlanId"] = request.vlanId();
  }

  if (!!request.hasVpconnAliUid()) {
    query["VpconnAliUid"] = request.vpconnAliUid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateVirtualPhysicalConnection"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateVirtualPhysicalConnectionResponse>();
}

/**
 * @summary Creates a hosted connection over Express Connect circuit.
 *
 * @description # [](#)Description
 * Before you call this operation, we recommend that you learn about the workflow for creating a hosted connection and the environment requirements. For more information, see [Overview of hosted connections](https://help.aliyun.com/document_detail/146571.html) and [Operations performed by Express Connect partners](https://help.aliyun.com/document_detail/155987.html).
 *
 * @param request CreateVirtualPhysicalConnectionRequest
 * @return CreateVirtualPhysicalConnectionResponse
 */
CreateVirtualPhysicalConnectionResponse Client::createVirtualPhysicalConnection(const CreateVirtualPhysicalConnectionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createVirtualPhysicalConnectionWithOptions(request, runtime);
}

/**
 * @summary Creates a virtual private cloud (VPC).
 *
 * @description When you call this operation, take note of the following items:
 * *   You can specify only one CIDR block for each VPC.
 * *   After you create a VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to the VPC.
 * *   In each VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
 * *   After you create a VPC, a vRouter and a route table are automatically created.
 * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if both 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
 * *   **CreateVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
 *     *   If the VPC is in the **Creating** state, the VPC is being created.
 *     *   If the VPC is in the **Created** state, the VPC is created.
 * *   You cannot repeatedly call the **DeleteRouteEntry** operation to create default VPCs within a specific time period. However, you can repeatedly call this operation to create custom VPCs within a specific time period.
 *
 * @param request CreateVpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpcResponse
 */
CreateVpcResponse Client::createVpcWithOptions(const CreateVpcRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCidrBlock()) {
    query["CidrBlock"] = request.cidrBlock();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEnableDnsHostname()) {
    query["EnableDnsHostname"] = request.enableDnsHostname();
  }

  if (!!request.hasEnableIpv6()) {
    query["EnableIpv6"] = request.enableIpv6();
  }

  if (!!request.hasIpv4CidrMask()) {
    query["Ipv4CidrMask"] = request.ipv4CidrMask();
  }

  if (!!request.hasIpv4IpamPoolId()) {
    query["Ipv4IpamPoolId"] = request.ipv4IpamPoolId();
  }

  if (!!request.hasIpv6CidrBlock()) {
    query["Ipv6CidrBlock"] = request.ipv6CidrBlock();
  }

  if (!!request.hasIpv6CidrMask()) {
    query["Ipv6CidrMask"] = request.ipv6CidrMask();
  }

  if (!!request.hasIpv6IpamPoolId()) {
    query["Ipv6IpamPoolId"] = request.ipv6IpamPoolId();
  }

  if (!!request.hasIpv6Isp()) {
    query["Ipv6Isp"] = request.ipv6Isp();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasUserCidr()) {
    query["UserCidr"] = request.userCidr();
  }

  if (!!request.hasVpcName()) {
    query["VpcName"] = request.vpcName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateVpc"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateVpcResponse>();
}

/**
 * @summary Creates a virtual private cloud (VPC).
 *
 * @description When you call this operation, take note of the following items:
 * *   You can specify only one CIDR block for each VPC.
 * *   After you create a VPC, you cannot change its CIDR block. However, you can add secondary IPv4 CIDR blocks to the VPC.
 * *   In each VPC, cloud services can use a maximum of 60,000 private IP addresses. You cannot increase the quota.
 * *   After you create a VPC, a vRouter and a route table are automatically created.
 * *   At most three user CIDR blocks can be added to a VPC. If a user CIDR block includes another user CIDR block, the one with the shorter subnet mask takes effect. For example, if both 10.0.0.0/8 and 10.1.0.0/16 are specified, only 10.0.0.0/8 takes effect.
 * *   **CreateVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task:
 *     *   If the VPC is in the **Creating** state, the VPC is being created.
 *     *   If the VPC is in the **Created** state, the VPC is created.
 * *   You cannot repeatedly call the **DeleteRouteEntry** operation to create default VPCs within a specific time period. However, you can repeatedly call this operation to create custom VPCs within a specific time period.
 *
 * @param request CreateVpcRequest
 * @return CreateVpcResponse
 */
CreateVpcResponse Client::createVpc(const CreateVpcRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createVpcWithOptions(request, runtime);
}

/**
 * @summary Creates a gateway endpoint.
 *
 * @description *   **CreateVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns an **EndpointId** and runs the task in the background. You can call the [ListVpcGatewayEndpoints](https://help.aliyun.com/document_detail/448682.html) operation to query the status of the task.
 *     *   If the gateway endpoint is in the **Creating** state, the gateway endpoint is being created.
 *     *   If the gateway endpoint is in the **Created** state, the gateway endpoint is created.
 * *   You cannot repeatedly call the **CreateVpcGatewayEndpoint** operation for the same endpoint service within the specified period of time.
 *
 * @param request CreateVpcGatewayEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpcGatewayEndpointResponse
 */
CreateVpcGatewayEndpointResponse Client::createVpcGatewayEndpointWithOptions(const CreateVpcGatewayEndpointRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEndpointDescription()) {
    query["EndpointDescription"] = request.endpointDescription();
  }

  if (!!request.hasEndpointName()) {
    query["EndpointName"] = request.endpointName();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPolicyDocument()) {
    query["PolicyDocument"] = request.policyDocument();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasServiceName()) {
    query["ServiceName"] = request.serviceName();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateVpcGatewayEndpoint"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateVpcGatewayEndpointResponse>();
}

/**
 * @summary Creates a gateway endpoint.
 *
 * @description *   **CreateVpcGatewayEndpoint** is an asynchronous operation. After a request is sent, the system returns an **EndpointId** and runs the task in the background. You can call the [ListVpcGatewayEndpoints](https://help.aliyun.com/document_detail/448682.html) operation to query the status of the task.
 *     *   If the gateway endpoint is in the **Creating** state, the gateway endpoint is being created.
 *     *   If the gateway endpoint is in the **Created** state, the gateway endpoint is created.
 * *   You cannot repeatedly call the **CreateVpcGatewayEndpoint** operation for the same endpoint service within the specified period of time.
 *
 * @param request CreateVpcGatewayEndpointRequest
 * @return CreateVpcGatewayEndpointResponse
 */
CreateVpcGatewayEndpointResponse Client::createVpcGatewayEndpoint(const CreateVpcGatewayEndpointRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createVpcGatewayEndpointWithOptions(request, runtime);
}

/**
 * @summary Creates a prefix list.
 *
 * @description You cannot repeatedly call the **CreateVpcPrefixList** operation within the specified period of time.
 *
 * @param request CreateVpcPrefixListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpcPrefixListResponse
 */
CreateVpcPrefixListResponse Client::createVpcPrefixListWithOptions(const CreateVpcPrefixListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIpVersion()) {
    query["IpVersion"] = request.ipVersion();
  }

  if (!!request.hasMaxEntries()) {
    query["MaxEntries"] = request.maxEntries();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPrefixListDescription()) {
    query["PrefixListDescription"] = request.prefixListDescription();
  }

  if (!!request.hasPrefixListEntries()) {
    query["PrefixListEntries"] = request.prefixListEntries();
  }

  if (!!request.hasPrefixListName()) {
    query["PrefixListName"] = request.prefixListName();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateVpcPrefixList"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateVpcPrefixListResponse>();
}

/**
 * @summary Creates a prefix list.
 *
 * @description You cannot repeatedly call the **CreateVpcPrefixList** operation within the specified period of time.
 *
 * @param request CreateVpcPrefixListRequest
 * @return CreateVpcPrefixListResponse
 */
CreateVpcPrefixListResponse Client::createVpcPrefixList(const CreateVpcPrefixListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createVpcPrefixListWithOptions(request, runtime);
}

/**
 * @summary Adds a shared port to a hosted connection.
 *
 * @description If an Express Connect partner has created a virtual border router (VBR) for a tenant before, the Express Connect partner can push the Express Connect circuit that is associated with the VBR to the tenant account by adding a shared port for the tenant account. The service of the tenant is not interrupted in this process.
 * Preparations:
 * Before the Express Connect partner performs the operation, the Express Connect partner must notify the tenant and request the tenant to enable outbound data transfer billing. For more information, see [Enable outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html).
 * What to do next:
 * 1.  After the Express Connect partner performs the operation, a shared port is added for the tenant account. The tenant must call the [ConfirmPhysicalConnection](https://help.aliyun.com/document_detail/324198.html) operation to accept the shared port.
 * 2.  Then, the Express Connect partner must call the [AttachVbrToVpconn](https://help.aliyun.com/document_detail/324191.html) operation to associate the VBR with the newly added shared port that belongs to the tenant account.
 *
 * @param request CreateVpconnFromVbrRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpconnFromVbrResponse
 */
CreateVpconnFromVbrResponse Client::createVpconnFromVbrWithOptions(const CreateVpconnFromVbrRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOrderMode()) {
    query["OrderMode"] = request.orderMode();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasToken()) {
    query["Token"] = request.token();
  }

  if (!!request.hasVbrId()) {
    query["VbrId"] = request.vbrId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateVpconnFromVbr"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateVpconnFromVbrResponse>();
}

/**
 * @summary Adds a shared port to a hosted connection.
 *
 * @description If an Express Connect partner has created a virtual border router (VBR) for a tenant before, the Express Connect partner can push the Express Connect circuit that is associated with the VBR to the tenant account by adding a shared port for the tenant account. The service of the tenant is not interrupted in this process.
 * Preparations:
 * Before the Express Connect partner performs the operation, the Express Connect partner must notify the tenant and request the tenant to enable outbound data transfer billing. For more information, see [Enable outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html).
 * What to do next:
 * 1.  After the Express Connect partner performs the operation, a shared port is added for the tenant account. The tenant must call the [ConfirmPhysicalConnection](https://help.aliyun.com/document_detail/324198.html) operation to accept the shared port.
 * 2.  Then, the Express Connect partner must call the [AttachVbrToVpconn](https://help.aliyun.com/document_detail/324191.html) operation to associate the VBR with the newly added shared port that belongs to the tenant account.
 *
 * @param request CreateVpconnFromVbrRequest
 * @return CreateVpconnFromVbrResponse
 */
CreateVpconnFromVbrResponse Client::createVpconnFromVbr(const CreateVpconnFromVbrRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createVpconnFromVbrWithOptions(request, runtime);
}

/**
 * @summary Creates an IPsec-VPN connection. After you create the IPsec-VPN connection, you can associate the IPsec-VPN connection with a transit router.
 *
 * @description *   By default, the IPsec-VPN connection created by calling the `CreateVpnAttachment` operation is not bound to any resources. You can call the [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/443993.html) operation to bind the IPsec-VPN connection to a transit router.
 * *   If you want to associate an IPsec-VPN connection with a transit router, you can create a dual-tunnel connection in some regions. For more information, see [Dual-tunnel IPsec-VPN connections](https://help.aliyun.com/document_detail/2853535.html).
 *     *   When you create a IPsec-VPN connection in dual tunnel mode, you can configure the following request parameters in addition to the required parameters: **ClientToken**, **Name**, **NetworkType**, **EffectImmediately**, **AutoConfigRoute**, **Tags** array, **ResourceGroupId**, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
 *     *   When you create a IPsec-VPN connection in single tunnel mode, you can configure the following request parameters in addition to the required parameters: **ClientToken**, **CustomerGatewayId**, **NetworkType**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **Tags** array, and **ResourceGroupId**.
 * ### [](#)Prerequisites
 * Before you create an IPsec-VPN connection, you must create a customer gateway in the region where you want to create the IPsec-VPN connection. For more information, see [CreateCustomerGateway](https://help.aliyun.com/document_detail/120368.html).
 * If you want to add BGP configurations to an IPsec-VPN connection, make sure that an autonomous system number (ASN) is assigned to the customer gateway.
 *
 * @param request CreateVpnAttachmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpnAttachmentResponse
 */
CreateVpnAttachmentResponse Client::createVpnAttachmentWithOptions(const CreateVpnAttachmentRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAutoConfigRoute()) {
    query["AutoConfigRoute"] = request.autoConfigRoute();
  }

  if (!!request.hasBgpConfig()) {
    query["BgpConfig"] = request.bgpConfig();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasCustomerGatewayId()) {
    query["CustomerGatewayId"] = request.customerGatewayId();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEffectImmediately()) {
    query["EffectImmediately"] = request.effectImmediately();
  }

  if (!!request.hasEnableDpd()) {
    query["EnableDpd"] = request.enableDpd();
  }

  if (!!request.hasEnableNatTraversal()) {
    query["EnableNatTraversal"] = request.enableNatTraversal();
  }

  if (!!request.hasEnableTunnelsBgp()) {
    query["EnableTunnelsBgp"] = request.enableTunnelsBgp();
  }

  if (!!request.hasHealthCheckConfig()) {
    query["HealthCheckConfig"] = request.healthCheckConfig();
  }

  if (!!request.hasIkeConfig()) {
    query["IkeConfig"] = request.ikeConfig();
  }

  if (!!request.hasIpsecConfig()) {
    query["IpsecConfig"] = request.ipsecConfig();
  }

  if (!!request.hasLocalSubnet()) {
    query["LocalSubnet"] = request.localSubnet();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasNetworkType()) {
    query["NetworkType"] = request.networkType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRemoteCaCert()) {
    query["RemoteCaCert"] = request.remoteCaCert();
  }

  if (!!request.hasRemoteSubnet()) {
    query["RemoteSubnet"] = request.remoteSubnet();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  json body = {};
  json bodyFlat = {};
  if (!!request.hasTunnelOptionsSpecification()) {
    bodyFlat["TunnelOptionsSpecification"] = request.tunnelOptionsSpecification();
  }

  body = Darabonba::Core::merge(body,
    Utils::Utils::query(bodyFlat)
  );
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)},
    {"body" , Utils::Utils::parseToMap(body)}
  }));
  Params params = Params(json({
    {"action" , "CreateVpnAttachment"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateVpnAttachmentResponse>();
}

/**
 * @summary Creates an IPsec-VPN connection. After you create the IPsec-VPN connection, you can associate the IPsec-VPN connection with a transit router.
 *
 * @description *   By default, the IPsec-VPN connection created by calling the `CreateVpnAttachment` operation is not bound to any resources. You can call the [CreateTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/443993.html) operation to bind the IPsec-VPN connection to a transit router.
 * *   If you want to associate an IPsec-VPN connection with a transit router, you can create a dual-tunnel connection in some regions. For more information, see [Dual-tunnel IPsec-VPN connections](https://help.aliyun.com/document_detail/2853535.html).
 *     *   When you create a IPsec-VPN connection in dual tunnel mode, you can configure the following request parameters in addition to the required parameters: **ClientToken**, **Name**, **NetworkType**, **EffectImmediately**, **AutoConfigRoute**, **Tags** array, **ResourceGroupId**, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
 *     *   When you create a IPsec-VPN connection in single tunnel mode, you can configure the following request parameters in addition to the required parameters: **ClientToken**, **CustomerGatewayId**, **NetworkType**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **Tags** array, and **ResourceGroupId**.
 * ### [](#)Prerequisites
 * Before you create an IPsec-VPN connection, you must create a customer gateway in the region where you want to create the IPsec-VPN connection. For more information, see [CreateCustomerGateway](https://help.aliyun.com/document_detail/120368.html).
 * If you want to add BGP configurations to an IPsec-VPN connection, make sure that an autonomous system number (ASN) is assigned to the customer gateway.
 *
 * @param request CreateVpnAttachmentRequest
 * @return CreateVpnAttachmentResponse
 */
CreateVpnAttachmentResponse Client::createVpnAttachment(const CreateVpnAttachmentRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createVpnAttachmentWithOptions(request, runtime);
}

/**
 * @summary Creates an IPsec-VPN connection.
 *
 * @description *   If the VPN gateway supports the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
 *     **ClientToken**, **Name**, **EffectImmediately**, **AutoConfigRoute**, **Tags** array, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
 *     For more information about the regions and zones that support the dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
 * *   If the VPN gateway supports only the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
 *     **ClientToken**, **CustomerGatewayId**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **RemoteCaCertificate**, and **Tags** array.
 * *   **CreateVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the IPsec-VPN connection is being created.
 *     *   If the VPN gateway is in the **active** state, the IPsec-VPN connection is created.
 * *   You cannot call **CreateVpnConnection** to create multiple IPsec-VPN connections associated with a VPN gateway at the same time.
 *
 * @param request CreateVpnConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpnConnectionResponse
 */
CreateVpnConnectionResponse Client::createVpnConnectionWithOptions(const CreateVpnConnectionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAutoConfigRoute()) {
    query["AutoConfigRoute"] = request.autoConfigRoute();
  }

  if (!!request.hasBgpConfig()) {
    query["BgpConfig"] = request.bgpConfig();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasCustomerGatewayId()) {
    query["CustomerGatewayId"] = request.customerGatewayId();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEffectImmediately()) {
    query["EffectImmediately"] = request.effectImmediately();
  }

  if (!!request.hasEnableDpd()) {
    query["EnableDpd"] = request.enableDpd();
  }

  if (!!request.hasEnableNatTraversal()) {
    query["EnableNatTraversal"] = request.enableNatTraversal();
  }

  if (!!request.hasEnableTunnelsBgp()) {
    query["EnableTunnelsBgp"] = request.enableTunnelsBgp();
  }

  if (!!request.hasHealthCheckConfig()) {
    query["HealthCheckConfig"] = request.healthCheckConfig();
  }

  if (!!request.hasIkeConfig()) {
    query["IkeConfig"] = request.ikeConfig();
  }

  if (!!request.hasIpsecConfig()) {
    query["IpsecConfig"] = request.ipsecConfig();
  }

  if (!!request.hasLocalSubnet()) {
    query["LocalSubnet"] = request.localSubnet();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRemoteCaCertificate()) {
    query["RemoteCaCertificate"] = request.remoteCaCertificate();
  }

  if (!!request.hasRemoteSubnet()) {
    query["RemoteSubnet"] = request.remoteSubnet();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  json body = {};
  json bodyFlat = {};
  if (!!request.hasTunnelOptionsSpecification()) {
    bodyFlat["TunnelOptionsSpecification"] = request.tunnelOptionsSpecification();
  }

  body = Darabonba::Core::merge(body,
    Utils::Utils::query(bodyFlat)
  );
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)},
    {"body" , Utils::Utils::parseToMap(body)}
  }));
  Params params = Params(json({
    {"action" , "CreateVpnConnection"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateVpnConnectionResponse>();
}

/**
 * @summary Creates an IPsec-VPN connection.
 *
 * @description *   If the VPN gateway supports the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
 *     **ClientToken**, **Name**, **EffectImmediately**, **AutoConfigRoute**, **Tags** array, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
 *     For more information about the regions and zones that support the dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
 * *   If the VPN gateway supports only the dual-tunnel mode, you can specify the following parameters in addition to the required parameters when you call `CreateVpnConnection`:
 *     **ClientToken**, **CustomerGatewayId**, **Name**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, **RemoteCaCertificate**, and **Tags** array.
 * *   **CreateVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the IPsec-VPN connection is being created.
 *     *   If the VPN gateway is in the **active** state, the IPsec-VPN connection is created.
 * *   You cannot call **CreateVpnConnection** to create multiple IPsec-VPN connections associated with a VPN gateway at the same time.
 *
 * @param request CreateVpnConnectionRequest
 * @return CreateVpnConnectionResponse
 */
CreateVpnConnectionResponse Client::createVpnConnection(const CreateVpnConnectionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createVpnConnectionWithOptions(request, runtime);
}

/**
 * @summary Creates a VPN gateway.
 *
 * @description *   Before you create a VPN gateway, we recommend that you know more about the limits of VPN gateways. For more information, see the [Limits](https://help.aliyun.com/document_detail/65290.html) section in the "Create and manage a VPN gateway" topic.
 * *   VPN gateways in some regions support only IPsec-VPN connections in dual-tunnel mode. If you call `CreateVpnGateway` in these regions, you must specify **VSwitchId** and **DisasterRecoveryVSwitchId** in addition to the required parameters. For more information about the regions and zones that support the IPsec-VPN connections in dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
 * *   **CreateVpnGateway** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the endpoint service is being created in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
 *     *   If the VPN gateway is in the **provisioning** state, the VPN gateway is being created.
 *     *   If the VPN gateway is in the **active** state, the VPN gateway is created.
 *
 * @param request CreateVpnGatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpnGatewayResponse
 */
CreateVpnGatewayResponse Client::createVpnGatewayWithOptions(const CreateVpnGatewayRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAutoPay()) {
    query["AutoPay"] = request.autoPay();
  }

  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDisasterRecoveryVSwitchId()) {
    query["DisasterRecoveryVSwitchId"] = request.disasterRecoveryVSwitchId();
  }

  if (!!request.hasEnableIpsec()) {
    query["EnableIpsec"] = request.enableIpsec();
  }

  if (!!request.hasEnableSsl()) {
    query["EnableSsl"] = request.enableSsl();
  }

  if (!!request.hasInstanceChargeType()) {
    query["InstanceChargeType"] = request.instanceChargeType();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasNetworkType()) {
    query["NetworkType"] = request.networkType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPeriod()) {
    query["Period"] = request.period();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSslConnections()) {
    query["SslConnections"] = request.sslConnections();
  }

  if (!!request.hasVSwitchId()) {
    query["VSwitchId"] = request.vSwitchId();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  if (!!request.hasVpnType()) {
    query["VpnType"] = request.vpnType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateVpnGateway"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateVpnGatewayResponse>();
}

/**
 * @summary Creates a VPN gateway.
 *
 * @description *   Before you create a VPN gateway, we recommend that you know more about the limits of VPN gateways. For more information, see the [Limits](https://help.aliyun.com/document_detail/65290.html) section in the "Create and manage a VPN gateway" topic.
 * *   VPN gateways in some regions support only IPsec-VPN connections in dual-tunnel mode. If you call `CreateVpnGateway` in these regions, you must specify **VSwitchId** and **DisasterRecoveryVSwitchId** in addition to the required parameters. For more information about the regions and zones that support the IPsec-VPN connections in dual-tunnel mode, see [IPsec-VPN connections support the dual-tunnel mode](https://help.aliyun.com/document_detail/2358946.html).
 * *   **CreateVpnGateway** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the endpoint service is being created in the backend. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
 *     *   If the VPN gateway is in the **provisioning** state, the VPN gateway is being created.
 *     *   If the VPN gateway is in the **active** state, the VPN gateway is created.
 *
 * @param request CreateVpnGatewayRequest
 * @return CreateVpnGatewayResponse
 */
CreateVpnGatewayResponse Client::createVpnGateway(const CreateVpnGatewayRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createVpnGatewayWithOptions(request, runtime);
}

/**
 * @summary Creates a policy-based route for a VPN gateway.
 *
 * @description *   Before you call this operation, make sure that you are familiar with the match rules of and limits on policy-based routes. For more information, see [Manage policy-based routes](https://help.aliyun.com/document_detail/110777.html).
 * *   Before you create a policy-based route, make sure that an IPsec-VPN connection is created. For more information, see [CreateVpnConnection](https://help.aliyun.com/document_detail/120391.html).
 * *   **CreateVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the policy-based route is being created.
 *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
 * *   You cannot call the **CreateVpnPbrRouteEntry** operation to create multiple policy-based routes for a VPN gateway at a time.
 *
 * @param request CreateVpnPbrRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpnPbrRouteEntryResponse
 */
CreateVpnPbrRouteEntryResponse Client::createVpnPbrRouteEntryWithOptions(const CreateVpnPbrRouteEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasNextHop()) {
    query["NextHop"] = request.nextHop();
  }

  if (!!request.hasOverlayMode()) {
    query["OverlayMode"] = request.overlayMode();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPriority()) {
    query["Priority"] = request.priority();
  }

  if (!!request.hasPublishVpc()) {
    query["PublishVpc"] = request.publishVpc();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteDest()) {
    query["RouteDest"] = request.routeDest();
  }

  if (!!request.hasRouteSource()) {
    query["RouteSource"] = request.routeSource();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  if (!!request.hasWeight()) {
    query["Weight"] = request.weight();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateVpnPbrRouteEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateVpnPbrRouteEntryResponse>();
}

/**
 * @summary Creates a policy-based route for a VPN gateway.
 *
 * @description *   Before you call this operation, make sure that you are familiar with the match rules of and limits on policy-based routes. For more information, see [Manage policy-based routes](https://help.aliyun.com/document_detail/110777.html).
 * *   Before you create a policy-based route, make sure that an IPsec-VPN connection is created. For more information, see [CreateVpnConnection](https://help.aliyun.com/document_detail/120391.html).
 * *   **CreateVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of the VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the policy-based route is being created.
 *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
 * *   You cannot call the **CreateVpnPbrRouteEntry** operation to create multiple policy-based routes for a VPN gateway at a time.
 *
 * @param request CreateVpnPbrRouteEntryRequest
 * @return CreateVpnPbrRouteEntryResponse
 */
CreateVpnPbrRouteEntryResponse Client::createVpnPbrRouteEntry(const CreateVpnPbrRouteEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createVpnPbrRouteEntryWithOptions(request, runtime);
}

/**
 * @summary Creates a destination-based route entry for a VPN gateway.
 *
 * @description *   **CreateVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
 *     *   If a VPN gateway is in the **updating** state, the destination-based route entry is being created.
 *     *   If a VPN gateway is in the **active** state, the destination-based route entry has been created.
 * *   You cannot repeatedly call **CreateVpnRouteEntry** to create a destination-based route entry for a VPN gateway within the specified period of time.
 *
 * @param request CreateVpnRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpnRouteEntryResponse
 */
CreateVpnRouteEntryResponse Client::createVpnRouteEntryWithOptions(const CreateVpnRouteEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasNextHop()) {
    query["NextHop"] = request.nextHop();
  }

  if (!!request.hasOverlayMode()) {
    query["OverlayMode"] = request.overlayMode();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPublishVpc()) {
    query["PublishVpc"] = request.publishVpc();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteDest()) {
    query["RouteDest"] = request.routeDest();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  if (!!request.hasWeight()) {
    query["Weight"] = request.weight();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateVpnRouteEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateVpnRouteEntryResponse>();
}

/**
 * @summary Creates a destination-based route entry for a VPN gateway.
 *
 * @description *   **CreateVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
 *     *   If a VPN gateway is in the **updating** state, the destination-based route entry is being created.
 *     *   If a VPN gateway is in the **active** state, the destination-based route entry has been created.
 * *   You cannot repeatedly call **CreateVpnRouteEntry** to create a destination-based route entry for a VPN gateway within the specified period of time.
 *
 * @param request CreateVpnRouteEntryRequest
 * @return CreateVpnRouteEntryResponse
 */
CreateVpnRouteEntryResponse Client::createVpnRouteEntry(const CreateVpnRouteEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createVpnRouteEntryWithOptions(request, runtime);
}

/**
 * @summary 冻结路由器接口
 *
 * @param request DeactivateRouterInterfaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeactivateRouterInterfaceResponse
 */
DeactivateRouterInterfaceResponse Client::deactivateRouterInterfaceWithOptions(const DeactivateRouterInterfaceRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouterInterfaceId()) {
    query["RouterInterfaceId"] = request.routerInterfaceId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeactivateRouterInterface"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeactivateRouterInterfaceResponse>();
}

/**
 * @summary 冻结路由器接口
 *
 * @param request DeactivateRouterInterfaceRequest
 * @return DeactivateRouterInterfaceResponse
 */
DeactivateRouterInterfaceResponse Client::deactivateRouterInterface(const DeactivateRouterInterfaceRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deactivateRouterInterfaceWithOptions(request, runtime);
}

/**
 * @summary Disables a flow log. After a flow log is disabled, the system no longer captures the traffic information about a resource.
 *
 * @description *   The **DeactiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
 *     *   If the flow log is in the **Deactivating** state, the flow log is being disabled.
 *     *   If the flow log is in the **Inactive** state, the flow log is disabled.
 * *   You cannot repeatedly call the **DeactiveFlowLog** operation to disable a flow log within the specified period of time.
 *
 * @param request DeactiveFlowLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeactiveFlowLogResponse
 */
DeactiveFlowLogResponse Client::deactiveFlowLogWithOptions(const DeactiveFlowLogRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFlowLogId()) {
    query["FlowLogId"] = request.flowLogId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeactiveFlowLog"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeactiveFlowLogResponse>();
}

/**
 * @summary Disables a flow log. After a flow log is disabled, the system no longer captures the traffic information about a resource.
 *
 * @description *   The **DeactiveFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
 *     *   If the flow log is in the **Deactivating** state, the flow log is being disabled.
 *     *   If the flow log is in the **Inactive** state, the flow log is disabled.
 * *   You cannot repeatedly call the **DeactiveFlowLog** operation to disable a flow log within the specified period of time.
 *
 * @param request DeactiveFlowLogRequest
 * @return DeactiveFlowLogResponse
 */
DeactiveFlowLogResponse Client::deactiveFlowLog(const DeactiveFlowLogRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deactiveFlowLogWithOptions(request, runtime);
}

/**
 * @summary Deletes a Border Gateway Protocol (BGP) group.
 *
 * @param request DeleteBgpGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBgpGroupResponse
 */
DeleteBgpGroupResponse Client::deleteBgpGroupWithOptions(const DeleteBgpGroupRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBgpGroupId()) {
    query["BgpGroupId"] = request.bgpGroupId();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteBgpGroup"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteBgpGroupResponse>();
}

/**
 * @summary Deletes a Border Gateway Protocol (BGP) group.
 *
 * @param request DeleteBgpGroupRequest
 * @return DeleteBgpGroupResponse
 */
DeleteBgpGroupResponse Client::deleteBgpGroup(const DeleteBgpGroupRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteBgpGroupWithOptions(request, runtime);
}

/**
 * @summary Deletes an advertised Border Gateway Protocol (BGP) network.
 *
 * @param request DeleteBgpNetworkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBgpNetworkResponse
 */
DeleteBgpNetworkResponse Client::deleteBgpNetworkWithOptions(const DeleteBgpNetworkRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDstCidrBlock()) {
    query["DstCidrBlock"] = request.dstCidrBlock();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouterId()) {
    query["RouterId"] = request.routerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteBgpNetwork"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteBgpNetworkResponse>();
}

/**
 * @summary Deletes an advertised Border Gateway Protocol (BGP) network.
 *
 * @param request DeleteBgpNetworkRequest
 * @return DeleteBgpNetworkResponse
 */
DeleteBgpNetworkResponse Client::deleteBgpNetwork(const DeleteBgpNetworkRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteBgpNetworkWithOptions(request, runtime);
}

/**
 * @summary Deletes a Border Gateway Protocol (BGP) peer.
 *
 * @param request DeleteBgpPeerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBgpPeerResponse
 */
DeleteBgpPeerResponse Client::deleteBgpPeerWithOptions(const DeleteBgpPeerRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBgpPeerId()) {
    query["BgpPeerId"] = request.bgpPeerId();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteBgpPeer"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteBgpPeerResponse>();
}

/**
 * @summary Deletes a Border Gateway Protocol (BGP) peer.
 *
 * @param request DeleteBgpPeerRequest
 * @return DeleteBgpPeerResponse
 */
DeleteBgpPeerResponse Client::deleteBgpPeer(const DeleteBgpPeerRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteBgpPeerWithOptions(request, runtime);
}

/**
 * @summary Deletes an Internet Shared Bandwidth instance.
 *
 * @description You cannot repeatedly call the **DeleteCommonBandwidthPackage** operation to delete an Internet Shared Bandwidth instance within the specified period of time.
 *
 * @param request DeleteCommonBandwidthPackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCommonBandwidthPackageResponse
 */
DeleteCommonBandwidthPackageResponse Client::deleteCommonBandwidthPackageWithOptions(const DeleteCommonBandwidthPackageRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidthPackageId()) {
    query["BandwidthPackageId"] = request.bandwidthPackageId();
  }

  if (!!request.hasForce()) {
    query["Force"] = request.force();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteCommonBandwidthPackage"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteCommonBandwidthPackageResponse>();
}

/**
 * @summary Deletes an Internet Shared Bandwidth instance.
 *
 * @description You cannot repeatedly call the **DeleteCommonBandwidthPackage** operation to delete an Internet Shared Bandwidth instance within the specified period of time.
 *
 * @param request DeleteCommonBandwidthPackageRequest
 * @return DeleteCommonBandwidthPackageResponse
 */
DeleteCommonBandwidthPackageResponse Client::deleteCommonBandwidthPackage(const DeleteCommonBandwidthPackageRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteCommonBandwidthPackageWithOptions(request, runtime);
}

/**
 * @summary Deletes a customer gateway.
 *
 * @description Before you delete a customer gateway, make sure that no IPsec-VPN connection is associated with the customer gateway. For more information about how to delete an IPsec-VPN connection, see [DeleteVpnAttachment](https://help.aliyun.com/document_detail/2526938.html) or [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
 *
 * @param request DeleteCustomerGatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCustomerGatewayResponse
 */
DeleteCustomerGatewayResponse Client::deleteCustomerGatewayWithOptions(const DeleteCustomerGatewayRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasCustomerGatewayId()) {
    query["CustomerGatewayId"] = request.customerGatewayId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteCustomerGateway"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteCustomerGatewayResponse>();
}

/**
 * @summary Deletes a customer gateway.
 *
 * @description Before you delete a customer gateway, make sure that no IPsec-VPN connection is associated with the customer gateway. For more information about how to delete an IPsec-VPN connection, see [DeleteVpnAttachment](https://help.aliyun.com/document_detail/2526938.html) or [DeleteVpnConnection](https://help.aliyun.com/document_detail/2526948.html).
 *
 * @param request DeleteCustomerGatewayRequest
 * @return DeleteCustomerGatewayResponse
 */
DeleteCustomerGatewayResponse Client::deleteCustomerGateway(const DeleteCustomerGatewayRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteCustomerGatewayWithOptions(request, runtime);
}

/**
 * @summary Deletes a DHCP options set.
 *
 * @description ## [](#)Description
 * *   **DeleteDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/189208.html) operation to query the status of the task.
 *     *   If the DHCP options set is in the **Deleting** state, the DHCP options set is being deleted.
 *     *   If you cannot query the DHCP options set, the DHCP options set is deleted.
 * *   You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a DHCP options set within the specified period of time.
 *
 * @param request DeleteDhcpOptionsSetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDhcpOptionsSetResponse
 */
DeleteDhcpOptionsSetResponse Client::deleteDhcpOptionsSetWithOptions(const DeleteDhcpOptionsSetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDhcpOptionsSetId()) {
    query["DhcpOptionsSetId"] = request.dhcpOptionsSetId();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteDhcpOptionsSet"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteDhcpOptionsSetResponse>();
}

/**
 * @summary Deletes a DHCP options set.
 *
 * @description ## [](#)Description
 * *   **DeleteDhcpOptionsSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetDhcpOptionsSet](https://help.aliyun.com/document_detail/189208.html) operation to query the status of the task.
 *     *   If the DHCP options set is in the **Deleting** state, the DHCP options set is being deleted.
 *     *   If you cannot query the DHCP options set, the DHCP options set is deleted.
 * *   You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a DHCP options set within the specified period of time.
 *
 * @param request DeleteDhcpOptionsSetRequest
 * @return DeleteDhcpOptionsSetResponse
 */
DeleteDhcpOptionsSetResponse Client::deleteDhcpOptionsSet(const DeleteDhcpOptionsSetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteDhcpOptionsSetWithOptions(request, runtime);
}

/**
 * @summary Deletes a quality of service (QoS) policy.
 *
 * @param request DeleteExpressConnectTrafficQosRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteExpressConnectTrafficQosResponse
 */
DeleteExpressConnectTrafficQosResponse Client::deleteExpressConnectTrafficQosWithOptions(const DeleteExpressConnectTrafficQosRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasQosId()) {
    query["QosId"] = request.qosId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteExpressConnectTrafficQos"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteExpressConnectTrafficQosResponse>();
}

/**
 * @summary Deletes a quality of service (QoS) policy.
 *
 * @param request DeleteExpressConnectTrafficQosRequest
 * @return DeleteExpressConnectTrafficQosResponse
 */
DeleteExpressConnectTrafficQosResponse Client::deleteExpressConnectTrafficQos(const DeleteExpressConnectTrafficQosRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteExpressConnectTrafficQosWithOptions(request, runtime);
}

/**
 * @summary Deletes a quality of service (QoS) queue.
 *
 * @param request DeleteExpressConnectTrafficQosQueueRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteExpressConnectTrafficQosQueueResponse
 */
DeleteExpressConnectTrafficQosQueueResponse Client::deleteExpressConnectTrafficQosQueueWithOptions(const DeleteExpressConnectTrafficQosQueueRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasQosId()) {
    query["QosId"] = request.qosId();
  }

  if (!!request.hasQueueId()) {
    query["QueueId"] = request.queueId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteExpressConnectTrafficQosQueue"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteExpressConnectTrafficQosQueueResponse>();
}

/**
 * @summary Deletes a quality of service (QoS) queue.
 *
 * @param request DeleteExpressConnectTrafficQosQueueRequest
 * @return DeleteExpressConnectTrafficQosQueueResponse
 */
DeleteExpressConnectTrafficQosQueueResponse Client::deleteExpressConnectTrafficQosQueue(const DeleteExpressConnectTrafficQosQueueRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteExpressConnectTrafficQosQueueWithOptions(request, runtime);
}

/**
 * @summary Deletes a quality of service (QoS) rule.
 *
 * @param request DeleteExpressConnectTrafficQosRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteExpressConnectTrafficQosRuleResponse
 */
DeleteExpressConnectTrafficQosRuleResponse Client::deleteExpressConnectTrafficQosRuleWithOptions(const DeleteExpressConnectTrafficQosRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasQosId()) {
    query["QosId"] = request.qosId();
  }

  if (!!request.hasQueueId()) {
    query["QueueId"] = request.queueId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasRuleId()) {
    query["RuleId"] = request.ruleId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteExpressConnectTrafficQosRule"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteExpressConnectTrafficQosRuleResponse>();
}

/**
 * @summary Deletes a quality of service (QoS) rule.
 *
 * @param request DeleteExpressConnectTrafficQosRuleRequest
 * @return DeleteExpressConnectTrafficQosRuleResponse
 */
DeleteExpressConnectTrafficQosRuleResponse Client::deleteExpressConnectTrafficQosRule(const DeleteExpressConnectTrafficQosRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteExpressConnectTrafficQosRuleWithOptions(request, runtime);
}

/**
 * @summary Deletes a failover test.
 *
 * @description You can delete only failover tests that are in the **Pending** or **Complete** state.
 *
 * @param request DeleteFailoverTestJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFailoverTestJobResponse
 */
DeleteFailoverTestJobResponse Client::deleteFailoverTestJobWithOptions(const DeleteFailoverTestJobRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasJobId()) {
    query["JobId"] = request.jobId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteFailoverTestJob"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteFailoverTestJobResponse>();
}

/**
 * @summary Deletes a failover test.
 *
 * @description You can delete only failover tests that are in the **Pending** or **Complete** state.
 *
 * @param request DeleteFailoverTestJobRequest
 * @return DeleteFailoverTestJobResponse
 */
DeleteFailoverTestJobResponse Client::deleteFailoverTestJob(const DeleteFailoverTestJobRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteFailoverTestJobWithOptions(request, runtime);
}

/**
 * @summary Deletes a flow log.
 *
 * @description *   The **DeleteFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
 *     *   If the flow log is in the **Deleting** state, the flow log is being deleted.
 *     *   If you cannot query the flow log, the flow log is deleted.
 * *   You cannot repeatedly call the **DeleteFlowLog** operation to delete a flow log within the specified period of time.
 *
 * @param request DeleteFlowLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFlowLogResponse
 */
DeleteFlowLogResponse Client::deleteFlowLogWithOptions(const DeleteFlowLogRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFlowLogId()) {
    query["FlowLogId"] = request.flowLogId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteFlowLog"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteFlowLogResponse>();
}

/**
 * @summary Deletes a flow log.
 *
 * @description *   The **DeleteFlowLog** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
 *     *   If the flow log is in the **Deleting** state, the flow log is being deleted.
 *     *   If you cannot query the flow log, the flow log is deleted.
 * *   You cannot repeatedly call the **DeleteFlowLog** operation to delete a flow log within the specified period of time.
 *
 * @param request DeleteFlowLogRequest
 * @return DeleteFlowLogResponse
 */
DeleteFlowLogResponse Client::deleteFlowLog(const DeleteFlowLogRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteFlowLogWithOptions(request, runtime);
}

/**
 * @summary Deletes a DNAT entry.
 *
 * @description ## [](#)Description
 * *   **DeleteForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
 *     *   If the DNAT entry is in the **Deleting** state, the system is deleting the DNAT entry. In this case, you can only query the status of the DNAT entry, but cannot perform other operations.
 *     *   If the DNAT entry cannot be found, it is deleted.
 * >  If a DNAT table has DNAT entries in the **Pending** state, you cannot delete the DNAT entries.
 * *   You cannot repeatedly call the **DeleteForwardEntry** operation to delete a DNAT entry within the specified period of time.
 *
 * @param request DeleteForwardEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteForwardEntryResponse
 */
DeleteForwardEntryResponse Client::deleteForwardEntryWithOptions(const DeleteForwardEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasForwardEntryId()) {
    query["ForwardEntryId"] = request.forwardEntryId();
  }

  if (!!request.hasForwardTableId()) {
    query["ForwardTableId"] = request.forwardTableId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteForwardEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteForwardEntryResponse>();
}

/**
 * @summary Deletes a DNAT entry.
 *
 * @description ## [](#)Description
 * *   **DeleteForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
 *     *   If the DNAT entry is in the **Deleting** state, the system is deleting the DNAT entry. In this case, you can only query the status of the DNAT entry, but cannot perform other operations.
 *     *   If the DNAT entry cannot be found, it is deleted.
 * >  If a DNAT table has DNAT entries in the **Pending** state, you cannot delete the DNAT entries.
 * *   You cannot repeatedly call the **DeleteForwardEntry** operation to delete a DNAT entry within the specified period of time.
 *
 * @param request DeleteForwardEntryRequest
 * @return DeleteForwardEntryResponse
 */
DeleteForwardEntryResponse Client::deleteForwardEntry(const DeleteForwardEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteForwardEntryWithOptions(request, runtime);
}

/**
 * @summary Deletes a FULLNAT entry.
 *
 * @description ## [](#)Description
 * **DeleteFullNatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
 * *   If the FULLNAT entry is in the **Deleting** state, the system is deleting the FULLNAT entry. In this case, you can query the status of the FULLNAT entry, but cannot perform other operations.
 * *   If the FULLNAT entry cannot be found, the FULLNAT entry is deleted.
 * You cannot repeatedly call the **DeleteFullNatEntry** operation to delete a FULLNAT entry within the specified period of time.
 *
 * @param request DeleteFullNatEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFullNatEntryResponse
 */
DeleteFullNatEntryResponse Client::deleteFullNatEntryWithOptions(const DeleteFullNatEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasFullNatEntryId()) {
    query["FullNatEntryId"] = request.fullNatEntryId();
  }

  if (!!request.hasFullNatTableId()) {
    query["FullNatTableId"] = request.fullNatTableId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteFullNatEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteFullNatEntryResponse>();
}

/**
 * @summary Deletes a FULLNAT entry.
 *
 * @description ## [](#)Description
 * **DeleteFullNatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
 * *   If the FULLNAT entry is in the **Deleting** state, the system is deleting the FULLNAT entry. In this case, you can query the status of the FULLNAT entry, but cannot perform other operations.
 * *   If the FULLNAT entry cannot be found, the FULLNAT entry is deleted.
 * You cannot repeatedly call the **DeleteFullNatEntry** operation to delete a FULLNAT entry within the specified period of time.
 *
 * @param request DeleteFullNatEntryRequest
 * @return DeleteFullNatEntryResponse
 */
DeleteFullNatEntryResponse Client::deleteFullNatEntry(const DeleteFullNatEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteFullNatEntryWithOptions(request, runtime);
}

/**
 * @summary Deletes a Global Accelerator (GA) instance.
 *
 * @description When you call this operation, take note of the following items:
 * *   You can delete only pay-as-you-go instances.
 * *   Before you can delete a dedicated instance, disassociate the backend server from the instance first.
 * *   Before you can delete a shared instance, disassociate the elastic IP address (EIP) from the instance first.
 *
 * @param request DeleteGlobalAccelerationInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGlobalAccelerationInstanceResponse
 */
DeleteGlobalAccelerationInstanceResponse Client::deleteGlobalAccelerationInstanceWithOptions(const DeleteGlobalAccelerationInstanceRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasGlobalAccelerationInstanceId()) {
    query["GlobalAccelerationInstanceId"] = request.globalAccelerationInstanceId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteGlobalAccelerationInstance"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteGlobalAccelerationInstanceResponse>();
}

/**
 * @summary Deletes a Global Accelerator (GA) instance.
 *
 * @description When you call this operation, take note of the following items:
 * *   You can delete only pay-as-you-go instances.
 * *   Before you can delete a dedicated instance, disassociate the backend server from the instance first.
 * *   Before you can delete a shared instance, disassociate the elastic IP address (EIP) from the instance first.
 *
 * @param request DeleteGlobalAccelerationInstanceRequest
 * @return DeleteGlobalAccelerationInstanceResponse
 */
DeleteGlobalAccelerationInstanceResponse Client::deleteGlobalAccelerationInstance(const DeleteGlobalAccelerationInstanceRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteGlobalAccelerationInstanceWithOptions(request, runtime);
}

/**
 * @summary Deletes a high-availability virtual IP address (HaVip).
 *
 * @description When you call this operation, take note of the following rules:
 * *   The HaVip must be in the available state before it can be deleted.
 * *   Make sure that no routes are destined for the HaVip.
 * *   Make sure that no elastic IP addresses (EIPs) are associated with the HaVip.
 * *   **DeleteHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID while deleting the HaVip in the background. Call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
 *     *   The **Deleting** state indicates the HaVip is being deleted.
 *     *   If no HaVip is found, the HaVip is deleted.
 * *   You cannot repeatedly call the **DeleteHaVip** operation to delete the same HaVip.
 *
 * @param request DeleteHaVipRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHaVipResponse
 */
DeleteHaVipResponse Client::deleteHaVipWithOptions(const DeleteHaVipRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasHaVipId()) {
    query["HaVipId"] = request.haVipId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteHaVip"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteHaVipResponse>();
}

/**
 * @summary Deletes a high-availability virtual IP address (HaVip).
 *
 * @description When you call this operation, take note of the following rules:
 * *   The HaVip must be in the available state before it can be deleted.
 * *   Make sure that no routes are destined for the HaVip.
 * *   Make sure that no elastic IP addresses (EIPs) are associated with the HaVip.
 * *   **DeleteHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID while deleting the HaVip in the background. Call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
 *     *   The **Deleting** state indicates the HaVip is being deleted.
 *     *   If no HaVip is found, the HaVip is deleted.
 * *   You cannot repeatedly call the **DeleteHaVip** operation to delete the same HaVip.
 *
 * @param request DeleteHaVipRequest
 * @return DeleteHaVipResponse
 */
DeleteHaVipResponse Client::deleteHaVip(const DeleteHaVipRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteHaVipWithOptions(request, runtime);
}

/**
 * @summary Deletes an IPv6 Translation Service instance.
 *
 * @param request DeleteIPv6TranslatorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIPv6TranslatorResponse
 */
DeleteIPv6TranslatorResponse Client::deleteIPv6TranslatorWithOptions(const DeleteIPv6TranslatorRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasIpv6TranslatorId()) {
    query["Ipv6TranslatorId"] = request.ipv6TranslatorId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteIPv6Translator"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteIPv6TranslatorResponse>();
}

/**
 * @summary Deletes an IPv6 Translation Service instance.
 *
 * @param request DeleteIPv6TranslatorRequest
 * @return DeleteIPv6TranslatorResponse
 */
DeleteIPv6TranslatorResponse Client::deleteIPv6Translator(const DeleteIPv6TranslatorRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteIPv6TranslatorWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI DeleteIPv6TranslatorAclList is deprecated
 *
 * @summary Deletes an access control list (ACL). You can delete an ACL only when the ACL is not associated with IPv6 translation mappings.
 *
 * @param request DeleteIPv6TranslatorAclListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIPv6TranslatorAclListResponse
 */
DeleteIPv6TranslatorAclListResponse Client::deleteIPv6TranslatorAclListWithOptions(const DeleteIPv6TranslatorAclListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAclId()) {
    query["AclId"] = request.aclId();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteIPv6TranslatorAclList"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteIPv6TranslatorAclListResponse>();
}

/**
 * @deprecated OpenAPI DeleteIPv6TranslatorAclList is deprecated
 *
 * @summary Deletes an access control list (ACL). You can delete an ACL only when the ACL is not associated with IPv6 translation mappings.
 *
 * @param request DeleteIPv6TranslatorAclListRequest
 * @return DeleteIPv6TranslatorAclListResponse
 */
DeleteIPv6TranslatorAclListResponse Client::deleteIPv6TranslatorAclList(const DeleteIPv6TranslatorAclListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteIPv6TranslatorAclListWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI DeleteIPv6TranslatorEntry is deprecated
 *
 * @summary Deletes an IPv6 mapping entry.
 *
 * @param request DeleteIPv6TranslatorEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIPv6TranslatorEntryResponse
 */
DeleteIPv6TranslatorEntryResponse Client::deleteIPv6TranslatorEntryWithOptions(const DeleteIPv6TranslatorEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasIpv6TranslatorEntryId()) {
    query["Ipv6TranslatorEntryId"] = request.ipv6TranslatorEntryId();
  }

  if (!!request.hasIpv6TranslatorId()) {
    query["Ipv6TranslatorId"] = request.ipv6TranslatorId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteIPv6TranslatorEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteIPv6TranslatorEntryResponse>();
}

/**
 * @deprecated OpenAPI DeleteIPv6TranslatorEntry is deprecated
 *
 * @summary Deletes an IPv6 mapping entry.
 *
 * @param request DeleteIPv6TranslatorEntryRequest
 * @return DeleteIPv6TranslatorEntryResponse
 */
DeleteIPv6TranslatorEntryResponse Client::deleteIPv6TranslatorEntry(const DeleteIPv6TranslatorEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteIPv6TranslatorEntryWithOptions(request, runtime);
}

/**
 * @summary Deletes an IPsec server.
 *
 * @description *   **DeleteIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the IPsec server is being deleted.
 *     *   If the VPN gateway is in the **active** state, the IPsec server is deleted.
 * *   You cannot call **DeleteIpsecServer** within the specified period of time.
 *
 * @param request DeleteIpsecServerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIpsecServerResponse
 */
DeleteIpsecServerResponse Client::deleteIpsecServerWithOptions(const DeleteIpsecServerRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIpsecServerId()) {
    query["IpsecServerId"] = request.ipsecServerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteIpsecServer"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteIpsecServerResponse>();
}

/**
 * @summary Deletes an IPsec server.
 *
 * @description *   **DeleteIpsecServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the IPsec server is being deleted.
 *     *   If the VPN gateway is in the **active** state, the IPsec server is deleted.
 * *   You cannot call **DeleteIpsecServer** within the specified period of time.
 *
 * @param request DeleteIpsecServerRequest
 * @return DeleteIpsecServerResponse
 */
DeleteIpsecServerResponse Client::deleteIpsecServer(const DeleteIpsecServerRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteIpsecServerWithOptions(request, runtime);
}

/**
 * @summary Deletes an IPv4 gateway.
 *
 * @description ### [](#)Description
 * *   Before you delete an IPv4 gateway, make sure that no route tables are associated with the IPv4 gateway.
 * *   **DeleteIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of the task.
 *     *   If the IPv4 gateway is in the **Deleting** state, the IPv4 gateway is being deleted.
 *     *   If the IPv4 gateway cannot be queried, the IPv4 gateway is deleted.
 * *   After you call the **DeleteIpv4Gateway** operation to delete an IPv4 gateway, you cannot call the operation again to delete the IPv4 gateway until the deletion task is complete.
 *
 * @param request DeleteIpv4GatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIpv4GatewayResponse
 */
DeleteIpv4GatewayResponse Client::deleteIpv4GatewayWithOptions(const DeleteIpv4GatewayRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasInternetMode()) {
    query["InternetMode"] = request.internetMode();
  }

  if (!!request.hasIpv4GatewayId()) {
    query["Ipv4GatewayId"] = request.ipv4GatewayId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteIpv4Gateway"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteIpv4GatewayResponse>();
}

/**
 * @summary Deletes an IPv4 gateway.
 *
 * @description ### [](#)Description
 * *   Before you delete an IPv4 gateway, make sure that no route tables are associated with the IPv4 gateway.
 * *   **DeleteIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of the task.
 *     *   If the IPv4 gateway is in the **Deleting** state, the IPv4 gateway is being deleted.
 *     *   If the IPv4 gateway cannot be queried, the IPv4 gateway is deleted.
 * *   After you call the **DeleteIpv4Gateway** operation to delete an IPv4 gateway, you cannot call the operation again to delete the IPv4 gateway until the deletion task is complete.
 *
 * @param request DeleteIpv4GatewayRequest
 * @return DeleteIpv4GatewayResponse
 */
DeleteIpv4GatewayResponse Client::deleteIpv4Gateway(const DeleteIpv4GatewayRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteIpv4GatewayWithOptions(request, runtime);
}

/**
 * @summary Deletes an egress-only rule.
 *
 * @description *   **DeleteIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
 *     *   If the egress-only rule is in the **Deleting** state, the egress-only rule is being deleted.
 *     *   If you cannot query the egress-only rule, the egress-only rule is deleted.
 * *   You cannot call the **DeleteIpv6EgressOnlyRule** within the specified period of time.
 *
 * @param request DeleteIpv6EgressOnlyRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIpv6EgressOnlyRuleResponse
 */
DeleteIpv6EgressOnlyRuleResponse Client::deleteIpv6EgressOnlyRuleWithOptions(const DeleteIpv6EgressOnlyRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasIpv6EgressOnlyRuleId()) {
    query["Ipv6EgressOnlyRuleId"] = request.ipv6EgressOnlyRuleId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteIpv6EgressOnlyRule"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteIpv6EgressOnlyRuleResponse>();
}

/**
 * @summary Deletes an egress-only rule.
 *
 * @description *   **DeleteIpv6EgressOnlyRule** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6EgressOnlyRules](https://help.aliyun.com/document_detail/102208.html) operation to query the status of the task.
 *     *   If the egress-only rule is in the **Deleting** state, the egress-only rule is being deleted.
 *     *   If you cannot query the egress-only rule, the egress-only rule is deleted.
 * *   You cannot call the **DeleteIpv6EgressOnlyRule** within the specified period of time.
 *
 * @param request DeleteIpv6EgressOnlyRuleRequest
 * @return DeleteIpv6EgressOnlyRuleResponse
 */
DeleteIpv6EgressOnlyRuleResponse Client::deleteIpv6EgressOnlyRule(const DeleteIpv6EgressOnlyRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteIpv6EgressOnlyRuleWithOptions(request, runtime);
}

/**
 * @summary Deletes an IPv6 gateway.
 *
 * @description Before you delete an IPv6 gateway, you must delete the egress-only rules of the IPv6 gateway. For more information, see [DeleteIpv6EgressOnlyRule](https://help.aliyun.com/document_detail/102201.html).
 * *   **DeleteIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task:
 *     *   If the IPv6 gateway is in the **Deleting** state, the IPv6 gateway is being deleted.
 *     *   If you cannot query the IPv6 gateway, the IPv6 gateway is deleted.
 * *   You cannot repeatedly call the **DeleteIpv6Gateway** operation to delete an IPv6 gateway within the specified period of time.
 *
 * @param request DeleteIpv6GatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIpv6GatewayResponse
 */
DeleteIpv6GatewayResponse Client::deleteIpv6GatewayWithOptions(const DeleteIpv6GatewayRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIpv6GatewayId()) {
    query["Ipv6GatewayId"] = request.ipv6GatewayId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteIpv6Gateway"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteIpv6GatewayResponse>();
}

/**
 * @summary Deletes an IPv6 gateway.
 *
 * @description Before you delete an IPv6 gateway, you must delete the egress-only rules of the IPv6 gateway. For more information, see [DeleteIpv6EgressOnlyRule](https://help.aliyun.com/document_detail/102201.html).
 * *   **DeleteIpv6Gateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpv6GatewayAttribute](https://help.aliyun.com/document_detail/102226.html) operation to query the status of the task:
 *     *   If the IPv6 gateway is in the **Deleting** state, the IPv6 gateway is being deleted.
 *     *   If you cannot query the IPv6 gateway, the IPv6 gateway is deleted.
 * *   You cannot repeatedly call the **DeleteIpv6Gateway** operation to delete an IPv6 gateway within the specified period of time.
 *
 * @param request DeleteIpv6GatewayRequest
 * @return DeleteIpv6GatewayResponse
 */
DeleteIpv6GatewayResponse Client::deleteIpv6Gateway(const DeleteIpv6GatewayRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteIpv6GatewayWithOptions(request, runtime);
}

/**
 * @summary Deletes Internet bandwidth.
 *
 * @description You cannot call the **DeleteIpv6InternetBandwidth** operation within the specified period of time.
 *
 * @param request DeleteIpv6InternetBandwidthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIpv6InternetBandwidthResponse
 */
DeleteIpv6InternetBandwidthResponse Client::deleteIpv6InternetBandwidthWithOptions(const DeleteIpv6InternetBandwidthRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIpv6AddressId()) {
    query["Ipv6AddressId"] = request.ipv6AddressId();
  }

  if (!!request.hasIpv6InternetBandwidthId()) {
    query["Ipv6InternetBandwidthId"] = request.ipv6InternetBandwidthId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteIpv6InternetBandwidth"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteIpv6InternetBandwidthResponse>();
}

/**
 * @summary Deletes Internet bandwidth.
 *
 * @description You cannot call the **DeleteIpv6InternetBandwidth** operation within the specified period of time.
 *
 * @param request DeleteIpv6InternetBandwidthRequest
 * @return DeleteIpv6InternetBandwidthResponse
 */
DeleteIpv6InternetBandwidthResponse Client::deleteIpv6InternetBandwidth(const DeleteIpv6InternetBandwidthRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteIpv6InternetBandwidthWithOptions(request, runtime);
}

/**
 * @summary Deletes a specified Internet NAT gateway.
 *
 * @description ## [](#)Description
 * *   **DeleteNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) to query the status of the task.
 *     *   If a NAT gateway is in the **Deleting** state, the NAT gateway is being deleted. In this case, you can query the NAT gateway but you cannot perform other operations.
 *     *   If the NAT gateway cannot be found, the NAT gateway is deleted.
 *         After you delete a NAT gateway, you cannot restore the NAT gateway. Proceed with caution.
 * *   You cannot repeatedly call the **DeleteNatGateway** operation to delete a NAT gateway within the specified period of time.
 *
 * @param request DeleteNatGatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNatGatewayResponse
 */
DeleteNatGatewayResponse Client::deleteNatGatewayWithOptions(const DeleteNatGatewayRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasForce()) {
    query["Force"] = request.force();
  }

  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteNatGateway"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteNatGatewayResponse>();
}

/**
 * @summary Deletes a specified Internet NAT gateway.
 *
 * @description ## [](#)Description
 * *   **DeleteNatGateway** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNatGateways](https://help.aliyun.com/document_detail/36054.html) to query the status of the task.
 *     *   If a NAT gateway is in the **Deleting** state, the NAT gateway is being deleted. In this case, you can query the NAT gateway but you cannot perform other operations.
 *     *   If the NAT gateway cannot be found, the NAT gateway is deleted.
 *         After you delete a NAT gateway, you cannot restore the NAT gateway. Proceed with caution.
 * *   You cannot repeatedly call the **DeleteNatGateway** operation to delete a NAT gateway within the specified period of time.
 *
 * @param request DeleteNatGatewayRequest
 * @return DeleteNatGatewayResponse
 */
DeleteNatGatewayResponse Client::deleteNatGateway(const DeleteNatGatewayRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteNatGatewayWithOptions(request, runtime);
}

/**
 * @summary Deletes a NAT IP address.
 *
 * @description ## [](#)Description
 * *   **DeleteNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/281979.html) operation to query the status of the task.
 *     *   If the NAT IP address is in the **Deleting** state, the NAT IP address is being deleted. In this case, you can only query the NAT IP address but cannot perform other operations.
 *     *   If the NAT IP address cannot be found, it is deleted.
 * *   You cannot repeatedly call the **DeleteNatIp** operation to delete a NAT IP address within the specified period of time.
 *
 * @param request DeleteNatIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNatIpResponse
 */
DeleteNatIpResponse Client::deleteNatIpWithOptions(const DeleteNatIpRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIpv4Prefix()) {
    query["Ipv4Prefix"] = request.ipv4Prefix();
  }

  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasNatIpId()) {
    query["NatIpId"] = request.natIpId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteNatIp"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteNatIpResponse>();
}

/**
 * @summary Deletes a NAT IP address.
 *
 * @description ## [](#)Description
 * *   **DeleteNatIp** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListNatIps](https://help.aliyun.com/document_detail/281979.html) operation to query the status of the task.
 *     *   If the NAT IP address is in the **Deleting** state, the NAT IP address is being deleted. In this case, you can only query the NAT IP address but cannot perform other operations.
 *     *   If the NAT IP address cannot be found, it is deleted.
 * *   You cannot repeatedly call the **DeleteNatIp** operation to delete a NAT IP address within the specified period of time.
 *
 * @param request DeleteNatIpRequest
 * @return DeleteNatIpResponse
 */
DeleteNatIpResponse Client::deleteNatIp(const DeleteNatIpRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteNatIpWithOptions(request, runtime);
}

/**
 * @summary Deletes a NAT CIDR block.
 *
 * @description ## [](#)Description
 * You cannot repeatedly call the **DeleteNatIpCidr** operation to delete a NAT CIDR block within the specified period of time.
 *
 * @param request DeleteNatIpCidrRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNatIpCidrResponse
 */
DeleteNatIpCidrResponse Client::deleteNatIpCidrWithOptions(const DeleteNatIpCidrRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasNatIpCidr()) {
    query["NatIpCidr"] = request.natIpCidr();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteNatIpCidr"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteNatIpCidrResponse>();
}

/**
 * @summary Deletes a NAT CIDR block.
 *
 * @description ## [](#)Description
 * You cannot repeatedly call the **DeleteNatIpCidr** operation to delete a NAT CIDR block within the specified period of time.
 *
 * @param request DeleteNatIpCidrRequest
 * @return DeleteNatIpCidrResponse
 */
DeleteNatIpCidrResponse Client::deleteNatIpCidr(const DeleteNatIpCidrRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteNatIpCidrWithOptions(request, runtime);
}

/**
 * @summary Deletes a network access control list (ACL).
 *
 * @description ## [](#)Description
 * You cannot repeatedly call the **DeleteNetworkAcl** operation within the specified period of time.
 *
 * @param request DeleteNetworkAclRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNetworkAclResponse
 */
DeleteNetworkAclResponse Client::deleteNetworkAclWithOptions(const DeleteNetworkAclRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasNetworkAclId()) {
    query["NetworkAclId"] = request.networkAclId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteNetworkAcl"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteNetworkAclResponse>();
}

/**
 * @summary Deletes a network access control list (ACL).
 *
 * @description ## [](#)Description
 * You cannot repeatedly call the **DeleteNetworkAcl** operation within the specified period of time.
 *
 * @param request DeleteNetworkAclRequest
 * @return DeleteNetworkAclResponse
 */
DeleteNetworkAclResponse Client::deleteNetworkAcl(const DeleteNetworkAclRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteNetworkAclWithOptions(request, runtime);
}

/**
 * @summary Deletes a connection over an Express Connect circuit.
 *
 * @description You can only delete a connection over an Express Connect circuit that is in the **Allocated**, **Confirmed**, **Rejected**, **Canceled**, **AllocationFailed**, and **Terminated** states.
 *
 * @param request DeletePhysicalConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePhysicalConnectionResponse
 */
DeletePhysicalConnectionResponse Client::deletePhysicalConnectionWithOptions(const DeletePhysicalConnectionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPhysicalConnectionId()) {
    query["PhysicalConnectionId"] = request.physicalConnectionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeletePhysicalConnection"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeletePhysicalConnectionResponse>();
}

/**
 * @summary Deletes a connection over an Express Connect circuit.
 *
 * @description You can only delete a connection over an Express Connect circuit that is in the **Allocated**, **Confirmed**, **Rejected**, **Canceled**, **AllocationFailed**, and **Terminated** states.
 *
 * @param request DeletePhysicalConnectionRequest
 * @return DeletePhysicalConnectionResponse
 */
DeletePhysicalConnectionResponse Client::deletePhysicalConnection(const DeletePhysicalConnectionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deletePhysicalConnectionWithOptions(request, runtime);
}

/**
 * @summary Deletes an IP address pool.
 *
 * @description Before you call this operation, take note of the following items:
 * *   Before you delete an IP address pool, make sure that no IP address in the pool is being used.
 * *   **DeletePublicIpAddressPool** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPools](https://help.aliyun.com/document_detail/429433.html) operation to query the status of the task.
 *     *   If the IP address pool is in the **Deleting** state, the IP address pool is being deleted. In this state. you can only query the IP address pool and cannot perform other operations.
 *     *   If you cannot query the IP address pool, the IP address pool is deleted.
 * *   You cannot repeatedly call the **DeletePublicIpAddressPool** operation to delete an IP address pool within the specified period of time.
 *
 * @param request DeletePublicIpAddressPoolRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePublicIpAddressPoolResponse
 */
DeletePublicIpAddressPoolResponse Client::deletePublicIpAddressPoolWithOptions(const DeletePublicIpAddressPoolRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPublicIpAddressPoolId()) {
    query["PublicIpAddressPoolId"] = request.publicIpAddressPoolId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeletePublicIpAddressPool"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeletePublicIpAddressPoolResponse>();
}

/**
 * @summary Deletes an IP address pool.
 *
 * @description Before you call this operation, take note of the following items:
 * *   Before you delete an IP address pool, make sure that no IP address in the pool is being used.
 * *   **DeletePublicIpAddressPool** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPools](https://help.aliyun.com/document_detail/429433.html) operation to query the status of the task.
 *     *   If the IP address pool is in the **Deleting** state, the IP address pool is being deleted. In this state. you can only query the IP address pool and cannot perform other operations.
 *     *   If you cannot query the IP address pool, the IP address pool is deleted.
 * *   You cannot repeatedly call the **DeletePublicIpAddressPool** operation to delete an IP address pool within the specified period of time.
 *
 * @param request DeletePublicIpAddressPoolRequest
 * @return DeletePublicIpAddressPoolResponse
 */
DeletePublicIpAddressPoolResponse Client::deletePublicIpAddressPool(const DeletePublicIpAddressPoolRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deletePublicIpAddressPoolWithOptions(request, runtime);
}

/**
 * @summary Deletes a CIDR block from an IP address pool.
 *
 * @description Before you call this operation, take note of the following items:
 * *   Before you delete a CIDR block, make sure that it is not being used.
 * *   **DeletePublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
 *     *   If the CIDR block is in the **Deleting** state, the CIDR block is being deleted. In this state, you can only query the CIDR block and cannot perform other operations.
 *     *   If you cannot query the CIDR block, the CIDR block is deleted.
 * *   You cannot repeatedly call the **DeletePublicIpAddressPoolCidrBlock** operation to delete a CIDR block within the specified period of time.
 *
 * @param request DeletePublicIpAddressPoolCidrBlockRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePublicIpAddressPoolCidrBlockResponse
 */
DeletePublicIpAddressPoolCidrBlockResponse Client::deletePublicIpAddressPoolCidrBlockWithOptions(const DeletePublicIpAddressPoolCidrBlockRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCidrBlock()) {
    query["CidrBlock"] = request.cidrBlock();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPublicIpAddressPoolId()) {
    query["PublicIpAddressPoolId"] = request.publicIpAddressPoolId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeletePublicIpAddressPoolCidrBlock"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeletePublicIpAddressPoolCidrBlockResponse>();
}

/**
 * @summary Deletes a CIDR block from an IP address pool.
 *
 * @description Before you call this operation, take note of the following items:
 * *   Before you delete a CIDR block, make sure that it is not being used.
 * *   **DeletePublicIpAddressPoolCidrBlock** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPublicIpAddressPoolCidrBlocks](https://help.aliyun.com/document_detail/429436.html) operation to query the status of the task.
 *     *   If the CIDR block is in the **Deleting** state, the CIDR block is being deleted. In this state, you can only query the CIDR block and cannot perform other operations.
 *     *   If you cannot query the CIDR block, the CIDR block is deleted.
 * *   You cannot repeatedly call the **DeletePublicIpAddressPoolCidrBlock** operation to delete a CIDR block within the specified period of time.
 *
 * @param request DeletePublicIpAddressPoolCidrBlockRequest
 * @return DeletePublicIpAddressPoolCidrBlockResponse
 */
DeletePublicIpAddressPoolCidrBlockResponse Client::deletePublicIpAddressPoolCidrBlock(const DeletePublicIpAddressPoolCidrBlockRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deletePublicIpAddressPoolCidrBlockWithOptions(request, runtime);
}

/**
 * @summary Deletes multiple custom route entries at a time.
 *
 * @description When you call this operation, take note of the following items:
 * *   You can delete only routes that are in the **Available** state.
 * *   You cannot delete a route of a virtual private cloud (VPC) in which a vSwitch or another route is being created or deleted.
 * *   **DeleteRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
 *     *   If the route is in the **Deleting** state, the route is being deleted.
 *     *   If you cannot query the route, the route is deleted.
 * *   You cannot repeatedly call **DeleteRouteEntries** within a specific period of time.
 *
 * @param request DeleteRouteEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRouteEntriesResponse
 */
DeleteRouteEntriesResponse Client::deleteRouteEntriesWithOptions(const DeleteRouteEntriesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteEntries()) {
    query["RouteEntries"] = request.routeEntries();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteRouteEntries"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteRouteEntriesResponse>();
}

/**
 * @summary Deletes multiple custom route entries at a time.
 *
 * @description When you call this operation, take note of the following items:
 * *   You can delete only routes that are in the **Available** state.
 * *   You cannot delete a route of a virtual private cloud (VPC) in which a vSwitch or another route is being created or deleted.
 * *   **DeleteRouteEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
 *     *   If the route is in the **Deleting** state, the route is being deleted.
 *     *   If you cannot query the route, the route is deleted.
 * *   You cannot repeatedly call **DeleteRouteEntries** within a specific period of time.
 *
 * @param request DeleteRouteEntriesRequest
 * @return DeleteRouteEntriesResponse
 */
DeleteRouteEntriesResponse Client::deleteRouteEntries(const DeleteRouteEntriesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteRouteEntriesWithOptions(request, runtime);
}

/**
 * @summary Deletes a route entry from a route table of a VRouter or virtual border router (VBR).
 *
 * @description When you call this operation, take note of the following items:
 * *   You can delete only routes that are in the **Available** state.
 * *   You cannot delete a route entry of a virtual private cloud (VPC) in which a vSwitch or another route entry is being created or deleted.
 * *   Before you call this operation to delete a route of a VBR route table, call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the **NextHopId** of the route first.
 * *   **DeleteRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
 *     *   If the route is in the **Deleting** state, the route is being deleted.
 *     *   If you cannot query the route entry, the route entry is deleted.
 * *   You cannot repeatedly call the **DeleteRouteEntry** operation to delete a route from the route table of a vRouter or a VBR within the specified period of time.
 *
 * @param request DeleteRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRouteEntryResponse
 */
DeleteRouteEntryResponse Client::deleteRouteEntryWithOptions(const DeleteRouteEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDestinationCidrBlock()) {
    query["DestinationCidrBlock"] = request.destinationCidrBlock();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasNextHopId()) {
    query["NextHopId"] = request.nextHopId();
  }

  if (!!request.hasNextHopList()) {
    query["NextHopList"] = request.nextHopList();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteEntryId()) {
    query["RouteEntryId"] = request.routeEntryId();
  }

  if (!!request.hasRouteTableId()) {
    query["RouteTableId"] = request.routeTableId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteRouteEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteRouteEntryResponse>();
}

/**
 * @summary Deletes a route entry from a route table of a VRouter or virtual border router (VBR).
 *
 * @description When you call this operation, take note of the following items:
 * *   You can delete only routes that are in the **Available** state.
 * *   You cannot delete a route entry of a virtual private cloud (VPC) in which a vSwitch or another route entry is being created or deleted.
 * *   Before you call this operation to delete a route of a VBR route table, call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the **NextHopId** of the route first.
 * *   **DeleteRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteEntryList](https://help.aliyun.com/document_detail/138148.html) operation to query the status of the task.
 *     *   If the route is in the **Deleting** state, the route is being deleted.
 *     *   If you cannot query the route entry, the route entry is deleted.
 * *   You cannot repeatedly call the **DeleteRouteEntry** operation to delete a route from the route table of a vRouter or a VBR within the specified period of time.
 *
 * @param request DeleteRouteEntryRequest
 * @return DeleteRouteEntryResponse
 */
DeleteRouteEntryResponse Client::deleteRouteEntry(const DeleteRouteEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteRouteEntryWithOptions(request, runtime);
}

/**
 * @summary Deletes a custom route table.
 *
 * @description ## [](#)Description
 * *   **DeleteRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
 *     *   If the custom route table is in the **Deleting** state, the custom route table is being deleted.
 *     *   If you cannot query the custom route table, the custom route table is deleted.
 * *   You cannot repeatedly call the **DeleteRouteTable** operation to delete a custom route table within the specified period of time.
 *
 * @param request DeleteRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRouteTableResponse
 */
DeleteRouteTableResponse Client::deleteRouteTableWithOptions(const DeleteRouteTableRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteTableId()) {
    query["RouteTableId"] = request.routeTableId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteRouteTable"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteRouteTableResponse>();
}

/**
 * @summary Deletes a custom route table.
 *
 * @description ## [](#)Description
 * *   **DeleteRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeRouteTableList](https://help.aliyun.com/document_detail/87602.html) operation to query the status of the task.
 *     *   If the custom route table is in the **Deleting** state, the custom route table is being deleted.
 *     *   If you cannot query the custom route table, the custom route table is deleted.
 * *   You cannot repeatedly call the **DeleteRouteTable** operation to delete a custom route table within the specified period of time.
 *
 * @param request DeleteRouteTableRequest
 * @return DeleteRouteTableResponse
 */
DeleteRouteTableResponse Client::deleteRouteTable(const DeleteRouteTableRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteRouteTableWithOptions(request, runtime);
}

/**
 * @summary Deletes a router interface.
 *
 * @description When you call this operation, take note of the following limits:
 * *   You can delete only a router interface that is in the **Idle** or **Inactive** state.
 * *   Before you delete a router interface, you must delete all custom route entries destined for the router interface.
 *
 * @param request DeleteRouterInterfaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRouterInterfaceResponse
 */
DeleteRouterInterfaceResponse Client::deleteRouterInterfaceWithOptions(const DeleteRouterInterfaceRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouterInterfaceId()) {
    query["RouterInterfaceId"] = request.routerInterfaceId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteRouterInterface"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteRouterInterfaceResponse>();
}

/**
 * @summary Deletes a router interface.
 *
 * @description When you call this operation, take note of the following limits:
 * *   You can delete only a router interface that is in the **Idle** or **Inactive** state.
 * *   Before you delete a router interface, you must delete all custom route entries destined for the router interface.
 *
 * @param request DeleteRouterInterfaceRequest
 * @return DeleteRouterInterfaceResponse
 */
DeleteRouterInterfaceResponse Client::deleteRouterInterface(const DeleteRouterInterfaceRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteRouterInterfaceWithOptions(request, runtime);
}

/**
 * @summary Deletes an SNAT entry.
 *
 * @description DeleteSnatEntry is an asynchronous operation. After you make a request, the ID of the request is returned but the specified SNAT entry is not deleted. The system deletes the SNAT entry in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of SNAT entries.
 * *   If the SNAT entries are in the **Deleting** state, the system is deleting the SNAT entries. In this case, you can only query the status of the SNAT entries, and cannot perform other operations.
 * *   If no SNAT entry is returned in the response, the SNAT entry is deleted.
 * If some SNAT entries are in the **Pending** state, you cannot delete these SNAT entries.
 *
 * @param request DeleteSnatEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSnatEntryResponse
 */
DeleteSnatEntryResponse Client::deleteSnatEntryWithOptions(const DeleteSnatEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSnatEntryId()) {
    query["SnatEntryId"] = request.snatEntryId();
  }

  if (!!request.hasSnatTableId()) {
    query["SnatTableId"] = request.snatTableId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteSnatEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteSnatEntryResponse>();
}

/**
 * @summary Deletes an SNAT entry.
 *
 * @description DeleteSnatEntry is an asynchronous operation. After you make a request, the ID of the request is returned but the specified SNAT entry is not deleted. The system deletes the SNAT entry in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of SNAT entries.
 * *   If the SNAT entries are in the **Deleting** state, the system is deleting the SNAT entries. In this case, you can only query the status of the SNAT entries, and cannot perform other operations.
 * *   If no SNAT entry is returned in the response, the SNAT entry is deleted.
 * If some SNAT entries are in the **Pending** state, you cannot delete these SNAT entries.
 *
 * @param request DeleteSnatEntryRequest
 * @return DeleteSnatEntryResponse
 */
DeleteSnatEntryResponse Client::deleteSnatEntry(const DeleteSnatEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteSnatEntryWithOptions(request, runtime);
}

/**
 * @summary Deletes an SSL client certificate.
 *
 * @description *   If you delete an SSL client certificate, all SSL-VPN client connections to the SSL server are disconnected. You need to reinitiate connections from SSL clients.
 *     For example, SSL client certificate 1 and SSL client certificate 2 are created on an SSL server. After you delete certificate 1, all client connections associated with certificate 1 and certificate 2 are disconnected from the SSL server.
 *     *   If clients associated with certificate 1 require SSL-VPN connections, you need to install other certificates on the clients and reinitiate connections from the clients.
 *     *   If clients associated with certificate 2 require SSL-VPN connections, you can directly reinitiate connections from the clients.
 * *   **DeleteSslVpnClientCert** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the SSL client certificate is being deleted.
 *     *   If the VPN gateway is in the **active** state, the SSL client certificate is deleted.
 * *   You cannot call **DeleteSslVpnClientCert** within the specified period of time.
 *
 * @param request DeleteSslVpnClientCertRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSslVpnClientCertResponse
 */
DeleteSslVpnClientCertResponse Client::deleteSslVpnClientCertWithOptions(const DeleteSslVpnClientCertRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSslVpnClientCertId()) {
    query["SslVpnClientCertId"] = request.sslVpnClientCertId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteSslVpnClientCert"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteSslVpnClientCertResponse>();
}

/**
 * @summary Deletes an SSL client certificate.
 *
 * @description *   If you delete an SSL client certificate, all SSL-VPN client connections to the SSL server are disconnected. You need to reinitiate connections from SSL clients.
 *     For example, SSL client certificate 1 and SSL client certificate 2 are created on an SSL server. After you delete certificate 1, all client connections associated with certificate 1 and certificate 2 are disconnected from the SSL server.
 *     *   If clients associated with certificate 1 require SSL-VPN connections, you need to install other certificates on the clients and reinitiate connections from the clients.
 *     *   If clients associated with certificate 2 require SSL-VPN connections, you can directly reinitiate connections from the clients.
 * *   **DeleteSslVpnClientCert** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the SSL client certificate is being deleted.
 *     *   If the VPN gateway is in the **active** state, the SSL client certificate is deleted.
 * *   You cannot call **DeleteSslVpnClientCert** within the specified period of time.
 *
 * @param request DeleteSslVpnClientCertRequest
 * @return DeleteSslVpnClientCertResponse
 */
DeleteSslVpnClientCertResponse Client::deleteSslVpnClientCert(const DeleteSslVpnClientCertRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteSslVpnClientCertWithOptions(request, runtime);
}

/**
 * @summary Deletes an SSL server.
 *
 * @description *   **DeleteSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the SSL server is being deleted.
 *     *   If the VPN gateway is in the **active** state, the SSL server is deleted.
 * *   You cannot repeatedly call the **DeleteSslVpnServer** operation to delete an SSL server from the same VPN gateway within the specified period of time.
 *
 * @param request DeleteSslVpnServerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSslVpnServerResponse
 */
DeleteSslVpnServerResponse Client::deleteSslVpnServerWithOptions(const DeleteSslVpnServerRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSslVpnServerId()) {
    query["SslVpnServerId"] = request.sslVpnServerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteSslVpnServer"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteSslVpnServerResponse>();
}

/**
 * @summary Deletes an SSL server.
 *
 * @description *   **DeleteSslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the SSL server is being deleted.
 *     *   If the VPN gateway is in the **active** state, the SSL server is deleted.
 * *   You cannot repeatedly call the **DeleteSslVpnServer** operation to delete an SSL server from the same VPN gateway within the specified period of time.
 *
 * @param request DeleteSslVpnServerRequest
 * @return DeleteSslVpnServerResponse
 */
DeleteSslVpnServerResponse Client::deleteSslVpnServer(const DeleteSslVpnServerRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteSslVpnServerWithOptions(request, runtime);
}

/**
 * @summary Deletes a filter of traffic mirror.
 *
 * @description *   The **DeleteTrafficMirrorFilter** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of a filter:
 *     *   If the filter is in the **Deleting** state, the filter is being deleted.
 *     *   If you cannot query the filter, the filter is deleted.
 * *   You cannot repeatedly call the **DeleteTrafficMirrorFilter** operation to delete a filter within the specified period of time.
 *
 * @param request DeleteTrafficMirrorFilterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTrafficMirrorFilterResponse
 */
DeleteTrafficMirrorFilterResponse Client::deleteTrafficMirrorFilterWithOptions(const DeleteTrafficMirrorFilterRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTrafficMirrorFilterId()) {
    query["TrafficMirrorFilterId"] = request.trafficMirrorFilterId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteTrafficMirrorFilter"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteTrafficMirrorFilterResponse>();
}

/**
 * @summary Deletes a filter of traffic mirror.
 *
 * @description *   The **DeleteTrafficMirrorFilter** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of a filter:
 *     *   If the filter is in the **Deleting** state, the filter is being deleted.
 *     *   If you cannot query the filter, the filter is deleted.
 * *   You cannot repeatedly call the **DeleteTrafficMirrorFilter** operation to delete a filter within the specified period of time.
 *
 * @param request DeleteTrafficMirrorFilterRequest
 * @return DeleteTrafficMirrorFilterResponse
 */
DeleteTrafficMirrorFilterResponse Client::deleteTrafficMirrorFilter(const DeleteTrafficMirrorFilterRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteTrafficMirrorFilterWithOptions(request, runtime);
}

/**
 * @summary Deletes an inbound or outbound rule of a filter for traffic mirror.
 *
 * @description *   **DeleteTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
 *     *   If the inbound or outbound rule is in the **Deleting** state, the rule is being deleted.
 *     *   If you cannot query the rule, the rule is deleted.
 * *   You cannot repeatedly call **DeleteTrafficMirrorFilterRules** within the specified period of time.
 *
 * @param request DeleteTrafficMirrorFilterRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTrafficMirrorFilterRulesResponse
 */
DeleteTrafficMirrorFilterRulesResponse Client::deleteTrafficMirrorFilterRulesWithOptions(const DeleteTrafficMirrorFilterRulesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTrafficMirrorFilterId()) {
    query["TrafficMirrorFilterId"] = request.trafficMirrorFilterId();
  }

  if (!!request.hasTrafficMirrorFilterRuleIds()) {
    query["TrafficMirrorFilterRuleIds"] = request.trafficMirrorFilterRuleIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteTrafficMirrorFilterRules"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteTrafficMirrorFilterRulesResponse>();
}

/**
 * @summary Deletes an inbound or outbound rule of a filter for traffic mirror.
 *
 * @description *   **DeleteTrafficMirrorFilterRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) to query the status of the task.
 *     *   If the inbound or outbound rule is in the **Deleting** state, the rule is being deleted.
 *     *   If you cannot query the rule, the rule is deleted.
 * *   You cannot repeatedly call **DeleteTrafficMirrorFilterRules** within the specified period of time.
 *
 * @param request DeleteTrafficMirrorFilterRulesRequest
 * @return DeleteTrafficMirrorFilterRulesResponse
 */
DeleteTrafficMirrorFilterRulesResponse Client::deleteTrafficMirrorFilterRules(const DeleteTrafficMirrorFilterRulesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteTrafficMirrorFilterRulesWithOptions(request, runtime);
}

/**
 * @summary Deletes a traffic mirror session.
 *
 * @description *   **DeleteTrafficMirrorSession** is an asynchronous operation. After you send the request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of a traffic mirror session.
 *     *   If the traffic mirror session is in the **Deleting** state, the traffic mirror session is being deleted.
 *     *   If you cannot query the traffic mirror session, the traffic mirror session is deleted.
 * *   You cannot repeatedly call the **DeleteTrafficMirrorSession** operation to delete a traffic mirror session within the specified period of time.
 *
 * @param request DeleteTrafficMirrorSessionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTrafficMirrorSessionResponse
 */
DeleteTrafficMirrorSessionResponse Client::deleteTrafficMirrorSessionWithOptions(const DeleteTrafficMirrorSessionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTrafficMirrorSessionId()) {
    query["TrafficMirrorSessionId"] = request.trafficMirrorSessionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteTrafficMirrorSession"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteTrafficMirrorSessionResponse>();
}

/**
 * @summary Deletes a traffic mirror session.
 *
 * @description *   **DeleteTrafficMirrorSession** is an asynchronous operation. After you send the request, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of a traffic mirror session.
 *     *   If the traffic mirror session is in the **Deleting** state, the traffic mirror session is being deleted.
 *     *   If you cannot query the traffic mirror session, the traffic mirror session is deleted.
 * *   You cannot repeatedly call the **DeleteTrafficMirrorSession** operation to delete a traffic mirror session within the specified period of time.
 *
 * @param request DeleteTrafficMirrorSessionRequest
 * @return DeleteTrafficMirrorSessionResponse
 */
DeleteTrafficMirrorSessionResponse Client::deleteTrafficMirrorSession(const DeleteTrafficMirrorSessionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteTrafficMirrorSessionWithOptions(request, runtime);
}

/**
 * @summary Deletes a vSwitch.
 *
 * @description When you call this operation, take note of the following limits:
 * *   Before you delete a vSwitch, you must first release or remove all virtual private cloud (VPC) resources, including vSwitches, instances, router interfaces, and high-availability virtual IP addresses (HaVips).
 * *   You can delete only vSwitches that are in the **Available** state.
 * *   You cannot delete a vSwitch from a VPC where a vSwitch or a route is being created or deleted.
 * *   **DeleteVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
 *     *   If the vSwitch is in the **Pending** state, the vSwitch is being deleted.
 *     *   If you cannot query the vSwitch, the vSwitch is deleted.
 * *   You cannot repeatedly call the **DeleteVSwitch** operation to delete a vSwitch within the specified period of time.
 *
 * @param request DeleteVSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVSwitchResponse
 */
DeleteVSwitchResponse Client::deleteVSwitchWithOptions(const DeleteVSwitchRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVSwitchId()) {
    query["VSwitchId"] = request.vSwitchId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteVSwitch"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteVSwitchResponse>();
}

/**
 * @summary Deletes a vSwitch.
 *
 * @description When you call this operation, take note of the following limits:
 * *   Before you delete a vSwitch, you must first release or remove all virtual private cloud (VPC) resources, including vSwitches, instances, router interfaces, and high-availability virtual IP addresses (HaVips).
 * *   You can delete only vSwitches that are in the **Available** state.
 * *   You cannot delete a vSwitch from a VPC where a vSwitch or a route is being created or deleted.
 * *   **DeleteVSwitch** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
 *     *   If the vSwitch is in the **Pending** state, the vSwitch is being deleted.
 *     *   If you cannot query the vSwitch, the vSwitch is deleted.
 * *   You cannot repeatedly call the **DeleteVSwitch** operation to delete a vSwitch within the specified period of time.
 *
 * @param request DeleteVSwitchRequest
 * @return DeleteVSwitchResponse
 */
DeleteVSwitchResponse Client::deleteVSwitch(const DeleteVSwitchRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteVSwitchWithOptions(request, runtime);
}

/**
 * @summary Deletes a reserved CIDR block of a vSwitch.
 *
 * @description ## [](#)Description
 * *   Before you call this operation, make sure that the IP address allocated to an elastic network interface (ENI) from the reserved CIDR block is deleted. If the IP address of the ENI is not deleted, call [UnassignPrivateIpAddresses](https://help.aliyun.com/document_detail/85919.html) or [UnassignIpv6Addresses](https://help.aliyun.com/document_detail/98611.html) to delete the IPv4 or IPv6 address.
 * *   **DeleteVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
 *     *   If the reserved CIDR block is in the **Releasing** state, it is being released.
 *     *   If the reserved CIDR block is in the **Released** state, it is released.
 *
 * @param request DeleteVSwitchCidrReservationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVSwitchCidrReservationResponse
 */
DeleteVSwitchCidrReservationResponse Client::deleteVSwitchCidrReservationWithOptions(const DeleteVSwitchCidrReservationRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVSwitchCidrReservationId()) {
    query["VSwitchCidrReservationId"] = request.vSwitchCidrReservationId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteVSwitchCidrReservation"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteVSwitchCidrReservationResponse>();
}

/**
 * @summary Deletes a reserved CIDR block of a vSwitch.
 *
 * @description ## [](#)Description
 * *   Before you call this operation, make sure that the IP address allocated to an elastic network interface (ENI) from the reserved CIDR block is deleted. If the IP address of the ENI is not deleted, call [UnassignPrivateIpAddresses](https://help.aliyun.com/document_detail/85919.html) or [UnassignIpv6Addresses](https://help.aliyun.com/document_detail/98611.html) to delete the IPv4 or IPv6 address.
 * *   **DeleteVSwitchCidrReservation** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListVSwitchCidrReservations](https://help.aliyun.com/document_detail/610155.html) to query the status of the task:
 *     *   If the reserved CIDR block is in the **Releasing** state, it is being released.
 *     *   If the reserved CIDR block is in the **Released** state, it is released.
 *
 * @param request DeleteVSwitchCidrReservationRequest
 * @return DeleteVSwitchCidrReservationResponse
 */
DeleteVSwitchCidrReservationResponse Client::deleteVSwitchCidrReservation(const DeleteVSwitchCidrReservationRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteVSwitchCidrReservationWithOptions(request, runtime);
}

/**
 * @summary Deletes a virtual border router (VBR) failover group.
 *
 * @param request DeleteVbrHaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVbrHaResponse
 */
DeleteVbrHaResponse Client::deleteVbrHaWithOptions(const DeleteVbrHaRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteVbrHa"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteVbrHaResponse>();
}

/**
 * @summary Deletes a virtual border router (VBR) failover group.
 *
 * @param request DeleteVbrHaRequest
 * @return DeleteVbrHaResponse
 */
DeleteVbrHaResponse Client::deleteVbrHa(const DeleteVbrHaRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteVbrHaWithOptions(request, runtime);
}

/**
 * @summary Deletes a destination-based route from an IPsec-VPN connection.
 *
 * @description *   **DeleteVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
 *     *   If the IPsec-VPN connection is in the **updating** state, the route is being deleted.
 *     *   If the IPsec-VPN connection is in the **attached** state, the route is deleted.
 * *   You cannot repeatedly call the **DeleteVcoRouteEntry** operation within a specific time period.
 *
 * @param request DeleteVcoRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVcoRouteEntryResponse
 */
DeleteVcoRouteEntryResponse Client::deleteVcoRouteEntryWithOptions(const DeleteVcoRouteEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasNextHop()) {
    query["NextHop"] = request.nextHop();
  }

  if (!!request.hasOverlayMode()) {
    query["OverlayMode"] = request.overlayMode();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteDest()) {
    query["RouteDest"] = request.routeDest();
  }

  if (!!request.hasVpnConnectionId()) {
    query["VpnConnectionId"] = request.vpnConnectionId();
  }

  if (!!request.hasWeight()) {
    query["Weight"] = request.weight();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteVcoRouteEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteVcoRouteEntryResponse>();
}

/**
 * @summary Deletes a destination-based route from an IPsec-VPN connection.
 *
 * @description *   **DeleteVcoRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task.
 *     *   If the IPsec-VPN connection is in the **updating** state, the route is being deleted.
 *     *   If the IPsec-VPN connection is in the **attached** state, the route is deleted.
 * *   You cannot repeatedly call the **DeleteVcoRouteEntry** operation within a specific time period.
 *
 * @param request DeleteVcoRouteEntryRequest
 * @return DeleteVcoRouteEntryResponse
 */
DeleteVcoRouteEntryResponse Client::deleteVcoRouteEntry(const DeleteVcoRouteEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteVcoRouteEntryWithOptions(request, runtime);
}

/**
 * @summary Deletes a virtual border router (VBR).
 *
 * @description Before you call this operation, take note of the following limits:
 * *   Before you delete a VBR, you must delete all router interfaces of the VBR.
 * *   You can delete only a VBR in the **unconfirmed**, **active**, or **terminated** state.
 * *   The owner of an Express Connect circuit can delete a VBR that belongs to another account only if the VBR is in the **unconfirmed** state.
 *
 * @param request DeleteVirtualBorderRouterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVirtualBorderRouterResponse
 */
DeleteVirtualBorderRouterResponse Client::deleteVirtualBorderRouterWithOptions(const DeleteVirtualBorderRouterRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVbrId()) {
    query["VbrId"] = request.vbrId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteVirtualBorderRouter"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteVirtualBorderRouterResponse>();
}

/**
 * @summary Deletes a virtual border router (VBR).
 *
 * @description Before you call this operation, take note of the following limits:
 * *   Before you delete a VBR, you must delete all router interfaces of the VBR.
 * *   You can delete only a VBR in the **unconfirmed**, **active**, or **terminated** state.
 * *   The owner of an Express Connect circuit can delete a VBR that belongs to another account only if the VBR is in the **unconfirmed** state.
 *
 * @param request DeleteVirtualBorderRouterRequest
 * @return DeleteVirtualBorderRouterResponse
 */
DeleteVirtualBorderRouterResponse Client::deleteVirtualBorderRouter(const DeleteVirtualBorderRouterRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteVirtualBorderRouterWithOptions(request, runtime);
}

/**
 * @summary Deletes a virtual private cloud (VPC).
 *
 * @description When you call this operation, take note of the following limits:
 * *   Before you delete a VPC, make sure that all resources deployed in the VPC are released or removed, such as vSwitches, instances, and high-availability virtual IP addresses (HaVips).
 * *   You can delete only a VPC that is in the **Available** state.
 * *   The **DeleteVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a VPC:
 *     *   If the VPC is in the **Deleting** state, the VPC is being deleted.
 *     *   If you cannot query the VPC, the VPC is deleted.
 * *   You cannot repeatedly call the **DeleteVpc** operation to delete a VPC within the specified period of time.
 *
 * @param request DeleteVpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVpcResponse
 */
DeleteVpcResponse Client::deleteVpcWithOptions(const DeleteVpcRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasForceDelete()) {
    query["ForceDelete"] = request.forceDelete();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteVpc"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteVpcResponse>();
}

/**
 * @summary Deletes a virtual private cloud (VPC).
 *
 * @description When you call this operation, take note of the following limits:
 * *   Before you delete a VPC, make sure that all resources deployed in the VPC are released or removed, such as vSwitches, instances, and high-availability virtual IP addresses (HaVips).
 * *   You can delete only a VPC that is in the **Available** state.
 * *   The **DeleteVpc** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a VPC:
 *     *   If the VPC is in the **Deleting** state, the VPC is being deleted.
 *     *   If you cannot query the VPC, the VPC is deleted.
 * *   You cannot repeatedly call the **DeleteVpc** operation to delete a VPC within the specified period of time.
 *
 * @param request DeleteVpcRequest
 * @return DeleteVpcResponse
 */
DeleteVpcResponse Client::deleteVpc(const DeleteVpcRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteVpcWithOptions(request, runtime);
}

/**
 * @summary Deletes a gateway endpoint.
 *
 * @param request DeleteVpcGatewayEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVpcGatewayEndpointResponse
 */
DeleteVpcGatewayEndpointResponse Client::deleteVpcGatewayEndpointWithOptions(const DeleteVpcGatewayEndpointRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEndpointId()) {
    query["EndpointId"] = request.endpointId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteVpcGatewayEndpoint"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteVpcGatewayEndpointResponse>();
}

/**
 * @summary Deletes a gateway endpoint.
 *
 * @param request DeleteVpcGatewayEndpointRequest
 * @return DeleteVpcGatewayEndpointResponse
 */
DeleteVpcGatewayEndpointResponse Client::deleteVpcGatewayEndpoint(const DeleteVpcGatewayEndpointRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteVpcGatewayEndpointWithOptions(request, runtime);
}

/**
 * @summary Deletes a prefix list.
 *
 * @description You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a prefix list within the specified period of time.
 *
 * @param request DeleteVpcPrefixListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVpcPrefixListResponse
 */
DeleteVpcPrefixListResponse Client::deleteVpcPrefixListWithOptions(const DeleteVpcPrefixListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPrefixListId()) {
    query["PrefixListId"] = request.prefixListId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteVpcPrefixList"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteVpcPrefixListResponse>();
}

/**
 * @summary Deletes a prefix list.
 *
 * @description You cannot repeatedly call the **DeleteDhcpOptionsSet** operation to delete a prefix list within the specified period of time.
 *
 * @param request DeleteVpcPrefixListRequest
 * @return DeleteVpcPrefixListResponse
 */
DeleteVpcPrefixListResponse Client::deleteVpcPrefixList(const DeleteVpcPrefixListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteVpcPrefixListWithOptions(request, runtime);
}

/**
 * @summary Deletes an IPsec-VPN connection.
 *
 * @description *   If an IPsec-VPN connection is associated with a transit router, you must disassociate the transit router from the IPsec-VPN connection before you delete the IPsec-VPN connection. For more information, see [DeleteTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468251.html).
 * *   If an IPsec-VPN connection is not associated with a resource, you can call `DeleteVpnAttachment` to directly delete the IPsec-VPN connection.
 *
 * @param request DeleteVpnAttachmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVpnAttachmentResponse
 */
DeleteVpnAttachmentResponse Client::deleteVpnAttachmentWithOptions(const DeleteVpnAttachmentRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpnConnectionId()) {
    query["VpnConnectionId"] = request.vpnConnectionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteVpnAttachment"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteVpnAttachmentResponse>();
}

/**
 * @summary Deletes an IPsec-VPN connection.
 *
 * @description *   If an IPsec-VPN connection is associated with a transit router, you must disassociate the transit router from the IPsec-VPN connection before you delete the IPsec-VPN connection. For more information, see [DeleteTransitRouterVpnAttachment](https://help.aliyun.com/document_detail/468251.html).
 * *   If an IPsec-VPN connection is not associated with a resource, you can call `DeleteVpnAttachment` to directly delete the IPsec-VPN connection.
 *
 * @param request DeleteVpnAttachmentRequest
 * @return DeleteVpnAttachmentResponse
 */
DeleteVpnAttachmentResponse Client::deleteVpnAttachment(const DeleteVpnAttachmentRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteVpnAttachmentWithOptions(request, runtime);
}

/**
 * @summary Deletes an IPsec-VPN connection.
 *
 * @description *   **DeleteVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
 *     *   If a VPN gateway is in the **updating** state, the IPsec-VPN connection is being deleted.
 *     *   If a VPN gateway is in the **active** state, the IPsec-VPN connection has been deleted.
 * *   You cannot call the **DeleteVpnConnection** operation to delete multiple IPsec-VPN connections for a VPN gateway at a time.
 * >  After an IPsec-VPN connection between a data center and Alibaba Cloud is deleted, the connection between the data center and Alibaba Cloud is closed.
 *
 * @param request DeleteVpnConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVpnConnectionResponse
 */
DeleteVpnConnectionResponse Client::deleteVpnConnectionWithOptions(const DeleteVpnConnectionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpnConnectionId()) {
    query["VpnConnectionId"] = request.vpnConnectionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteVpnConnection"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteVpnConnectionResponse>();
}

/**
 * @summary Deletes an IPsec-VPN connection.
 *
 * @description *   **DeleteVpnConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
 *     *   If a VPN gateway is in the **updating** state, the IPsec-VPN connection is being deleted.
 *     *   If a VPN gateway is in the **active** state, the IPsec-VPN connection has been deleted.
 * *   You cannot call the **DeleteVpnConnection** operation to delete multiple IPsec-VPN connections for a VPN gateway at a time.
 * >  After an IPsec-VPN connection between a data center and Alibaba Cloud is deleted, the connection between the data center and Alibaba Cloud is closed.
 *
 * @param request DeleteVpnConnectionRequest
 * @return DeleteVpnConnectionResponse
 */
DeleteVpnConnectionResponse Client::deleteVpnConnection(const DeleteVpnConnectionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteVpnConnectionWithOptions(request, runtime);
}

/**
 * @summary Deletes a VPN gateway.
 *
 * @description >  You cannot delete a VPN gateway associated with existing IPsec-VPN connections.
 *
 * @param request DeleteVpnGatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVpnGatewayResponse
 */
DeleteVpnGatewayResponse Client::deleteVpnGatewayWithOptions(const DeleteVpnGatewayRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteVpnGateway"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteVpnGatewayResponse>();
}

/**
 * @summary Deletes a VPN gateway.
 *
 * @description >  You cannot delete a VPN gateway associated with existing IPsec-VPN connections.
 *
 * @param request DeleteVpnGatewayRequest
 * @return DeleteVpnGatewayResponse
 */
DeleteVpnGatewayResponse Client::deleteVpnGateway(const DeleteVpnGatewayRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteVpnGatewayWithOptions(request, runtime);
}

/**
 * @summary Deletes a policy-based route from a VPN gateway.
 *
 * @description *   **DeleteVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
 *     *   If a VPN gateway is in the **updating** state, the policy-based route is being deleted.
 *     *   If a VPN gateway is in the **active** state, the policy-based route has been deleted.
 * *   You cannot repeatedly call **DeleteVpnPbrRouteEntry** to delete a policy-based route within the specified period of time.
 *
 * @param request DeleteVpnPbrRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVpnPbrRouteEntryResponse
 */
DeleteVpnPbrRouteEntryResponse Client::deleteVpnPbrRouteEntryWithOptions(const DeleteVpnPbrRouteEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasNextHop()) {
    query["NextHop"] = request.nextHop();
  }

  if (!!request.hasOverlayMode()) {
    query["OverlayMode"] = request.overlayMode();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPriority()) {
    query["Priority"] = request.priority();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteDest()) {
    query["RouteDest"] = request.routeDest();
  }

  if (!!request.hasRouteSource()) {
    query["RouteSource"] = request.routeSource();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  if (!!request.hasWeight()) {
    query["Weight"] = request.weight();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteVpnPbrRouteEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteVpnPbrRouteEntryResponse>();
}

/**
 * @summary Deletes a policy-based route from a VPN gateway.
 *
 * @description *   **DeleteVpnPbrRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
 *     *   If a VPN gateway is in the **updating** state, the policy-based route is being deleted.
 *     *   If a VPN gateway is in the **active** state, the policy-based route has been deleted.
 * *   You cannot repeatedly call **DeleteVpnPbrRouteEntry** to delete a policy-based route within the specified period of time.
 *
 * @param request DeleteVpnPbrRouteEntryRequest
 * @return DeleteVpnPbrRouteEntryResponse
 */
DeleteVpnPbrRouteEntryResponse Client::deleteVpnPbrRouteEntry(const DeleteVpnPbrRouteEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteVpnPbrRouteEntryWithOptions(request, runtime);
}

/**
 * @summary Deletes a destination-based route from a VPN gateway.
 *
 * @description *   **DeleteVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
 *     *   If a VPN gateway is in the **updating** state, the destination-based route is being deleted.
 *     *   If the VPN gateway is in the **active** state, the destination-based route is deleted.
 * *   You cannot repeatedly call **DeleteVpnRouteEntry** to delete a destination-based route from a VPN gateway within the specified period of time.
 *
 * @param request DeleteVpnRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVpnRouteEntryResponse
 */
DeleteVpnRouteEntryResponse Client::deleteVpnRouteEntryWithOptions(const DeleteVpnRouteEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasNextHop()) {
    query["NextHop"] = request.nextHop();
  }

  if (!!request.hasOverlayMode()) {
    query["OverlayMode"] = request.overlayMode();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteDest()) {
    query["RouteDest"] = request.routeDest();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  if (!!request.hasWeight()) {
    query["Weight"] = request.weight();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteVpnRouteEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteVpnRouteEntryResponse>();
}

/**
 * @summary Deletes a destination-based route from a VPN gateway.
 *
 * @description *   **DeleteVpnRouteEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
 *     *   If a VPN gateway is in the **updating** state, the destination-based route is being deleted.
 *     *   If the VPN gateway is in the **active** state, the destination-based route is deleted.
 * *   You cannot repeatedly call **DeleteVpnRouteEntry** to delete a destination-based route from a VPN gateway within the specified period of time.
 *
 * @param request DeleteVpnRouteEntryRequest
 * @return DeleteVpnRouteEntryResponse
 */
DeleteVpnRouteEntryResponse Client::deleteVpnRouteEntry(const DeleteVpnRouteEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteVpnRouteEntryWithOptions(request, runtime);
}

/**
 * @summary 设置实例删除保护功能。
 *
 * @description After you enable deletion protection for an instance, you cannot delete the instance. You must disable deletion protection before you can delete the instance.
 *
 * @param request DeletionProtectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletionProtectionResponse
 */
DeletionProtectionResponse Client::deletionProtectionWithOptions(const DeletionProtectionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasProtectionEnable()) {
    query["ProtectionEnable"] = request.protectionEnable();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeletionProtection"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeletionProtectionResponse>();
}

/**
 * @summary 设置实例删除保护功能。
 *
 * @description After you enable deletion protection for an instance, you cannot delete the instance. You must disable deletion protection before you can delete the instance.
 *
 * @param request DeletionProtectionRequest
 * @return DeletionProtectionResponse
 */
DeletionProtectionResponse Client::deletionProtection(const DeletionProtectionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deletionProtectionWithOptions(request, runtime);
}

/**
 * @summary Queries traffic data of a pay-by-enhanced-95th-percentile Internet Shared Bandwidth instance.
 *
 * @param request Describe95TrafficRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return Describe95TrafficResponse
 */
Describe95TrafficResponse Client::describe95TrafficWithOptions(const Describe95TrafficRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDay()) {
    query["Day"] = request.day();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasResourceType()) {
    query["ResourceType"] = request.resourceType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "Describe95Traffic"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<Describe95TrafficResponse>();
}

/**
 * @summary Queries traffic data of a pay-by-enhanced-95th-percentile Internet Shared Bandwidth instance.
 *
 * @param request Describe95TrafficRequest
 * @return Describe95TrafficResponse
 */
Describe95TrafficResponse Client::describe95Traffic(const Describe95TrafficRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describe95TrafficWithOptions(request, runtime);
}

/**
 * @summary Queries the access points of Express Connect circuits in a region.
 *
 * @param request DescribeAccessPointsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAccessPointsResponse
 */
DescribeAccessPointsResponse Client::describeAccessPointsWithOptions(const DescribeAccessPointsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAcceptLanguage()) {
    query["AcceptLanguage"] = request.acceptLanguage();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeAccessPoints"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAccessPointsResponse>();
}

/**
 * @summary Queries the access points of Express Connect circuits in a region.
 *
 * @param request DescribeAccessPointsRequest
 * @return DescribeAccessPointsResponse
 */
DescribeAccessPointsResponse Client::describeAccessPoints(const DescribeAccessPointsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAccessPointsWithOptions(request, runtime);
}

/**
 * @summary Queries Border Gateway Protocol (BGP) groups in a region.
 *
 * @param request DescribeBgpGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBgpGroupsResponse
 */
DescribeBgpGroupsResponse Client::describeBgpGroupsWithOptions(const DescribeBgpGroupsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBgpGroupId()) {
    query["BgpGroupId"] = request.bgpGroupId();
  }

  if (!!request.hasIsDefault()) {
    query["IsDefault"] = request.isDefault();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouterId()) {
    query["RouterId"] = request.routerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeBgpGroups"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeBgpGroupsResponse>();
}

/**
 * @summary Queries Border Gateway Protocol (BGP) groups in a region.
 *
 * @param request DescribeBgpGroupsRequest
 * @return DescribeBgpGroupsResponse
 */
DescribeBgpGroupsResponse Client::describeBgpGroups(const DescribeBgpGroupsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeBgpGroupsWithOptions(request, runtime);
}

/**
 * @summary Queries advertised Border Gateway Protocol (BGP) networks.
 *
 * @param request DescribeBgpNetworksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBgpNetworksResponse
 */
DescribeBgpNetworksResponse Client::describeBgpNetworksWithOptions(const DescribeBgpNetworksRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouterId()) {
    query["RouterId"] = request.routerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeBgpNetworks"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeBgpNetworksResponse>();
}

/**
 * @summary Queries advertised Border Gateway Protocol (BGP) networks.
 *
 * @param request DescribeBgpNetworksRequest
 * @return DescribeBgpNetworksResponse
 */
DescribeBgpNetworksResponse Client::describeBgpNetworks(const DescribeBgpNetworksRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeBgpNetworksWithOptions(request, runtime);
}

/**
 * @summary Queries Border Gateway Protocol (BGP) peers in a region.
 *
 * @param request DescribeBgpPeersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBgpPeersResponse
 */
DescribeBgpPeersResponse Client::describeBgpPeersWithOptions(const DescribeBgpPeersRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBgpGroupId()) {
    query["BgpGroupId"] = request.bgpGroupId();
  }

  if (!!request.hasBgpPeerId()) {
    query["BgpPeerId"] = request.bgpPeerId();
  }

  if (!!request.hasIsDefault()) {
    query["IsDefault"] = request.isDefault();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouterId()) {
    query["RouterId"] = request.routerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeBgpPeers"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeBgpPeersResponse>();
}

/**
 * @summary Queries Border Gateway Protocol (BGP) peers in a region.
 *
 * @param request DescribeBgpPeersRequest
 * @return DescribeBgpPeersResponse
 */
DescribeBgpPeersResponse Client::describeBgpPeers(const DescribeBgpPeersRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeBgpPeersWithOptions(request, runtime);
}

/**
 * @summary Queries a list of Internet Shared Bandwidth instances in a region.
 *
 * @param request DescribeCommonBandwidthPackagesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCommonBandwidthPackagesResponse
 */
DescribeCommonBandwidthPackagesResponse Client::describeCommonBandwidthPackagesWithOptions(const DescribeCommonBandwidthPackagesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidthPackageId()) {
    query["BandwidthPackageId"] = request.bandwidthPackageId();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIncludeReservationData()) {
    query["IncludeReservationData"] = request.includeReservationData();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSecurityProtectionEnabled()) {
    query["SecurityProtectionEnabled"] = request.securityProtectionEnabled();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCommonBandwidthPackages"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCommonBandwidthPackagesResponse>();
}

/**
 * @summary Queries a list of Internet Shared Bandwidth instances in a region.
 *
 * @param request DescribeCommonBandwidthPackagesRequest
 * @return DescribeCommonBandwidthPackagesResponse
 */
DescribeCommonBandwidthPackagesResponse Client::describeCommonBandwidthPackages(const DescribeCommonBandwidthPackagesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCommonBandwidthPackagesWithOptions(request, runtime);
}

/**
 * @summary Queries details of a customer gateway.
 *
 * @param request DescribeCustomerGatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCustomerGatewayResponse
 */
DescribeCustomerGatewayResponse Client::describeCustomerGatewayWithOptions(const DescribeCustomerGatewayRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCustomerGatewayId()) {
    query["CustomerGatewayId"] = request.customerGatewayId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCustomerGateway"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCustomerGatewayResponse>();
}

/**
 * @summary Queries details of a customer gateway.
 *
 * @param request DescribeCustomerGatewayRequest
 * @return DescribeCustomerGatewayResponse
 */
DescribeCustomerGatewayResponse Client::describeCustomerGateway(const DescribeCustomerGatewayRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCustomerGatewayWithOptions(request, runtime);
}

/**
 * @summary Queries customer gateways.
 *
 * @param request DescribeCustomerGatewaysRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCustomerGatewaysResponse
 */
DescribeCustomerGatewaysResponse Client::describeCustomerGatewaysWithOptions(const DescribeCustomerGatewaysRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCustomerGatewayId()) {
    query["CustomerGatewayId"] = request.customerGatewayId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCustomerGateways"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCustomerGatewaysResponse>();
}

/**
 * @summary Queries customer gateways.
 *
 * @param request DescribeCustomerGatewaysRequest
 * @return DescribeCustomerGatewaysResponse
 */
DescribeCustomerGatewaysResponse Client::describeCustomerGateways(const DescribeCustomerGatewaysRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCustomerGatewaysWithOptions(request, runtime);
}

/**
 * @summary Queries whether permissions on a virtual private cloud (VPC) are granted to a virtual border router (VBR).
 *
 * @param request DescribeEcGrantRelationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEcGrantRelationResponse
 */
DescribeEcGrantRelationResponse Client::describeEcGrantRelationWithOptions(const DescribeEcGrantRelationRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasInstanceType()) {
    query["InstanceType"] = request.instanceType();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasVbrRegionNo()) {
    query["VbrRegionNo"] = request.vbrRegionNo();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeEcGrantRelation"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeEcGrantRelationResponse>();
}

/**
 * @summary Queries whether permissions on a virtual private cloud (VPC) are granted to a virtual border router (VBR).
 *
 * @param request DescribeEcGrantRelationRequest
 * @return DescribeEcGrantRelationResponse
 */
DescribeEcGrantRelationResponse Client::describeEcGrantRelation(const DescribeEcGrantRelationRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeEcGrantRelationWithOptions(request, runtime);
}

/**
 * @summary Queries elastic IP addresses (EIPs) created in a region.
 *
 * @description You can call this operation to query information about EIPs in a region, including maximum bandwidth, billing methods, and associated instances.
 *
 * @param request DescribeEipAddressesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEipAddressesResponse
 */
DescribeEipAddressesResponse Client::describeEipAddressesWithOptions(const DescribeEipAddressesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAllocationId()) {
    query["AllocationId"] = request.allocationId();
  }

  if (!!request.hasAssociatedInstanceId()) {
    query["AssociatedInstanceId"] = request.associatedInstanceId();
  }

  if (!!request.hasAssociatedInstanceType()) {
    query["AssociatedInstanceType"] = request.associatedInstanceType();
  }

  if (!!request.hasChargeType()) {
    query["ChargeType"] = request.chargeType();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEipAddress()) {
    query["EipAddress"] = request.eipAddress();
  }

  if (!!request.hasEipName()) {
    query["EipName"] = request.eipName();
  }

  if (!!request.hasISP()) {
    query["ISP"] = request.ISP();
  }

  if (!!request.hasIncludeReservationData()) {
    query["IncludeReservationData"] = request.includeReservationData();
  }

  if (!!request.hasLockReason()) {
    query["LockReason"] = request.lockReason();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPublicIpAddressPoolId()) {
    query["PublicIpAddressPoolId"] = request.publicIpAddressPoolId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSecurityProtectionEnabled()) {
    query["SecurityProtectionEnabled"] = request.securityProtectionEnabled();
  }

  if (!!request.hasSegmentInstanceId()) {
    query["SegmentInstanceId"] = request.segmentInstanceId();
  }

  if (!!request.hasServiceManaged()) {
    query["ServiceManaged"] = request.serviceManaged();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasFilter()) {
    query["Filter"] = request.filter();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeEipAddresses"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeEipAddressesResponse>();
}

/**
 * @summary Queries elastic IP addresses (EIPs) created in a region.
 *
 * @description You can call this operation to query information about EIPs in a region, including maximum bandwidth, billing methods, and associated instances.
 *
 * @param request DescribeEipAddressesRequest
 * @return DescribeEipAddressesResponse
 */
DescribeEipAddressesResponse Client::describeEipAddresses(const DescribeEipAddressesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeEipAddressesWithOptions(request, runtime);
}

/**
 * @summary Queries the gateway and subnet mask of an elastic IP address (EIP).
 *
 * @description You can query only EIPs that are associated with secondary elastic network interfaces (ENIs) in multi-EIP-to-ENI mode.
 *
 * @param request DescribeEipGatewayInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEipGatewayInfoResponse
 */
DescribeEipGatewayInfoResponse Client::describeEipGatewayInfoWithOptions(const DescribeEipGatewayInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeEipGatewayInfo"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeEipGatewayInfoResponse>();
}

/**
 * @summary Queries the gateway and subnet mask of an elastic IP address (EIP).
 *
 * @description You can query only EIPs that are associated with secondary elastic network interfaces (ENIs) in multi-EIP-to-ENI mode.
 *
 * @param request DescribeEipGatewayInfoRequest
 * @return DescribeEipGatewayInfoResponse
 */
DescribeEipGatewayInfoResponse Client::describeEipGatewayInfo(const DescribeEipGatewayInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeEipGatewayInfoWithOptions(request, runtime);
}

/**
 * @summary Queries the monitoring data of an elastic IP address (EIP). You can query monitoring data within the last 30 days, and obtain up to 400 data points in each request.
 *
 * @description To improve user experience in querying monitoring data, we recommend that you call the DescribeMetricList API operation provided by CloudMonitor to query EIP monitoring data. For more information, see [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html) and [EIP monitoring data](https://help.aliyun.com/document_detail/162874.html).
 *
 * @param request DescribeEipMonitorDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEipMonitorDataResponse
 */
DescribeEipMonitorDataResponse Client::describeEipMonitorDataWithOptions(const DescribeEipMonitorDataRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAllocationId()) {
    query["AllocationId"] = request.allocationId();
  }

  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPeriod()) {
    query["Period"] = request.period();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeEipMonitorData"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeEipMonitorDataResponse>();
}

/**
 * @summary Queries the monitoring data of an elastic IP address (EIP). You can query monitoring data within the last 30 days, and obtain up to 400 data points in each request.
 *
 * @description To improve user experience in querying monitoring data, we recommend that you call the DescribeMetricList API operation provided by CloudMonitor to query EIP monitoring data. For more information, see [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html) and [EIP monitoring data](https://help.aliyun.com/document_detail/162874.html).
 *
 * @param request DescribeEipMonitorDataRequest
 * @return DescribeEipMonitorDataResponse
 */
DescribeEipMonitorDataResponse Client::describeEipMonitorData(const DescribeEipMonitorDataRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeEipMonitorDataWithOptions(request, runtime);
}

/**
 * @summary Queries contiguous elastic IP address (EIP) groups.
 *
 * @param request DescribeEipSegmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEipSegmentResponse
 */
DescribeEipSegmentResponse Client::describeEipSegmentWithOptions(const DescribeEipSegmentRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSegmentInstanceId()) {
    query["SegmentInstanceId"] = request.segmentInstanceId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeEipSegment"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeEipSegmentResponse>();
}

/**
 * @summary Queries contiguous elastic IP address (EIP) groups.
 *
 * @param request DescribeEipSegmentRequest
 * @return DescribeEipSegmentResponse
 */
DescribeEipSegmentResponse Client::describeEipSegment(const DescribeEipSegmentRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeEipSegmentWithOptions(request, runtime);
}

/**
 * @summary Queries the quality of service (QoS) policies of Express Connect. The response can be displayed by page.
 *
 * @param request DescribeExpressConnectTrafficQosRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExpressConnectTrafficQosResponse
 */
DescribeExpressConnectTrafficQosResponse Client::describeExpressConnectTrafficQosWithOptions(const DescribeExpressConnectTrafficQosRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasQosIdList()) {
    query["QosIdList"] = request.qosIdList();
  }

  if (!!request.hasQosNameList()) {
    query["QosNameList"] = request.qosNameList();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeExpressConnectTrafficQos"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeExpressConnectTrafficQosResponse>();
}

/**
 * @summary Queries the quality of service (QoS) policies of Express Connect. The response can be displayed by page.
 *
 * @param request DescribeExpressConnectTrafficQosRequest
 * @return DescribeExpressConnectTrafficQosResponse
 */
DescribeExpressConnectTrafficQosResponse Client::describeExpressConnectTrafficQos(const DescribeExpressConnectTrafficQosRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeExpressConnectTrafficQosWithOptions(request, runtime);
}

/**
 * @summary Queries the information about the quality of service (QoS) queues of the Express Connect circuit.
 *
 * @param request DescribeExpressConnectTrafficQosQueueRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExpressConnectTrafficQosQueueResponse
 */
DescribeExpressConnectTrafficQosQueueResponse Client::describeExpressConnectTrafficQosQueueWithOptions(const DescribeExpressConnectTrafficQosQueueRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasQosId()) {
    query["QosId"] = request.qosId();
  }

  if (!!request.hasQueueIdList()) {
    query["QueueIdList"] = request.queueIdList();
  }

  if (!!request.hasQueueNameList()) {
    query["QueueNameList"] = request.queueNameList();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeExpressConnectTrafficQosQueue"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeExpressConnectTrafficQosQueueResponse>();
}

/**
 * @summary Queries the information about the quality of service (QoS) queues of the Express Connect circuit.
 *
 * @param request DescribeExpressConnectTrafficQosQueueRequest
 * @return DescribeExpressConnectTrafficQosQueueResponse
 */
DescribeExpressConnectTrafficQosQueueResponse Client::describeExpressConnectTrafficQosQueue(const DescribeExpressConnectTrafficQosQueueRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeExpressConnectTrafficQosQueueWithOptions(request, runtime);
}

/**
 * @summary Queries quality of service (QoS) rules. Paging parameters are not supported.
 *
 * @param request DescribeExpressConnectTrafficQosRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExpressConnectTrafficQosRuleResponse
 */
DescribeExpressConnectTrafficQosRuleResponse Client::describeExpressConnectTrafficQosRuleWithOptions(const DescribeExpressConnectTrafficQosRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasQosId()) {
    query["QosId"] = request.qosId();
  }

  if (!!request.hasQueueId()) {
    query["QueueId"] = request.queueId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasRuleIdList()) {
    query["RuleIdList"] = request.ruleIdList();
  }

  if (!!request.hasRuleNameList()) {
    query["RuleNameList"] = request.ruleNameList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeExpressConnectTrafficQosRule"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeExpressConnectTrafficQosRuleResponse>();
}

/**
 * @summary Queries quality of service (QoS) rules. Paging parameters are not supported.
 *
 * @param request DescribeExpressConnectTrafficQosRuleRequest
 * @return DescribeExpressConnectTrafficQosRuleResponse
 */
DescribeExpressConnectTrafficQosRuleResponse Client::describeExpressConnectTrafficQosRule(const DescribeExpressConnectTrafficQosRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeExpressConnectTrafficQosRuleWithOptions(request, runtime);
}

/**
 * @summary Queries failover tests.
 *
 * @param request DescribeFailoverTestJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFailoverTestJobResponse
 */
DescribeFailoverTestJobResponse Client::describeFailoverTestJobWithOptions(const DescribeFailoverTestJobRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasJobId()) {
    query["JobId"] = request.jobId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeFailoverTestJob"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeFailoverTestJobResponse>();
}

/**
 * @summary Queries failover tests.
 *
 * @param request DescribeFailoverTestJobRequest
 * @return DescribeFailoverTestJobResponse
 */
DescribeFailoverTestJobResponse Client::describeFailoverTestJob(const DescribeFailoverTestJobRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeFailoverTestJobWithOptions(request, runtime);
}

/**
 * @summary Queries failover tests for Express Connect.
 *
 * @param request DescribeFailoverTestJobsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFailoverTestJobsResponse
 */
DescribeFailoverTestJobsResponse Client::describeFailoverTestJobsWithOptions(const DescribeFailoverTestJobsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasFilter()) {
    query["Filter"] = request.filter();
  }

  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeFailoverTestJobs"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeFailoverTestJobsResponse>();
}

/**
 * @summary Queries failover tests for Express Connect.
 *
 * @param request DescribeFailoverTestJobsRequest
 * @return DescribeFailoverTestJobsResponse
 */
DescribeFailoverTestJobsResponse Client::describeFailoverTestJobs(const DescribeFailoverTestJobsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeFailoverTestJobsWithOptions(request, runtime);
}

/**
 * @summary Query flow logs.
 *
 * @param request DescribeFlowLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFlowLogsResponse
 */
DescribeFlowLogsResponse Client::describeFlowLogsWithOptions(const DescribeFlowLogsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasFlowLogId()) {
    query["FlowLogId"] = request.flowLogId();
  }

  if (!!request.hasFlowLogName()) {
    query["FlowLogName"] = request.flowLogName();
  }

  if (!!request.hasLogStoreName()) {
    query["LogStoreName"] = request.logStoreName();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasProjectName()) {
    query["ProjectName"] = request.projectName();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceId()) {
    query["ResourceId"] = request.resourceId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasResourceType()) {
    query["ResourceType"] = request.resourceType();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  if (!!request.hasTrafficType()) {
    query["TrafficType"] = request.trafficType();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeFlowLogs"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeFlowLogsResponse>();
}

/**
 * @summary Query flow logs.
 *
 * @param request DescribeFlowLogsRequest
 * @return DescribeFlowLogsResponse
 */
DescribeFlowLogsResponse Client::describeFlowLogs(const DescribeFlowLogsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeFlowLogsWithOptions(request, runtime);
}

/**
 * @summary Queries DNAT entries.
 *
 * @param request DescribeForwardTableEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeForwardTableEntriesResponse
 */
DescribeForwardTableEntriesResponse Client::describeForwardTableEntriesWithOptions(const DescribeForwardTableEntriesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasExternalIp()) {
    query["ExternalIp"] = request.externalIp();
  }

  if (!!request.hasExternalPort()) {
    query["ExternalPort"] = request.externalPort();
  }

  if (!!request.hasForwardEntryId()) {
    query["ForwardEntryId"] = request.forwardEntryId();
  }

  if (!!request.hasForwardEntryName()) {
    query["ForwardEntryName"] = request.forwardEntryName();
  }

  if (!!request.hasForwardTableId()) {
    query["ForwardTableId"] = request.forwardTableId();
  }

  if (!!request.hasInternalIp()) {
    query["InternalIp"] = request.internalIp();
  }

  if (!!request.hasInternalPort()) {
    query["InternalPort"] = request.internalPort();
  }

  if (!!request.hasIpProtocol()) {
    query["IpProtocol"] = request.ipProtocol();
  }

  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeForwardTableEntries"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeForwardTableEntriesResponse>();
}

/**
 * @summary Queries DNAT entries.
 *
 * @param request DescribeForwardTableEntriesRequest
 * @return DescribeForwardTableEntriesResponse
 */
DescribeForwardTableEntriesResponse Client::describeForwardTableEntries(const DescribeForwardTableEntriesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeForwardTableEntriesWithOptions(request, runtime);
}

/**
 * @summary Queries Global Accelerator (GA) instances.
 *
 * @param request DescribeGlobalAccelerationInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGlobalAccelerationInstancesResponse
 */
DescribeGlobalAccelerationInstancesResponse Client::describeGlobalAccelerationInstancesWithOptions(const DescribeGlobalAccelerationInstancesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidthType()) {
    query["BandwidthType"] = request.bandwidthType();
  }

  if (!!request.hasGlobalAccelerationInstanceId()) {
    query["GlobalAccelerationInstanceId"] = request.globalAccelerationInstanceId();
  }

  if (!!request.hasIncludeReservationData()) {
    query["IncludeReservationData"] = request.includeReservationData();
  }

  if (!!request.hasIpAddress()) {
    query["IpAddress"] = request.ipAddress();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasServerId()) {
    query["ServerId"] = request.serverId();
  }

  if (!!request.hasServiceLocation()) {
    query["ServiceLocation"] = request.serviceLocation();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeGlobalAccelerationInstances"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeGlobalAccelerationInstancesResponse>();
}

/**
 * @summary Queries Global Accelerator (GA) instances.
 *
 * @param request DescribeGlobalAccelerationInstancesRequest
 * @return DescribeGlobalAccelerationInstancesResponse
 */
DescribeGlobalAccelerationInstancesResponse Client::describeGlobalAccelerationInstances(const DescribeGlobalAccelerationInstancesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeGlobalAccelerationInstancesWithOptions(request, runtime);
}

/**
 * @summary 查询指定网络实例（VPC、VBR）的云企业网跨账号授权信息
 *
 * @param request DescribeGrantRulesToCenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGrantRulesToCenResponse
 */
DescribeGrantRulesToCenResponse Client::describeGrantRulesToCenWithOptions(const DescribeGrantRulesToCenRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasInstanceType()) {
    query["InstanceType"] = request.instanceType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeGrantRulesToCen"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeGrantRulesToCenResponse>();
}

/**
 * @summary 查询指定网络实例（VPC、VBR）的云企业网跨账号授权信息
 *
 * @param request DescribeGrantRulesToCenRequest
 * @return DescribeGrantRulesToCenResponse
 */
DescribeGrantRulesToCenResponse Client::describeGrantRulesToCen(const DescribeGrantRulesToCenRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeGrantRulesToCenWithOptions(request, runtime);
}

/**
 * @summary Queries HaVips in a region.
 *
 * @param request DescribeHaVipsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHaVipsResponse
 */
DescribeHaVipsResponse Client::describeHaVipsWithOptions(const DescribeHaVipsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFilter()) {
    query["Filter"] = request.filter();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeHaVips"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeHaVipsResponse>();
}

/**
 * @summary Queries HaVips in a region.
 *
 * @param request DescribeHaVipsRequest
 * @return DescribeHaVipsResponse
 */
DescribeHaVipsResponse Client::describeHaVips(const DescribeHaVipsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeHaVipsWithOptions(request, runtime);
}

/**
 * @summary Queries configurations about the fine-grained monitoring feature of an elastic IP address (EIP).
 *
 * @param request DescribeHighDefinitionMonitorLogAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHighDefinitionMonitorLogAttributeResponse
 */
DescribeHighDefinitionMonitorLogAttributeResponse Client::describeHighDefinitionMonitorLogAttributeWithOptions(const DescribeHighDefinitionMonitorLogAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasInstanceType()) {
    query["InstanceType"] = request.instanceType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeHighDefinitionMonitorLogAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeHighDefinitionMonitorLogAttributeResponse>();
}

/**
 * @summary Queries configurations about the fine-grained monitoring feature of an elastic IP address (EIP).
 *
 * @param request DescribeHighDefinitionMonitorLogAttributeRequest
 * @return DescribeHighDefinitionMonitorLogAttributeResponse
 */
DescribeHighDefinitionMonitorLogAttributeResponse Client::describeHighDefinitionMonitorLogAttribute(const DescribeHighDefinitionMonitorLogAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeHighDefinitionMonitorLogAttributeWithOptions(request, runtime);
}

/**
 * @summary Queries the details of an access control list (ACL), including the specified IP addresses and associated IPv6 mapping entries.
 *
 * @param request DescribeIPv6TranslatorAclListAttributesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIPv6TranslatorAclListAttributesResponse
 */
DescribeIPv6TranslatorAclListAttributesResponse Client::describeIPv6TranslatorAclListAttributesWithOptions(const DescribeIPv6TranslatorAclListAttributesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAclId()) {
    query["AclId"] = request.aclId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeIPv6TranslatorAclListAttributes"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeIPv6TranslatorAclListAttributesResponse>();
}

/**
 * @summary Queries the details of an access control list (ACL), including the specified IP addresses and associated IPv6 mapping entries.
 *
 * @param request DescribeIPv6TranslatorAclListAttributesRequest
 * @return DescribeIPv6TranslatorAclListAttributesResponse
 */
DescribeIPv6TranslatorAclListAttributesResponse Client::describeIPv6TranslatorAclListAttributes(const DescribeIPv6TranslatorAclListAttributesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeIPv6TranslatorAclListAttributesWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI DescribeIPv6TranslatorAclLists is deprecated
 *
 * @summary Queries access control lists (ACLs).
 *
 * @param request DescribeIPv6TranslatorAclListsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIPv6TranslatorAclListsResponse
 */
DescribeIPv6TranslatorAclListsResponse Client::describeIPv6TranslatorAclListsWithOptions(const DescribeIPv6TranslatorAclListsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAclId()) {
    query["AclId"] = request.aclId();
  }

  if (!!request.hasAclName()) {
    query["AclName"] = request.aclName();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeIPv6TranslatorAclLists"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeIPv6TranslatorAclListsResponse>();
}

/**
 * @deprecated OpenAPI DescribeIPv6TranslatorAclLists is deprecated
 *
 * @summary Queries access control lists (ACLs).
 *
 * @param request DescribeIPv6TranslatorAclListsRequest
 * @return DescribeIPv6TranslatorAclListsResponse
 */
DescribeIPv6TranslatorAclListsResponse Client::describeIPv6TranslatorAclLists(const DescribeIPv6TranslatorAclListsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeIPv6TranslatorAclListsWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI DescribeIPv6TranslatorEntries is deprecated
 *
 * @summary Queries IPv6 mapping entries.
 *
 * @param request DescribeIPv6TranslatorEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIPv6TranslatorEntriesResponse
 */
DescribeIPv6TranslatorEntriesResponse Client::describeIPv6TranslatorEntriesWithOptions(const DescribeIPv6TranslatorEntriesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAclId()) {
    query["AclId"] = request.aclId();
  }

  if (!!request.hasAclStatus()) {
    query["AclStatus"] = request.aclStatus();
  }

  if (!!request.hasAclType()) {
    query["AclType"] = request.aclType();
  }

  if (!!request.hasAllocateIpv6Addr()) {
    query["AllocateIpv6Addr"] = request.allocateIpv6Addr();
  }

  if (!!request.hasAllocateIpv6Port()) {
    query["AllocateIpv6Port"] = request.allocateIpv6Port();
  }

  if (!!request.hasBackendIpv4Addr()) {
    query["BackendIpv4Addr"] = request.backendIpv4Addr();
  }

  if (!!request.hasBackendIpv4Port()) {
    query["BackendIpv4Port"] = request.backendIpv4Port();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasEntryName()) {
    query["EntryName"] = request.entryName();
  }

  if (!!request.hasIpv6TranslatorEntryId()) {
    query["Ipv6TranslatorEntryId"] = request.ipv6TranslatorEntryId();
  }

  if (!!request.hasIpv6TranslatorId()) {
    query["Ipv6TranslatorId"] = request.ipv6TranslatorId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTransProtocol()) {
    query["TransProtocol"] = request.transProtocol();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeIPv6TranslatorEntries"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeIPv6TranslatorEntriesResponse>();
}

/**
 * @deprecated OpenAPI DescribeIPv6TranslatorEntries is deprecated
 *
 * @summary Queries IPv6 mapping entries.
 *
 * @param request DescribeIPv6TranslatorEntriesRequest
 * @return DescribeIPv6TranslatorEntriesResponse
 */
DescribeIPv6TranslatorEntriesResponse Client::describeIPv6TranslatorEntries(const DescribeIPv6TranslatorEntriesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeIPv6TranslatorEntriesWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI DescribeIPv6Translators is deprecated
 *
 * @summary Queries IPv6 Translation Service instances.
 *
 * @param request DescribeIPv6TranslatorsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIPv6TranslatorsResponse
 */
DescribeIPv6TranslatorsResponse Client::describeIPv6TranslatorsWithOptions(const DescribeIPv6TranslatorsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAllocateIpv4Addr()) {
    query["AllocateIpv4Addr"] = request.allocateIpv4Addr();
  }

  if (!!request.hasAllocateIpv6Addr()) {
    query["AllocateIpv6Addr"] = request.allocateIpv6Addr();
  }

  if (!!request.hasBusinessStatus()) {
    query["BusinessStatus"] = request.businessStatus();
  }

  if (!!request.hasIpv6TranslatorId()) {
    query["Ipv6TranslatorId"] = request.ipv6TranslatorId();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPayType()) {
    query["PayType"] = request.payType();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSpec()) {
    query["Spec"] = request.spec();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeIPv6Translators"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeIPv6TranslatorsResponse>();
}

/**
 * @deprecated OpenAPI DescribeIPv6Translators is deprecated
 *
 * @summary Queries IPv6 Translation Service instances.
 *
 * @param request DescribeIPv6TranslatorsRequest
 * @return DescribeIPv6TranslatorsResponse
 */
DescribeIPv6TranslatorsResponse Client::describeIPv6Translators(const DescribeIPv6TranslatorsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeIPv6TranslatorsWithOptions(request, runtime);
}

/**
 * @summary Queries IPv6 addresses in a region.
 *
 * @param request DescribeIpv6AddressesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIpv6AddressesResponse
 */
DescribeIpv6AddressesResponse Client::describeIpv6AddressesWithOptions(const DescribeIpv6AddressesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAddressType()) {
    query["AddressType"] = request.addressType();
  }

  if (!!request.hasAssociatedInstanceId()) {
    query["AssociatedInstanceId"] = request.associatedInstanceId();
  }

  if (!!request.hasAssociatedInstanceType()) {
    query["AssociatedInstanceType"] = request.associatedInstanceType();
  }

  if (!!request.hasIncludeReservationData()) {
    query["IncludeReservationData"] = request.includeReservationData();
  }

  if (!!request.hasIpv6Address()) {
    query["Ipv6Address"] = request.ipv6Address();
  }

  if (!!request.hasIpv6AddressId()) {
    query["Ipv6AddressId"] = request.ipv6AddressId();
  }

  if (!!request.hasIpv6InternetBandwidthId()) {
    query["Ipv6InternetBandwidthId"] = request.ipv6InternetBandwidthId();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasNetworkType()) {
    query["NetworkType"] = request.networkType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasServiceManaged()) {
    query["ServiceManaged"] = request.serviceManaged();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasVSwitchId()) {
    query["VSwitchId"] = request.vSwitchId();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeIpv6Addresses"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeIpv6AddressesResponse>();
}

/**
 * @summary Queries IPv6 addresses in a region.
 *
 * @param request DescribeIpv6AddressesRequest
 * @return DescribeIpv6AddressesResponse
 */
DescribeIpv6AddressesResponse Client::describeIpv6Addresses(const DescribeIpv6AddressesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeIpv6AddressesWithOptions(request, runtime);
}

/**
 * @summary Queries egress-only rules.
 *
 * @param request DescribeIpv6EgressOnlyRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIpv6EgressOnlyRulesResponse
 */
DescribeIpv6EgressOnlyRulesResponse Client::describeIpv6EgressOnlyRulesWithOptions(const DescribeIpv6EgressOnlyRulesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasInstanceType()) {
    query["InstanceType"] = request.instanceType();
  }

  if (!!request.hasIpv6EgressOnlyRuleId()) {
    query["Ipv6EgressOnlyRuleId"] = request.ipv6EgressOnlyRuleId();
  }

  if (!!request.hasIpv6GatewayId()) {
    query["Ipv6GatewayId"] = request.ipv6GatewayId();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeIpv6EgressOnlyRules"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeIpv6EgressOnlyRulesResponse>();
}

/**
 * @summary Queries egress-only rules.
 *
 * @param request DescribeIpv6EgressOnlyRulesRequest
 * @return DescribeIpv6EgressOnlyRulesResponse
 */
DescribeIpv6EgressOnlyRulesResponse Client::describeIpv6EgressOnlyRules(const DescribeIpv6EgressOnlyRulesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeIpv6EgressOnlyRulesWithOptions(request, runtime);
}

/**
 * @summary Queries the information about an IPv6 gateway, including the region, virtual private cloud (VPC), status, and billing method.
 *
 * @param request DescribeIpv6GatewayAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIpv6GatewayAttributeResponse
 */
DescribeIpv6GatewayAttributeResponse Client::describeIpv6GatewayAttributeWithOptions(const DescribeIpv6GatewayAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIpv6GatewayId()) {
    query["Ipv6GatewayId"] = request.ipv6GatewayId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeIpv6GatewayAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeIpv6GatewayAttributeResponse>();
}

/**
 * @summary Queries the information about an IPv6 gateway, including the region, virtual private cloud (VPC), status, and billing method.
 *
 * @param request DescribeIpv6GatewayAttributeRequest
 * @return DescribeIpv6GatewayAttributeResponse
 */
DescribeIpv6GatewayAttributeResponse Client::describeIpv6GatewayAttribute(const DescribeIpv6GatewayAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeIpv6GatewayAttributeWithOptions(request, runtime);
}

/**
 * @summary Queries IPv6 gateways in a region.
 *
 * @param request DescribeIpv6GatewaysRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIpv6GatewaysResponse
 */
DescribeIpv6GatewaysResponse Client::describeIpv6GatewaysWithOptions(const DescribeIpv6GatewaysRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIpv6GatewayId()) {
    query["Ipv6GatewayId"] = request.ipv6GatewayId();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeIpv6Gateways"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeIpv6GatewaysResponse>();
}

/**
 * @summary Queries IPv6 gateways in a region.
 *
 * @param request DescribeIpv6GatewaysRequest
 * @return DescribeIpv6GatewaysResponse
 */
DescribeIpv6GatewaysResponse Client::describeIpv6Gateways(const DescribeIpv6GatewaysRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeIpv6GatewaysWithOptions(request, runtime);
}

/**
 * @summary 查询NAT已绑定ENI信息
 *
 * @param request DescribeNatGatewayAssociateNetworkInterfacesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNatGatewayAssociateNetworkInterfacesResponse
 */
DescribeNatGatewayAssociateNetworkInterfacesResponse Client::describeNatGatewayAssociateNetworkInterfacesWithOptions(const DescribeNatGatewayAssociateNetworkInterfacesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasFilter()) {
    query["Filter"] = request.filter();
  }

  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeNatGatewayAssociateNetworkInterfaces"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeNatGatewayAssociateNetworkInterfacesResponse>();
}

/**
 * @summary 查询NAT已绑定ENI信息
 *
 * @param request DescribeNatGatewayAssociateNetworkInterfacesRequest
 * @return DescribeNatGatewayAssociateNetworkInterfacesResponse
 */
DescribeNatGatewayAssociateNetworkInterfacesResponse Client::describeNatGatewayAssociateNetworkInterfaces(const DescribeNatGatewayAssociateNetworkInterfacesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeNatGatewayAssociateNetworkInterfacesWithOptions(request, runtime);
}

/**
 * @summary Queries NAT gateways that meet specific conditions in a specified region.
 *
 * @description You can call this operation to query both Virtual Private Cloud (VPC) NAT gateways and Internet NAT gateways. NAT gateways in this topic refer to both VPC NAT gateways and Internet NAT gateways.
 *
 * @param request DescribeNatGatewaysRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNatGatewaysResponse
 */
DescribeNatGatewaysResponse Client::describeNatGatewaysWithOptions(const DescribeNatGatewaysRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasInstanceChargeType()) {
    query["InstanceChargeType"] = request.instanceChargeType();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasNatType()) {
    query["NatType"] = request.natType();
  }

  if (!!request.hasNetworkType()) {
    query["NetworkType"] = request.networkType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSpec()) {
    query["Spec"] = request.spec();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  if (!!request.hasZoneId()) {
    query["ZoneId"] = request.zoneId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeNatGateways"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeNatGatewaysResponse>();
}

/**
 * @summary Queries NAT gateways that meet specific conditions in a specified region.
 *
 * @description You can call this operation to query both Virtual Private Cloud (VPC) NAT gateways and Internet NAT gateways. NAT gateways in this topic refer to both VPC NAT gateways and Internet NAT gateways.
 *
 * @param request DescribeNatGatewaysRequest
 * @return DescribeNatGatewaysResponse
 */
DescribeNatGatewaysResponse Client::describeNatGateways(const DescribeNatGatewaysRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeNatGatewaysWithOptions(request, runtime);
}

/**
 * @summary Queries network access control lists (ACLs).
 *
 * @param request DescribeNetworkAclAttributesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNetworkAclAttributesResponse
 */
DescribeNetworkAclAttributesResponse Client::describeNetworkAclAttributesWithOptions(const DescribeNetworkAclAttributesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasNetworkAclId()) {
    query["NetworkAclId"] = request.networkAclId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeNetworkAclAttributes"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeNetworkAclAttributesResponse>();
}

/**
 * @summary Queries network access control lists (ACLs).
 *
 * @param request DescribeNetworkAclAttributesRequest
 * @return DescribeNetworkAclAttributesResponse
 */
DescribeNetworkAclAttributesResponse Client::describeNetworkAclAttributes(const DescribeNetworkAclAttributesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeNetworkAclAttributesWithOptions(request, runtime);
}

/**
 * @summary Queries network ACLs.
 *
 * @param request DescribeNetworkAclsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNetworkAclsResponse
 */
DescribeNetworkAclsResponse Client::describeNetworkAclsWithOptions(const DescribeNetworkAclsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasNetworkAclId()) {
    query["NetworkAclId"] = request.networkAclId();
  }

  if (!!request.hasNetworkAclName()) {
    query["NetworkAclName"] = request.networkAclName();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceId()) {
    query["ResourceId"] = request.resourceId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasResourceType()) {
    query["ResourceType"] = request.resourceType();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeNetworkAcls"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeNetworkAclsResponse>();
}

/**
 * @summary Queries network ACLs.
 *
 * @param request DescribeNetworkAclsRequest
 * @return DescribeNetworkAclsResponse
 */
DescribeNetworkAclsResponse Client::describeNetworkAcls(const DescribeNetworkAclsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeNetworkAclsWithOptions(request, runtime);
}

/**
 * @summary 查询物理专线LOA信息
 *
 * @param request DescribePhysicalConnectionLOARequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePhysicalConnectionLOAResponse
 */
DescribePhysicalConnectionLOAResponse Client::describePhysicalConnectionLOAWithOptions(const DescribePhysicalConnectionLOARequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePhysicalConnectionLOA"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePhysicalConnectionLOAResponse>();
}

/**
 * @summary 查询物理专线LOA信息
 *
 * @param request DescribePhysicalConnectionLOARequest
 * @return DescribePhysicalConnectionLOAResponse
 */
DescribePhysicalConnectionLOAResponse Client::describePhysicalConnectionLOA(const DescribePhysicalConnectionLOARequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePhysicalConnectionLOAWithOptions(request, runtime);
}

/**
 * @summary Queries Express Connect circuits in a region.
 *
 * @description By default, the system queries information about all Express Connect circuits in the specified region. You can query Express Connect circuits that meet specific conditions by specifying filter conditions provided by the **DescribePhysicalConnections** operation. For more information about the supported filter conditions, see **Key** in the **Request parameters** section.
 *
 * @param request DescribePhysicalConnectionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePhysicalConnectionsResponse
 */
DescribePhysicalConnectionsResponse Client::describePhysicalConnectionsWithOptions(const DescribePhysicalConnectionsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasFilter()) {
    query["Filter"] = request.filter();
  }

  if (!!request.hasIncludeReservationData()) {
    query["IncludeReservationData"] = request.includeReservationData();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePhysicalConnections"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePhysicalConnectionsResponse>();
}

/**
 * @summary Queries Express Connect circuits in a region.
 *
 * @description By default, the system queries information about all Express Connect circuits in the specified region. You can query Express Connect circuits that meet specific conditions by specifying filter conditions provided by the **DescribePhysicalConnections** operation. For more information about the supported filter conditions, see **Key** in the **Request parameters** section.
 *
 * @param request DescribePhysicalConnectionsRequest
 * @return DescribePhysicalConnectionsResponse
 */
DescribePhysicalConnectionsResponse Client::describePhysicalConnections(const DescribePhysicalConnectionsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePhysicalConnectionsWithOptions(request, runtime);
}

/**
 * @summary Queries the public IP address range of a virtual private cloud (VPC) in a region.
 *
 * @description You cannot query the range of public IP addresses of a classic network by calling the **DescribePublicIpAddress** operation.
 *
 * @param request DescribePublicIpAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePublicIpAddressResponse
 */
DescribePublicIpAddressResponse Client::describePublicIpAddressWithOptions(const DescribePublicIpAddressRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIpVersion()) {
    query["IpVersion"] = request.ipVersion();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePublicIpAddress"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePublicIpAddressResponse>();
}

/**
 * @summary Queries the public IP address range of a virtual private cloud (VPC) in a region.
 *
 * @description You cannot query the range of public IP addresses of a classic network by calling the **DescribePublicIpAddress** operation.
 *
 * @param request DescribePublicIpAddressRequest
 * @return DescribePublicIpAddressResponse
 */
DescribePublicIpAddressResponse Client::describePublicIpAddress(const DescribePublicIpAddressRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePublicIpAddressWithOptions(request, runtime);
}

/**
 * @summary Queries the most recent region list.
 *
 * @param request DescribeRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
DescribeRegionsResponse Client::describeRegionsWithOptions(const DescribeRegionsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAcceptLanguage()) {
    query["AcceptLanguage"] = request.acceptLanguage();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasProductType()) {
    query["ProductType"] = request.productType();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeRegions"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeRegionsResponse>();
}

/**
 * @summary Queries the most recent region list.
 *
 * @param request DescribeRegionsRequest
 * @return DescribeRegionsResponse
 */
DescribeRegionsResponse Client::describeRegions(const DescribeRegionsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeRegionsWithOptions(request, runtime);
}

/**
 * @summary Queries information about route entries in a route table.
 *
 * @description Before you call the [DeleteRouteEntry](https://help.aliyun.com/document_detail/36013.html) operation to delete a route, you can call this operation to query the next hop of the route that you want to delete.
 *
 * @param request DescribeRouteEntryListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRouteEntryListResponse
 */
DescribeRouteEntryListResponse Client::describeRouteEntryListWithOptions(const DescribeRouteEntryListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDestCidrBlockList()) {
    query["DestCidrBlockList"] = request.destCidrBlockList();
  }

  if (!!request.hasDestinationCidrBlock()) {
    query["DestinationCidrBlock"] = request.destinationCidrBlock();
  }

  if (!!request.hasIpVersion()) {
    query["IpVersion"] = request.ipVersion();
  }

  if (!!request.hasMaxResult()) {
    query["MaxResult"] = request.maxResult();
  }

  if (!!request.hasNextHopId()) {
    query["NextHopId"] = request.nextHopId();
  }

  if (!!request.hasNextHopType()) {
    query["NextHopType"] = request.nextHopType();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteEntryId()) {
    query["RouteEntryId"] = request.routeEntryId();
  }

  if (!!request.hasRouteEntryName()) {
    query["RouteEntryName"] = request.routeEntryName();
  }

  if (!!request.hasRouteEntryType()) {
    query["RouteEntryType"] = request.routeEntryType();
  }

  if (!!request.hasRouteTableId()) {
    query["RouteTableId"] = request.routeTableId();
  }

  if (!!request.hasServiceType()) {
    query["ServiceType"] = request.serviceType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeRouteEntryList"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeRouteEntryListResponse>();
}

/**
 * @summary Queries information about route entries in a route table.
 *
 * @description Before you call the [DeleteRouteEntry](https://help.aliyun.com/document_detail/36013.html) operation to delete a route, you can call this operation to query the next hop of the route that you want to delete.
 *
 * @param request DescribeRouteEntryListRequest
 * @return DescribeRouteEntryListResponse
 */
DescribeRouteEntryListResponse Client::describeRouteEntryList(const DescribeRouteEntryListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeRouteEntryListWithOptions(request, runtime);
}

/**
 * @summary Queries route tables.
 *
 * @param request DescribeRouteTableListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRouteTableListResponse
 */
DescribeRouteTableListResponse Client::describeRouteTableListWithOptions(const DescribeRouteTableListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteTableId()) {
    query["RouteTableId"] = request.routeTableId();
  }

  if (!!request.hasRouteTableName()) {
    query["RouteTableName"] = request.routeTableName();
  }

  if (!!request.hasRouteTableType()) {
    query["RouteTableType"] = request.routeTableType();
  }

  if (!!request.hasRouterId()) {
    query["RouterId"] = request.routerId();
  }

  if (!!request.hasRouterType()) {
    query["RouterType"] = request.routerType();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeRouteTableList"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeRouteTableListResponse>();
}

/**
 * @summary Queries route tables.
 *
 * @param request DescribeRouteTableListRequest
 * @return DescribeRouteTableListResponse
 */
DescribeRouteTableListResponse Client::describeRouteTableList(const DescribeRouteTableListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeRouteTableListWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI DescribeRouteTables is deprecated, please use Vpc::2016-04-28::DescribeRouteTableList instead.
 *
 * @summary Queries route tables.
 *
 * @param request DescribeRouteTablesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRouteTablesResponse
 */
DescribeRouteTablesResponse Client::describeRouteTablesWithOptions(const DescribeRouteTablesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteTableId()) {
    query["RouteTableId"] = request.routeTableId();
  }

  if (!!request.hasRouteTableName()) {
    query["RouteTableName"] = request.routeTableName();
  }

  if (!!request.hasRouterId()) {
    query["RouterId"] = request.routerId();
  }

  if (!!request.hasRouterType()) {
    query["RouterType"] = request.routerType();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasVRouterId()) {
    query["VRouterId"] = request.VRouterId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeRouteTables"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeRouteTablesResponse>();
}

/**
 * @deprecated OpenAPI DescribeRouteTables is deprecated, please use Vpc::2016-04-28::DescribeRouteTableList instead.
 *
 * @summary Queries route tables.
 *
 * @param request DescribeRouteTablesRequest
 * @return DescribeRouteTablesResponse
 */
DescribeRouteTablesResponse Client::describeRouteTables(const DescribeRouteTablesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeRouteTablesWithOptions(request, runtime);
}

/**
 * @summary Queries the configuration of a router interface.
 *
 * @param request DescribeRouterInterfaceAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRouterInterfaceAttributeResponse
 */
DescribeRouterInterfaceAttributeResponse Client::describeRouterInterfaceAttributeWithOptions(const DescribeRouterInterfaceAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeRouterInterfaceAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeRouterInterfaceAttributeResponse>();
}

/**
 * @summary Queries the configuration of a router interface.
 *
 * @param request DescribeRouterInterfaceAttributeRequest
 * @return DescribeRouterInterfaceAttributeResponse
 */
DescribeRouterInterfaceAttributeResponse Client::describeRouterInterfaceAttribute(const DescribeRouterInterfaceAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeRouterInterfaceAttributeWithOptions(request, runtime);
}

/**
 * @summary Queries router interfaces in a specified region.
 *
 * @param request DescribeRouterInterfacesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRouterInterfacesResponse
 */
DescribeRouterInterfacesResponse Client::describeRouterInterfacesWithOptions(const DescribeRouterInterfacesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFilter()) {
    query["Filter"] = request.filter();
  }

  if (!!request.hasIncludeReservationData()) {
    query["IncludeReservationData"] = request.includeReservationData();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeRouterInterfaces"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeRouterInterfacesResponse>();
}

/**
 * @summary Queries router interfaces in a specified region.
 *
 * @param request DescribeRouterInterfacesRequest
 * @return DescribeRouterInterfacesResponse
 */
DescribeRouterInterfacesResponse Client::describeRouterInterfaces(const DescribeRouterInterfacesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeRouterInterfacesWithOptions(request, runtime);
}

/**
 * @summary Queries Global Accelerator (GA) instances that are associated with a backend server.
 *
 * @description > You can call this operation to query only dedicated-bandwidth GA instances.
 *
 * @param request DescribeServerRelatedGlobalAccelerationInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeServerRelatedGlobalAccelerationInstancesResponse
 */
DescribeServerRelatedGlobalAccelerationInstancesResponse Client::describeServerRelatedGlobalAccelerationInstancesWithOptions(const DescribeServerRelatedGlobalAccelerationInstancesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasServerId()) {
    query["ServerId"] = request.serverId();
  }

  if (!!request.hasServerType()) {
    query["ServerType"] = request.serverType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeServerRelatedGlobalAccelerationInstances"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeServerRelatedGlobalAccelerationInstancesResponse>();
}

/**
 * @summary Queries Global Accelerator (GA) instances that are associated with a backend server.
 *
 * @description > You can call this operation to query only dedicated-bandwidth GA instances.
 *
 * @param request DescribeServerRelatedGlobalAccelerationInstancesRequest
 * @return DescribeServerRelatedGlobalAccelerationInstancesResponse
 */
DescribeServerRelatedGlobalAccelerationInstancesResponse Client::describeServerRelatedGlobalAccelerationInstances(const DescribeServerRelatedGlobalAccelerationInstancesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeServerRelatedGlobalAccelerationInstancesWithOptions(request, runtime);
}

/**
 * @summary Queries SNAT entries.
 *
 * @param request DescribeSnatTableEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSnatTableEntriesResponse
 */
DescribeSnatTableEntriesResponse Client::describeSnatTableEntriesWithOptions(const DescribeSnatTableEntriesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasNetworkInterfaceIds()) {
    query["NetworkInterfaceIds"] = request.networkInterfaceIds();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSnatEntryId()) {
    query["SnatEntryId"] = request.snatEntryId();
  }

  if (!!request.hasSnatEntryName()) {
    query["SnatEntryName"] = request.snatEntryName();
  }

  if (!!request.hasSnatIp()) {
    query["SnatIp"] = request.snatIp();
  }

  if (!!request.hasSnatTableId()) {
    query["SnatTableId"] = request.snatTableId();
  }

  if (!!request.hasSourceCIDR()) {
    query["SourceCIDR"] = request.sourceCIDR();
  }

  if (!!request.hasSourceVSwitchId()) {
    query["SourceVSwitchId"] = request.sourceVSwitchId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSnatTableEntries"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSnatTableEntriesResponse>();
}

/**
 * @summary Queries SNAT entries.
 *
 * @param request DescribeSnatTableEntriesRequest
 * @return DescribeSnatTableEntriesResponse
 */
DescribeSnatTableEntriesResponse Client::describeSnatTableEntries(const DescribeSnatTableEntriesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSnatTableEntriesWithOptions(request, runtime);
}

/**
 * @summary Queries the details of an SSL client certificate.
 *
 * @param request DescribeSslVpnClientCertRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSslVpnClientCertResponse
 */
DescribeSslVpnClientCertResponse Client::describeSslVpnClientCertWithOptions(const DescribeSslVpnClientCertRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSslVpnClientCertId()) {
    query["SslVpnClientCertId"] = request.sslVpnClientCertId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSslVpnClientCert"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSslVpnClientCertResponse>();
}

/**
 * @summary Queries the details of an SSL client certificate.
 *
 * @param request DescribeSslVpnClientCertRequest
 * @return DescribeSslVpnClientCertResponse
 */
DescribeSslVpnClientCertResponse Client::describeSslVpnClientCert(const DescribeSslVpnClientCertRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSslVpnClientCertWithOptions(request, runtime);
}

/**
 * @summary Queries SSL client certificates.
 *
 * @param request DescribeSslVpnClientCertsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSslVpnClientCertsResponse
 */
DescribeSslVpnClientCertsResponse Client::describeSslVpnClientCertsWithOptions(const DescribeSslVpnClientCertsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSslVpnClientCertId()) {
    query["SslVpnClientCertId"] = request.sslVpnClientCertId();
  }

  if (!!request.hasSslVpnServerId()) {
    query["SslVpnServerId"] = request.sslVpnServerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSslVpnClientCerts"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSslVpnClientCertsResponse>();
}

/**
 * @summary Queries SSL client certificates.
 *
 * @param request DescribeSslVpnClientCertsRequest
 * @return DescribeSslVpnClientCertsResponse
 */
DescribeSslVpnClientCertsResponse Client::describeSslVpnClientCerts(const DescribeSslVpnClientCertsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSslVpnClientCertsWithOptions(request, runtime);
}

/**
 * @summary Queries the clients that have connected to a VPN gateway through SSL-VPN connections.
 *
 * @description If your VPN gateway was created before December 10, 2022, you need to upgrade the VPN gateway to the latest version to view the connection information about SSL clients. For more information, see [Upgrade a VPN gateway](https://help.aliyun.com/document_detail/2671058.html).
 * If your VPN gateway was created after December 10, 2022, you can view the connection information about SSL clients by default.
 *
 * @param request DescribeSslVpnClientsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSslVpnClientsResponse
 */
DescribeSslVpnClientsResponse Client::describeSslVpnClientsWithOptions(const DescribeSslVpnClientsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSslVpnClients"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSslVpnClientsResponse>();
}

/**
 * @summary Queries the clients that have connected to a VPN gateway through SSL-VPN connections.
 *
 * @description If your VPN gateway was created before December 10, 2022, you need to upgrade the VPN gateway to the latest version to view the connection information about SSL clients. For more information, see [Upgrade a VPN gateway](https://help.aliyun.com/document_detail/2671058.html).
 * If your VPN gateway was created after December 10, 2022, you can view the connection information about SSL clients by default.
 *
 * @param request DescribeSslVpnClientsRequest
 * @return DescribeSslVpnClientsResponse
 */
DescribeSslVpnClientsResponse Client::describeSslVpnClients(const DescribeSslVpnClientsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSslVpnClientsWithOptions(request, runtime);
}

/**
 * @summary Queries one or more SSL-VPN servers.
 *
 * @param request DescribeSslVpnServersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSslVpnServersResponse
 */
DescribeSslVpnServersResponse Client::describeSslVpnServersWithOptions(const DescribeSslVpnServersRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSslVpnServerId()) {
    query["SslVpnServerId"] = request.sslVpnServerId();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSslVpnServers"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSslVpnServersResponse>();
}

/**
 * @summary Queries one or more SSL-VPN servers.
 *
 * @param request DescribeSslVpnServersRequest
 * @return DescribeSslVpnServersResponse
 */
DescribeSslVpnServersResponse Client::describeSslVpnServers(const DescribeSslVpnServersRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSslVpnServersWithOptions(request, runtime);
}

/**
 * @summary Queries tag keys.
 *
 * @param request DescribeTagKeysRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTagKeysResponse
 */
DescribeTagKeysResponse Client::describeTagKeysWithOptions(const DescribeTagKeysRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasKeyword()) {
    query["Keyword"] = request.keyword();
  }

  if (!!request.hasMaxResult()) {
    query["MaxResult"] = request.maxResult();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceId()) {
    query["ResourceId"] = request.resourceId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasResourceType()) {
    query["ResourceType"] = request.resourceType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeTagKeys"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeTagKeysResponse>();
}

/**
 * @summary Queries tag keys.
 *
 * @param request DescribeTagKeysRequest
 * @return DescribeTagKeysResponse
 */
DescribeTagKeysResponse Client::describeTagKeys(const DescribeTagKeysRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeTagKeysWithOptions(request, runtime);
}

/**
 * @summary Queries the tags of an Express Connect circuit.
 *
 * @param request DescribeTagKeysForExpressConnectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTagKeysForExpressConnectResponse
 */
DescribeTagKeysForExpressConnectResponse Client::describeTagKeysForExpressConnectWithOptions(const DescribeTagKeysForExpressConnectRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasKeyword()) {
    query["Keyword"] = request.keyword();
  }

  if (!!request.hasMaxResult()) {
    query["MaxResult"] = request.maxResult();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceId()) {
    query["ResourceId"] = request.resourceId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasResourceType()) {
    query["ResourceType"] = request.resourceType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeTagKeysForExpressConnect"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeTagKeysForExpressConnectResponse>();
}

/**
 * @summary Queries the tags of an Express Connect circuit.
 *
 * @param request DescribeTagKeysForExpressConnectRequest
 * @return DescribeTagKeysForExpressConnectResponse
 */
DescribeTagKeysForExpressConnectResponse Client::describeTagKeysForExpressConnect(const DescribeTagKeysForExpressConnectRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeTagKeysForExpressConnectWithOptions(request, runtime);
}

/**
 * @summary Queries tags that meet the specified filter conditions.
 *
 * @description *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
 * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
 * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, all tags that match the key-value pairs are returned.
 *
 * @param request DescribeTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTagsResponse
 */
DescribeTagsResponse Client::describeTagsWithOptions(const DescribeTagsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasMaxResult()) {
    query["MaxResult"] = request.maxResult();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceId()) {
    query["ResourceId"] = request.resourceId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasResourceType()) {
    query["ResourceType"] = request.resourceType();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeTags"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeTagsResponse>();
}

/**
 * @summary Queries tags that meet the specified filter conditions.
 *
 * @description *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
 * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
 * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, all tags that match the key-value pairs are returned.
 *
 * @param request DescribeTagsRequest
 * @return DescribeTagsResponse
 */
DescribeTagsResponse Client::describeTags(const DescribeTagsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeTagsWithOptions(request, runtime);
}

/**
 * @summary Queries vRouters in a region.
 *
 * @param request DescribeVRoutersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVRoutersResponse
 */
DescribeVRoutersResponse Client::describeVRoutersWithOptions(const DescribeVRoutersRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVRouterId()) {
    query["VRouterId"] = request.VRouterId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVRouters"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVRoutersResponse>();
}

/**
 * @summary Queries vRouters in a region.
 *
 * @param request DescribeVRoutersRequest
 * @return DescribeVRoutersResponse
 */
DescribeVRoutersResponse Client::describeVRouters(const DescribeVRoutersRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVRoutersWithOptions(request, runtime);
}

/**
 * @summary Queries the detailed information about a vSwitch.
 *
 * @param request DescribeVSwitchAttributesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVSwitchAttributesResponse
 */
DescribeVSwitchAttributesResponse Client::describeVSwitchAttributesWithOptions(const DescribeVSwitchAttributesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVSwitchId()) {
    query["VSwitchId"] = request.vSwitchId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVSwitchAttributes"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVSwitchAttributesResponse>();
}

/**
 * @summary Queries the detailed information about a vSwitch.
 *
 * @param request DescribeVSwitchAttributesRequest
 * @return DescribeVSwitchAttributesResponse
 */
DescribeVSwitchAttributesResponse Client::describeVSwitchAttributes(const DescribeVSwitchAttributesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVSwitchAttributesWithOptions(request, runtime);
}

/**
 * @summary Queries the information about available vSwitches that are used for an internal network.
 *
 * @param request DescribeVSwitchesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVSwitchesResponse
 */
DescribeVSwitchesResponse Client::describeVSwitchesWithOptions(const DescribeVSwitchesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEnableIpv6()) {
    query["EnableIpv6"] = request.enableIpv6();
  }

  if (!!request.hasIsDefault()) {
    query["IsDefault"] = request.isDefault();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteTableId()) {
    query["RouteTableId"] = request.routeTableId();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasVSwitchId()) {
    query["VSwitchId"] = request.vSwitchId();
  }

  if (!!request.hasVSwitchName()) {
    query["VSwitchName"] = request.vSwitchName();
  }

  if (!!request.hasVSwitchOwnerId()) {
    query["VSwitchOwnerId"] = request.vSwitchOwnerId();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  if (!!request.hasZoneId()) {
    query["ZoneId"] = request.zoneId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVSwitches"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVSwitchesResponse>();
}

/**
 * @summary Queries the information about available vSwitches that are used for an internal network.
 *
 * @param request DescribeVSwitchesRequest
 * @return DescribeVSwitchesResponse
 */
DescribeVSwitchesResponse Client::describeVSwitches(const DescribeVSwitchesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVSwitchesWithOptions(request, runtime);
}

/**
 * @summary Queries virtual border router (VBR) failover groups.
 *
 * @param request DescribeVbrHaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVbrHaResponse
 */
DescribeVbrHaResponse Client::describeVbrHaWithOptions(const DescribeVbrHaRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVbrHaId()) {
    query["VbrHaId"] = request.vbrHaId();
  }

  if (!!request.hasVbrId()) {
    query["VbrId"] = request.vbrId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVbrHa"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVbrHaResponse>();
}

/**
 * @summary Queries virtual border router (VBR) failover groups.
 *
 * @param request DescribeVbrHaRequest
 * @return DescribeVbrHaResponse
 */
DescribeVbrHaResponse Client::describeVbrHa(const DescribeVbrHaRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVbrHaWithOptions(request, runtime);
}

/**
 * @summary Queries the routes of an IPsec-VPN connection.
 *
 * @param request DescribeVcoRouteEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVcoRouteEntriesResponse
 */
DescribeVcoRouteEntriesResponse Client::describeVcoRouteEntriesWithOptions(const DescribeVcoRouteEntriesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteEntryType()) {
    query["RouteEntryType"] = request.routeEntryType();
  }

  if (!!request.hasVpnConnectionId()) {
    query["VpnConnectionId"] = request.vpnConnectionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVcoRouteEntries"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVcoRouteEntriesResponse>();
}

/**
 * @summary Queries the routes of an IPsec-VPN connection.
 *
 * @param request DescribeVcoRouteEntriesRequest
 * @return DescribeVcoRouteEntriesResponse
 */
DescribeVcoRouteEntriesResponse Client::describeVcoRouteEntries(const DescribeVcoRouteEntriesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVcoRouteEntriesWithOptions(request, runtime);
}

/**
 * @summary Queries virtual border routers (VBRs).
 *
 * @param request DescribeVirtualBorderRoutersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVirtualBorderRoutersResponse
 */
DescribeVirtualBorderRoutersResponse Client::describeVirtualBorderRoutersWithOptions(const DescribeVirtualBorderRoutersRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFilter()) {
    query["Filter"] = request.filter();
  }

  if (!!request.hasIncludeCrossAccountVbr()) {
    query["IncludeCrossAccountVbr"] = request.includeCrossAccountVbr();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVirtualBorderRouters"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVirtualBorderRoutersResponse>();
}

/**
 * @summary Queries virtual border routers (VBRs).
 *
 * @param request DescribeVirtualBorderRoutersRequest
 * @return DescribeVirtualBorderRoutersResponse
 */
DescribeVirtualBorderRoutersResponse Client::describeVirtualBorderRouters(const DescribeVirtualBorderRoutersRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVirtualBorderRoutersWithOptions(request, runtime);
}

/**
 * @summary Queries the virtual border routers (VBRs) that are associated with an Express Connect circuit. The VBRs can be created by the owner of the Express Connect circuit and by other Alibaba Cloud accounts.
 *
 * @param request DescribeVirtualBorderRoutersForPhysicalConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVirtualBorderRoutersForPhysicalConnectionResponse
 */
DescribeVirtualBorderRoutersForPhysicalConnectionResponse Client::describeVirtualBorderRoutersForPhysicalConnectionWithOptions(const DescribeVirtualBorderRoutersForPhysicalConnectionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFilter()) {
    query["Filter"] = request.filter();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPhysicalConnectionId()) {
    query["PhysicalConnectionId"] = request.physicalConnectionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVirtualBorderRoutersForPhysicalConnection"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVirtualBorderRoutersForPhysicalConnectionResponse>();
}

/**
 * @summary Queries the virtual border routers (VBRs) that are associated with an Express Connect circuit. The VBRs can be created by the owner of the Express Connect circuit and by other Alibaba Cloud accounts.
 *
 * @param request DescribeVirtualBorderRoutersForPhysicalConnectionRequest
 * @return DescribeVirtualBorderRoutersForPhysicalConnectionResponse
 */
DescribeVirtualBorderRoutersForPhysicalConnectionResponse Client::describeVirtualBorderRoutersForPhysicalConnection(const DescribeVirtualBorderRoutersForPhysicalConnectionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVirtualBorderRoutersForPhysicalConnectionWithOptions(request, runtime);
}

/**
 * @summary Queries the configuration of a virtual private cloud (VPC).
 *
 * @param request DescribeVpcAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpcAttributeResponse
 */
DescribeVpcAttributeResponse Client::describeVpcAttributeWithOptions(const DescribeVpcAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIsDefault()) {
    query["IsDefault"] = request.isDefault();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVpcAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVpcAttributeResponse>();
}

/**
 * @summary Queries the configuration of a virtual private cloud (VPC).
 *
 * @param request DescribeVpcAttributeRequest
 * @return DescribeVpcAttributeResponse
 */
DescribeVpcAttributeResponse Client::describeVpcAttribute(const DescribeVpcAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVpcAttributeWithOptions(request, runtime);
}

/**
 * @summary 查询VPC跨账号授权给ECR
 *
 * @param request DescribeVpcGrantRulesToEcrRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpcGrantRulesToEcrResponse
 */
DescribeVpcGrantRulesToEcrResponse Client::describeVpcGrantRulesToEcrWithOptions(const DescribeVpcGrantRulesToEcrRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEcrInstanceId()) {
    query["EcrInstanceId"] = request.ecrInstanceId();
  }

  if (!!request.hasEcrOwnerId()) {
    query["EcrOwnerId"] = request.ecrOwnerId();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasInstanceType()) {
    query["InstanceType"] = request.instanceType();
  }

  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVpcGrantRulesToEcr"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVpcGrantRulesToEcrResponse>();
}

/**
 * @summary 查询VPC跨账号授权给ECR
 *
 * @param request DescribeVpcGrantRulesToEcrRequest
 * @return DescribeVpcGrantRulesToEcrResponse
 */
DescribeVpcGrantRulesToEcrResponse Client::describeVpcGrantRulesToEcr(const DescribeVpcGrantRulesToEcrRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVpcGrantRulesToEcrWithOptions(request, runtime);
}

/**
 * @summary Queries virtual private clouds (VPCs).
 *
 * @param request DescribeVpcsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpcsResponse
 */
DescribeVpcsResponse Client::describeVpcsWithOptions(const DescribeVpcsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDhcpOptionsSetId()) {
    query["DhcpOptionsSetId"] = request.dhcpOptionsSetId();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEnableIpv6()) {
    query["EnableIpv6"] = request.enableIpv6();
  }

  if (!!request.hasIsDefault()) {
    query["IsDefault"] = request.isDefault();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  if (!!request.hasVpcName()) {
    query["VpcName"] = request.vpcName();
  }

  if (!!request.hasVpcOwnerId()) {
    query["VpcOwnerId"] = request.vpcOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVpcs"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVpcsResponse>();
}

/**
 * @summary Queries virtual private clouds (VPCs).
 *
 * @param request DescribeVpcsRequest
 * @return DescribeVpcsResponse
 */
DescribeVpcsResponse Client::describeVpcs(const DescribeVpcsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVpcsWithOptions(request, runtime);
}

/**
 * @summary Queries the IPsec-VPN connections associated with a transit router.
 *
 * @param request DescribeVpnAttachmentsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpnAttachmentsResponse
 */
DescribeVpnAttachmentsResponse Client::describeVpnAttachmentsWithOptions(const DescribeVpnAttachmentsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAttachType()) {
    query["AttachType"] = request.attachType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpnConnectionId()) {
    query["VpnConnectionId"] = request.vpnConnectionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVpnAttachments"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVpnAttachmentsResponse>();
}

/**
 * @summary Queries the IPsec-VPN connections associated with a transit router.
 *
 * @param request DescribeVpnAttachmentsRequest
 * @return DescribeVpnAttachmentsResponse
 */
DescribeVpnAttachmentsResponse Client::describeVpnAttachments(const DescribeVpnAttachmentsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVpnAttachmentsWithOptions(request, runtime);
}

/**
 * @summary Queries the detailed information about an IPsec-VPN connection.
 *
 * @param request DescribeVpnConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpnConnectionResponse
 */
DescribeVpnConnectionResponse Client::describeVpnConnectionWithOptions(const DescribeVpnConnectionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpnConnectionId()) {
    query["VpnConnectionId"] = request.vpnConnectionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVpnConnection"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVpnConnectionResponse>();
}

/**
 * @summary Queries the detailed information about an IPsec-VPN connection.
 *
 * @param request DescribeVpnConnectionRequest
 * @return DescribeVpnConnectionResponse
 */
DescribeVpnConnectionResponse Client::describeVpnConnection(const DescribeVpnConnectionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVpnConnectionWithOptions(request, runtime);
}

/**
 * @summary Queries logs of IPsec-VPN connections.
 *
 * @param request DescribeVpnConnectionLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpnConnectionLogsResponse
 */
DescribeVpnConnectionLogsResponse Client::describeVpnConnectionLogsWithOptions(const DescribeVpnConnectionLogsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasMinutePeriod()) {
    query["MinutePeriod"] = request.minutePeriod();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTo()) {
    query["To"] = request.to();
  }

  if (!!request.hasTunnelId()) {
    query["TunnelId"] = request.tunnelId();
  }

  if (!!request.hasVpnConnectionId()) {
    query["VpnConnectionId"] = request.vpnConnectionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVpnConnectionLogs"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVpnConnectionLogsResponse>();
}

/**
 * @summary Queries logs of IPsec-VPN connections.
 *
 * @param request DescribeVpnConnectionLogsRequest
 * @return DescribeVpnConnectionLogsResponse
 */
DescribeVpnConnectionLogsResponse Client::describeVpnConnectionLogs(const DescribeVpnConnectionLogsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVpnConnectionLogsWithOptions(request, runtime);
}

/**
 * @summary Queries IPsec-VPN connections.
 *
 * @param request DescribeVpnConnectionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpnConnectionsResponse
 */
DescribeVpnConnectionsResponse Client::describeVpnConnectionsWithOptions(const DescribeVpnConnectionsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCustomerGatewayId()) {
    query["CustomerGatewayId"] = request.customerGatewayId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasVpnConnectionId()) {
    query["VpnConnectionId"] = request.vpnConnectionId();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVpnConnections"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVpnConnectionsResponse>();
}

/**
 * @summary Queries IPsec-VPN connections.
 *
 * @param request DescribeVpnConnectionsRequest
 * @return DescribeVpnConnectionsResponse
 */
DescribeVpnConnectionsResponse Client::describeVpnConnections(const DescribeVpnConnectionsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVpnConnectionsWithOptions(request, runtime);
}

/**
 * @summary Queries the cross-account authorization information about an IPsec-VPN connection.
 *
 * @param request DescribeVpnCrossAccountAuthorizationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpnCrossAccountAuthorizationsResponse
 */
DescribeVpnCrossAccountAuthorizationsResponse Client::describeVpnCrossAccountAuthorizationsWithOptions(const DescribeVpnCrossAccountAuthorizationsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpnConnectionId()) {
    query["VpnConnectionId"] = request.vpnConnectionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVpnCrossAccountAuthorizations"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVpnCrossAccountAuthorizationsResponse>();
}

/**
 * @summary Queries the cross-account authorization information about an IPsec-VPN connection.
 *
 * @param request DescribeVpnCrossAccountAuthorizationsRequest
 * @return DescribeVpnCrossAccountAuthorizationsResponse
 */
DescribeVpnCrossAccountAuthorizationsResponse Client::describeVpnCrossAccountAuthorizations(const DescribeVpnCrossAccountAuthorizationsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVpnCrossAccountAuthorizationsWithOptions(request, runtime);
}

/**
 * @summary Queries the detailed information about a VPN gateway.
 *
 * @param request DescribeVpnGatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpnGatewayResponse
 */
DescribeVpnGatewayResponse Client::describeVpnGatewayWithOptions(const DescribeVpnGatewayRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIncludeReservationData()) {
    query["IncludeReservationData"] = request.includeReservationData();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVpnGateway"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVpnGatewayResponse>();
}

/**
 * @summary Queries the detailed information about a VPN gateway.
 *
 * @param request DescribeVpnGatewayRequest
 * @return DescribeVpnGatewayResponse
 */
DescribeVpnGatewayResponse Client::describeVpnGateway(const DescribeVpnGatewayRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVpnGatewayWithOptions(request, runtime);
}

/**
 * @summary Queries zones that support IPsec-VPN connections in a region.
 *
 * @param request DescribeVpnGatewayAvailableZonesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpnGatewayAvailableZonesResponse
 */
DescribeVpnGatewayAvailableZonesResponse Client::describeVpnGatewayAvailableZonesWithOptions(const DescribeVpnGatewayAvailableZonesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  map<string, string> query = Utils::Utils::query(request.toMap());
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVpnGatewayAvailableZones"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "GET"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVpnGatewayAvailableZonesResponse>();
}

/**
 * @summary Queries zones that support IPsec-VPN connections in a region.
 *
 * @param request DescribeVpnGatewayAvailableZonesRequest
 * @return DescribeVpnGatewayAvailableZonesResponse
 */
DescribeVpnGatewayAvailableZonesResponse Client::describeVpnGatewayAvailableZones(const DescribeVpnGatewayAvailableZonesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVpnGatewayAvailableZonesWithOptions(request, runtime);
}

/**
 * @summary Queries VPN gateways in a region.
 *
 * @param request DescribeVpnGatewaysRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpnGatewaysResponse
 */
DescribeVpnGatewaysResponse Client::describeVpnGatewaysWithOptions(const DescribeVpnGatewaysRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBusinessStatus()) {
    query["BusinessStatus"] = request.businessStatus();
  }

  if (!!request.hasIncludeReservationData()) {
    query["IncludeReservationData"] = request.includeReservationData();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVpnGateways"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVpnGatewaysResponse>();
}

/**
 * @summary Queries VPN gateways in a region.
 *
 * @param request DescribeVpnGatewaysRequest
 * @return DescribeVpnGatewaysResponse
 */
DescribeVpnGatewaysResponse Client::describeVpnGateways(const DescribeVpnGatewaysRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVpnGatewaysWithOptions(request, runtime);
}

/**
 * @summary Queries policy-based routes configured for a VPN gateway.
 *
 * @param request DescribeVpnPbrRouteEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpnPbrRouteEntriesResponse
 */
DescribeVpnPbrRouteEntriesResponse Client::describeVpnPbrRouteEntriesWithOptions(const DescribeVpnPbrRouteEntriesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVpnPbrRouteEntries"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVpnPbrRouteEntriesResponse>();
}

/**
 * @summary Queries policy-based routes configured for a VPN gateway.
 *
 * @param request DescribeVpnPbrRouteEntriesRequest
 * @return DescribeVpnPbrRouteEntriesResponse
 */
DescribeVpnPbrRouteEntriesResponse Client::describeVpnPbrRouteEntries(const DescribeVpnPbrRouteEntriesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVpnPbrRouteEntriesWithOptions(request, runtime);
}

/**
 * @summary Queries destination-based and BGP route entries of a VPN gateway.
 *
 * @param request DescribeVpnRouteEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpnRouteEntriesResponse
 */
DescribeVpnRouteEntriesResponse Client::describeVpnRouteEntriesWithOptions(const DescribeVpnRouteEntriesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteEntryType()) {
    query["RouteEntryType"] = request.routeEntryType();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVpnRouteEntries"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVpnRouteEntriesResponse>();
}

/**
 * @summary Queries destination-based and BGP route entries of a VPN gateway.
 *
 * @param request DescribeVpnRouteEntriesRequest
 * @return DescribeVpnRouteEntriesResponse
 */
DescribeVpnRouteEntriesResponse Client::describeVpnRouteEntries(const DescribeVpnRouteEntriesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVpnRouteEntriesWithOptions(request, runtime);
}

/**
 * @summary Queries the log entries of an SSL server.
 *
 * @param request DescribeVpnSslServerLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpnSslServerLogsResponse
 */
DescribeVpnSslServerLogsResponse Client::describeVpnSslServerLogsWithOptions(const DescribeVpnSslServerLogsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasMinutePeriod()) {
    query["MinutePeriod"] = request.minutePeriod();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSslVpnClientCertId()) {
    query["SslVpnClientCertId"] = request.sslVpnClientCertId();
  }

  if (!!request.hasTo()) {
    query["To"] = request.to();
  }

  if (!!request.hasVpnSslServerId()) {
    query["VpnSslServerId"] = request.vpnSslServerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVpnSslServerLogs"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVpnSslServerLogsResponse>();
}

/**
 * @summary Queries the log entries of an SSL server.
 *
 * @param request DescribeVpnSslServerLogsRequest
 * @return DescribeVpnSslServerLogsResponse
 */
DescribeVpnSslServerLogsResponse Client::describeVpnSslServerLogs(const DescribeVpnSslServerLogsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVpnSslServerLogsWithOptions(request, runtime);
}

/**
 * @summary Queries zones in a region.
 *
 * @param request DescribeZonesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeZonesResponse
 */
DescribeZonesResponse Client::describeZonesWithOptions(const DescribeZonesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAcceptLanguage()) {
    query["AcceptLanguage"] = request.acceptLanguage();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasZoneType()) {
    query["ZoneType"] = request.zoneType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeZones"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeZonesResponse>();
}

/**
 * @summary Queries zones in a region.
 *
 * @param request DescribeZonesRequest
 * @return DescribeZonesResponse
 */
DescribeZonesResponse Client::describeZones(const DescribeZonesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeZonesWithOptions(request, runtime);
}

/**
 * @summary Disassociates a DHCP options set from a virtual private cloud (VPC).
 *
 * @description ## [](#)Description
 * *   **DetachDhcpOptionsSetFromVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task.
 *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being disassociated.
 *     *   If the DHCP options set is in the **UnUsed** state, the DHCP options set is disassociated.
 * *   You cannot repeatedly call the **DetachDhcpOptionsSetFromVpc** operation to disassociate a DHCP options set from a VPC within the specified period of time.
 *
 * @param request DetachDhcpOptionsSetFromVpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachDhcpOptionsSetFromVpcResponse
 */
DetachDhcpOptionsSetFromVpcResponse Client::detachDhcpOptionsSetFromVpcWithOptions(const DetachDhcpOptionsSetFromVpcRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDhcpOptionsSetId()) {
    query["DhcpOptionsSetId"] = request.dhcpOptionsSetId();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DetachDhcpOptionsSetFromVpc"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DetachDhcpOptionsSetFromVpcResponse>();
}

/**
 * @summary Disassociates a DHCP options set from a virtual private cloud (VPC).
 *
 * @description ## [](#)Description
 * *   **DetachDhcpOptionsSetFromVpc** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of the task.
 *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being disassociated.
 *     *   If the DHCP options set is in the **UnUsed** state, the DHCP options set is disassociated.
 * *   You cannot repeatedly call the **DetachDhcpOptionsSetFromVpc** operation to disassociate a DHCP options set from a VPC within the specified period of time.
 *
 * @param request DetachDhcpOptionsSetFromVpcRequest
 * @return DetachDhcpOptionsSetFromVpcResponse
 */
DetachDhcpOptionsSetFromVpcResponse Client::detachDhcpOptionsSetFromVpc(const DetachDhcpOptionsSetFromVpcRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return detachDhcpOptionsSetFromVpcWithOptions(request, runtime);
}

/**
 * @summary Diagnoses IPsec-VPN connections.
 *
 * @description *   If the IPsec-VPN connection is in single-tunnel mode, the request parameter `VpnConnectionIds` is required when you call the **DiagnoseVpnConnections** operation.
 * *   If the IPsec-VPN connection is in dual-tunnel mode, the request parameter `TunnelIds` is required when you call the **DiagnoseVpnConnections** operation.
 * *   After you call the **DiagnoseVpnConnections** operation, if the current IPsec-VPN connection is faulty, the operation returns the corresponding error code (**FailedReasonCode**) and log (**SourceLog**). You can troubleshoot based on the error code and log information. For more information, see [Common errors and troubleshooting methods for IPsec-VPN connections](https://help.aliyun.com/document_detail/477862.html).
 *
 * @param request DiagnoseVpnConnectionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DiagnoseVpnConnectionsResponse
 */
DiagnoseVpnConnectionsResponse Client::diagnoseVpnConnectionsWithOptions(const DiagnoseVpnConnectionsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTunnelIds()) {
    query["TunnelIds"] = request.tunnelIds();
  }

  if (!!request.hasVpnConnectionIds()) {
    query["VpnConnectionIds"] = request.vpnConnectionIds();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DiagnoseVpnConnections"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DiagnoseVpnConnectionsResponse>();
}

/**
 * @summary Diagnoses IPsec-VPN connections.
 *
 * @description *   If the IPsec-VPN connection is in single-tunnel mode, the request parameter `VpnConnectionIds` is required when you call the **DiagnoseVpnConnections** operation.
 * *   If the IPsec-VPN connection is in dual-tunnel mode, the request parameter `TunnelIds` is required when you call the **DiagnoseVpnConnections** operation.
 * *   After you call the **DiagnoseVpnConnections** operation, if the current IPsec-VPN connection is faulty, the operation returns the corresponding error code (**FailedReasonCode**) and log (**SourceLog**). You can troubleshoot based on the error code and log information. For more information, see [Common errors and troubleshooting methods for IPsec-VPN connections](https://help.aliyun.com/document_detail/477862.html).
 *
 * @param request DiagnoseVpnConnectionsRequest
 * @return DiagnoseVpnConnectionsResponse
 */
DiagnoseVpnConnectionsResponse Client::diagnoseVpnConnections(const DiagnoseVpnConnectionsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return diagnoseVpnConnectionsWithOptions(request, runtime);
}

/**
 * @summary Diagnoses a VPN gateway.
 *
 * @param request DiagnoseVpnGatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DiagnoseVpnGatewayResponse
 */
DiagnoseVpnGatewayResponse Client::diagnoseVpnGatewayWithOptions(const DiagnoseVpnGatewayRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasIPsecExtendInfo()) {
    query["IPsecExtendInfo"] = request.IPsecExtendInfo();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceId()) {
    query["ResourceId"] = request.resourceId();
  }

  if (!!request.hasResourceType()) {
    query["ResourceType"] = request.resourceType();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DiagnoseVpnGateway"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DiagnoseVpnGatewayResponse>();
}

/**
 * @summary Diagnoses a VPN gateway.
 *
 * @param request DiagnoseVpnGatewayRequest
 * @return DiagnoseVpnGatewayResponse
 */
DiagnoseVpnGatewayResponse Client::diagnoseVpnGateway(const DiagnoseVpnGatewayRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return diagnoseVpnGatewayWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI DisableNatGatewayEcsMetric is deprecated
 *
 * @summary Disables traffic monitoring for an Elastic Compute Service (ECS) instance.
 *
 * @param request DisableNatGatewayEcsMetricRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableNatGatewayEcsMetricResponse
 */
DisableNatGatewayEcsMetricResponse Client::disableNatGatewayEcsMetricWithOptions(const DisableNatGatewayEcsMetricRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DisableNatGatewayEcsMetric"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DisableNatGatewayEcsMetricResponse>();
}

/**
 * @deprecated OpenAPI DisableNatGatewayEcsMetric is deprecated
 *
 * @summary Disables traffic monitoring for an Elastic Compute Service (ECS) instance.
 *
 * @param request DisableNatGatewayEcsMetricRequest
 * @return DisableNatGatewayEcsMetricResponse
 */
DisableNatGatewayEcsMetricResponse Client::disableNatGatewayEcsMetric(const DisableNatGatewayEcsMetricRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return disableNatGatewayEcsMetricWithOptions(request, runtime);
}

/**
 * @summary Disables ClassicLink for a virtual private cloud (VPC).
 *
 * @param request DisableVpcClassicLinkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableVpcClassicLinkResponse
 */
DisableVpcClassicLinkResponse Client::disableVpcClassicLinkWithOptions(const DisableVpcClassicLinkRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DisableVpcClassicLink"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DisableVpcClassicLinkResponse>();
}

/**
 * @summary Disables ClassicLink for a virtual private cloud (VPC).
 *
 * @param request DisableVpcClassicLinkRequest
 * @return DisableVpcClassicLinkResponse
 */
DisableVpcClassicLinkResponse Client::disableVpcClassicLink(const DisableVpcClassicLinkRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return disableVpcClassicLinkWithOptions(request, runtime);
}

/**
 * @summary Disassociates a gateway route table from an IPv4 gateway.
 *
 * @param request DissociateRouteTableFromGatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DissociateRouteTableFromGatewayResponse
 */
DissociateRouteTableFromGatewayResponse Client::dissociateRouteTableFromGatewayWithOptions(const DissociateRouteTableFromGatewayRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasGatewayId()) {
    query["GatewayId"] = request.gatewayId();
  }

  if (!!request.hasGatewayType()) {
    query["GatewayType"] = request.gatewayType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteTableId()) {
    query["RouteTableId"] = request.routeTableId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DissociateRouteTableFromGateway"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DissociateRouteTableFromGatewayResponse>();
}

/**
 * @summary Disassociates a gateway route table from an IPv4 gateway.
 *
 * @param request DissociateRouteTableFromGatewayRequest
 * @return DissociateRouteTableFromGatewayResponse
 */
DissociateRouteTableFromGatewayResponse Client::dissociateRouteTableFromGateway(const DissociateRouteTableFromGatewayRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return dissociateRouteTableFromGatewayWithOptions(request, runtime);
}

/**
 * @summary Disassociates a gateway endpoint from a route table.
 *
 * @param request DissociateRouteTablesFromVpcGatewayEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DissociateRouteTablesFromVpcGatewayEndpointResponse
 */
DissociateRouteTablesFromVpcGatewayEndpointResponse Client::dissociateRouteTablesFromVpcGatewayEndpointWithOptions(const DissociateRouteTablesFromVpcGatewayEndpointRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEndpointId()) {
    query["EndpointId"] = request.endpointId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteTableIds()) {
    query["RouteTableIds"] = request.routeTableIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DissociateRouteTablesFromVpcGatewayEndpoint"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DissociateRouteTablesFromVpcGatewayEndpointResponse>();
}

/**
 * @summary Disassociates a gateway endpoint from a route table.
 *
 * @param request DissociateRouteTablesFromVpcGatewayEndpointRequest
 * @return DissociateRouteTablesFromVpcGatewayEndpointResponse
 */
DissociateRouteTablesFromVpcGatewayEndpointResponse Client::dissociateRouteTablesFromVpcGatewayEndpoint(const DissociateRouteTablesFromVpcGatewayEndpointRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return dissociateRouteTablesFromVpcGatewayEndpointWithOptions(request, runtime);
}

/**
 * @summary Disassociates a certificate from a VPN gateway.
 *
 * @description *   **DissociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status the task.
 *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being disassociated from the VPN gateway.
 *     *   If the VPN gateway is in the **active** state, the SSL certificate is disassociated from the VPN gateway.
 * *   You cannot repeatedly call **DissociateVpnGatewayWithCertificate** within a specific period of time.
 *
 * @param request DissociateVpnGatewayWithCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DissociateVpnGatewayWithCertificateResponse
 */
DissociateVpnGatewayWithCertificateResponse Client::dissociateVpnGatewayWithCertificateWithOptions(const DissociateVpnGatewayWithCertificateRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCertificateId()) {
    query["CertificateId"] = request.certificateId();
  }

  if (!!request.hasCertificateType()) {
    query["CertificateType"] = request.certificateType();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DissociateVpnGatewayWithCertificate"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DissociateVpnGatewayWithCertificateResponse>();
}

/**
 * @summary Disassociates a certificate from a VPN gateway.
 *
 * @description *   **DissociateVpnGatewayWithCertificate** is an asynchronous operation. After a request is sent, the system returns a request and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status the task.
 *     *   If the VPN gateway is in the **updating** state, the SSL certificate is being disassociated from the VPN gateway.
 *     *   If the VPN gateway is in the **active** state, the SSL certificate is disassociated from the VPN gateway.
 * *   You cannot repeatedly call **DissociateVpnGatewayWithCertificate** within a specific period of time.
 *
 * @param request DissociateVpnGatewayWithCertificateRequest
 * @return DissociateVpnGatewayWithCertificateResponse
 */
DissociateVpnGatewayWithCertificateResponse Client::dissociateVpnGatewayWithCertificate(const DissociateVpnGatewayWithCertificateRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return dissociateVpnGatewayWithCertificateWithOptions(request, runtime);
}

/**
 * @summary Queries the configuration of an IPsec-VPN connection.
 *
 * @param request DownloadVpnConnectionConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DownloadVpnConnectionConfigResponse
 */
DownloadVpnConnectionConfigResponse Client::downloadVpnConnectionConfigWithOptions(const DownloadVpnConnectionConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpnConnectionId()) {
    query["VpnConnectionId"] = request.vpnConnectionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DownloadVpnConnectionConfig"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DownloadVpnConnectionConfigResponse>();
}

/**
 * @summary Queries the configuration of an IPsec-VPN connection.
 *
 * @param request DownloadVpnConnectionConfigRequest
 * @return DownloadVpnConnectionConfigResponse
 */
DownloadVpnConnectionConfigResponse Client::downloadVpnConnectionConfig(const DownloadVpnConnectionConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return downloadVpnConnectionConfigWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI EnableNatGatewayEcsMetric is deprecated
 *
 * @summary Enables Elastic Compute Service (ECS) traffic monitoring.
 *
 * @param request EnableNatGatewayEcsMetricRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableNatGatewayEcsMetricResponse
 */
EnableNatGatewayEcsMetricResponse Client::enableNatGatewayEcsMetricWithOptions(const EnableNatGatewayEcsMetricRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "EnableNatGatewayEcsMetric"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<EnableNatGatewayEcsMetricResponse>();
}

/**
 * @deprecated OpenAPI EnableNatGatewayEcsMetric is deprecated
 *
 * @summary Enables Elastic Compute Service (ECS) traffic monitoring.
 *
 * @param request EnableNatGatewayEcsMetricRequest
 * @return EnableNatGatewayEcsMetricResponse
 */
EnableNatGatewayEcsMetricResponse Client::enableNatGatewayEcsMetric(const EnableNatGatewayEcsMetricRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return enableNatGatewayEcsMetricWithOptions(request, runtime);
}

/**
 * @summary Enables an Express Connect circuit that is in the Confirmed state. After you perform this operation, the Express Connect circuit enters the Enabled state.
 *
 * @description When you call this operation, take note of the following limits:
 * *   You can enable only an Express Connect circuit that is in the **Confirmed** state.
 * *   After you enable an Express Connect circuit, it enters the **Enabled** state.
 * *   **EnablePhysicalConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribePhysicalConnections](https://help.aliyun.com/document_detail/36042.html) operation to query the status of the task.
 * *   You cannot repeatedly call **EnablePhysicalConnection** for an Express Connect circuit in the **Confirmed** state within a specific time period.
 *
 * @param request EnablePhysicalConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnablePhysicalConnectionResponse
 */
EnablePhysicalConnectionResponse Client::enablePhysicalConnectionWithOptions(const EnablePhysicalConnectionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasByPassSp()) {
    query["ByPassSp"] = request.byPassSp();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPhysicalConnectionId()) {
    query["PhysicalConnectionId"] = request.physicalConnectionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "EnablePhysicalConnection"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<EnablePhysicalConnectionResponse>();
}

/**
 * @summary Enables an Express Connect circuit that is in the Confirmed state. After you perform this operation, the Express Connect circuit enters the Enabled state.
 *
 * @description When you call this operation, take note of the following limits:
 * *   You can enable only an Express Connect circuit that is in the **Confirmed** state.
 * *   After you enable an Express Connect circuit, it enters the **Enabled** state.
 * *   **EnablePhysicalConnection** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribePhysicalConnections](https://help.aliyun.com/document_detail/36042.html) operation to query the status of the task.
 * *   You cannot repeatedly call **EnablePhysicalConnection** for an Express Connect circuit in the **Confirmed** state within a specific time period.
 *
 * @param request EnablePhysicalConnectionRequest
 * @return EnablePhysicalConnectionResponse
 */
EnablePhysicalConnectionResponse Client::enablePhysicalConnection(const EnablePhysicalConnectionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return enablePhysicalConnectionWithOptions(request, runtime);
}

/**
 * @summary Enables ClassicLink for a VPC.
 *
 * @param request EnableVpcClassicLinkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableVpcClassicLinkResponse
 */
EnableVpcClassicLinkResponse Client::enableVpcClassicLinkWithOptions(const EnableVpcClassicLinkRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "EnableVpcClassicLink"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<EnableVpcClassicLinkResponse>();
}

/**
 * @summary Enables ClassicLink for a VPC.
 *
 * @param request EnableVpcClassicLinkRequest
 * @return EnableVpcClassicLinkResponse
 */
EnableVpcClassicLinkResponse Client::enableVpcClassicLink(const EnableVpcClassicLinkRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return enableVpcClassicLinkWithOptions(request, runtime);
}

/**
 * @summary Activates an IPv4 gateway.
 *
 * @description ## [](#)Description
 * *   **EnableVpcIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway.
 *     *   If the IPv4 gateway is in the **Activating** state, the IPv4 gateway is being activated.
 *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is activated.
 * *   You cannot repeatedly call the **EnableVpcIpv4Gateway** operation to activate an IPv4 gateway within the specified period of time.
 *
 * @param request EnableVpcIpv4GatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableVpcIpv4GatewayResponse
 */
EnableVpcIpv4GatewayResponse Client::enableVpcIpv4GatewayWithOptions(const EnableVpcIpv4GatewayRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIpv4GatewayId()) {
    query["Ipv4GatewayId"] = request.ipv4GatewayId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteTableList()) {
    query["RouteTableList"] = request.routeTableList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "EnableVpcIpv4Gateway"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<EnableVpcIpv4GatewayResponse>();
}

/**
 * @summary Activates an IPv4 gateway.
 *
 * @description ## [](#)Description
 * *   **EnableVpcIpv4Gateway** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetIpv4GatewayAttribute](https://help.aliyun.com/document_detail/407670.html) operation to query the status of an IPv4 gateway.
 *     *   If the IPv4 gateway is in the **Activating** state, the IPv4 gateway is being activated.
 *     *   If the IPv4 gateway is in the **Created** state, the IPv4 gateway is activated.
 * *   You cannot repeatedly call the **EnableVpcIpv4Gateway** operation to activate an IPv4 gateway within the specified period of time.
 *
 * @param request EnableVpcIpv4GatewayRequest
 * @return EnableVpcIpv4GatewayResponse
 */
EnableVpcIpv4GatewayResponse Client::enableVpcIpv4Gateway(const EnableVpcIpv4GatewayRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return enableVpcIpv4GatewayWithOptions(request, runtime);
}

/**
 * @summary Queries a DHCP options set.
 *
 * @param request GetDhcpOptionsSetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDhcpOptionsSetResponse
 */
GetDhcpOptionsSetResponse Client::getDhcpOptionsSetWithOptions(const GetDhcpOptionsSetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDhcpOptionsSetId()) {
    query["DhcpOptionsSetId"] = request.dhcpOptionsSetId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetDhcpOptionsSet"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetDhcpOptionsSetResponse>();
}

/**
 * @summary Queries a DHCP options set.
 *
 * @param request GetDhcpOptionsSetRequest
 * @return GetDhcpOptionsSetResponse
 */
GetDhcpOptionsSetResponse Client::getDhcpOptionsSet(const GetDhcpOptionsSetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getDhcpOptionsSetWithOptions(request, runtime);
}

/**
 * @summary Queries the status of a flow log.
 *
 * @param request GetFlowLogServiceStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFlowLogServiceStatusResponse
 */
GetFlowLogServiceStatusResponse Client::getFlowLogServiceStatusWithOptions(const GetFlowLogServiceStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetFlowLogServiceStatus"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetFlowLogServiceStatusResponse>();
}

/**
 * @summary Queries the status of a flow log.
 *
 * @param request GetFlowLogServiceStatusRequest
 * @return GetFlowLogServiceStatusResponse
 */
GetFlowLogServiceStatusResponse Client::getFlowLogServiceStatus(const GetFlowLogServiceStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getFlowLogServiceStatusWithOptions(request, runtime);
}

/**
 * @summary Queries an IPv4 gateway.
 *
 * @param request GetIpv4GatewayAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetIpv4GatewayAttributeResponse
 */
GetIpv4GatewayAttributeResponse Client::getIpv4GatewayAttributeWithOptions(const GetIpv4GatewayAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIpv4GatewayId()) {
    query["Ipv4GatewayId"] = request.ipv4GatewayId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetIpv4GatewayAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetIpv4GatewayAttributeResponse>();
}

/**
 * @summary Queries an IPv4 gateway.
 *
 * @param request GetIpv4GatewayAttributeRequest
 * @return GetIpv4GatewayAttributeResponse
 */
GetIpv4GatewayAttributeResponse Client::getIpv4GatewayAttribute(const GetIpv4GatewayAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getIpv4GatewayAttributeWithOptions(request, runtime);
}

/**
 * @summary 查询NAT详情信息
 *
 * @description You can call this operation to query information about a specified Internet NAT gateway or Virtual Private Cloud (VPC) NAT gateway. In this topic, "NAT gateway" refers to both gateway types.
 *
 * @param request GetNatGatewayAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetNatGatewayAttributeResponse
 */
GetNatGatewayAttributeResponse Client::getNatGatewayAttributeWithOptions(const GetNatGatewayAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetNatGatewayAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetNatGatewayAttributeResponse>();
}

/**
 * @summary 查询NAT详情信息
 *
 * @description You can call this operation to query information about a specified Internet NAT gateway or Virtual Private Cloud (VPC) NAT gateway. In this topic, "NAT gateway" refers to both gateway types.
 *
 * @param request GetNatGatewayAttributeRequest
 * @return GetNatGatewayAttributeResponse
 */
GetNatGatewayAttributeResponse Client::getNatGatewayAttribute(const GetNatGatewayAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getNatGatewayAttributeWithOptions(request, runtime);
}

/**
 * @summary 查询是否开通了出云流量服务
 *
 * @description You can call this API operation to query the status of outbound data transfer billing for the current account. For more information about outbound data transfer billing, see [Outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html) and [Billing](https://help.aliyun.com/document_detail/54582.html).
 *
 * @param request GetPhysicalConnectionServiceStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPhysicalConnectionServiceStatusResponse
 */
GetPhysicalConnectionServiceStatusResponse Client::getPhysicalConnectionServiceStatusWithOptions(const GetPhysicalConnectionServiceStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetPhysicalConnectionServiceStatus"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetPhysicalConnectionServiceStatusResponse>();
}

/**
 * @summary 查询是否开通了出云流量服务
 *
 * @description You can call this API operation to query the status of outbound data transfer billing for the current account. For more information about outbound data transfer billing, see [Outbound data transfer billing](https://help.aliyun.com/document_detail/274385.html) and [Billing](https://help.aliyun.com/document_detail/54582.html).
 *
 * @param request GetPhysicalConnectionServiceStatusRequest
 * @return GetPhysicalConnectionServiceStatusResponse
 */
GetPhysicalConnectionServiceStatusResponse Client::getPhysicalConnectionServiceStatus(const GetPhysicalConnectionServiceStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getPhysicalConnectionServiceStatusWithOptions(request, runtime);
}

/**
 * @summary Queries whether the IP address pool feature is enabled.
 *
 * @param request GetPublicIpAddressPoolServiceStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPublicIpAddressPoolServiceStatusResponse
 */
GetPublicIpAddressPoolServiceStatusResponse Client::getPublicIpAddressPoolServiceStatusWithOptions(const GetPublicIpAddressPoolServiceStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetPublicIpAddressPoolServiceStatus"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetPublicIpAddressPoolServiceStatusResponse>();
}

/**
 * @summary Queries whether the IP address pool feature is enabled.
 *
 * @param request GetPublicIpAddressPoolServiceStatusRequest
 * @return GetPublicIpAddressPoolServiceStatusResponse
 */
GetPublicIpAddressPoolServiceStatusResponse Client::getPublicIpAddressPoolServiceStatus(const GetPublicIpAddressPoolServiceStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getPublicIpAddressPoolServiceStatusWithOptions(request, runtime);
}

/**
 * @summary Queries the status of the traffic mirror feature.
 *
 * @param request GetTrafficMirrorServiceStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTrafficMirrorServiceStatusResponse
 */
GetTrafficMirrorServiceStatusResponse Client::getTrafficMirrorServiceStatusWithOptions(const GetTrafficMirrorServiceStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetTrafficMirrorServiceStatus"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetTrafficMirrorServiceStatusResponse>();
}

/**
 * @summary Queries the status of the traffic mirror feature.
 *
 * @param request GetTrafficMirrorServiceStatusRequest
 * @return GetTrafficMirrorServiceStatusResponse
 */
GetTrafficMirrorServiceStatusResponse Client::getTrafficMirrorServiceStatus(const GetTrafficMirrorServiceStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getTrafficMirrorServiceStatusWithOptions(request, runtime);
}

/**
 * @summary Queries the usage of a prefix list.
 *
 * @param request GetVSwitchCidrReservationUsageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVSwitchCidrReservationUsageResponse
 */
GetVSwitchCidrReservationUsageResponse Client::getVSwitchCidrReservationUsageWithOptions(const GetVSwitchCidrReservationUsageRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVSwitchCidrReservationId()) {
    query["VSwitchCidrReservationId"] = request.vSwitchCidrReservationId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetVSwitchCidrReservationUsage"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetVSwitchCidrReservationUsageResponse>();
}

/**
 * @summary Queries the usage of a prefix list.
 *
 * @param request GetVSwitchCidrReservationUsageRequest
 * @return GetVSwitchCidrReservationUsageResponse
 */
GetVSwitchCidrReservationUsageResponse Client::getVSwitchCidrReservationUsage(const GetVSwitchCidrReservationUsageRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getVSwitchCidrReservationUsageWithOptions(request, runtime);
}

/**
 * @summary Queries the attributes of a gateway endpoint.
 *
 * @param request GetVpcGatewayEndpointAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVpcGatewayEndpointAttributeResponse
 */
GetVpcGatewayEndpointAttributeResponse Client::getVpcGatewayEndpointAttributeWithOptions(const GetVpcGatewayEndpointAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEndpointId()) {
    query["EndpointId"] = request.endpointId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetVpcGatewayEndpointAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetVpcGatewayEndpointAttributeResponse>();
}

/**
 * @summary Queries the attributes of a gateway endpoint.
 *
 * @param request GetVpcGatewayEndpointAttributeRequest
 * @return GetVpcGatewayEndpointAttributeResponse
 */
GetVpcGatewayEndpointAttributeResponse Client::getVpcGatewayEndpointAttribute(const GetVpcGatewayEndpointAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getVpcGatewayEndpointAttributeWithOptions(request, runtime);
}

/**
 * @summary Queries the resources that are associated with a prefix list.
 *
 * @param request GetVpcPrefixListAssociationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVpcPrefixListAssociationsResponse
 */
GetVpcPrefixListAssociationsResponse Client::getVpcPrefixListAssociationsWithOptions(const GetVpcPrefixListAssociationsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPrefixListId()) {
    query["PrefixListId"] = request.prefixListId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetVpcPrefixListAssociations"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetVpcPrefixListAssociationsResponse>();
}

/**
 * @summary Queries the resources that are associated with a prefix list.
 *
 * @param request GetVpcPrefixListAssociationsRequest
 * @return GetVpcPrefixListAssociationsResponse
 */
GetVpcPrefixListAssociationsResponse Client::getVpcPrefixListAssociations(const GetVpcPrefixListAssociationsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getVpcPrefixListAssociationsWithOptions(request, runtime);
}

/**
 * @summary Queries the information about a prefix list.
 *
 * @param request GetVpcPrefixListEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVpcPrefixListEntriesResponse
 */
GetVpcPrefixListEntriesResponse Client::getVpcPrefixListEntriesWithOptions(const GetVpcPrefixListEntriesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPrefixListId()) {
    query["PrefixListId"] = request.prefixListId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetVpcPrefixListEntries"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetVpcPrefixListEntriesResponse>();
}

/**
 * @summary Queries the information about a prefix list.
 *
 * @param request GetVpcPrefixListEntriesRequest
 * @return GetVpcPrefixListEntriesResponse
 */
GetVpcPrefixListEntriesResponse Client::getVpcPrefixListEntries(const GetVpcPrefixListEntriesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getVpcPrefixListEntriesWithOptions(request, runtime);
}

/**
 * @summary 查询路由类型的明细。
 *
 * @param request GetVpcRouteEntrySummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVpcRouteEntrySummaryResponse
 */
GetVpcRouteEntrySummaryResponse Client::getVpcRouteEntrySummaryWithOptions(const GetVpcRouteEntrySummaryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteEntryType()) {
    query["RouteEntryType"] = request.routeEntryType();
  }

  if (!!request.hasRouteTableId()) {
    query["RouteTableId"] = request.routeTableId();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetVpcRouteEntrySummary"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetVpcRouteEntrySummaryResponse>();
}

/**
 * @summary 查询路由类型的明细。
 *
 * @param request GetVpcRouteEntrySummaryRequest
 * @return GetVpcRouteEntrySummaryResponse
 */
GetVpcRouteEntrySummaryResponse Client::getVpcRouteEntrySummary(const GetVpcRouteEntrySummaryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getVpcRouteEntrySummaryWithOptions(request, runtime);
}

/**
 * @summary Queries the diagnostic result of a VPN gateway.
 *
 * @description When you call the **GetVpnGatewayDiagnoseResult** operation, you must specify one of **DiagnoseId** and **VpnGatewayId**.
 *
 * @param request GetVpnGatewayDiagnoseResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVpnGatewayDiagnoseResultResponse
 */
GetVpnGatewayDiagnoseResultResponse Client::getVpnGatewayDiagnoseResultWithOptions(const GetVpnGatewayDiagnoseResultRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDiagnoseId()) {
    query["DiagnoseId"] = request.diagnoseId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetVpnGatewayDiagnoseResult"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetVpnGatewayDiagnoseResultResponse>();
}

/**
 * @summary Queries the diagnostic result of a VPN gateway.
 *
 * @description When you call the **GetVpnGatewayDiagnoseResult** operation, you must specify one of **DiagnoseId** and **VpnGatewayId**.
 *
 * @param request GetVpnGatewayDiagnoseResultRequest
 * @return GetVpnGatewayDiagnoseResultResponse
 */
GetVpnGatewayDiagnoseResultResponse Client::getVpnGatewayDiagnoseResult(const GetVpnGatewayDiagnoseResultRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getVpnGatewayDiagnoseResultWithOptions(request, runtime);
}

/**
 * @summary Grants permissions to a Cloud Enterprise Network (CEN) instance.
 *
 * @description *   Before you can attach a network instance that belongs to another Alibaba Cloud account to your CEN instance, you must grant permissions to your CEN instance.
 * >  **GrantInstanceToCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use the `vpc.aliyuncs.com` domain name to call this operation. The API version is `2016-04-28`.
 * *   You cannot repeatedly call the **GrantInstanceToCen** operation to grant the permissions on a network instance to a CEN instance. The network instance can be a VPC, a virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
 *
 * @param request GrantInstanceToCenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantInstanceToCenResponse
 */
GrantInstanceToCenResponse Client::grantInstanceToCenWithOptions(const GrantInstanceToCenRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCenId()) {
    query["CenId"] = request.cenId();
  }

  if (!!request.hasCenOwnerId()) {
    query["CenOwnerId"] = request.cenOwnerId();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasInstanceType()) {
    query["InstanceType"] = request.instanceType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GrantInstanceToCen"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GrantInstanceToCenResponse>();
}

/**
 * @summary Grants permissions to a Cloud Enterprise Network (CEN) instance.
 *
 * @description *   Before you can attach a network instance that belongs to another Alibaba Cloud account to your CEN instance, you must grant permissions to your CEN instance.
 * >  **GrantInstanceToCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use the `vpc.aliyuncs.com` domain name to call this operation. The API version is `2016-04-28`.
 * *   You cannot repeatedly call the **GrantInstanceToCen** operation to grant the permissions on a network instance to a CEN instance. The network instance can be a VPC, a virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
 *
 * @param request GrantInstanceToCenRequest
 * @return GrantInstanceToCenResponse
 */
GrantInstanceToCenResponse Client::grantInstanceToCen(const GrantInstanceToCenRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return grantInstanceToCenWithOptions(request, runtime);
}

/**
 * @summary Grants a virtual border router (VBR) the permissions to connect to a virtual private cloud (VPC) that belongs to another Alibaba Cloud account.
 *
 * @description ## Usage notes
 * When you connect a VBR to a VPC that belongs to another Alibaba Cloud account, the VBR must acquire the required permissions from the VPC.
 *
 * @param tmpReq GrantInstanceToVbrRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantInstanceToVbrResponse
 */
GrantInstanceToVbrResponse Client::grantInstanceToVbrWithOptions(const GrantInstanceToVbrRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  GrantInstanceToVbrShrinkRequest request = GrantInstanceToVbrShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasVbrInstanceIds()) {
    request.setVbrInstanceIdsShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.vbrInstanceIds(), "VbrInstanceIds", "simple"));
  }

  json query = {};
  if (!!request.hasGrantType()) {
    query["GrantType"] = request.grantType();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasVbrInstanceIdsShrink()) {
    query["VbrInstanceIds"] = request.vbrInstanceIdsShrink();
  }

  if (!!request.hasVbrOwnerUid()) {
    query["VbrOwnerUid"] = request.vbrOwnerUid();
  }

  if (!!request.hasVbrRegionNo()) {
    query["VbrRegionNo"] = request.vbrRegionNo();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GrantInstanceToVbr"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GrantInstanceToVbrResponse>();
}

/**
 * @summary Grants a virtual border router (VBR) the permissions to connect to a virtual private cloud (VPC) that belongs to another Alibaba Cloud account.
 *
 * @description ## Usage notes
 * When you connect a VBR to a VPC that belongs to another Alibaba Cloud account, the VBR must acquire the required permissions from the VPC.
 *
 * @param request GrantInstanceToVbrRequest
 * @return GrantInstanceToVbrResponse
 */
GrantInstanceToVbrResponse Client::grantInstanceToVbr(const GrantInstanceToVbrRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return grantInstanceToVbrWithOptions(request, runtime);
}

/**
 * @summary Queries the access points of an Express Connect circuit.
 *
 * @param request ListBusinessAccessPointsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListBusinessAccessPointsResponse
 */
ListBusinessAccessPointsResponse Client::listBusinessAccessPointsWithOptions(const ListBusinessAccessPointsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListBusinessAccessPoints"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListBusinessAccessPointsResponse>();
}

/**
 * @summary Queries the access points of an Express Connect circuit.
 *
 * @param request ListBusinessAccessPointsRequest
 * @return ListBusinessAccessPointsResponse
 */
ListBusinessAccessPointsResponse Client::listBusinessAccessPoints(const ListBusinessAccessPointsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listBusinessAccessPointsWithOptions(request, runtime);
}

/**
 * @summary Queries Dynamic Host Configuration Protocol (DHCP) options sets.
 *
 * @param request ListDhcpOptionsSetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDhcpOptionsSetsResponse
 */
ListDhcpOptionsSetsResponse Client::listDhcpOptionsSetsWithOptions(const ListDhcpOptionsSetsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDhcpOptionsSetId()) {
    query["DhcpOptionsSetId"] = request.dhcpOptionsSetId();
  }

  if (!!request.hasDhcpOptionsSetName()) {
    query["DhcpOptionsSetName"] = request.dhcpOptionsSetName();
  }

  if (!!request.hasDomainName()) {
    query["DomainName"] = request.domainName();
  }

  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListDhcpOptionsSets"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListDhcpOptionsSetsResponse>();
}

/**
 * @summary Queries Dynamic Host Configuration Protocol (DHCP) options sets.
 *
 * @param request ListDhcpOptionsSetsRequest
 * @return ListDhcpOptionsSetsResponse
 */
ListDhcpOptionsSetsResponse Client::listDhcpOptionsSets(const ListDhcpOptionsSetsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listDhcpOptionsSetsWithOptions(request, runtime);
}

/**
 * @summary Queries the zones that support NAT gateways.
 *
 * @description You can call this operation to query zones that support NAT gateways, including Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways.
 *
 * @param request ListEnhanhcedNatGatewayAvailableZonesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListEnhanhcedNatGatewayAvailableZonesResponse
 */
ListEnhanhcedNatGatewayAvailableZonesResponse Client::listEnhanhcedNatGatewayAvailableZonesWithOptions(const ListEnhanhcedNatGatewayAvailableZonesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAcceptLanguage()) {
    query["AcceptLanguage"] = request.acceptLanguage();
  }

  if (!!request.hasFilter()) {
    query["Filter"] = request.filter();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListEnhanhcedNatGatewayAvailableZones"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListEnhanhcedNatGatewayAvailableZonesResponse>();
}

/**
 * @summary Queries the zones that support NAT gateways.
 *
 * @description You can call this operation to query zones that support NAT gateways, including Internet NAT gateways and Virtual Private Cloud (VPC) NAT gateways.
 *
 * @param request ListEnhanhcedNatGatewayAvailableZonesRequest
 * @return ListEnhanhcedNatGatewayAvailableZonesResponse
 */
ListEnhanhcedNatGatewayAvailableZonesResponse Client::listEnhanhcedNatGatewayAvailableZones(const ListEnhanhcedNatGatewayAvailableZonesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listEnhanhcedNatGatewayAvailableZonesWithOptions(request, runtime);
}

/**
 * @summary Queries FULLNAT entries.
 *
 * @param request ListFullNatEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFullNatEntriesResponse
 */
ListFullNatEntriesResponse Client::listFullNatEntriesWithOptions(const ListFullNatEntriesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasFullNatEntryId()) {
    query["FullNatEntryId"] = request.fullNatEntryId();
  }

  if (!!request.hasFullNatEntryNames()) {
    query["FullNatEntryNames"] = request.fullNatEntryNames();
  }

  if (!!request.hasFullNatTableId()) {
    query["FullNatTableId"] = request.fullNatTableId();
  }

  if (!!request.hasIpProtocol()) {
    query["IpProtocol"] = request.ipProtocol();
  }

  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasNatIp()) {
    query["NatIp"] = request.natIp();
  }

  if (!!request.hasNatIpPort()) {
    query["NatIpPort"] = request.natIpPort();
  }

  if (!!request.hasNetworkInterfaceIds()) {
    query["NetworkInterfaceIds"] = request.networkInterfaceIds();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListFullNatEntries"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListFullNatEntriesResponse>();
}

/**
 * @summary Queries FULLNAT entries.
 *
 * @param request ListFullNatEntriesRequest
 * @return ListFullNatEntriesResponse
 */
ListFullNatEntriesResponse Client::listFullNatEntries(const ListFullNatEntriesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listFullNatEntriesWithOptions(request, runtime);
}

/**
 * @summary Queries route entries of a gateway route table.
 *
 * @param request ListGatewayRouteTableEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListGatewayRouteTableEntriesResponse
 */
ListGatewayRouteTableEntriesResponse Client::listGatewayRouteTableEntriesWithOptions(const ListGatewayRouteTableEntriesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDestinationCidrBlock()) {
    query["DestinationCidrBlock"] = request.destinationCidrBlock();
  }

  if (!!request.hasGatewayRouteTableId()) {
    query["GatewayRouteTableId"] = request.gatewayRouteTableId();
  }

  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListGatewayRouteTableEntries"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListGatewayRouteTableEntriesResponse>();
}

/**
 * @summary Queries route entries of a gateway route table.
 *
 * @param request ListGatewayRouteTableEntriesRequest
 * @return ListGatewayRouteTableEntriesResponse
 */
ListGatewayRouteTableEntriesResponse Client::listGatewayRouteTableEntries(const ListGatewayRouteTableEntriesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listGatewayRouteTableEntriesWithOptions(request, runtime);
}

/**
 * @summary Queries the most recent region list.
 *
 * @param request ListGeographicSubRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListGeographicSubRegionsResponse
 */
ListGeographicSubRegionsResponse Client::listGeographicSubRegionsWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "ListGeographicSubRegions"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListGeographicSubRegionsResponse>();
}

/**
 * @summary Queries the most recent region list.
 *
 * @return ListGeographicSubRegionsResponse
 */
ListGeographicSubRegionsResponse Client::listGeographicSubRegions() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listGeographicSubRegionsWithOptions(runtime);
}

/**
 * @summary Queries the logs of an IPsec server.
 *
 * @param request ListIpsecServerLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListIpsecServerLogsResponse
 */
ListIpsecServerLogsResponse Client::listIpsecServerLogsWithOptions(const ListIpsecServerLogsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasIpsecServerId()) {
    query["IpsecServerId"] = request.ipsecServerId();
  }

  if (!!request.hasMinutePeriod()) {
    query["MinutePeriod"] = request.minutePeriod();
  }

  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasTo()) {
    query["To"] = request.to();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListIpsecServerLogs"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListIpsecServerLogsResponse>();
}

/**
 * @summary Queries the logs of an IPsec server.
 *
 * @param request ListIpsecServerLogsRequest
 * @return ListIpsecServerLogsResponse
 */
ListIpsecServerLogsResponse Client::listIpsecServerLogs(const ListIpsecServerLogsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listIpsecServerLogsWithOptions(request, runtime);
}

/**
 * @summary Queries IPsec servers.
 *
 * @param request ListIpsecServersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListIpsecServersResponse
 */
ListIpsecServersResponse Client::listIpsecServersWithOptions(const ListIpsecServersRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIpsecServerId()) {
    query["IpsecServerId"] = request.ipsecServerId();
  }

  if (!!request.hasIpsecServerName()) {
    query["IpsecServerName"] = request.ipsecServerName();
  }

  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListIpsecServers"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListIpsecServersResponse>();
}

/**
 * @summary Queries IPsec servers.
 *
 * @param request ListIpsecServersRequest
 * @return ListIpsecServersResponse
 */
ListIpsecServersResponse Client::listIpsecServers(const ListIpsecServersRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listIpsecServersWithOptions(request, runtime);
}

/**
 * @summary Queries IPv4 gateways.
 *
 * @param request ListIpv4GatewaysRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListIpv4GatewaysResponse
 */
ListIpv4GatewaysResponse Client::listIpv4GatewaysWithOptions(const ListIpv4GatewaysRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIpv4GatewayId()) {
    query["Ipv4GatewayId"] = request.ipv4GatewayId();
  }

  if (!!request.hasIpv4GatewayName()) {
    query["Ipv4GatewayName"] = request.ipv4GatewayName();
  }

  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListIpv4Gateways"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListIpv4GatewaysResponse>();
}

/**
 * @summary Queries IPv4 gateways.
 *
 * @param request ListIpv4GatewaysRequest
 * @return ListIpv4GatewaysResponse
 */
ListIpv4GatewaysResponse Client::listIpv4Gateways(const ListIpv4GatewaysRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listIpv4GatewaysWithOptions(request, runtime);
}

/**
 * @summary Queries the CIDR blocks of a specified NAT gateway.
 *
 * @param request ListNatIpCidrsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListNatIpCidrsResponse
 */
ListNatIpCidrsResponse Client::listNatIpCidrsWithOptions(const ListNatIpCidrsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasNatIpCidr()) {
    query["NatIpCidr"] = request.natIpCidr();
  }

  if (!!request.hasNatIpCidrName()) {
    query["NatIpCidrName"] = request.natIpCidrName();
  }

  if (!!request.hasNatIpCidrStatus()) {
    query["NatIpCidrStatus"] = request.natIpCidrStatus();
  }

  if (!!request.hasNatIpCidrs()) {
    query["NatIpCidrs"] = request.natIpCidrs();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListNatIpCidrs"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListNatIpCidrsResponse>();
}

/**
 * @summary Queries the CIDR blocks of a specified NAT gateway.
 *
 * @param request ListNatIpCidrsRequest
 * @return ListNatIpCidrsResponse
 */
ListNatIpCidrsResponse Client::listNatIpCidrs(const ListNatIpCidrsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listNatIpCidrsWithOptions(request, runtime);
}

/**
 * @summary Queries the IP addresses on a NAT gateway.
 *
 * @param request ListNatIpsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListNatIpsResponse
 */
ListNatIpsResponse Client::listNatIpsWithOptions(const ListNatIpsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasNatIpCidr()) {
    query["NatIpCidr"] = request.natIpCidr();
  }

  if (!!request.hasNatIpIds()) {
    query["NatIpIds"] = request.natIpIds();
  }

  if (!!request.hasNatIpName()) {
    query["NatIpName"] = request.natIpName();
  }

  if (!!request.hasNatIpStatus()) {
    query["NatIpStatus"] = request.natIpStatus();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListNatIps"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListNatIpsResponse>();
}

/**
 * @summary Queries the IP addresses on a NAT gateway.
 *
 * @param request ListNatIpsRequest
 * @return ListNatIpsResponse
 */
ListNatIpsResponse Client::listNatIps(const ListNatIpsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listNatIpsWithOptions(request, runtime);
}

/**
 * @summary Queries prefix lists.
 *
 * @param request ListPrefixListsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPrefixListsResponse
 */
ListPrefixListsResponse Client::listPrefixListsWithOptions(const ListPrefixListsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPrefixListIds()) {
    query["PrefixListIds"] = request.prefixListIds();
  }

  if (!!request.hasPrefixListName()) {
    query["PrefixListName"] = request.prefixListName();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListPrefixLists"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListPrefixListsResponse>();
}

/**
 * @summary Queries prefix lists.
 *
 * @param request ListPrefixListsRequest
 * @return ListPrefixListsResponse
 */
ListPrefixListsResponse Client::listPrefixLists(const ListPrefixListsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listPrefixListsWithOptions(request, runtime);
}

/**
 * @summary 查询IP地址池中的IP地址网段信息
 *
 * @param request ListPublicIpAddressPoolCidrBlocksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPublicIpAddressPoolCidrBlocksResponse
 */
ListPublicIpAddressPoolCidrBlocksResponse Client::listPublicIpAddressPoolCidrBlocksWithOptions(const ListPublicIpAddressPoolCidrBlocksRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCidrBlock()) {
    query["CidrBlock"] = request.cidrBlock();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPublicIpAddressPoolId()) {
    query["PublicIpAddressPoolId"] = request.publicIpAddressPoolId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListPublicIpAddressPoolCidrBlocks"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListPublicIpAddressPoolCidrBlocksResponse>();
}

/**
 * @summary 查询IP地址池中的IP地址网段信息
 *
 * @param request ListPublicIpAddressPoolCidrBlocksRequest
 * @return ListPublicIpAddressPoolCidrBlocksResponse
 */
ListPublicIpAddressPoolCidrBlocksResponse Client::listPublicIpAddressPoolCidrBlocks(const ListPublicIpAddressPoolCidrBlocksRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listPublicIpAddressPoolCidrBlocksWithOptions(request, runtime);
}

/**
 * @summary Queries available IP address pools.
 *
 * @param request ListPublicIpAddressPoolsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPublicIpAddressPoolsResponse
 */
ListPublicIpAddressPoolsResponse Client::listPublicIpAddressPoolsWithOptions(const ListPublicIpAddressPoolsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIsp()) {
    query["Isp"] = request.isp();
  }

  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPublicIpAddressPoolIds()) {
    query["PublicIpAddressPoolIds"] = request.publicIpAddressPoolIds();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSecurityProtectionEnabled()) {
    query["SecurityProtectionEnabled"] = request.securityProtectionEnabled();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListPublicIpAddressPools"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListPublicIpAddressPoolsResponse>();
}

/**
 * @summary Queries available IP address pools.
 *
 * @param request ListPublicIpAddressPoolsRequest
 * @return ListPublicIpAddressPoolsResponse
 */
ListPublicIpAddressPoolsResponse Client::listPublicIpAddressPools(const ListPublicIpAddressPoolsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listPublicIpAddressPoolsWithOptions(request, runtime);
}

/**
 * @summary Queries the tags that are added to resources.
 *
 * @description ## Usage notes
 * *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
 * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
 * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
 *
 * @param request ListTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
ListTagResourcesResponse Client::listTagResourcesWithOptions(const ListTagResourcesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceId()) {
    query["ResourceId"] = request.resourceId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasResourceType()) {
    query["ResourceType"] = request.resourceType();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListTagResources"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListTagResourcesResponse>();
}

/**
 * @summary Queries the tags that are added to resources.
 *
 * @description ## Usage notes
 * *   You must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object that you want to query.
 * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
 * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
ListTagResourcesResponse Client::listTagResources(const ListTagResourcesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listTagResourcesWithOptions(request, runtime);
}

/**
 * @summary Queries the tags that are added to an Express Connect circuit.
 *
 * @description ## [](#)
 * *   If you want to query a specific object, you must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request.
 * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
 * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
 *
 * @param request ListTagResourcesForExpressConnectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesForExpressConnectResponse
 */
ListTagResourcesForExpressConnectResponse Client::listTagResourcesForExpressConnectWithOptions(const ListTagResourcesForExpressConnectRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceId()) {
    query["ResourceId"] = request.resourceId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasResourceType()) {
    query["ResourceType"] = request.resourceType();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListTagResourcesForExpressConnect"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListTagResourcesForExpressConnectResponse>();
}

/**
 * @summary Queries the tags that are added to an Express Connect circuit.
 *
 * @description ## [](#)
 * *   If you want to query a specific object, you must specify **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request.
 * *   **Tag.N** is a resource tag that consists of a key-value pair. If you specify only **Tag.N.Key**, all tag values that are associated with the specified key are returned. If you specify only **Tag.N.Value**, an error message is returned.
 * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
 *
 * @param request ListTagResourcesForExpressConnectRequest
 * @return ListTagResourcesForExpressConnectResponse
 */
ListTagResourcesForExpressConnectResponse Client::listTagResourcesForExpressConnect(const ListTagResourcesForExpressConnectRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listTagResourcesForExpressConnectWithOptions(request, runtime);
}

/**
 * @summary Queries filters for traffic mirror.
 *
 * @param request ListTrafficMirrorFiltersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTrafficMirrorFiltersResponse
 */
ListTrafficMirrorFiltersResponse Client::listTrafficMirrorFiltersWithOptions(const ListTrafficMirrorFiltersRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  if (!!request.hasTrafficMirrorFilterIds()) {
    query["TrafficMirrorFilterIds"] = request.trafficMirrorFilterIds();
  }

  if (!!request.hasTrafficMirrorFilterName()) {
    query["TrafficMirrorFilterName"] = request.trafficMirrorFilterName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListTrafficMirrorFilters"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListTrafficMirrorFiltersResponse>();
}

/**
 * @summary Queries filters for traffic mirror.
 *
 * @param request ListTrafficMirrorFiltersRequest
 * @return ListTrafficMirrorFiltersResponse
 */
ListTrafficMirrorFiltersResponse Client::listTrafficMirrorFilters(const ListTrafficMirrorFiltersRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listTrafficMirrorFiltersWithOptions(request, runtime);
}

/**
 * @summary Queries the details of a traffic mirror session.
 *
 * @param request ListTrafficMirrorSessionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTrafficMirrorSessionsResponse
 */
ListTrafficMirrorSessionsResponse Client::listTrafficMirrorSessionsWithOptions(const ListTrafficMirrorSessionsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEnabled()) {
    query["Enabled"] = request.enabled();
  }

  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPriority()) {
    query["Priority"] = request.priority();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  if (!!request.hasTrafficMirrorFilterId()) {
    query["TrafficMirrorFilterId"] = request.trafficMirrorFilterId();
  }

  if (!!request.hasTrafficMirrorSessionIds()) {
    query["TrafficMirrorSessionIds"] = request.trafficMirrorSessionIds();
  }

  if (!!request.hasTrafficMirrorSessionName()) {
    query["TrafficMirrorSessionName"] = request.trafficMirrorSessionName();
  }

  if (!!request.hasTrafficMirrorSourceId()) {
    query["TrafficMirrorSourceId"] = request.trafficMirrorSourceId();
  }

  if (!!request.hasTrafficMirrorTargetId()) {
    query["TrafficMirrorTargetId"] = request.trafficMirrorTargetId();
  }

  if (!!request.hasVirtualNetworkId()) {
    query["VirtualNetworkId"] = request.virtualNetworkId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListTrafficMirrorSessions"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListTrafficMirrorSessionsResponse>();
}

/**
 * @summary Queries the details of a traffic mirror session.
 *
 * @param request ListTrafficMirrorSessionsRequest
 * @return ListTrafficMirrorSessionsResponse
 */
ListTrafficMirrorSessionsResponse Client::listTrafficMirrorSessions(const ListTrafficMirrorSessionsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listTrafficMirrorSessionsWithOptions(request, runtime);
}

/**
 * @summary Queries the CIDR reservation information about vSwitches.
 *
 * @param request ListVSwitchCidrReservationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVSwitchCidrReservationsResponse
 */
ListVSwitchCidrReservationsResponse Client::listVSwitchCidrReservationsWithOptions(const ListVSwitchCidrReservationsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIpVersion()) {
    query["IpVersion"] = request.ipVersion();
  }

  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  if (!!request.hasVSwitchCidrReservationIds()) {
    query["VSwitchCidrReservationIds"] = request.vSwitchCidrReservationIds();
  }

  if (!!request.hasVSwitchCidrReservationType()) {
    query["VSwitchCidrReservationType"] = request.vSwitchCidrReservationType();
  }

  if (!!request.hasVSwitchId()) {
    query["VSwitchId"] = request.vSwitchId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListVSwitchCidrReservations"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListVSwitchCidrReservationsResponse>();
}

/**
 * @summary Queries the CIDR reservation information about vSwitches.
 *
 * @param request ListVSwitchCidrReservationsRequest
 * @return ListVSwitchCidrReservationsResponse
 */
ListVSwitchCidrReservationsResponse Client::listVSwitchCidrReservations(const ListVSwitchCidrReservationsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listVSwitchCidrReservationsWithOptions(request, runtime);
}

/**
 * @summary Queries hosted connections.
 *
 * @param request ListVirtualPhysicalConnectionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVirtualPhysicalConnectionsResponse
 */
ListVirtualPhysicalConnectionsResponse Client::listVirtualPhysicalConnectionsWithOptions(const ListVirtualPhysicalConnectionsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIsConfirmed()) {
    query["IsConfirmed"] = request.isConfirmed();
  }

  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasPhysicalConnectionId()) {
    query["PhysicalConnectionId"] = request.physicalConnectionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  if (!!request.hasVirtualPhysicalConnectionAliUids()) {
    query["VirtualPhysicalConnectionAliUids"] = request.virtualPhysicalConnectionAliUids();
  }

  if (!!request.hasVirtualPhysicalConnectionBusinessStatus()) {
    query["VirtualPhysicalConnectionBusinessStatus"] = request.virtualPhysicalConnectionBusinessStatus();
  }

  if (!!request.hasVirtualPhysicalConnectionIds()) {
    query["VirtualPhysicalConnectionIds"] = request.virtualPhysicalConnectionIds();
  }

  if (!!request.hasVirtualPhysicalConnectionStatuses()) {
    query["VirtualPhysicalConnectionStatuses"] = request.virtualPhysicalConnectionStatuses();
  }

  if (!!request.hasVlanIds()) {
    query["VlanIds"] = request.vlanIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListVirtualPhysicalConnections"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListVirtualPhysicalConnectionsResponse>();
}

/**
 * @summary Queries hosted connections.
 *
 * @param request ListVirtualPhysicalConnectionsRequest
 * @return ListVirtualPhysicalConnectionsResponse
 */
ListVirtualPhysicalConnectionsResponse Client::listVirtualPhysicalConnections(const ListVirtualPhysicalConnectionsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listVirtualPhysicalConnectionsWithOptions(request, runtime);
}

/**
 * @summary Queries available endpoint services.
 *
 * @param request ListVpcEndpointServicesByEndUserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVpcEndpointServicesByEndUserResponse
 */
ListVpcEndpointServicesByEndUserResponse Client::listVpcEndpointServicesByEndUserWithOptions(const ListVpcEndpointServicesByEndUserRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasServiceName()) {
    query["ServiceName"] = request.serviceName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListVpcEndpointServicesByEndUser"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListVpcEndpointServicesByEndUserResponse>();
}

/**
 * @summary Queries available endpoint services.
 *
 * @param request ListVpcEndpointServicesByEndUserRequest
 * @return ListVpcEndpointServicesByEndUserResponse
 */
ListVpcEndpointServicesByEndUserResponse Client::listVpcEndpointServicesByEndUser(const ListVpcEndpointServicesByEndUserRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listVpcEndpointServicesByEndUserWithOptions(request, runtime);
}

/**
 * @summary Queries gateway endpoints.
 *
 * @param request ListVpcGatewayEndpointsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVpcGatewayEndpointsResponse
 */
ListVpcGatewayEndpointsResponse Client::listVpcGatewayEndpointsWithOptions(const ListVpcGatewayEndpointsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEndpointId()) {
    query["EndpointId"] = request.endpointId();
  }

  if (!!request.hasEndpointName()) {
    query["EndpointName"] = request.endpointName();
  }

  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasServiceName()) {
    query["ServiceName"] = request.serviceName();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListVpcGatewayEndpoints"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListVpcGatewayEndpointsResponse>();
}

/**
 * @summary Queries gateway endpoints.
 *
 * @param request ListVpcGatewayEndpointsRequest
 * @return ListVpcGatewayEndpointsResponse
 */
ListVpcGatewayEndpointsResponse Client::listVpcGatewayEndpoints(const ListVpcGatewayEndpointsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listVpcGatewayEndpointsWithOptions(request, runtime);
}

/**
 * @summary Queries advertised routes.
 *
 * @param request ListVpcPublishedRouteEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVpcPublishedRouteEntriesResponse
 */
ListVpcPublishedRouteEntriesResponse Client::listVpcPublishedRouteEntriesWithOptions(const ListVpcPublishedRouteEntriesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDestinationCidrBlock()) {
    query["DestinationCidrBlock"] = request.destinationCidrBlock();
  }

  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteTableId()) {
    query["RouteTableId"] = request.routeTableId();
  }

  if (!!request.hasTargetInstanceId()) {
    query["TargetInstanceId"] = request.targetInstanceId();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListVpcPublishedRouteEntries"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListVpcPublishedRouteEntriesResponse>();
}

/**
 * @summary Queries advertised routes.
 *
 * @param request ListVpcPublishedRouteEntriesRequest
 * @return ListVpcPublishedRouteEntriesResponse
 */
ListVpcPublishedRouteEntriesResponse Client::listVpcPublishedRouteEntries(const ListVpcPublishedRouteEntriesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listVpcPublishedRouteEntriesWithOptions(request, runtime);
}

/**
 * @summary Queries the association between VPN gateways and certificates in a region.
 *
 * @description When you call **ListVpnCertificateAssociations**, take note of the following information:
 * *   If you specify only **RegionId**, the SSL certificates associated with all VPN gateways in the specified region are queried.
 * *   If you specify **RegionId** and **CertificateType**, the SSL certificates of the specified type that are associated with the VPN gateways in the specified region are queried.
 * *   If you specify **RegionId** and **VpnGatewayId**, the SSL certificates associated with the specified VPN gateway in the specified region are queried.
 * *   If you specify **RegionId** and **CertificateId**, the VPN gateways associated with the specified SSL certificate in the specified region are queried.
 *
 * @param request ListVpnCertificateAssociationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVpnCertificateAssociationsResponse
 */
ListVpnCertificateAssociationsResponse Client::listVpnCertificateAssociationsWithOptions(const ListVpnCertificateAssociationsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCertificateId()) {
    query["CertificateId"] = request.certificateId();
  }

  if (!!request.hasCertificateType()) {
    query["CertificateType"] = request.certificateType();
  }

  if (!!request.hasMaxResults()) {
    query["MaxResults"] = request.maxResults();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListVpnCertificateAssociations"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListVpnCertificateAssociationsResponse>();
}

/**
 * @summary Queries the association between VPN gateways and certificates in a region.
 *
 * @description When you call **ListVpnCertificateAssociations**, take note of the following information:
 * *   If you specify only **RegionId**, the SSL certificates associated with all VPN gateways in the specified region are queried.
 * *   If you specify **RegionId** and **CertificateType**, the SSL certificates of the specified type that are associated with the VPN gateways in the specified region are queried.
 * *   If you specify **RegionId** and **VpnGatewayId**, the SSL certificates associated with the specified VPN gateway in the specified region are queried.
 * *   If you specify **RegionId** and **CertificateId**, the VPN gateways associated with the specified SSL certificate in the specified region are queried.
 *
 * @param request ListVpnCertificateAssociationsRequest
 * @return ListVpnCertificateAssociationsResponse
 */
ListVpnCertificateAssociationsResponse Client::listVpnCertificateAssociations(const ListVpnCertificateAssociationsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listVpnCertificateAssociationsWithOptions(request, runtime);
}

/**
 * @summary Modifies the configuration of a Border Gateway Protocol (BGP) group.
 *
 * @param request ModifyBgpGroupAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyBgpGroupAttributeResponse
 */
ModifyBgpGroupAttributeResponse Client::modifyBgpGroupAttributeWithOptions(const ModifyBgpGroupAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAuthKey()) {
    query["AuthKey"] = request.authKey();
  }

  if (!!request.hasBgpGroupId()) {
    query["BgpGroupId"] = request.bgpGroupId();
  }

  if (!!request.hasClearAuthKey()) {
    query["ClearAuthKey"] = request.clearAuthKey();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasIsFakeAsn()) {
    query["IsFakeAsn"] = request.isFakeAsn();
  }

  if (!!request.hasLocalAsn()) {
    query["LocalAsn"] = request.localAsn();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPeerAsn()) {
    query["PeerAsn"] = request.peerAsn();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteQuota()) {
    query["RouteQuota"] = request.routeQuota();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyBgpGroupAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyBgpGroupAttributeResponse>();
}

/**
 * @summary Modifies the configuration of a Border Gateway Protocol (BGP) group.
 *
 * @param request ModifyBgpGroupAttributeRequest
 * @return ModifyBgpGroupAttributeResponse
 */
ModifyBgpGroupAttributeResponse Client::modifyBgpGroupAttribute(const ModifyBgpGroupAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyBgpGroupAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the configuration of a BGP peer.
 *
 * @param request ModifyBgpPeerAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyBgpPeerAttributeResponse
 */
ModifyBgpPeerAttributeResponse Client::modifyBgpPeerAttributeWithOptions(const ModifyBgpPeerAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBfdMultiHop()) {
    query["BfdMultiHop"] = request.bfdMultiHop();
  }

  if (!!request.hasBgpGroupId()) {
    query["BgpGroupId"] = request.bgpGroupId();
  }

  if (!!request.hasBgpPeerId()) {
    query["BgpPeerId"] = request.bgpPeerId();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasEnableBfd()) {
    query["EnableBfd"] = request.enableBfd();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPeerIpAddress()) {
    query["PeerIpAddress"] = request.peerIpAddress();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyBgpPeerAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyBgpPeerAttributeResponse>();
}

/**
 * @summary Modifies the configuration of a BGP peer.
 *
 * @param request ModifyBgpPeerAttributeRequest
 * @return ModifyBgpPeerAttributeResponse
 */
ModifyBgpPeerAttributeResponse Client::modifyBgpPeerAttribute(const ModifyBgpPeerAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyBgpPeerAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the name and description of an EIP bandwidth plan.
 *
 * @param request ModifyCommonBandwidthPackageAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCommonBandwidthPackageAttributeResponse
 */
ModifyCommonBandwidthPackageAttributeResponse Client::modifyCommonBandwidthPackageAttributeWithOptions(const ModifyCommonBandwidthPackageAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidthPackageId()) {
    query["BandwidthPackageId"] = request.bandwidthPackageId();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyCommonBandwidthPackageAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyCommonBandwidthPackageAttributeResponse>();
}

/**
 * @summary Modifies the name and description of an EIP bandwidth plan.
 *
 * @param request ModifyCommonBandwidthPackageAttributeRequest
 * @return ModifyCommonBandwidthPackageAttributeResponse
 */
ModifyCommonBandwidthPackageAttributeResponse Client::modifyCommonBandwidthPackageAttribute(const ModifyCommonBandwidthPackageAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyCommonBandwidthPackageAttributeWithOptions(request, runtime);
}

/**
 * @summary Sets the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance.
 *
 * @description You can call the **ModifyCommonBandwidthPackageIpBandwidth** operation to set the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance. This prevents an EIP from exhausting the bandwidth resources of an Internet Shared Bandwidth instance.
 * For example, two EIPs are associated with an Internet Shared Bandwidth instance whose maximum bandwidth is 800 Mbit/s. In this case, you can set the maximum bandwidth of one EIP to 500 Mbit/s and that of the other EIP to 400 Mbit/s. After you set the maximum bandwidth values, the first EIP cannot consume bandwidth higher than 500 Mbit/s. The second EIP cannot consume bandwidth higher than 400 Mbit/s.
 * When you call this operation, take note of the following items:
 * *   This operation is valid only for EIPs that are associated with Elastic Compute Service (ECS) instances. This operation is invalid for EIPs that are associated with Server Load Balancer (SLB) instances, NAT gateways, secondary elastic network interfaces (ENIs), or high-availability virtual IP addresses (HAVIPs).
 * *   This operation is in public preview. You can call this operation to set the maximum bandwidth of EIPs only if the EIPs are associated with an Internet Shared Bandwidth instance. The feature is not supported in the console.
 * *   You cannot repeatedly call this operation to set the maximum bandwidth of an EIP within the specified period of time.
 *
 * @param request ModifyCommonBandwidthPackageIpBandwidthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCommonBandwidthPackageIpBandwidthResponse
 */
ModifyCommonBandwidthPackageIpBandwidthResponse Client::modifyCommonBandwidthPackageIpBandwidthWithOptions(const ModifyCommonBandwidthPackageIpBandwidthRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasBandwidthPackageId()) {
    query["BandwidthPackageId"] = request.bandwidthPackageId();
  }

  if (!!request.hasEipId()) {
    query["EipId"] = request.eipId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyCommonBandwidthPackageIpBandwidth"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyCommonBandwidthPackageIpBandwidthResponse>();
}

/**
 * @summary Sets the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance.
 *
 * @description You can call the **ModifyCommonBandwidthPackageIpBandwidth** operation to set the maximum bandwidth of an EIP that is associated with an Internet Shared Bandwidth instance. This prevents an EIP from exhausting the bandwidth resources of an Internet Shared Bandwidth instance.
 * For example, two EIPs are associated with an Internet Shared Bandwidth instance whose maximum bandwidth is 800 Mbit/s. In this case, you can set the maximum bandwidth of one EIP to 500 Mbit/s and that of the other EIP to 400 Mbit/s. After you set the maximum bandwidth values, the first EIP cannot consume bandwidth higher than 500 Mbit/s. The second EIP cannot consume bandwidth higher than 400 Mbit/s.
 * When you call this operation, take note of the following items:
 * *   This operation is valid only for EIPs that are associated with Elastic Compute Service (ECS) instances. This operation is invalid for EIPs that are associated with Server Load Balancer (SLB) instances, NAT gateways, secondary elastic network interfaces (ENIs), or high-availability virtual IP addresses (HAVIPs).
 * *   This operation is in public preview. You can call this operation to set the maximum bandwidth of EIPs only if the EIPs are associated with an Internet Shared Bandwidth instance. The feature is not supported in the console.
 * *   You cannot repeatedly call this operation to set the maximum bandwidth of an EIP within the specified period of time.
 *
 * @param request ModifyCommonBandwidthPackageIpBandwidthRequest
 * @return ModifyCommonBandwidthPackageIpBandwidthResponse
 */
ModifyCommonBandwidthPackageIpBandwidthResponse Client::modifyCommonBandwidthPackageIpBandwidth(const ModifyCommonBandwidthPackageIpBandwidthRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyCommonBandwidthPackageIpBandwidthWithOptions(request, runtime);
}

/**
 * @summary Modifies the maximum bandwidth of an Internet Shared Bandwidth instance.
 *
 * @description Before you call this operation, take note of the following items:
 * *   **ModifyCommonBandwidthPackageSpec** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the task.
 *     *   If the Internet Shared Bandwidth instance is in the **Modifying** state, the maximum bandwidth of the Internet Shared Bandwidth instance is being modified. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
 *     *   If the Internet Shared Bandwidth instance is in the **Available** state, the maximum bandwidth of the Internet Shared Bandwidth instance is modified.
 * *   You cannot repeatedly call the **ModifyCommonBandwidthPackageSpec** operation to modify the maximum bandwidth of an Internet Shared Bandwidth instance within the specified period of time.
 *
 * @param request ModifyCommonBandwidthPackageSpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCommonBandwidthPackageSpecResponse
 */
ModifyCommonBandwidthPackageSpecResponse Client::modifyCommonBandwidthPackageSpecWithOptions(const ModifyCommonBandwidthPackageSpecRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasBandwidthPackageId()) {
    query["BandwidthPackageId"] = request.bandwidthPackageId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyCommonBandwidthPackageSpec"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyCommonBandwidthPackageSpecResponse>();
}

/**
 * @summary Modifies the maximum bandwidth of an Internet Shared Bandwidth instance.
 *
 * @description Before you call this operation, take note of the following items:
 * *   **ModifyCommonBandwidthPackageSpec** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCommonBandwidthPackages](https://help.aliyun.com/document_detail/120309.html) operation to query the status of the task.
 *     *   If the Internet Shared Bandwidth instance is in the **Modifying** state, the maximum bandwidth of the Internet Shared Bandwidth instance is being modified. In this state, you can only query the Internet Shared Bandwidth instance and cannot perform other operations.
 *     *   If the Internet Shared Bandwidth instance is in the **Available** state, the maximum bandwidth of the Internet Shared Bandwidth instance is modified.
 * *   You cannot repeatedly call the **ModifyCommonBandwidthPackageSpec** operation to modify the maximum bandwidth of an Internet Shared Bandwidth instance within the specified period of time.
 *
 * @param request ModifyCommonBandwidthPackageSpecRequest
 * @return ModifyCommonBandwidthPackageSpecResponse
 */
ModifyCommonBandwidthPackageSpecResponse Client::modifyCommonBandwidthPackageSpec(const ModifyCommonBandwidthPackageSpecRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyCommonBandwidthPackageSpecWithOptions(request, runtime);
}

/**
 * @summary Modifies the configuration of a customer gateway.
 *
 * @description *   When you call **ModifyCustomerGatewayAttribute**, if a value is assigned to **AuthKey**, the operation is asynchronous. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
 *     *   If a VPN gateway is in the **updating** state, the configurations are being modified.
 *     *   If a VPN gateway is in the **active** state, the configurations are modified.
 * *   When you call **ModifyCustomerGatewayAttribute**, if no value is assigned to **AuthKey**, the operation is synchronous.
 * *   You cannot repeatedly call **ModifyCustomerGatewayAttribute** to modify the configurations of a customer gateway within the specified period of time.
 *
 * @param request ModifyCustomerGatewayAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCustomerGatewayAttributeResponse
 */
ModifyCustomerGatewayAttributeResponse Client::modifyCustomerGatewayAttributeWithOptions(const ModifyCustomerGatewayAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAuthKey()) {
    query["AuthKey"] = request.authKey();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasCustomerGatewayId()) {
    query["CustomerGatewayId"] = request.customerGatewayId();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyCustomerGatewayAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyCustomerGatewayAttributeResponse>();
}

/**
 * @summary Modifies the configuration of a customer gateway.
 *
 * @description *   When you call **ModifyCustomerGatewayAttribute**, if a value is assigned to **AuthKey**, the operation is asynchronous. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
 *     *   If a VPN gateway is in the **updating** state, the configurations are being modified.
 *     *   If a VPN gateway is in the **active** state, the configurations are modified.
 * *   When you call **ModifyCustomerGatewayAttribute**, if no value is assigned to **AuthKey**, the operation is synchronous.
 * *   You cannot repeatedly call **ModifyCustomerGatewayAttribute** to modify the configurations of a customer gateway within the specified period of time.
 *
 * @param request ModifyCustomerGatewayAttributeRequest
 * @return ModifyCustomerGatewayAttributeResponse
 */
ModifyCustomerGatewayAttributeResponse Client::modifyCustomerGatewayAttribute(const ModifyCustomerGatewayAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyCustomerGatewayAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the name, description, and maximum bandwidth of an elastic IP address (EIP).
 *
 * @param request ModifyEipAddressAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyEipAddressAttributeResponse
 */
ModifyEipAddressAttributeResponse Client::modifyEipAddressAttributeWithOptions(const ModifyEipAddressAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAllocationId()) {
    query["AllocationId"] = request.allocationId();
  }

  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyEipAddressAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyEipAddressAttributeResponse>();
}

/**
 * @summary Modifies the name, description, and maximum bandwidth of an elastic IP address (EIP).
 *
 * @param request ModifyEipAddressAttributeRequest
 * @return ModifyEipAddressAttributeResponse
 */
ModifyEipAddressAttributeResponse Client::modifyEipAddressAttribute(const ModifyEipAddressAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyEipAddressAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the EIP forwarding mode.
 *
 * @param request ModifyEipForwardModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyEipForwardModeResponse
 */
ModifyEipForwardModeResponse Client::modifyEipForwardModeWithOptions(const ModifyEipForwardModeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasMode()) {
    query["Mode"] = request.mode();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyEipForwardMode"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyEipForwardModeResponse>();
}

/**
 * @summary Modifies the EIP forwarding mode.
 *
 * @param request ModifyEipForwardModeRequest
 * @return ModifyEipForwardModeResponse
 */
ModifyEipForwardModeResponse Client::modifyEipForwardMode(const ModifyEipForwardModeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyEipForwardModeWithOptions(request, runtime);
}

/**
 * @summary Modifies the configuration of an Express Cloud Connect (ECC) instance.
 *
 * @param request ModifyExpressCloudConnectionAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyExpressCloudConnectionAttributeResponse
 */
ModifyExpressCloudConnectionAttributeResponse Client::modifyExpressCloudConnectionAttributeWithOptions(const ModifyExpressCloudConnectionAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBgpAs()) {
    query["BgpAs"] = request.bgpAs();
  }

  if (!!request.hasCeIp()) {
    query["CeIp"] = request.ceIp();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasEccId()) {
    query["EccId"] = request.eccId();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPeIp()) {
    query["PeIp"] = request.peIp();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyExpressCloudConnectionAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyExpressCloudConnectionAttributeResponse>();
}

/**
 * @summary Modifies the configuration of an Express Cloud Connect (ECC) instance.
 *
 * @param request ModifyExpressCloudConnectionAttributeRequest
 * @return ModifyExpressCloudConnectionAttributeResponse
 */
ModifyExpressCloudConnectionAttributeResponse Client::modifyExpressCloudConnectionAttribute(const ModifyExpressCloudConnectionAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyExpressCloudConnectionAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the bandwidth of an Express Cloud Connect (ECC) instance.
 *
 * @param request ModifyExpressCloudConnectionBandwidthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyExpressCloudConnectionBandwidthResponse
 */
ModifyExpressCloudConnectionBandwidthResponse Client::modifyExpressCloudConnectionBandwidthWithOptions(const ModifyExpressCloudConnectionBandwidthRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasEccId()) {
    query["EccId"] = request.eccId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyExpressCloudConnectionBandwidth"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyExpressCloudConnectionBandwidthResponse>();
}

/**
 * @summary Modifies the bandwidth of an Express Cloud Connect (ECC) instance.
 *
 * @param request ModifyExpressCloudConnectionBandwidthRequest
 * @return ModifyExpressCloudConnectionBandwidthResponse
 */
ModifyExpressCloudConnectionBandwidthResponse Client::modifyExpressCloudConnectionBandwidth(const ModifyExpressCloudConnectionBandwidthRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyExpressCloudConnectionBandwidthWithOptions(request, runtime);
}

/**
 * @summary Modifies a quality of service (QoS) policy or associates a QoS policy with a dedicated Express Connect circuit.
 *
 * @param request ModifyExpressConnectTrafficQosRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyExpressConnectTrafficQosResponse
 */
ModifyExpressConnectTrafficQosResponse Client::modifyExpressConnectTrafficQosWithOptions(const ModifyExpressConnectTrafficQosRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAddInstanceList()) {
    query["AddInstanceList"] = request.addInstanceList();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasQosDescription()) {
    query["QosDescription"] = request.qosDescription();
  }

  if (!!request.hasQosId()) {
    query["QosId"] = request.qosId();
  }

  if (!!request.hasQosName()) {
    query["QosName"] = request.qosName();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRemoveInstanceList()) {
    query["RemoveInstanceList"] = request.removeInstanceList();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyExpressConnectTrafficQos"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyExpressConnectTrafficQosResponse>();
}

/**
 * @summary Modifies a quality of service (QoS) policy or associates a QoS policy with a dedicated Express Connect circuit.
 *
 * @param request ModifyExpressConnectTrafficQosRequest
 * @return ModifyExpressConnectTrafficQosResponse
 */
ModifyExpressConnectTrafficQosResponse Client::modifyExpressConnectTrafficQos(const ModifyExpressConnectTrafficQosRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyExpressConnectTrafficQosWithOptions(request, runtime);
}

/**
 * @summary Modifies a quality of service (QoS) queue.
 *
 * @param request ModifyExpressConnectTrafficQosQueueRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyExpressConnectTrafficQosQueueResponse
 */
ModifyExpressConnectTrafficQosQueueResponse Client::modifyExpressConnectTrafficQosQueueWithOptions(const ModifyExpressConnectTrafficQosQueueRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidthPercent()) {
    query["BandwidthPercent"] = request.bandwidthPercent();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasQosId()) {
    query["QosId"] = request.qosId();
  }

  if (!!request.hasQueueDescription()) {
    query["QueueDescription"] = request.queueDescription();
  }

  if (!!request.hasQueueId()) {
    query["QueueId"] = request.queueId();
  }

  if (!!request.hasQueueName()) {
    query["QueueName"] = request.queueName();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyExpressConnectTrafficQosQueue"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyExpressConnectTrafficQosQueueResponse>();
}

/**
 * @summary Modifies a quality of service (QoS) queue.
 *
 * @param request ModifyExpressConnectTrafficQosQueueRequest
 * @return ModifyExpressConnectTrafficQosQueueResponse
 */
ModifyExpressConnectTrafficQosQueueResponse Client::modifyExpressConnectTrafficQosQueue(const ModifyExpressConnectTrafficQosQueueRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyExpressConnectTrafficQosQueueWithOptions(request, runtime);
}

/**
 * @summary Modifies a quality of service (QoS) rule.
 *
 * @param request ModifyExpressConnectTrafficQosRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyExpressConnectTrafficQosRuleResponse
 */
ModifyExpressConnectTrafficQosRuleResponse Client::modifyExpressConnectTrafficQosRuleWithOptions(const ModifyExpressConnectTrafficQosRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDstCidr()) {
    query["DstCidr"] = request.dstCidr();
  }

  if (!!request.hasDstIPv6Cidr()) {
    query["DstIPv6Cidr"] = request.dstIPv6Cidr();
  }

  if (!!request.hasDstPortRange()) {
    query["DstPortRange"] = request.dstPortRange();
  }

  if (!!request.hasMatchDscp()) {
    query["MatchDscp"] = request.matchDscp();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPriority()) {
    query["Priority"] = request.priority();
  }

  if (!!request.hasProtocol()) {
    query["Protocol"] = request.protocol();
  }

  if (!!request.hasQosId()) {
    query["QosId"] = request.qosId();
  }

  if (!!request.hasQueueId()) {
    query["QueueId"] = request.queueId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRemarkingDscp()) {
    query["RemarkingDscp"] = request.remarkingDscp();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasRuleDescription()) {
    query["RuleDescription"] = request.ruleDescription();
  }

  if (!!request.hasRuleId()) {
    query["RuleId"] = request.ruleId();
  }

  if (!!request.hasRuleName()) {
    query["RuleName"] = request.ruleName();
  }

  if (!!request.hasSrcCidr()) {
    query["SrcCidr"] = request.srcCidr();
  }

  if (!!request.hasSrcIPv6Cidr()) {
    query["SrcIPv6Cidr"] = request.srcIPv6Cidr();
  }

  if (!!request.hasSrcPortRange()) {
    query["SrcPortRange"] = request.srcPortRange();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyExpressConnectTrafficQosRule"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyExpressConnectTrafficQosRuleResponse>();
}

/**
 * @summary Modifies a quality of service (QoS) rule.
 *
 * @param request ModifyExpressConnectTrafficQosRuleRequest
 * @return ModifyExpressConnectTrafficQosRuleResponse
 */
ModifyExpressConnectTrafficQosRuleResponse Client::modifyExpressConnectTrafficQosRule(const ModifyExpressConnectTrafficQosRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyExpressConnectTrafficQosRuleWithOptions(request, runtime);
}

/**
 * @summary Modifies the name and description of a flow log.
 *
 * @description *   **ModifyFlowLogAttribute** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
 *     *   If the flow log is in the **Modifying** state, the flow log is being modified.
 *     *   If the flow log is in the **Active** or **Inactive** state, the flow log is modified.
 * *   You cannot repeatedly call the **ModifyFlowLogAttribute** operation to modify a flow log within the specified period of time.
 *
 * @param request ModifyFlowLogAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyFlowLogAttributeResponse
 */
ModifyFlowLogAttributeResponse Client::modifyFlowLogAttributeWithOptions(const ModifyFlowLogAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAggregationInterval()) {
    query["AggregationInterval"] = request.aggregationInterval();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasFlowLogId()) {
    query["FlowLogId"] = request.flowLogId();
  }

  if (!!request.hasFlowLogName()) {
    query["FlowLogName"] = request.flowLogName();
  }

  if (!!request.hasIpVersion()) {
    query["IpVersion"] = request.ipVersion();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyFlowLogAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyFlowLogAttributeResponse>();
}

/**
 * @summary Modifies the name and description of a flow log.
 *
 * @description *   **ModifyFlowLogAttribute** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeFlowLogs](https://help.aliyun.com/document_detail/87923.html) operation to query the status of a flow log:
 *     *   If the flow log is in the **Modifying** state, the flow log is being modified.
 *     *   If the flow log is in the **Active** or **Inactive** state, the flow log is modified.
 * *   You cannot repeatedly call the **ModifyFlowLogAttribute** operation to modify a flow log within the specified period of time.
 *
 * @param request ModifyFlowLogAttributeRequest
 * @return ModifyFlowLogAttributeResponse
 */
ModifyFlowLogAttributeResponse Client::modifyFlowLogAttribute(const ModifyFlowLogAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyFlowLogAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies a DNAT entry.
 *
 * @description *   **ModifyForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
 *     *   **Pending**: indicates that the system is modifying the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
 *     *   **Available**: indicates that the DNAT entry is modified.
 * *   You cannot repeatedly call the **ModifyForwardEntry** operation to modify a DNAT entry within the specified period of time.
 *
 * @param request ModifyForwardEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyForwardEntryResponse
 */
ModifyForwardEntryResponse Client::modifyForwardEntryWithOptions(const ModifyForwardEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasExternalIp()) {
    query["ExternalIp"] = request.externalIp();
  }

  if (!!request.hasExternalPort()) {
    query["ExternalPort"] = request.externalPort();
  }

  if (!!request.hasForwardEntryId()) {
    query["ForwardEntryId"] = request.forwardEntryId();
  }

  if (!!request.hasForwardEntryName()) {
    query["ForwardEntryName"] = request.forwardEntryName();
  }

  if (!!request.hasForwardTableId()) {
    query["ForwardTableId"] = request.forwardTableId();
  }

  if (!!request.hasInternalIp()) {
    query["InternalIp"] = request.internalIp();
  }

  if (!!request.hasInternalPort()) {
    query["InternalPort"] = request.internalPort();
  }

  if (!!request.hasIpProtocol()) {
    query["IpProtocol"] = request.ipProtocol();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPortBreak()) {
    query["PortBreak"] = request.portBreak();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyForwardEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyForwardEntryResponse>();
}

/**
 * @summary Modifies a DNAT entry.
 *
 * @description *   **ModifyForwardEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeForwardTableEntries](https://help.aliyun.com/document_detail/36053.html) operation to query the status of the task.
 *     *   **Pending**: indicates that the system is modifying the DNAT entry. You can only query the DNAT entry, but cannot perform other operations.
 *     *   **Available**: indicates that the DNAT entry is modified.
 * *   You cannot repeatedly call the **ModifyForwardEntry** operation to modify a DNAT entry within the specified period of time.
 *
 * @param request ModifyForwardEntryRequest
 * @return ModifyForwardEntryResponse
 */
ModifyForwardEntryResponse Client::modifyForwardEntry(const ModifyForwardEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyForwardEntryWithOptions(request, runtime);
}

/**
 * @summary Modifies a FULLNAT entry.
 *
 * @description ## [](#)
 * *   **ModifyFullNatEntryAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
 *     *   **Modifying**: indicates that the system is modifying the FULLNAT entry. You can query the FULLNAT entry, but cannot perform other operations.
 *     *   **Available**: indicates that the FULLNAT entry is modified.
 * *   You cannot repeatedly call the **ModifyFullNatEntryAttribute** operation to modify a FULLNAT entry within the specified period of time.
 *
 * @param request ModifyFullNatEntryAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyFullNatEntryAttributeResponse
 */
ModifyFullNatEntryAttributeResponse Client::modifyFullNatEntryAttributeWithOptions(const ModifyFullNatEntryAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAccessIp()) {
    query["AccessIp"] = request.accessIp();
  }

  if (!!request.hasAccessPort()) {
    query["AccessPort"] = request.accessPort();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasFullNatEntryDescription()) {
    query["FullNatEntryDescription"] = request.fullNatEntryDescription();
  }

  if (!!request.hasFullNatEntryId()) {
    query["FullNatEntryId"] = request.fullNatEntryId();
  }

  if (!!request.hasFullNatEntryName()) {
    query["FullNatEntryName"] = request.fullNatEntryName();
  }

  if (!!request.hasFullNatTableId()) {
    query["FullNatTableId"] = request.fullNatTableId();
  }

  if (!!request.hasIpProtocol()) {
    query["IpProtocol"] = request.ipProtocol();
  }

  if (!!request.hasNatIp()) {
    query["NatIp"] = request.natIp();
  }

  if (!!request.hasNatIpPort()) {
    query["NatIpPort"] = request.natIpPort();
  }

  if (!!request.hasNetworkInterfaceId()) {
    query["NetworkInterfaceId"] = request.networkInterfaceId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyFullNatEntryAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyFullNatEntryAttributeResponse>();
}

/**
 * @summary Modifies a FULLNAT entry.
 *
 * @description ## [](#)
 * *   **ModifyFullNatEntryAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListFullNatEntries](https://help.aliyun.com/document_detail/348779.html) operation to query the status of a FULLNAT entry.
 *     *   **Modifying**: indicates that the system is modifying the FULLNAT entry. You can query the FULLNAT entry, but cannot perform other operations.
 *     *   **Available**: indicates that the FULLNAT entry is modified.
 * *   You cannot repeatedly call the **ModifyFullNatEntryAttribute** operation to modify a FULLNAT entry within the specified period of time.
 *
 * @param request ModifyFullNatEntryAttributeRequest
 * @return ModifyFullNatEntryAttributeResponse
 */
ModifyFullNatEntryAttributeResponse Client::modifyFullNatEntryAttribute(const ModifyFullNatEntryAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyFullNatEntryAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the name and description of a Global Accelerator (GA) instance.
 *
 * @param request ModifyGlobalAccelerationInstanceAttributesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyGlobalAccelerationInstanceAttributesResponse
 */
ModifyGlobalAccelerationInstanceAttributesResponse Client::modifyGlobalAccelerationInstanceAttributesWithOptions(const ModifyGlobalAccelerationInstanceAttributesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasGlobalAccelerationInstanceId()) {
    query["GlobalAccelerationInstanceId"] = request.globalAccelerationInstanceId();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyGlobalAccelerationInstanceAttributes"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyGlobalAccelerationInstanceAttributesResponse>();
}

/**
 * @summary Modifies the name and description of a Global Accelerator (GA) instance.
 *
 * @param request ModifyGlobalAccelerationInstanceAttributesRequest
 * @return ModifyGlobalAccelerationInstanceAttributesResponse
 */
ModifyGlobalAccelerationInstanceAttributesResponse Client::modifyGlobalAccelerationInstanceAttributes(const ModifyGlobalAccelerationInstanceAttributesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyGlobalAccelerationInstanceAttributesWithOptions(request, runtime);
}

/**
 * @summary Modifies the maximum bandwidth of a Global Accelerator (GA) instance.
 *
 * @description ## Usage notes
 * You cannot call this operation to modify the maximum bandwidth of a subscription GA instance.
 *
 * @param request ModifyGlobalAccelerationInstanceSpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyGlobalAccelerationInstanceSpecResponse
 */
ModifyGlobalAccelerationInstanceSpecResponse Client::modifyGlobalAccelerationInstanceSpecWithOptions(const ModifyGlobalAccelerationInstanceSpecRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasGlobalAccelerationInstanceId()) {
    query["GlobalAccelerationInstanceId"] = request.globalAccelerationInstanceId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyGlobalAccelerationInstanceSpec"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyGlobalAccelerationInstanceSpecResponse>();
}

/**
 * @summary Modifies the maximum bandwidth of a Global Accelerator (GA) instance.
 *
 * @description ## Usage notes
 * You cannot call this operation to modify the maximum bandwidth of a subscription GA instance.
 *
 * @param request ModifyGlobalAccelerationInstanceSpecRequest
 * @return ModifyGlobalAccelerationInstanceSpecResponse
 */
ModifyGlobalAccelerationInstanceSpecResponse Client::modifyGlobalAccelerationInstanceSpec(const ModifyGlobalAccelerationInstanceSpecRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyGlobalAccelerationInstanceSpecWithOptions(request, runtime);
}

/**
 * @summary Modifies the name and description of a high-availability virtual IP address (HaVip).
 *
 * @description You cannot repeatedly call the **ModifyHaVipAttribute** operation to modify the name and description of an HaVip within the specified periods of time.
 *
 * @param request ModifyHaVipAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyHaVipAttributeResponse
 */
ModifyHaVipAttributeResponse Client::modifyHaVipAttributeWithOptions(const ModifyHaVipAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasHaVipId()) {
    query["HaVipId"] = request.haVipId();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyHaVipAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyHaVipAttributeResponse>();
}

/**
 * @summary Modifies the name and description of a high-availability virtual IP address (HaVip).
 *
 * @description You cannot repeatedly call the **ModifyHaVipAttribute** operation to modify the name and description of an HaVip within the specified periods of time.
 *
 * @param request ModifyHaVipAttributeRequest
 * @return ModifyHaVipAttributeResponse
 */
ModifyHaVipAttributeResponse Client::modifyHaVipAttribute(const ModifyHaVipAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyHaVipAttributeWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI ModifyIPv6TranslatorAclAttribute is deprecated
 *
 * @summary Modifies the name of an access control list (ACL).
 *
 * @param request ModifyIPv6TranslatorAclAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyIPv6TranslatorAclAttributeResponse
 */
ModifyIPv6TranslatorAclAttributeResponse Client::modifyIPv6TranslatorAclAttributeWithOptions(const ModifyIPv6TranslatorAclAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAclId()) {
    query["AclId"] = request.aclId();
  }

  if (!!request.hasAclName()) {
    query["AclName"] = request.aclName();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyIPv6TranslatorAclAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyIPv6TranslatorAclAttributeResponse>();
}

/**
 * @deprecated OpenAPI ModifyIPv6TranslatorAclAttribute is deprecated
 *
 * @summary Modifies the name of an access control list (ACL).
 *
 * @param request ModifyIPv6TranslatorAclAttributeRequest
 * @return ModifyIPv6TranslatorAclAttributeResponse
 */
ModifyIPv6TranslatorAclAttributeResponse Client::modifyIPv6TranslatorAclAttribute(const ModifyIPv6TranslatorAclAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyIPv6TranslatorAclAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies an IP entry in an access control list (ACL).
 *
 * @param request ModifyIPv6TranslatorAclListEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyIPv6TranslatorAclListEntryResponse
 */
ModifyIPv6TranslatorAclListEntryResponse Client::modifyIPv6TranslatorAclListEntryWithOptions(const ModifyIPv6TranslatorAclListEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAclEntryComment()) {
    query["AclEntryComment"] = request.aclEntryComment();
  }

  if (!!request.hasAclEntryId()) {
    query["AclEntryId"] = request.aclEntryId();
  }

  if (!!request.hasAclId()) {
    query["AclId"] = request.aclId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyIPv6TranslatorAclListEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyIPv6TranslatorAclListEntryResponse>();
}

/**
 * @summary Modifies an IP entry in an access control list (ACL).
 *
 * @param request ModifyIPv6TranslatorAclListEntryRequest
 * @return ModifyIPv6TranslatorAclListEntryResponse
 */
ModifyIPv6TranslatorAclListEntryResponse Client::modifyIPv6TranslatorAclListEntry(const ModifyIPv6TranslatorAclListEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyIPv6TranslatorAclListEntryWithOptions(request, runtime);
}

/**
 * @summary Modifies the name and description of an IPv6 Translation Service instance.
 *
 * @param request ModifyIPv6TranslatorAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyIPv6TranslatorAttributeResponse
 */
ModifyIPv6TranslatorAttributeResponse Client::modifyIPv6TranslatorAttributeWithOptions(const ModifyIPv6TranslatorAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasIpv6TranslatorId()) {
    query["Ipv6TranslatorId"] = request.ipv6TranslatorId();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyIPv6TranslatorAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyIPv6TranslatorAttributeResponse>();
}

/**
 * @summary Modifies the name and description of an IPv6 Translation Service instance.
 *
 * @param request ModifyIPv6TranslatorAttributeRequest
 * @return ModifyIPv6TranslatorAttributeResponse
 */
ModifyIPv6TranslatorAttributeResponse Client::modifyIPv6TranslatorAttribute(const ModifyIPv6TranslatorAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyIPv6TranslatorAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the maximum bandwidth of an IPv6 Translation Service instance.
 *
 * @param request ModifyIPv6TranslatorBandwidthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyIPv6TranslatorBandwidthResponse
 */
ModifyIPv6TranslatorBandwidthResponse Client::modifyIPv6TranslatorBandwidthWithOptions(const ModifyIPv6TranslatorBandwidthRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAutoPay()) {
    query["AutoPay"] = request.autoPay();
  }

  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasIpv6TranslatorId()) {
    query["Ipv6TranslatorId"] = request.ipv6TranslatorId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyIPv6TranslatorBandwidth"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyIPv6TranslatorBandwidthResponse>();
}

/**
 * @summary Modifies the maximum bandwidth of an IPv6 Translation Service instance.
 *
 * @param request ModifyIPv6TranslatorBandwidthRequest
 * @return ModifyIPv6TranslatorBandwidthResponse
 */
ModifyIPv6TranslatorBandwidthResponse Client::modifyIPv6TranslatorBandwidth(const ModifyIPv6TranslatorBandwidthRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyIPv6TranslatorBandwidthWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI ModifyIPv6TranslatorEntry is deprecated
 *
 * @summary Modifies an IPv6 mapping entry.
 *
 * @param request ModifyIPv6TranslatorEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyIPv6TranslatorEntryResponse
 */
ModifyIPv6TranslatorEntryResponse Client::modifyIPv6TranslatorEntryWithOptions(const ModifyIPv6TranslatorEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAclId()) {
    query["AclId"] = request.aclId();
  }

  if (!!request.hasAclStatus()) {
    query["AclStatus"] = request.aclStatus();
  }

  if (!!request.hasAclType()) {
    query["AclType"] = request.aclType();
  }

  if (!!request.hasAllocateIpv6Port()) {
    query["AllocateIpv6Port"] = request.allocateIpv6Port();
  }

  if (!!request.hasBackendIpv4Addr()) {
    query["BackendIpv4Addr"] = request.backendIpv4Addr();
  }

  if (!!request.hasBackendIpv4Port()) {
    query["BackendIpv4Port"] = request.backendIpv4Port();
  }

  if (!!request.hasEntryBandwidth()) {
    query["EntryBandwidth"] = request.entryBandwidth();
  }

  if (!!request.hasEntryDescription()) {
    query["EntryDescription"] = request.entryDescription();
  }

  if (!!request.hasEntryName()) {
    query["EntryName"] = request.entryName();
  }

  if (!!request.hasIpv6TranslatorEntryId()) {
    query["Ipv6TranslatorEntryId"] = request.ipv6TranslatorEntryId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTransProtocol()) {
    query["TransProtocol"] = request.transProtocol();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyIPv6TranslatorEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyIPv6TranslatorEntryResponse>();
}

/**
 * @deprecated OpenAPI ModifyIPv6TranslatorEntry is deprecated
 *
 * @summary Modifies an IPv6 mapping entry.
 *
 * @param request ModifyIPv6TranslatorEntryRequest
 * @return ModifyIPv6TranslatorEntryResponse
 */
ModifyIPv6TranslatorEntryResponse Client::modifyIPv6TranslatorEntry(const ModifyIPv6TranslatorEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyIPv6TranslatorEntryWithOptions(request, runtime);
}

/**
 * @summary Modifies the name and description of an IPv6 address.
 *
 * @param request ModifyIpv6AddressAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyIpv6AddressAttributeResponse
 */
ModifyIpv6AddressAttributeResponse Client::modifyIpv6AddressAttributeWithOptions(const ModifyIpv6AddressAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIpv6AddressId()) {
    query["Ipv6AddressId"] = request.ipv6AddressId();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyIpv6AddressAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyIpv6AddressAttributeResponse>();
}

/**
 * @summary Modifies the name and description of an IPv6 address.
 *
 * @param request ModifyIpv6AddressAttributeRequest
 * @return ModifyIpv6AddressAttributeResponse
 */
ModifyIpv6AddressAttributeResponse Client::modifyIpv6AddressAttribute(const ModifyIpv6AddressAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyIpv6AddressAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the name and description of an IPv6 gateway.
 *
 * @param request ModifyIpv6GatewayAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyIpv6GatewayAttributeResponse
 */
ModifyIpv6GatewayAttributeResponse Client::modifyIpv6GatewayAttributeWithOptions(const ModifyIpv6GatewayAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIpv6GatewayId()) {
    query["Ipv6GatewayId"] = request.ipv6GatewayId();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyIpv6GatewayAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyIpv6GatewayAttributeResponse>();
}

/**
 * @summary Modifies the name and description of an IPv6 gateway.
 *
 * @param request ModifyIpv6GatewayAttributeRequest
 * @return ModifyIpv6GatewayAttributeResponse
 */
ModifyIpv6GatewayAttributeResponse Client::modifyIpv6GatewayAttribute(const ModifyIpv6GatewayAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyIpv6GatewayAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the Internet bandwidth of an IPv6 address.
 *
 * @description You cannot repeatedly call the **ModifyIpv6InternetBandwidth** operation to modify the Internet bandwidth value of an IPv6 CIDR block within the specified period of time.
 *
 * @param request ModifyIpv6InternetBandwidthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyIpv6InternetBandwidthResponse
 */
ModifyIpv6InternetBandwidthResponse Client::modifyIpv6InternetBandwidthWithOptions(const ModifyIpv6InternetBandwidthRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIpv6AddressId()) {
    query["Ipv6AddressId"] = request.ipv6AddressId();
  }

  if (!!request.hasIpv6InternetBandwidthId()) {
    query["Ipv6InternetBandwidthId"] = request.ipv6InternetBandwidthId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyIpv6InternetBandwidth"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyIpv6InternetBandwidthResponse>();
}

/**
 * @summary Modifies the Internet bandwidth of an IPv6 address.
 *
 * @description You cannot repeatedly call the **ModifyIpv6InternetBandwidth** operation to modify the Internet bandwidth value of an IPv6 CIDR block within the specified period of time.
 *
 * @param request ModifyIpv6InternetBandwidthRequest
 * @return ModifyIpv6InternetBandwidthResponse
 */
ModifyIpv6InternetBandwidthResponse Client::modifyIpv6InternetBandwidth(const ModifyIpv6InternetBandwidthRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyIpv6InternetBandwidthWithOptions(request, runtime);
}

/**
 * @summary Modifies the name and description of a NAT gateway.
 *
 * @description ## [](#)Description
 * You can call this operation to query an Internet NAT gateway or a virtual private cloud (VPC) NAT gateway. The term NAT gateway in this topic refers to both NAT gateway types.
 *
 * @param tmpReq ModifyNatGatewayAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyNatGatewayAttributeResponse
 */
ModifyNatGatewayAttributeResponse Client::modifyNatGatewayAttributeWithOptions(const ModifyNatGatewayAttributeRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  ModifyNatGatewayAttributeShrinkRequest request = ModifyNatGatewayAttributeShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasLogDelivery()) {
    request.setLogDeliveryShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.logDelivery(), "LogDelivery", "json"));
  }

  json query = {};
  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasEipBindMode()) {
    query["EipBindMode"] = request.eipBindMode();
  }

  if (!!request.hasEnableSessionLog()) {
    query["EnableSessionLog"] = request.enableSessionLog();
  }

  if (!!request.hasIcmpReplyEnabled()) {
    query["IcmpReplyEnabled"] = request.icmpReplyEnabled();
  }

  if (!!request.hasLogDeliveryShrink()) {
    query["LogDelivery"] = request.logDeliveryShrink();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyNatGatewayAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyNatGatewayAttributeResponse>();
}

/**
 * @summary Modifies the name and description of a NAT gateway.
 *
 * @description ## [](#)Description
 * You can call this operation to query an Internet NAT gateway or a virtual private cloud (VPC) NAT gateway. The term NAT gateway in this topic refers to both NAT gateway types.
 *
 * @param request ModifyNatGatewayAttributeRequest
 * @return ModifyNatGatewayAttributeResponse
 */
ModifyNatGatewayAttributeResponse Client::modifyNatGatewayAttribute(const ModifyNatGatewayAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyNatGatewayAttributeWithOptions(request, runtime);
}

/**
 * @summary Upgrades a subscription Internet NAT gateway.
 *
 * @description - You cannot call this operation to downgrade a subscription Internet NAT gateway. You can downgrade a subscription Internet NAT gateway only in the console.
 * - When you call this operation to upgrade a subscription Internet NAT gateway, an order is generated. After you complete the payment in the order center, the Internet NAT gateway is upgraded.
 * - **ModifyNatGatewaySpec** is an asynchronous operation. After you make a request, the ID of the request is returned but the Internet NAT gateway is not upgraded. The system upgrades the NAT gateway in the background. You can call the [DescribeNatGateways](/help/en/virtual-private-cloud/latest/describenatgateways) operation to query the status of an Internet NAT gateway.    - If an Internet NAT gateway is in the **Modifying** state, the NAT gateway is being upgraded. In this case, you can only query the NAT gateway but cannot perform other operations.
 *   - If an Internet NAT gateway is in the **Available** state, the Internet NAT gateway is upgraded.
 * - You cannot repeatedly call the **ModifyNatGatewaySpec** operation to resize a pay-by-specification NAT gateway.
 * Internet NAT gateways are available in different sizes. The size of an Internet NAT gateway determines the SNAT performance, which includes the maximum number of connections and the number of new connections per second. However, the size of a NAT gateway does not affect the data throughput. The following table describes the correlations between different sizes of Internet NAT gateways and SNAT performance metrics.  
 * | Size | Maximum number of connections | Number of new connections per second |
 * | ---- | ----------------------------- | ------------------------------------ |
 * | Small | 10,000 | 1,000 |
 * | Medium | 50,000 | 5,000 |
 * | Large | 200,000 | 10,000 |
 *
 * @param request ModifyNatGatewaySpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyNatGatewaySpecResponse
 */
ModifyNatGatewaySpecResponse Client::modifyNatGatewaySpecWithOptions(const ModifyNatGatewaySpecRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAutoPay()) {
    query["AutoPay"] = request.autoPay();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSpec()) {
    query["Spec"] = request.spec();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyNatGatewaySpec"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyNatGatewaySpecResponse>();
}

/**
 * @summary Upgrades a subscription Internet NAT gateway.
 *
 * @description - You cannot call this operation to downgrade a subscription Internet NAT gateway. You can downgrade a subscription Internet NAT gateway only in the console.
 * - When you call this operation to upgrade a subscription Internet NAT gateway, an order is generated. After you complete the payment in the order center, the Internet NAT gateway is upgraded.
 * - **ModifyNatGatewaySpec** is an asynchronous operation. After you make a request, the ID of the request is returned but the Internet NAT gateway is not upgraded. The system upgrades the NAT gateway in the background. You can call the [DescribeNatGateways](/help/en/virtual-private-cloud/latest/describenatgateways) operation to query the status of an Internet NAT gateway.    - If an Internet NAT gateway is in the **Modifying** state, the NAT gateway is being upgraded. In this case, you can only query the NAT gateway but cannot perform other operations.
 *   - If an Internet NAT gateway is in the **Available** state, the Internet NAT gateway is upgraded.
 * - You cannot repeatedly call the **ModifyNatGatewaySpec** operation to resize a pay-by-specification NAT gateway.
 * Internet NAT gateways are available in different sizes. The size of an Internet NAT gateway determines the SNAT performance, which includes the maximum number of connections and the number of new connections per second. However, the size of a NAT gateway does not affect the data throughput. The following table describes the correlations between different sizes of Internet NAT gateways and SNAT performance metrics.  
 * | Size | Maximum number of connections | Number of new connections per second |
 * | ---- | ----------------------------- | ------------------------------------ |
 * | Small | 10,000 | 1,000 |
 * | Medium | 50,000 | 5,000 |
 * | Large | 200,000 | 10,000 |
 *
 * @param request ModifyNatGatewaySpecRequest
 * @return ModifyNatGatewaySpecResponse
 */
ModifyNatGatewaySpecResponse Client::modifyNatGatewaySpec(const ModifyNatGatewaySpecRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyNatGatewaySpecWithOptions(request, runtime);
}

/**
 * @summary Modifies the name and description of a NAT IP address.
 *
 * @description ## [](#)Description
 * You cannot repeatedly call the **ModifyNatIpAttribute** operation to modify the name and description of a NAT IP address within the specified period of time.
 *
 * @param request ModifyNatIpAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyNatIpAttributeResponse
 */
ModifyNatIpAttributeResponse Client::modifyNatIpAttributeWithOptions(const ModifyNatIpAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasNatIpDescription()) {
    query["NatIpDescription"] = request.natIpDescription();
  }

  if (!!request.hasNatIpId()) {
    query["NatIpId"] = request.natIpId();
  }

  if (!!request.hasNatIpName()) {
    query["NatIpName"] = request.natIpName();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyNatIpAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyNatIpAttributeResponse>();
}

/**
 * @summary Modifies the name and description of a NAT IP address.
 *
 * @description ## [](#)Description
 * You cannot repeatedly call the **ModifyNatIpAttribute** operation to modify the name and description of a NAT IP address within the specified period of time.
 *
 * @param request ModifyNatIpAttributeRequest
 * @return ModifyNatIpAttributeResponse
 */
ModifyNatIpAttributeResponse Client::modifyNatIpAttribute(const ModifyNatIpAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyNatIpAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the name and description of a NAT CIDR block.
 *
 * @param request ModifyNatIpCidrAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyNatIpCidrAttributeResponse
 */
ModifyNatIpCidrAttributeResponse Client::modifyNatIpCidrAttributeWithOptions(const ModifyNatIpCidrAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasNatIpCidr()) {
    query["NatIpCidr"] = request.natIpCidr();
  }

  if (!!request.hasNatIpCidrDescription()) {
    query["NatIpCidrDescription"] = request.natIpCidrDescription();
  }

  if (!!request.hasNatIpCidrName()) {
    query["NatIpCidrName"] = request.natIpCidrName();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyNatIpCidrAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyNatIpCidrAttributeResponse>();
}

/**
 * @summary Modifies the name and description of a NAT CIDR block.
 *
 * @param request ModifyNatIpCidrAttributeRequest
 * @return ModifyNatIpCidrAttributeResponse
 */
ModifyNatIpCidrAttributeResponse Client::modifyNatIpCidrAttribute(const ModifyNatIpCidrAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyNatIpCidrAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the attributes of a network access control list (ACL).
 *
 * @param request ModifyNetworkAclAttributesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyNetworkAclAttributesResponse
 */
ModifyNetworkAclAttributesResponse Client::modifyNetworkAclAttributesWithOptions(const ModifyNetworkAclAttributesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasNetworkAclId()) {
    query["NetworkAclId"] = request.networkAclId();
  }

  if (!!request.hasNetworkAclName()) {
    query["NetworkAclName"] = request.networkAclName();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyNetworkAclAttributes"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyNetworkAclAttributesResponse>();
}

/**
 * @summary Modifies the attributes of a network access control list (ACL).
 *
 * @param request ModifyNetworkAclAttributesRequest
 * @return ModifyNetworkAclAttributesResponse
 */
ModifyNetworkAclAttributesResponse Client::modifyNetworkAclAttributes(const ModifyNetworkAclAttributesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyNetworkAclAttributesWithOptions(request, runtime);
}

/**
 * @summary Modifies the configurations of an Express Connect circuit.
 *
 * @description When you call this operation, take note of the following limits:
 * *   If an Express Connect circuit is in the **Initial**, **Enabled**, or **Rejected** state, you can modify the specifications of the Express Connect circuit and the ID of the redundant circuit.
 * *   If an Express Connect circuit is in the **Canceled**, **Allocating**, **AllocationFailed**, or **Terminated** state, you cannot modify the specifications of the Express Connect circuit.
 * *   After you modify the specifications of an Express Connect circuit that is in the **Rejected** state, the Express Connect circuit enters the **Initial** state.
 *
 * @param request ModifyPhysicalConnectionAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyPhysicalConnectionAttributeResponse
 */
ModifyPhysicalConnectionAttributeResponse Client::modifyPhysicalConnectionAttributeWithOptions(const ModifyPhysicalConnectionAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCircuitCode()) {
    query["CircuitCode"] = request.circuitCode();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasLineOperator()) {
    query["LineOperator"] = request.lineOperator();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPeerLocation()) {
    query["PeerLocation"] = request.peerLocation();
  }

  if (!!request.hasPhysicalConnectionId()) {
    query["PhysicalConnectionId"] = request.physicalConnectionId();
  }

  if (!!request.hasPortType()) {
    query["PortType"] = request.portType();
  }

  if (!!request.hasRedundantPhysicalConnectionId()) {
    query["RedundantPhysicalConnectionId"] = request.redundantPhysicalConnectionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasBandwidth()) {
    query["bandwidth"] = request.bandwidth();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyPhysicalConnectionAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyPhysicalConnectionAttributeResponse>();
}

/**
 * @summary Modifies the configurations of an Express Connect circuit.
 *
 * @description When you call this operation, take note of the following limits:
 * *   If an Express Connect circuit is in the **Initial**, **Enabled**, or **Rejected** state, you can modify the specifications of the Express Connect circuit and the ID of the redundant circuit.
 * *   If an Express Connect circuit is in the **Canceled**, **Allocating**, **AllocationFailed**, or **Terminated** state, you cannot modify the specifications of the Express Connect circuit.
 * *   After you modify the specifications of an Express Connect circuit that is in the **Rejected** state, the Express Connect circuit enters the **Initial** state.
 *
 * @param request ModifyPhysicalConnectionAttributeRequest
 * @return ModifyPhysicalConnectionAttributeResponse
 */
ModifyPhysicalConnectionAttributeResponse Client::modifyPhysicalConnectionAttribute(const ModifyPhysicalConnectionAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyPhysicalConnectionAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the name and description of a custom route entry.
 *
 * @description You cannot repeatedly call the **ModifyRouteEntry** operation to modify the name and description of a custom route within the specified period of time.
 *
 * @param request ModifyRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyRouteEntryResponse
 */
ModifyRouteEntryResponse Client::modifyRouteEntryWithOptions(const ModifyRouteEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDestinationCidrBlock()) {
    query["DestinationCidrBlock"] = request.destinationCidrBlock();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasNewNextHopId()) {
    query["NewNextHopId"] = request.newNextHopId();
  }

  if (!!request.hasNewNextHopType()) {
    query["NewNextHopType"] = request.newNextHopType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteEntryId()) {
    query["RouteEntryId"] = request.routeEntryId();
  }

  if (!!request.hasRouteEntryName()) {
    query["RouteEntryName"] = request.routeEntryName();
  }

  if (!!request.hasRouteTableId()) {
    query["RouteTableId"] = request.routeTableId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyRouteEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyRouteEntryResponse>();
}

/**
 * @summary Modifies the name and description of a custom route entry.
 *
 * @description You cannot repeatedly call the **ModifyRouteEntry** operation to modify the name and description of a custom route within the specified period of time.
 *
 * @param request ModifyRouteEntryRequest
 * @return ModifyRouteEntryResponse
 */
ModifyRouteEntryResponse Client::modifyRouteEntry(const ModifyRouteEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyRouteEntryWithOptions(request, runtime);
}

/**
 * @summary Modifies the name and description of a route table.
 *
 * @description You cannot repeatedly call the **ModifyRouteTableAttributes** operation to modify the name and description of a route table within the specified period of time.
 *
 * @param request ModifyRouteTableAttributesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyRouteTableAttributesResponse
 */
ModifyRouteTableAttributesResponse Client::modifyRouteTableAttributesWithOptions(const ModifyRouteTableAttributesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRoutePropagationEnable()) {
    query["RoutePropagationEnable"] = request.routePropagationEnable();
  }

  if (!!request.hasRouteTableId()) {
    query["RouteTableId"] = request.routeTableId();
  }

  if (!!request.hasRouteTableName()) {
    query["RouteTableName"] = request.routeTableName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyRouteTableAttributes"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyRouteTableAttributesResponse>();
}

/**
 * @summary Modifies the name and description of a route table.
 *
 * @description You cannot repeatedly call the **ModifyRouteTableAttributes** operation to modify the name and description of a route table within the specified period of time.
 *
 * @param request ModifyRouteTableAttributesRequest
 * @return ModifyRouteTableAttributesResponse
 */
ModifyRouteTableAttributesResponse Client::modifyRouteTableAttributes(const ModifyRouteTableAttributesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyRouteTableAttributesWithOptions(request, runtime);
}

/**
 * @summary Modifies the configuration of a router interface.
 *
 * @param request ModifyRouterInterfaceAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyRouterInterfaceAttributeResponse
 */
ModifyRouterInterfaceAttributeResponse Client::modifyRouterInterfaceAttributeWithOptions(const ModifyRouterInterfaceAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDeleteHealthCheckIp()) {
    query["DeleteHealthCheckIp"] = request.deleteHealthCheckIp();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasHcRate()) {
    query["HcRate"] = request.hcRate();
  }

  if (!!request.hasHcThreshold()) {
    query["HcThreshold"] = request.hcThreshold();
  }

  if (!!request.hasHealthCheckSourceIp()) {
    query["HealthCheckSourceIp"] = request.healthCheckSourceIp();
  }

  if (!!request.hasHealthCheckTargetIp()) {
    query["HealthCheckTargetIp"] = request.healthCheckTargetIp();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOppositeInterfaceId()) {
    query["OppositeInterfaceId"] = request.oppositeInterfaceId();
  }

  if (!!request.hasOppositeInterfaceOwnerId()) {
    query["OppositeInterfaceOwnerId"] = request.oppositeInterfaceOwnerId();
  }

  if (!!request.hasOppositeRouterId()) {
    query["OppositeRouterId"] = request.oppositeRouterId();
  }

  if (!!request.hasOppositeRouterType()) {
    query["OppositeRouterType"] = request.oppositeRouterType();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouterInterfaceId()) {
    query["RouterInterfaceId"] = request.routerInterfaceId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyRouterInterfaceAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyRouterInterfaceAttributeResponse>();
}

/**
 * @summary Modifies the configuration of a router interface.
 *
 * @param request ModifyRouterInterfaceAttributeRequest
 * @return ModifyRouterInterfaceAttributeResponse
 */
ModifyRouterInterfaceAttributeResponse Client::modifyRouterInterfaceAttribute(const ModifyRouterInterfaceAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyRouterInterfaceAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the specification of a router interface.
 *
 * @description After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, the router interface enters the **Active** state.
 * >  You cannot modify the specification of a router interface that has overdue payments.
 *
 * @param request ModifyRouterInterfaceSpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyRouterInterfaceSpecResponse
 */
ModifyRouterInterfaceSpecResponse Client::modifyRouterInterfaceSpecWithOptions(const ModifyRouterInterfaceSpecRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouterInterfaceId()) {
    query["RouterInterfaceId"] = request.routerInterfaceId();
  }

  if (!!request.hasSpec()) {
    query["Spec"] = request.spec();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyRouterInterfaceSpec"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyRouterInterfaceSpecResponse>();
}

/**
 * @summary Modifies the specification of a router interface.
 *
 * @description After you call this operation, the router interface enters the **Activating** state. After the router interface is activated, the router interface enters the **Active** state.
 * >  You cannot modify the specification of a router interface that has overdue payments.
 *
 * @param request ModifyRouterInterfaceSpecRequest
 * @return ModifyRouterInterfaceSpecResponse
 */
ModifyRouterInterfaceSpecResponse Client::modifyRouterInterfaceSpec(const ModifyRouterInterfaceSpecRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyRouterInterfaceSpecWithOptions(request, runtime);
}

/**
 * @summary Modifies an SNAT entry.
 *
 * @description ## [](#)
 * **ModifySnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
 * *   **Pending**: indicates that the system is modifying the SNAT entry. You can only query the status of the SNAT entry, but cannot perform other operations.
 * *   **Available**: indicates that the SNAT entry is modified.
 * >  If an SNAT entry is in the **Pending** state, it indicates that you cannot modify the SNAT entry.
 * You cannot repeatedly call the **ModifySnatEntry** operation to modify an SNAT entry within a specific period of time.
 *
 * @param request ModifySnatEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySnatEntryResponse
 */
ModifySnatEntryResponse Client::modifySnatEntryWithOptions(const ModifySnatEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEipAffinity()) {
    query["EipAffinity"] = request.eipAffinity();
  }

  if (!!request.hasNetworkInterfaceId()) {
    query["NetworkInterfaceId"] = request.networkInterfaceId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSnatEntryId()) {
    query["SnatEntryId"] = request.snatEntryId();
  }

  if (!!request.hasSnatEntryName()) {
    query["SnatEntryName"] = request.snatEntryName();
  }

  if (!!request.hasSnatIp()) {
    query["SnatIp"] = request.snatIp();
  }

  if (!!request.hasSnatTableId()) {
    query["SnatTableId"] = request.snatTableId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifySnatEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifySnatEntryResponse>();
}

/**
 * @summary Modifies an SNAT entry.
 *
 * @description ## [](#)
 * **ModifySnatEntry** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeSnatTableEntries](https://help.aliyun.com/document_detail/42677.html) operation to query the status of the task.
 * *   **Pending**: indicates that the system is modifying the SNAT entry. You can only query the status of the SNAT entry, but cannot perform other operations.
 * *   **Available**: indicates that the SNAT entry is modified.
 * >  If an SNAT entry is in the **Pending** state, it indicates that you cannot modify the SNAT entry.
 * You cannot repeatedly call the **ModifySnatEntry** operation to modify an SNAT entry within a specific period of time.
 *
 * @param request ModifySnatEntryRequest
 * @return ModifySnatEntryResponse
 */
ModifySnatEntryResponse Client::modifySnatEntry(const ModifySnatEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifySnatEntryWithOptions(request, runtime);
}

/**
 * @summary Modifies the name of an SSL-VPN client certificate.
 *
 * @param request ModifySslVpnClientCertRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySslVpnClientCertResponse
 */
ModifySslVpnClientCertResponse Client::modifySslVpnClientCertWithOptions(const ModifySslVpnClientCertRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSslVpnClientCertId()) {
    query["SslVpnClientCertId"] = request.sslVpnClientCertId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifySslVpnClientCert"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifySslVpnClientCertResponse>();
}

/**
 * @summary Modifies the name of an SSL-VPN client certificate.
 *
 * @param request ModifySslVpnClientCertRequest
 * @return ModifySslVpnClientCertResponse
 */
ModifySslVpnClientCertResponse Client::modifySslVpnClientCert(const ModifySslVpnClientCertRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifySslVpnClientCertWithOptions(request, runtime);
}

/**
 * @summary Modifies the configurations of an SSL server.
 *
 * @description *   To enable two-factor authentication for an SSL server, make sure that the VPN gateway supports two-factor authentication. You may need to upgrade the VPN gateway. For more information, see [Two-factor authentication supports IDaaS EIAM 2.0](https://help.aliyun.com/document_detail/2785320.html).
 * *   If you modify only **Name**, this operation is synchronous. If you modify other parameters besides **Name**, this operation is asynchronous.
 * *   **ModifySslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the SSL server is being modified.
 *     *   If the VPN gateway is in the **active** state, the SSL server is modified.
 * *   You cannot repeatedly call **ModifySslVpnServer** within the specified period of time.
 *
 * @param request ModifySslVpnServerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySslVpnServerResponse
 */
ModifySslVpnServerResponse Client::modifySslVpnServerWithOptions(const ModifySslVpnServerRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCipher()) {
    query["Cipher"] = request.cipher();
  }

  if (!!request.hasClientIpPool()) {
    query["ClientIpPool"] = request.clientIpPool();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasCompress()) {
    query["Compress"] = request.compress();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEnableMultiFactorAuth()) {
    query["EnableMultiFactorAuth"] = request.enableMultiFactorAuth();
  }

  if (!!request.hasIDaaSApplicationId()) {
    query["IDaaSApplicationId"] = request.IDaaSApplicationId();
  }

  if (!!request.hasIDaaSInstanceId()) {
    query["IDaaSInstanceId"] = request.IDaaSInstanceId();
  }

  if (!!request.hasIDaaSRegionId()) {
    query["IDaaSRegionId"] = request.IDaaSRegionId();
  }

  if (!!request.hasLocalSubnet()) {
    query["LocalSubnet"] = request.localSubnet();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPort()) {
    query["Port"] = request.port();
  }

  if (!!request.hasProto()) {
    query["Proto"] = request.proto();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSslVpnServerId()) {
    query["SslVpnServerId"] = request.sslVpnServerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifySslVpnServer"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifySslVpnServerResponse>();
}

/**
 * @summary Modifies the configurations of an SSL server.
 *
 * @description *   To enable two-factor authentication for an SSL server, make sure that the VPN gateway supports two-factor authentication. You may need to upgrade the VPN gateway. For more information, see [Two-factor authentication supports IDaaS EIAM 2.0](https://help.aliyun.com/document_detail/2785320.html).
 * *   If you modify only **Name**, this operation is synchronous. If you modify other parameters besides **Name**, this operation is asynchronous.
 * *   **ModifySslVpnServer** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the SSL server is being modified.
 *     *   If the VPN gateway is in the **active** state, the SSL server is modified.
 * *   You cannot repeatedly call **ModifySslVpnServer** within the specified period of time.
 *
 * @param request ModifySslVpnServerRequest
 * @return ModifySslVpnServerResponse
 */
ModifySslVpnServerResponse Client::modifySslVpnServer(const ModifySslVpnServerRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifySslVpnServerWithOptions(request, runtime);
}

/**
 * @summary Modifies a VPN tunnel.
 *
 * @param request ModifyTunnelAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyTunnelAttributeResponse
 */
ModifyTunnelAttributeResponse Client::modifyTunnelAttributeWithOptions(const ModifyTunnelAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTunnelId()) {
    query["TunnelId"] = request.tunnelId();
  }

  if (!!request.hasTunnelOptionsSpecification()) {
    query["TunnelOptionsSpecification"] = request.tunnelOptionsSpecification();
  }

  if (!!request.hasVpnConnectionId()) {
    query["VpnConnectionId"] = request.vpnConnectionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyTunnelAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyTunnelAttributeResponse>();
}

/**
 * @summary Modifies a VPN tunnel.
 *
 * @param request ModifyTunnelAttributeRequest
 * @return ModifyTunnelAttributeResponse
 */
ModifyTunnelAttributeResponse Client::modifyTunnelAttribute(const ModifyTunnelAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyTunnelAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the name and description of a vRouter.
 *
 * @description You cannot repeatedly call the **ModifyVRouterAttribute** operation within a specific period of time.
 *
 * @param request ModifyVRouterAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVRouterAttributeResponse
 */
ModifyVRouterAttributeResponse Client::modifyVRouterAttributeWithOptions(const ModifyVRouterAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVRouterId()) {
    query["VRouterId"] = request.VRouterId();
  }

  if (!!request.hasVRouterName()) {
    query["VRouterName"] = request.VRouterName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyVRouterAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyVRouterAttributeResponse>();
}

/**
 * @summary Modifies the name and description of a vRouter.
 *
 * @description You cannot repeatedly call the **ModifyVRouterAttribute** operation within a specific period of time.
 *
 * @param request ModifyVRouterAttributeRequest
 * @return ModifyVRouterAttributeResponse
 */
ModifyVRouterAttributeResponse Client::modifyVRouterAttribute(const ModifyVRouterAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyVRouterAttributeWithOptions(request, runtime);
}

/**
 * @summary 修改VSwitch属性
 *
 * @description *   **ModifyVSwitchAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
 *     *   If the vSwitch is in the **Pending** state, the name and description of the vSwitch are being modified.
 *     *   If the vSwitch is in the **Available** state, the name and description of the vSwitch are modified.
 * *   You cannot repeatedly call the **ModifyVSwitchAttribute** operation to modify the name and description of a vSwitch within the specified period of time.
 *
 * @param request ModifyVSwitchAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVSwitchAttributeResponse
 */
ModifyVSwitchAttributeResponse Client::modifyVSwitchAttributeWithOptions(const ModifyVSwitchAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasEnableIPv6()) {
    query["EnableIPv6"] = request.enableIPv6();
  }

  if (!!request.hasIpv6CidrBlock()) {
    query["Ipv6CidrBlock"] = request.ipv6CidrBlock();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVSwitchId()) {
    query["VSwitchId"] = request.vSwitchId();
  }

  if (!!request.hasVSwitchName()) {
    query["VSwitchName"] = request.vSwitchName();
  }

  if (!!request.hasVpcIpv6CidrBlock()) {
    query["VpcIpv6CidrBlock"] = request.vpcIpv6CidrBlock();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyVSwitchAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyVSwitchAttributeResponse>();
}

/**
 * @summary 修改VSwitch属性
 *
 * @description *   **ModifyVSwitchAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task:
 *     *   If the vSwitch is in the **Pending** state, the name and description of the vSwitch are being modified.
 *     *   If the vSwitch is in the **Available** state, the name and description of the vSwitch are modified.
 * *   You cannot repeatedly call the **ModifyVSwitchAttribute** operation to modify the name and description of a vSwitch within the specified period of time.
 *
 * @param request ModifyVSwitchAttributeRequest
 * @return ModifyVSwitchAttributeResponse
 */
ModifyVSwitchAttributeResponse Client::modifyVSwitchAttribute(const ModifyVSwitchAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyVSwitchAttributeWithOptions(request, runtime);
}

/**
 * @summary 修改交换机预留网段的名称和描述信息。
 *
 * @description ## [](#)Usage notes
 * You cannot repeatedly call **ModifyVSwitchCidrReservationAttribute** within a specific time period.
 *
 * @param request ModifyVSwitchCidrReservationAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVSwitchCidrReservationAttributeResponse
 */
ModifyVSwitchCidrReservationAttributeResponse Client::modifyVSwitchCidrReservationAttributeWithOptions(const ModifyVSwitchCidrReservationAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVSwitchCidrReservationDescription()) {
    query["VSwitchCidrReservationDescription"] = request.vSwitchCidrReservationDescription();
  }

  if (!!request.hasVSwitchCidrReservationId()) {
    query["VSwitchCidrReservationId"] = request.vSwitchCidrReservationId();
  }

  if (!!request.hasVSwitchCidrReservationName()) {
    query["VSwitchCidrReservationName"] = request.vSwitchCidrReservationName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyVSwitchCidrReservationAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyVSwitchCidrReservationAttributeResponse>();
}

/**
 * @summary 修改交换机预留网段的名称和描述信息。
 *
 * @description ## [](#)Usage notes
 * You cannot repeatedly call **ModifyVSwitchCidrReservationAttribute** within a specific time period.
 *
 * @param request ModifyVSwitchCidrReservationAttributeRequest
 * @return ModifyVSwitchCidrReservationAttributeResponse
 */
ModifyVSwitchCidrReservationAttributeResponse Client::modifyVSwitchCidrReservationAttribute(const ModifyVSwitchCidrReservationAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyVSwitchCidrReservationAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the weight of a destination-based route for an IPsec-VPN connection.
 *
 * @description *   **ModifyVcoRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the associated IPsec-VPN connection and determine whether the weight of the specified destination-based route is modified.
 *     *   If the IPsec-VPN connection is in the **updating** state, the weight of the destination-based route is being modified.
 *     *   If the IPsec-VPN connection is in the **attached** state, the weight of the destination-based route is modified.
 * *   You cannot repeatedly call the **ModifyVcoRouteEntryWeight** operation for the same IPsec-VPN connection within the specified period of time.
 *
 * @param request ModifyVcoRouteEntryWeightRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVcoRouteEntryWeightResponse
 */
ModifyVcoRouteEntryWeightResponse Client::modifyVcoRouteEntryWeightWithOptions(const ModifyVcoRouteEntryWeightRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasNewWeight()) {
    query["NewWeight"] = request.newWeight();
  }

  if (!!request.hasNextHop()) {
    query["NextHop"] = request.nextHop();
  }

  if (!!request.hasOverlayMode()) {
    query["OverlayMode"] = request.overlayMode();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteDest()) {
    query["RouteDest"] = request.routeDest();
  }

  if (!!request.hasVpnConnectionId()) {
    query["VpnConnectionId"] = request.vpnConnectionId();
  }

  if (!!request.hasWeight()) {
    query["Weight"] = request.weight();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyVcoRouteEntryWeight"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyVcoRouteEntryWeightResponse>();
}

/**
 * @summary Modifies the weight of a destination-based route for an IPsec-VPN connection.
 *
 * @description *   **ModifyVcoRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the associated IPsec-VPN connection and determine whether the weight of the specified destination-based route is modified.
 *     *   If the IPsec-VPN connection is in the **updating** state, the weight of the destination-based route is being modified.
 *     *   If the IPsec-VPN connection is in the **attached** state, the weight of the destination-based route is modified.
 * *   You cannot repeatedly call the **ModifyVcoRouteEntryWeight** operation for the same IPsec-VPN connection within the specified period of time.
 *
 * @param request ModifyVcoRouteEntryWeightRequest
 * @return ModifyVcoRouteEntryWeightResponse
 */
ModifyVcoRouteEntryWeightResponse Client::modifyVcoRouteEntryWeight(const ModifyVcoRouteEntryWeightRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyVcoRouteEntryWeightWithOptions(request, runtime);
}

/**
 * @summary Modifies the configuration of a virtual border router (VBR).
 *
 * @description # [](#)
 * *   Only the owner of an Express Connect circuit can modify the **VlanId** parameter.
 * *   One VLAN ID of an Express Connect circuit cannot be used only by one VBR at the same time.
 * *   The VLAN ID of a VBR in the **Terminated** state is reserved for seven days and cannot be used by other VBRs. The VLAN ID can be used by other VBRs after 7 days.
 * *   You cannot set **LocalGatewayIp**, **PeerGatewayIp**, or **PeeringSubnetMask** for VBRs that do not belong to your Alibaba Cloud account.
 * *   Set **PeeringSubnetMask** to a subnet mask with 24 to 30 bits in length (255.255.255.0～255.255.255.252).
 * *   Set **LocalGatewayIp** and **PeerGatewayIp** to IP addresses that belong to the same CIDR block. For example, you can set LocalGatewayIp to 192.168.XX.XX, PeerGatewayIp to 192.168.XX.XX, and PeeringSubnetMask to 255.255.255.248.
 *
 * @param request ModifyVirtualBorderRouterAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVirtualBorderRouterAttributeResponse
 */
ModifyVirtualBorderRouterAttributeResponse Client::modifyVirtualBorderRouterAttributeWithOptions(const ModifyVirtualBorderRouterAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAssociatedPhysicalConnections()) {
    query["AssociatedPhysicalConnections"] = request.associatedPhysicalConnections();
  }

  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasCircuitCode()) {
    query["CircuitCode"] = request.circuitCode();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDetectMultiplier()) {
    query["DetectMultiplier"] = request.detectMultiplier();
  }

  if (!!request.hasEnableIpv6()) {
    query["EnableIpv6"] = request.enableIpv6();
  }

  if (!!request.hasLocalGatewayIp()) {
    query["LocalGatewayIp"] = request.localGatewayIp();
  }

  if (!!request.hasLocalIpv6GatewayIp()) {
    query["LocalIpv6GatewayIp"] = request.localIpv6GatewayIp();
  }

  if (!!request.hasMinRxInterval()) {
    query["MinRxInterval"] = request.minRxInterval();
  }

  if (!!request.hasMinTxInterval()) {
    query["MinTxInterval"] = request.minTxInterval();
  }

  if (!!request.hasMtu()) {
    query["Mtu"] = request.mtu();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPeerGatewayIp()) {
    query["PeerGatewayIp"] = request.peerGatewayIp();
  }

  if (!!request.hasPeerIpv6GatewayIp()) {
    query["PeerIpv6GatewayIp"] = request.peerIpv6GatewayIp();
  }

  if (!!request.hasPeeringIpv6SubnetMask()) {
    query["PeeringIpv6SubnetMask"] = request.peeringIpv6SubnetMask();
  }

  if (!!request.hasPeeringSubnetMask()) {
    query["PeeringSubnetMask"] = request.peeringSubnetMask();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSitelinkEnable()) {
    query["SitelinkEnable"] = request.sitelinkEnable();
  }

  if (!!request.hasVbrId()) {
    query["VbrId"] = request.vbrId();
  }

  if (!!request.hasVlanId()) {
    query["VlanId"] = request.vlanId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyVirtualBorderRouterAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyVirtualBorderRouterAttributeResponse>();
}

/**
 * @summary Modifies the configuration of a virtual border router (VBR).
 *
 * @description # [](#)
 * *   Only the owner of an Express Connect circuit can modify the **VlanId** parameter.
 * *   One VLAN ID of an Express Connect circuit cannot be used only by one VBR at the same time.
 * *   The VLAN ID of a VBR in the **Terminated** state is reserved for seven days and cannot be used by other VBRs. The VLAN ID can be used by other VBRs after 7 days.
 * *   You cannot set **LocalGatewayIp**, **PeerGatewayIp**, or **PeeringSubnetMask** for VBRs that do not belong to your Alibaba Cloud account.
 * *   Set **PeeringSubnetMask** to a subnet mask with 24 to 30 bits in length (255.255.255.0～255.255.255.252).
 * *   Set **LocalGatewayIp** and **PeerGatewayIp** to IP addresses that belong to the same CIDR block. For example, you can set LocalGatewayIp to 192.168.XX.XX, PeerGatewayIp to 192.168.XX.XX, and PeeringSubnetMask to 255.255.255.248.
 *
 * @param request ModifyVirtualBorderRouterAttributeRequest
 * @return ModifyVirtualBorderRouterAttributeResponse
 */
ModifyVirtualBorderRouterAttributeResponse Client::modifyVirtualBorderRouterAttribute(const ModifyVirtualBorderRouterAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyVirtualBorderRouterAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the name and description of a virtual private cloud (VPC).
 *
 * @description ## [](#)Description
 * You cannot repeatedly call the **ModifyVpcAttribute** operation to modify the name and description of a VPC within the specified period of time.
 *
 * @param request ModifyVpcAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpcAttributeResponse
 */
ModifyVpcAttributeResponse Client::modifyVpcAttributeWithOptions(const ModifyVpcAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCidrBlock()) {
    query["CidrBlock"] = request.cidrBlock();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasEnableDnsHostname()) {
    query["EnableDnsHostname"] = request.enableDnsHostname();
  }

  if (!!request.hasEnableIPv6()) {
    query["EnableIPv6"] = request.enableIPv6();
  }

  if (!!request.hasIpv6CidrBlock()) {
    query["Ipv6CidrBlock"] = request.ipv6CidrBlock();
  }

  if (!!request.hasIpv6Isp()) {
    query["Ipv6Isp"] = request.ipv6Isp();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  if (!!request.hasVpcName()) {
    query["VpcName"] = request.vpcName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyVpcAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyVpcAttributeResponse>();
}

/**
 * @summary Modifies the name and description of a virtual private cloud (VPC).
 *
 * @description ## [](#)Description
 * You cannot repeatedly call the **ModifyVpcAttribute** operation to modify the name and description of a VPC within the specified period of time.
 *
 * @param request ModifyVpcAttributeRequest
 * @return ModifyVpcAttributeResponse
 */
ModifyVpcAttributeResponse Client::modifyVpcAttribute(const ModifyVpcAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyVpcAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the configuration of a prefix list.
 *
 * @description *   **ModifyVpcPrefixList** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPrefixLists](https://help.aliyun.com/document_detail/311535.html) to query the status of the task.
 *     *   If the prefix list is in the **Modifying** state, the configuration of the prefix list is being modified.
 *     *   If the prefix list is in the **Created** state, the configuration of the prefix list is modified.
 *     *   After the configuration of the prefix list is modified, you can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) operation to query the information about the network instances that are associated with the prefix list and determine whether the associated network instances use the new CIDR blocks. If the association **status** of the prefix list is **Created**, the new CIDR blocks are used by the network instances that are associated with the prefix list.
 * *   You cannot repeatedly call **ModifyVpcPrefixList** to modify the configuration of a prefix list within the specified period of time.
 *
 * @param request ModifyVpcPrefixListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpcPrefixListResponse
 */
ModifyVpcPrefixListResponse Client::modifyVpcPrefixListWithOptions(const ModifyVpcPrefixListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAddPrefixListEntry()) {
    query["AddPrefixListEntry"] = request.addPrefixListEntry();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasMaxEntries()) {
    query["MaxEntries"] = request.maxEntries();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPrefixListDescription()) {
    query["PrefixListDescription"] = request.prefixListDescription();
  }

  if (!!request.hasPrefixListId()) {
    query["PrefixListId"] = request.prefixListId();
  }

  if (!!request.hasPrefixListName()) {
    query["PrefixListName"] = request.prefixListName();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRemovePrefixListEntry()) {
    query["RemovePrefixListEntry"] = request.removePrefixListEntry();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyVpcPrefixList"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyVpcPrefixListResponse>();
}

/**
 * @summary Modifies the configuration of a prefix list.
 *
 * @description *   **ModifyVpcPrefixList** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListPrefixLists](https://help.aliyun.com/document_detail/311535.html) to query the status of the task.
 *     *   If the prefix list is in the **Modifying** state, the configuration of the prefix list is being modified.
 *     *   If the prefix list is in the **Created** state, the configuration of the prefix list is modified.
 *     *   After the configuration of the prefix list is modified, you can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) operation to query the information about the network instances that are associated with the prefix list and determine whether the associated network instances use the new CIDR blocks. If the association **status** of the prefix list is **Created**, the new CIDR blocks are used by the network instances that are associated with the prefix list.
 * *   You cannot repeatedly call **ModifyVpcPrefixList** to modify the configuration of a prefix list within the specified period of time.
 *
 * @param request ModifyVpcPrefixListRequest
 * @return ModifyVpcPrefixListResponse
 */
ModifyVpcPrefixListResponse Client::modifyVpcPrefixList(const ModifyVpcPrefixListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyVpcPrefixListWithOptions(request, runtime);
}

/**
 * @summary Modifies the configuration of an IPsec-VPN connection.
 *
 * @description *   When you modify a IPsec-VPN connection in dual-tunnel mode, you can configure the following parameters in addition to the required request parameters: **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
 * *   When you modify a IPsec-VPN connection in single tunnel mode, you can configure the following parameters in addition to the required request parameters: **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **CustomerGatewayId**.
 * *   **ModifyVpnAttachmentAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task:
 *     *   If the IPsec-VPN connection is in the **updating** state, the IPsec-VPN connection is being modified.
 *     *   If the IPsec-VPN connection is in the **attached** state, the IPsec-VPN connection is modified.
 * *   You cannot concurrently call **ModifyVpnAttachmentAttribute** within the specified period of time.
 * *   You cannot call **ModifyVpnAttachmentAttribute** to modify the gateway type of an IPsec-VPN connection.
 *
 * @param request ModifyVpnAttachmentAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpnAttachmentAttributeResponse
 */
ModifyVpnAttachmentAttributeResponse Client::modifyVpnAttachmentAttributeWithOptions(const ModifyVpnAttachmentAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAutoConfigRoute()) {
    query["AutoConfigRoute"] = request.autoConfigRoute();
  }

  if (!!request.hasBgpConfig()) {
    query["BgpConfig"] = request.bgpConfig();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasCustomerGatewayId()) {
    query["CustomerGatewayId"] = request.customerGatewayId();
  }

  if (!!request.hasEffectImmediately()) {
    query["EffectImmediately"] = request.effectImmediately();
  }

  if (!!request.hasEnableDpd()) {
    query["EnableDpd"] = request.enableDpd();
  }

  if (!!request.hasEnableNatTraversal()) {
    query["EnableNatTraversal"] = request.enableNatTraversal();
  }

  if (!!request.hasEnableTunnelsBgp()) {
    query["EnableTunnelsBgp"] = request.enableTunnelsBgp();
  }

  if (!!request.hasHealthCheckConfig()) {
    query["HealthCheckConfig"] = request.healthCheckConfig();
  }

  if (!!request.hasIkeConfig()) {
    query["IkeConfig"] = request.ikeConfig();
  }

  if (!!request.hasIpsecConfig()) {
    query["IpsecConfig"] = request.ipsecConfig();
  }

  if (!!request.hasLocalSubnet()) {
    query["LocalSubnet"] = request.localSubnet();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasNetworkType()) {
    query["NetworkType"] = request.networkType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRemoteCaCert()) {
    query["RemoteCaCert"] = request.remoteCaCert();
  }

  if (!!request.hasRemoteSubnet()) {
    query["RemoteSubnet"] = request.remoteSubnet();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpnConnectionId()) {
    query["VpnConnectionId"] = request.vpnConnectionId();
  }

  json body = {};
  json bodyFlat = {};
  if (!!request.hasTunnelOptionsSpecification()) {
    bodyFlat["TunnelOptionsSpecification"] = request.tunnelOptionsSpecification();
  }

  body = Darabonba::Core::merge(body,
    Utils::Utils::query(bodyFlat)
  );
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)},
    {"body" , Utils::Utils::parseToMap(body)}
  }));
  Params params = Params(json({
    {"action" , "ModifyVpnAttachmentAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyVpnAttachmentAttributeResponse>();
}

/**
 * @summary Modifies the configuration of an IPsec-VPN connection.
 *
 * @description *   When you modify a IPsec-VPN connection in dual-tunnel mode, you can configure the following parameters in addition to the required request parameters: **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification** array, and **EnableTunnelsBgp**.
 * *   When you modify a IPsec-VPN connection in single tunnel mode, you can configure the following parameters in addition to the required request parameters: **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **CustomerGatewayId**.
 * *   **ModifyVpnAttachmentAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnConnection](https://help.aliyun.com/document_detail/53046.html) operation to query the status of the task:
 *     *   If the IPsec-VPN connection is in the **updating** state, the IPsec-VPN connection is being modified.
 *     *   If the IPsec-VPN connection is in the **attached** state, the IPsec-VPN connection is modified.
 * *   You cannot concurrently call **ModifyVpnAttachmentAttribute** within the specified period of time.
 * *   You cannot call **ModifyVpnAttachmentAttribute** to modify the gateway type of an IPsec-VPN connection.
 *
 * @param request ModifyVpnAttachmentAttributeRequest
 * @return ModifyVpnAttachmentAttributeResponse
 */
ModifyVpnAttachmentAttributeResponse Client::modifyVpnAttachmentAttribute(const ModifyVpnAttachmentAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyVpnAttachmentAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the configuration of an IPsec-VPN connection.
 *
 * @description *   If you want to modify a IPsec-VPN connection in dual-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
 *     **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification**, and **EnableTunnelsBgp**.
 * *   If you want to modify a IPsec-VPN connection in single-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
 *     **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **RemoteCaCertificate**.
 * *   **ModifyVpnConnectionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and modifies the configuration of the IPsec-VPN connection in the backend. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the configuration of the IPsec-VPN connection is being modified.
 *     *   If the VPN gateway is in the **active** state, the configuration of the IPsec-VPN connection is modified.
 * *   You cannot repeatedly call the **ModifyVpnConnectionAttribute** operation for the same VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnConnectionAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpnConnectionAttributeResponse
 */
ModifyVpnConnectionAttributeResponse Client::modifyVpnConnectionAttributeWithOptions(const ModifyVpnConnectionAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAutoConfigRoute()) {
    query["AutoConfigRoute"] = request.autoConfigRoute();
  }

  if (!!request.hasBgpConfig()) {
    query["BgpConfig"] = request.bgpConfig();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasEffectImmediately()) {
    query["EffectImmediately"] = request.effectImmediately();
  }

  if (!!request.hasEnableDpd()) {
    query["EnableDpd"] = request.enableDpd();
  }

  if (!!request.hasEnableNatTraversal()) {
    query["EnableNatTraversal"] = request.enableNatTraversal();
  }

  if (!!request.hasEnableTunnelsBgp()) {
    query["EnableTunnelsBgp"] = request.enableTunnelsBgp();
  }

  if (!!request.hasHealthCheckConfig()) {
    query["HealthCheckConfig"] = request.healthCheckConfig();
  }

  if (!!request.hasIkeConfig()) {
    query["IkeConfig"] = request.ikeConfig();
  }

  if (!!request.hasIpsecConfig()) {
    query["IpsecConfig"] = request.ipsecConfig();
  }

  if (!!request.hasLocalSubnet()) {
    query["LocalSubnet"] = request.localSubnet();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRemoteCaCertificate()) {
    query["RemoteCaCertificate"] = request.remoteCaCertificate();
  }

  if (!!request.hasRemoteSubnet()) {
    query["RemoteSubnet"] = request.remoteSubnet();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpnConnectionId()) {
    query["VpnConnectionId"] = request.vpnConnectionId();
  }

  json body = {};
  json bodyFlat = {};
  if (!!request.hasTunnelOptionsSpecification()) {
    bodyFlat["TunnelOptionsSpecification"] = request.tunnelOptionsSpecification();
  }

  body = Darabonba::Core::merge(body,
    Utils::Utils::query(bodyFlat)
  );
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)},
    {"body" , Utils::Utils::parseToMap(body)}
  }));
  Params params = Params(json({
    {"action" , "ModifyVpnConnectionAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyVpnConnectionAttributeResponse>();
}

/**
 * @summary Modifies the configuration of an IPsec-VPN connection.
 *
 * @description *   If you want to modify a IPsec-VPN connection in dual-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
 *     **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **AutoConfigRoute**, **TunnelOptionsSpecification**, and **EnableTunnelsBgp**.
 * *   If you want to modify a IPsec-VPN connection in single-tunnel mode, call the `ModifyVpnConnectionAttribute` operation. You can modify the required parameters and the following request parameters:
 *     **ClientToken**, **Name**, **LocalSubnet**, **RemoteSubnet**, **EffectImmediately**, **IkeConfig**, **IpsecConfig**, **HealthCheckConfig**, **AutoConfigRoute**, **EnableDpd**, **EnableNatTraversal**, **BgpConfig**, and **RemoteCaCertificate**.
 * *   **ModifyVpnConnectionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and modifies the configuration of the IPsec-VPN connection in the backend. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) operation to query the status of a VPN gateway.
 *     *   If the VPN gateway is in the **updating** state, the configuration of the IPsec-VPN connection is being modified.
 *     *   If the VPN gateway is in the **active** state, the configuration of the IPsec-VPN connection is modified.
 * *   You cannot repeatedly call the **ModifyVpnConnectionAttribute** operation for the same VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnConnectionAttributeRequest
 * @return ModifyVpnConnectionAttributeResponse
 */
ModifyVpnConnectionAttributeResponse Client::modifyVpnConnectionAttribute(const ModifyVpnConnectionAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyVpnConnectionAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the name and description of a VPN gateway.
 *
 * @description *   **ModifyVpnGatewayAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the VPN gateway is being modified.
 *     *   If the VPN gateway is in the **active** state, the VPN gateway is modified.
 * *   You cannot repeatedly call **ModifyVpnGatewayAttribute** to modify a VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnGatewayAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpnGatewayAttributeResponse
 */
ModifyVpnGatewayAttributeResponse Client::modifyVpnGatewayAttributeWithOptions(const ModifyVpnGatewayAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAutoPropagate()) {
    query["AutoPropagate"] = request.autoPropagate();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyVpnGatewayAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyVpnGatewayAttributeResponse>();
}

/**
 * @summary Modifies the name and description of a VPN gateway.
 *
 * @description *   **ModifyVpnGatewayAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the VPN gateway is being modified.
 *     *   If the VPN gateway is in the **active** state, the VPN gateway is modified.
 * *   You cannot repeatedly call **ModifyVpnGatewayAttribute** to modify a VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnGatewayAttributeRequest
 * @return ModifyVpnGatewayAttributeResponse
 */
ModifyVpnGatewayAttributeResponse Client::modifyVpnGatewayAttribute(const ModifyVpnGatewayAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyVpnGatewayAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the weight and priority of a policy-based route.
 *
 * @description *   You can call the **ModifyVpnPbrRouteEntryAttribute** operation to modify the weight and priority of a policy-based route.
 *     *   If you want to modify only the weight of a policy-based route, call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html).
 *     *   If you want to modify only the priority of a policy-based route, call [ModifyVpnPbrRouteEntryPriority](https://help.aliyun.com/document_detail/466870.html).
 *     *   If a policy-based route does not support priorities, you can only call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html) to modify its weight.
 * *   The **ModifyVpnPbrRouteEntryAttribute** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
 *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
 *     *   If a VPN gateway is in the **active** state, the policy-based route entry is modified.
 * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryAttribute** operation for the same VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnPbrRouteEntryAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpnPbrRouteEntryAttributeResponse
 */
ModifyVpnPbrRouteEntryAttributeResponse Client::modifyVpnPbrRouteEntryAttributeWithOptions(const ModifyVpnPbrRouteEntryAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasNewPriority()) {
    query["NewPriority"] = request.newPriority();
  }

  if (!!request.hasNewWeight()) {
    query["NewWeight"] = request.newWeight();
  }

  if (!!request.hasNextHop()) {
    query["NextHop"] = request.nextHop();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPriority()) {
    query["Priority"] = request.priority();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteDest()) {
    query["RouteDest"] = request.routeDest();
  }

  if (!!request.hasRouteSource()) {
    query["RouteSource"] = request.routeSource();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  if (!!request.hasWeight()) {
    query["Weight"] = request.weight();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyVpnPbrRouteEntryAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyVpnPbrRouteEntryAttributeResponse>();
}

/**
 * @summary Modifies the weight and priority of a policy-based route.
 *
 * @description *   You can call the **ModifyVpnPbrRouteEntryAttribute** operation to modify the weight and priority of a policy-based route.
 *     *   If you want to modify only the weight of a policy-based route, call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html).
 *     *   If you want to modify only the priority of a policy-based route, call [ModifyVpnPbrRouteEntryPriority](https://help.aliyun.com/document_detail/466870.html).
 *     *   If a policy-based route does not support priorities, you can only call [ModifyVpnPbrRouteEntryWeight](https://help.aliyun.com/document_detail/127249.html) to modify its weight.
 * *   The **ModifyVpnPbrRouteEntryAttribute** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of a VPN gateway.
 *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
 *     *   If a VPN gateway is in the **active** state, the policy-based route entry is modified.
 * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryAttribute** operation for the same VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnPbrRouteEntryAttributeRequest
 * @return ModifyVpnPbrRouteEntryAttributeResponse
 */
ModifyVpnPbrRouteEntryAttributeResponse Client::modifyVpnPbrRouteEntryAttribute(const ModifyVpnPbrRouteEntryAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyVpnPbrRouteEntryAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the priority of a policy-based route.
 *
 * @description *   **ModifyVpnPbrRouteEntryPriority** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
 *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
 *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
 * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryPriority** operation for the same VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnPbrRouteEntryPriorityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpnPbrRouteEntryPriorityResponse
 */
ModifyVpnPbrRouteEntryPriorityResponse Client::modifyVpnPbrRouteEntryPriorityWithOptions(const ModifyVpnPbrRouteEntryPriorityRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasNewPriority()) {
    query["NewPriority"] = request.newPriority();
  }

  if (!!request.hasNextHop()) {
    query["NextHop"] = request.nextHop();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPriority()) {
    query["Priority"] = request.priority();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteDest()) {
    query["RouteDest"] = request.routeDest();
  }

  if (!!request.hasRouteSource()) {
    query["RouteSource"] = request.routeSource();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  if (!!request.hasWeight()) {
    query["Weight"] = request.weight();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyVpnPbrRouteEntryPriority"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyVpnPbrRouteEntryPriorityResponse>();
}

/**
 * @summary Modifies the priority of a policy-based route.
 *
 * @description *   **ModifyVpnPbrRouteEntryPriority** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
 *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
 *     *   If the VPN gateway is in the **active** state, the policy-based route is created.
 * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryPriority** operation for the same VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnPbrRouteEntryPriorityRequest
 * @return ModifyVpnPbrRouteEntryPriorityResponse
 */
ModifyVpnPbrRouteEntryPriorityResponse Client::modifyVpnPbrRouteEntryPriority(const ModifyVpnPbrRouteEntryPriorityRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyVpnPbrRouteEntryPriorityWithOptions(request, runtime);
}

/**
 * @summary Modifies the weight of a policy-based route of a VPN gateway.
 *
 * @description *   **ModifyVpnPbrRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
 *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
 *     *   If a VPN gateway is in the **active** state, the policy-based route entry is modified.
 * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryWeight** operation for the same VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnPbrRouteEntryWeightRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpnPbrRouteEntryWeightResponse
 */
ModifyVpnPbrRouteEntryWeightResponse Client::modifyVpnPbrRouteEntryWeightWithOptions(const ModifyVpnPbrRouteEntryWeightRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasNewWeight()) {
    query["NewWeight"] = request.newWeight();
  }

  if (!!request.hasNextHop()) {
    query["NextHop"] = request.nextHop();
  }

  if (!!request.hasOverlayMode()) {
    query["OverlayMode"] = request.overlayMode();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPriority()) {
    query["Priority"] = request.priority();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteDest()) {
    query["RouteDest"] = request.routeDest();
  }

  if (!!request.hasRouteSource()) {
    query["RouteSource"] = request.routeSource();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  if (!!request.hasWeight()) {
    query["Weight"] = request.weight();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyVpnPbrRouteEntryWeight"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyVpnPbrRouteEntryWeightResponse>();
}

/**
 * @summary Modifies the weight of a policy-based route of a VPN gateway.
 *
 * @description *   **ModifyVpnPbrRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
 *     *   If a VPN gateway is in the **updating** state, the policy-based route entry is being modified.
 *     *   If a VPN gateway is in the **active** state, the policy-based route entry is modified.
 * *   You cannot repeatedly call the **ModifyVpnPbrRouteEntryWeight** operation for the same VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnPbrRouteEntryWeightRequest
 * @return ModifyVpnPbrRouteEntryWeightResponse
 */
ModifyVpnPbrRouteEntryWeightResponse Client::modifyVpnPbrRouteEntryWeight(const ModifyVpnPbrRouteEntryWeightRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyVpnPbrRouteEntryWeightWithOptions(request, runtime);
}

/**
 * @summary Modifies the weight of a destination-based route.
 *
 * @description *   In scenarios where a VPN gateway has an active and a standby destination-based route, if you need to modify the weight of the active destination-based route, you must first delete the standby destination-based route. After you modify the active destination-based route, configure a standby destination-based route. If you need to modify the weight of the standby destination-based route, you also need to delete the active destination-based route first. After you modify the standby destination-based route, configure an active destination-based route. For more information about how to delete a destination-based route, see [DeleteVpnRouteEntry](https://help.aliyun.com/document_detail/2526961.html).
 * *   **ModifyVpnRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the weight of the destination-based route is being modified.
 *     *   If the VPN gateway is in the **active** state, the weight of the destination-based route is modified.
 * *   You cannot repeatedly call the **ModifyVpnRouteEntryWeight** operation to modify the weight of destination-based route for the same VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnRouteEntryWeightRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpnRouteEntryWeightResponse
 */
ModifyVpnRouteEntryWeightResponse Client::modifyVpnRouteEntryWeightWithOptions(const ModifyVpnRouteEntryWeightRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasNewWeight()) {
    query["NewWeight"] = request.newWeight();
  }

  if (!!request.hasNextHop()) {
    query["NextHop"] = request.nextHop();
  }

  if (!!request.hasOverlayMode()) {
    query["OverlayMode"] = request.overlayMode();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteDest()) {
    query["RouteDest"] = request.routeDest();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  if (!!request.hasWeight()) {
    query["Weight"] = request.weight();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyVpnRouteEntryWeight"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyVpnRouteEntryWeightResponse>();
}

/**
 * @summary Modifies the weight of a destination-based route.
 *
 * @description *   In scenarios where a VPN gateway has an active and a standby destination-based route, if you need to modify the weight of the active destination-based route, you must first delete the standby destination-based route. After you modify the active destination-based route, configure a standby destination-based route. If you need to modify the weight of the standby destination-based route, you also need to delete the active destination-based route first. After you modify the standby destination-based route, configure an active destination-based route. For more information about how to delete a destination-based route, see [DeleteVpnRouteEntry](https://help.aliyun.com/document_detail/2526961.html).
 * *   **ModifyVpnRouteEntryWeight** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [DescribeVpnGateway](https://help.aliyun.com/document_detail/73720.html) to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the weight of the destination-based route is being modified.
 *     *   If the VPN gateway is in the **active** state, the weight of the destination-based route is modified.
 * *   You cannot repeatedly call the **ModifyVpnRouteEntryWeight** operation to modify the weight of destination-based route for the same VPN gateway within the specified period of time.
 *
 * @param request ModifyVpnRouteEntryWeightRequest
 * @return ModifyVpnRouteEntryWeightResponse
 */
ModifyVpnRouteEntryWeightResponse Client::modifyVpnRouteEntryWeight(const ModifyVpnRouteEntryWeightRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyVpnRouteEntryWeightWithOptions(request, runtime);
}

/**
 * @summary Moves a resource to another resource group.
 *
 * @param request MoveResourceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return MoveResourceGroupResponse
 */
MoveResourceGroupResponse Client::moveResourceGroupWithOptions(const MoveResourceGroupRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasNewResourceGroupId()) {
    query["NewResourceGroupId"] = request.newResourceGroupId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceId()) {
    query["ResourceId"] = request.resourceId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasResourceType()) {
    query["ResourceType"] = request.resourceType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "MoveResourceGroup"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<MoveResourceGroupResponse>();
}

/**
 * @summary Moves a resource to another resource group.
 *
 * @param request MoveResourceGroupRequest
 * @return MoveResourceGroupResponse
 */
MoveResourceGroupResponse Client::moveResourceGroup(const MoveResourceGroupRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return moveResourceGroupWithOptions(request, runtime);
}

/**
 * @summary Moves a VPN gateway resource to a new resource group.
 *
 * @param request MoveVpnResourceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return MoveVpnResourceGroupResponse
 */
MoveVpnResourceGroupResponse Client::moveVpnResourceGroupWithOptions(const MoveVpnResourceGroupRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasNewResourceGroupId()) {
    query["NewResourceGroupId"] = request.newResourceGroupId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasResourceType()) {
    query["ResourceType"] = request.resourceType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "MoveVpnResourceGroup"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<MoveVpnResourceGroupResponse>();
}

/**
 * @summary Moves a VPN gateway resource to a new resource group.
 *
 * @param request MoveVpnResourceGroupRequest
 * @return MoveVpnResourceGroupResponse
 */
MoveVpnResourceGroupResponse Client::moveVpnResourceGroup(const MoveVpnResourceGroupRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return moveVpnResourceGroupWithOptions(request, runtime);
}

/**
 * @summary Enables the flow log feature.
 *
 * @description *   You cannot repeatedly call the **OpenFlowLogService** operation within the specified period of time by using an Alibaba Cloud account.
 * *   You can call the [GetFlowLogServiceStatus](https://help.aliyun.com/document_detail/449624.html) operation to query the status of the flow log feature.
 *
 * @param request OpenFlowLogServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenFlowLogServiceResponse
 */
OpenFlowLogServiceResponse Client::openFlowLogServiceWithOptions(const OpenFlowLogServiceRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OpenFlowLogService"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OpenFlowLogServiceResponse>();
}

/**
 * @summary Enables the flow log feature.
 *
 * @description *   You cannot repeatedly call the **OpenFlowLogService** operation within the specified period of time by using an Alibaba Cloud account.
 * *   You can call the [GetFlowLogServiceStatus](https://help.aliyun.com/document_detail/449624.html) operation to query the status of the flow log feature.
 *
 * @param request OpenFlowLogServiceRequest
 * @return OpenFlowLogServiceResponse
 */
OpenFlowLogServiceResponse Client::openFlowLogService(const OpenFlowLogServiceRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return openFlowLogServiceWithOptions(request, runtime);
}

/**
 * @summary Enables billing for outbound data transfer.
 *
 * @param request OpenPhysicalConnectionServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenPhysicalConnectionServiceResponse
 */
OpenPhysicalConnectionServiceResponse Client::openPhysicalConnectionServiceWithOptions(const OpenPhysicalConnectionServiceRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OpenPhysicalConnectionService"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OpenPhysicalConnectionServiceResponse>();
}

/**
 * @summary Enables billing for outbound data transfer.
 *
 * @param request OpenPhysicalConnectionServiceRequest
 * @return OpenPhysicalConnectionServiceResponse
 */
OpenPhysicalConnectionServiceResponse Client::openPhysicalConnectionService(const OpenPhysicalConnectionServiceRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return openPhysicalConnectionServiceWithOptions(request, runtime);
}

/**
 * @summary 开通IP地址池功能。
 *
 * @param request OpenPublicIpAddressPoolServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenPublicIpAddressPoolServiceResponse
 */
OpenPublicIpAddressPoolServiceResponse Client::openPublicIpAddressPoolServiceWithOptions(const OpenPublicIpAddressPoolServiceRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OpenPublicIpAddressPoolService"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OpenPublicIpAddressPoolServiceResponse>();
}

/**
 * @summary 开通IP地址池功能。
 *
 * @param request OpenPublicIpAddressPoolServiceRequest
 * @return OpenPublicIpAddressPoolServiceResponse
 */
OpenPublicIpAddressPoolServiceResponse Client::openPublicIpAddressPoolService(const OpenPublicIpAddressPoolServiceRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return openPublicIpAddressPoolServiceWithOptions(request, runtime);
}

/**
 * @summary Enables traffic mirror.
 *
 * @description ## [](#)Usage notes
 * You can enable traffic mirror for different regions. You cannot repeatedly call the **OpenTrafficMirrorService** operation to enable traffic mirror for one region within the specified period of time.
 *
 * @param request OpenTrafficMirrorServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenTrafficMirrorServiceResponse
 */
OpenTrafficMirrorServiceResponse Client::openTrafficMirrorServiceWithOptions(const OpenTrafficMirrorServiceRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OpenTrafficMirrorService"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OpenTrafficMirrorServiceResponse>();
}

/**
 * @summary Enables traffic mirror.
 *
 * @description ## [](#)Usage notes
 * You can enable traffic mirror for different regions. You cannot repeatedly call the **OpenTrafficMirrorService** operation to enable traffic mirror for one region within the specified period of time.
 *
 * @param request OpenTrafficMirrorServiceRequest
 * @return OpenTrafficMirrorServiceResponse
 */
OpenTrafficMirrorServiceResponse Client::openTrafficMirrorService(const OpenTrafficMirrorServiceRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return openTrafficMirrorServiceWithOptions(request, runtime);
}

/**
 * @summary Advertises VPC routes to an external component.
 *
 * @param request PublishVpcRouteEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublishVpcRouteEntriesResponse
 */
PublishVpcRouteEntriesResponse Client::publishVpcRouteEntriesWithOptions(const PublishVpcRouteEntriesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteEntries()) {
    query["RouteEntries"] = request.routeEntries();
  }

  if (!!request.hasTargetInstanceId()) {
    query["TargetInstanceId"] = request.targetInstanceId();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "PublishVpcRouteEntries"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<PublishVpcRouteEntriesResponse>();
}

/**
 * @summary Advertises VPC routes to an external component.
 *
 * @param request PublishVpcRouteEntriesRequest
 * @return PublishVpcRouteEntriesResponse
 */
PublishVpcRouteEntriesResponse Client::publishVpcRouteEntries(const PublishVpcRouteEntriesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return publishVpcRouteEntriesWithOptions(request, runtime);
}

/**
 * @summary Advertises a VPN route to a VPC.
 *
 * @param request PublishVpnRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublishVpnRouteEntryResponse
 */
PublishVpnRouteEntryResponse Client::publishVpnRouteEntryWithOptions(const PublishVpnRouteEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasNextHop()) {
    query["NextHop"] = request.nextHop();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPublishVpc()) {
    query["PublishVpc"] = request.publishVpc();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteDest()) {
    query["RouteDest"] = request.routeDest();
  }

  if (!!request.hasRouteType()) {
    query["RouteType"] = request.routeType();
  }

  if (!!request.hasVpnGatewayId()) {
    query["VpnGatewayId"] = request.vpnGatewayId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "PublishVpnRouteEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<PublishVpnRouteEntryResponse>();
}

/**
 * @summary Advertises a VPN route to a VPC.
 *
 * @param request PublishVpnRouteEntryRequest
 * @return PublishVpnRouteEntryResponse
 */
PublishVpnRouteEntryResponse Client::publishVpnRouteEntry(const PublishVpnRouteEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return publishVpnRouteEntryWithOptions(request, runtime);
}

/**
 * @summary Resumes an Express Connect circuit.
 *
 * @description # [](#)Description
 * You can call this API operation to resume a suspended Express Connect circuit. You can resume only shared Express Connect circuits by calling this API operation.
 *
 * @param request RecoverPhysicalConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RecoverPhysicalConnectionResponse
 */
RecoverPhysicalConnectionResponse Client::recoverPhysicalConnectionWithOptions(const RecoverPhysicalConnectionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasToken()) {
    query["Token"] = request.token();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "RecoverPhysicalConnection"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<RecoverPhysicalConnectionResponse>();
}

/**
 * @summary Resumes an Express Connect circuit.
 *
 * @description # [](#)Description
 * You can call this API operation to resume a suspended Express Connect circuit. You can resume only shared Express Connect circuits by calling this API operation.
 *
 * @param request RecoverPhysicalConnectionRequest
 * @return RecoverPhysicalConnectionResponse
 */
RecoverPhysicalConnectionResponse Client::recoverPhysicalConnection(const RecoverPhysicalConnectionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return recoverPhysicalConnectionWithOptions(request, runtime);
}

/**
 * @summary Enables a disabled virtual border router (VBR).
 *
 * @description After you call this operation, the VBR changes from the **terminated** state to the **recovering** state. After the operation is performed, the VBR enters the **active** state.
 * When you call this operation, take note of the following items:
 * *   Only the owner of the Express Connect circuit can call this operation.
 * *   The Express Connect circuit to which the VBR connects must be in the **Enabled** state.
 *
 * @param request RecoverVirtualBorderRouterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RecoverVirtualBorderRouterResponse
 */
RecoverVirtualBorderRouterResponse Client::recoverVirtualBorderRouterWithOptions(const RecoverVirtualBorderRouterRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVbrId()) {
    query["VbrId"] = request.vbrId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "RecoverVirtualBorderRouter"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<RecoverVirtualBorderRouterResponse>();
}

/**
 * @summary Enables a disabled virtual border router (VBR).
 *
 * @description After you call this operation, the VBR changes from the **terminated** state to the **recovering** state. After the operation is performed, the VBR enters the **active** state.
 * When you call this operation, take note of the following items:
 * *   Only the owner of the Express Connect circuit can call this operation.
 * *   The Express Connect circuit to which the VBR connects must be in the **Enabled** state.
 *
 * @param request RecoverVirtualBorderRouterRequest
 * @return RecoverVirtualBorderRouterResponse
 */
RecoverVirtualBorderRouterResponse Client::recoverVirtualBorderRouter(const RecoverVirtualBorderRouterRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return recoverVirtualBorderRouterWithOptions(request, runtime);
}

/**
 * @summary Releases an elastic IP address (EIP).
 *
 * @description Before you call this operation, take note of the following items:
 * *   Before you release an EIP, make sure that the EIP meets the following requirements:
 *     *   You can release only an EIP that is in the **Available** state.
 *     *   You can release only a pay-as-you-go EIP. You cannot release a subscription EIP.
 * *   **ReleaseEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task:
 *     *   If the EIP is in the **Releasing** state, the EIP is being released. In this state, you can only query the EIP and cannot perform other operations.
 *     *   If you cannot query the EIP, the EIP is released.
 * *   You cannot repeatedly call the **ReleaseEipAddress** operation to release an EIP within the specified period of time.
 *
 * @param request ReleaseEipAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseEipAddressResponse
 */
ReleaseEipAddressResponse Client::releaseEipAddressWithOptions(const ReleaseEipAddressRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAllocationId()) {
    query["AllocationId"] = request.allocationId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ReleaseEipAddress"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ReleaseEipAddressResponse>();
}

/**
 * @summary Releases an elastic IP address (EIP).
 *
 * @description Before you call this operation, take note of the following items:
 * *   Before you release an EIP, make sure that the EIP meets the following requirements:
 *     *   You can release only an EIP that is in the **Available** state.
 *     *   You can release only a pay-as-you-go EIP. You cannot release a subscription EIP.
 * *   **ReleaseEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task:
 *     *   If the EIP is in the **Releasing** state, the EIP is being released. In this state, you can only query the EIP and cannot perform other operations.
 *     *   If you cannot query the EIP, the EIP is released.
 * *   You cannot repeatedly call the **ReleaseEipAddress** operation to release an EIP within the specified period of time.
 *
 * @param request ReleaseEipAddressRequest
 * @return ReleaseEipAddressResponse
 */
ReleaseEipAddressResponse Client::releaseEipAddress(const ReleaseEipAddressRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return releaseEipAddressWithOptions(request, runtime);
}

/**
 * @summary Releases contiguous elastic IP addresses (EIPs).
 *
 * @description *   After you call the **ReleaseEipSegmentAddress** operation, all EIPs in the specified group are released.
 * *   **ReleaseEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
 *     *   If the group is in the **Releasing** state, EIPs in the group are being released. In this state, you can only query the group and cannot perform other operations.
 *     *   If you cannot query the group of contiguous EIPs, the contiguous EIPs are released.
 * *   You cannot repeatedly call the **ReleaseEipSegmentAddress** operation to release a group of contiguous EIPs within the specified period of time.
 *
 * @param request ReleaseEipSegmentAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseEipSegmentAddressResponse
 */
ReleaseEipSegmentAddressResponse Client::releaseEipSegmentAddressWithOptions(const ReleaseEipSegmentAddressRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSegmentInstanceId()) {
    query["SegmentInstanceId"] = request.segmentInstanceId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ReleaseEipSegmentAddress"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ReleaseEipSegmentAddressResponse>();
}

/**
 * @summary Releases contiguous elastic IP addresses (EIPs).
 *
 * @description *   After you call the **ReleaseEipSegmentAddress** operation, all EIPs in the specified group are released.
 * *   **ReleaseEipSegmentAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipSegment](https://help.aliyun.com/document_detail/156063.html) operation to query the status of the task.
 *     *   If the group is in the **Releasing** state, EIPs in the group are being released. In this state, you can only query the group and cannot perform other operations.
 *     *   If you cannot query the group of contiguous EIPs, the contiguous EIPs are released.
 * *   You cannot repeatedly call the **ReleaseEipSegmentAddress** operation to release a group of contiguous EIPs within the specified period of time.
 *
 * @param request ReleaseEipSegmentAddressRequest
 * @return ReleaseEipSegmentAddressResponse
 */
ReleaseEipSegmentAddressResponse Client::releaseEipSegmentAddress(const ReleaseEipSegmentAddressRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return releaseEipSegmentAddressWithOptions(request, runtime);
}

/**
 * @summary Releases an idle IPv6 address.
 *
 * @param request ReleaseIpv6AddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseIpv6AddressResponse
 */
ReleaseIpv6AddressResponse Client::releaseIpv6AddressWithOptions(const ReleaseIpv6AddressRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIpv6AddressId()) {
    query["Ipv6AddressId"] = request.ipv6AddressId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ReleaseIpv6Address"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ReleaseIpv6AddressResponse>();
}

/**
 * @summary Releases an idle IPv6 address.
 *
 * @param request ReleaseIpv6AddressRequest
 * @return ReleaseIpv6AddressResponse
 */
ReleaseIpv6AddressResponse Client::releaseIpv6Address(const ReleaseIpv6AddressRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return releaseIpv6AddressWithOptions(request, runtime);
}

/**
 * @summary Disassociates an EIP from an Internet Shared Bandwidth instance.
 *
 * @param request RemoveCommonBandwidthPackageIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveCommonBandwidthPackageIpResponse
 */
RemoveCommonBandwidthPackageIpResponse Client::removeCommonBandwidthPackageIpWithOptions(const RemoveCommonBandwidthPackageIpRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidthPackageId()) {
    query["BandwidthPackageId"] = request.bandwidthPackageId();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasIpInstanceId()) {
    query["IpInstanceId"] = request.ipInstanceId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "RemoveCommonBandwidthPackageIp"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<RemoveCommonBandwidthPackageIpResponse>();
}

/**
 * @summary Disassociates an EIP from an Internet Shared Bandwidth instance.
 *
 * @param request RemoveCommonBandwidthPackageIpRequest
 * @return RemoveCommonBandwidthPackageIpResponse
 */
RemoveCommonBandwidthPackageIpResponse Client::removeCommonBandwidthPackageIp(const RemoveCommonBandwidthPackageIpRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return removeCommonBandwidthPackageIpWithOptions(request, runtime);
}

/**
 * @param request RemoveGlobalAccelerationInstanceIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveGlobalAccelerationInstanceIpResponse
 */
RemoveGlobalAccelerationInstanceIpResponse Client::removeGlobalAccelerationInstanceIpWithOptions(const RemoveGlobalAccelerationInstanceIpRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasGlobalAccelerationInstanceId()) {
    query["GlobalAccelerationInstanceId"] = request.globalAccelerationInstanceId();
  }

  if (!!request.hasIpInstanceId()) {
    query["IpInstanceId"] = request.ipInstanceId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "RemoveGlobalAccelerationInstanceIp"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<RemoveGlobalAccelerationInstanceIpResponse>();
}

/**
 * @param request RemoveGlobalAccelerationInstanceIpRequest
 * @return RemoveGlobalAccelerationInstanceIpResponse
 */
RemoveGlobalAccelerationInstanceIpResponse Client::removeGlobalAccelerationInstanceIp(const RemoveGlobalAccelerationInstanceIpRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return removeGlobalAccelerationInstanceIpWithOptions(request, runtime);
}

/**
 * @summary Deletes an IP entry from an ACL.
 *
 * @param request RemoveIPv6TranslatorAclListEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveIPv6TranslatorAclListEntryResponse
 */
RemoveIPv6TranslatorAclListEntryResponse Client::removeIPv6TranslatorAclListEntryWithOptions(const RemoveIPv6TranslatorAclListEntryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAclEntryId()) {
    query["AclEntryId"] = request.aclEntryId();
  }

  if (!!request.hasAclId()) {
    query["AclId"] = request.aclId();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "RemoveIPv6TranslatorAclListEntry"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<RemoveIPv6TranslatorAclListEntryResponse>();
}

/**
 * @summary Deletes an IP entry from an ACL.
 *
 * @param request RemoveIPv6TranslatorAclListEntryRequest
 * @return RemoveIPv6TranslatorAclListEntryResponse
 */
RemoveIPv6TranslatorAclListEntryResponse Client::removeIPv6TranslatorAclListEntry(const RemoveIPv6TranslatorAclListEntryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return removeIPv6TranslatorAclListEntryWithOptions(request, runtime);
}

/**
 * @summary Deletes a traffic mirror source from a traffic mirror session.
 *
 * @description *   **RemoveSourcesFromTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
 *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being deleted.
 *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is deleted.
 * *   You cannot repeatedly call **RemoveSourcesFromTrafficMirrorSession** within the specified period of time.
 *
 * @param request RemoveSourcesFromTrafficMirrorSessionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveSourcesFromTrafficMirrorSessionResponse
 */
RemoveSourcesFromTrafficMirrorSessionResponse Client::removeSourcesFromTrafficMirrorSessionWithOptions(const RemoveSourcesFromTrafficMirrorSessionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTrafficMirrorSessionId()) {
    query["TrafficMirrorSessionId"] = request.trafficMirrorSessionId();
  }

  if (!!request.hasTrafficMirrorSourceIds()) {
    query["TrafficMirrorSourceIds"] = request.trafficMirrorSourceIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "RemoveSourcesFromTrafficMirrorSession"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<RemoveSourcesFromTrafficMirrorSessionResponse>();
}

/**
 * @summary Deletes a traffic mirror source from a traffic mirror session.
 *
 * @description *   **RemoveSourcesFromTrafficMirrorSession** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
 *     *   If the traffic mirror session is in the **Modifying** state, the traffic mirror source is being deleted.
 *     *   If the traffic mirror session is in the **Created** state, the traffic mirror source is deleted.
 * *   You cannot repeatedly call **RemoveSourcesFromTrafficMirrorSession** within the specified period of time.
 *
 * @param request RemoveSourcesFromTrafficMirrorSessionRequest
 * @return RemoveSourcesFromTrafficMirrorSessionResponse
 */
RemoveSourcesFromTrafficMirrorSessionResponse Client::removeSourcesFromTrafficMirrorSession(const RemoveSourcesFromTrafficMirrorSessionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return removeSourcesFromTrafficMirrorSessionWithOptions(request, runtime);
}

/**
 * @summary 更改DHCP选项集与VPC的关联。
 *
 * @description *   The **ReplaceVpcDhcpOptionsSet** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
 *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being replaced.
 *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is replaced.
 * *   You cannot repeatedly call the **ReplaceVpcDhcpOptionsSet** operation to replace the DHCP options set associated with a VPC within the specified period of time.
 *
 * @param request ReplaceVpcDhcpOptionsSetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReplaceVpcDhcpOptionsSetResponse
 */
ReplaceVpcDhcpOptionsSetResponse Client::replaceVpcDhcpOptionsSetWithOptions(const ReplaceVpcDhcpOptionsSetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDhcpOptionsSetId()) {
    query["DhcpOptionsSetId"] = request.dhcpOptionsSetId();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ReplaceVpcDhcpOptionsSet"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ReplaceVpcDhcpOptionsSetResponse>();
}

/**
 * @summary 更改DHCP选项集与VPC的关联。
 *
 * @description *   The **ReplaceVpcDhcpOptionsSet** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [DescribeVpcAttribute](https://help.aliyun.com/document_detail/94565.html) operation to query the status of a DHCP options set:
 *     *   If the DHCP options set is in the **Pending** state, the DHCP options set is being replaced.
 *     *   If the DHCP options set is in the **InUse** state, the DHCP options set is replaced.
 * *   You cannot repeatedly call the **ReplaceVpcDhcpOptionsSet** operation to replace the DHCP options set associated with a VPC within the specified period of time.
 *
 * @param request ReplaceVpcDhcpOptionsSetRequest
 * @return ReplaceVpcDhcpOptionsSetResponse
 */
ReplaceVpcDhcpOptionsSetResponse Client::replaceVpcDhcpOptionsSet(const ReplaceVpcDhcpOptionsSetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return replaceVpcDhcpOptionsSetWithOptions(request, runtime);
}

/**
 * @summary Re-applies a prefix list.
 *
 * @description *   If you modify the information about a prefix list but the modification is not automatically applied to the route table that is associated with the prefix list, you can call this operation to apply the latest prefix list to the associated route table.
 * *   The **RetryVpcPrefixListAssociation** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the background. You can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) to check whether the prefix list is re-applied.
 *     *   If the prefix list is in the **Modifying** state, the prefix list is being re-applied.
 *     *   If the prefix list is in the **ModifyFailed** state, the prefix list fails to be re-applied.
 *     *   If the prefix list is in the **Created** state, the prefix list is re-applied.
 * *   After you call the **RetryVpcPrefixListAssociation** operation to re-apply a prefix list, you cannot call the operation again until the current task is complete.
 *
 * @param request RetryVpcPrefixListAssociationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RetryVpcPrefixListAssociationResponse
 */
RetryVpcPrefixListAssociationResponse Client::retryVpcPrefixListAssociationWithOptions(const RetryVpcPrefixListAssociationRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPrefixListId()) {
    query["PrefixListId"] = request.prefixListId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceId()) {
    query["ResourceId"] = request.resourceId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasResourceType()) {
    query["ResourceType"] = request.resourceType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "RetryVpcPrefixListAssociation"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<RetryVpcPrefixListAssociationResponse>();
}

/**
 * @summary Re-applies a prefix list.
 *
 * @description *   If you modify the information about a prefix list but the modification is not automatically applied to the route table that is associated with the prefix list, you can call this operation to apply the latest prefix list to the associated route table.
 * *   The **RetryVpcPrefixListAssociation** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the background. You can call the [GetVpcPrefixListAssociations](https://help.aliyun.com/document_detail/445478.html) to check whether the prefix list is re-applied.
 *     *   If the prefix list is in the **Modifying** state, the prefix list is being re-applied.
 *     *   If the prefix list is in the **ModifyFailed** state, the prefix list fails to be re-applied.
 *     *   If the prefix list is in the **Created** state, the prefix list is re-applied.
 * *   After you call the **RetryVpcPrefixListAssociation** operation to re-apply a prefix list, you cannot call the operation again until the current task is complete.
 *
 * @param request RetryVpcPrefixListAssociationRequest
 * @return RetryVpcPrefixListAssociationResponse
 */
RetryVpcPrefixListAssociationResponse Client::retryVpcPrefixListAssociation(const RetryVpcPrefixListAssociationRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return retryVpcPrefixListAssociationWithOptions(request, runtime);
}

/**
 * @summary Revokes the permissions granted to a Cloud Enterprise Network (CEN) instance on a network instance.
 *
 * @description ## [](#)Usage notes
 * *   **RevokeInstanceFromCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use `vpc.aliyuncs.com` as the domain name when you call this operation. The API version is `2016-04-28`.
 * *   You cannot repeatedly call the **RevokeInstanceFromCen** operation to revoke the permissions on a network instance that is attached to a CEN instance within the specified period of time. The network instance can be a VPC, virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
 *
 * @param request RevokeInstanceFromCenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokeInstanceFromCenResponse
 */
RevokeInstanceFromCenResponse Client::revokeInstanceFromCenWithOptions(const RevokeInstanceFromCenRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCenId()) {
    query["CenId"] = request.cenId();
  }

  if (!!request.hasCenOwnerId()) {
    query["CenOwnerId"] = request.cenOwnerId();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasInstanceType()) {
    query["InstanceType"] = request.instanceType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "RevokeInstanceFromCen"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<RevokeInstanceFromCenResponse>();
}

/**
 * @summary Revokes the permissions granted to a Cloud Enterprise Network (CEN) instance on a network instance.
 *
 * @description ## [](#)Usage notes
 * *   **RevokeInstanceFromCen** is a Virtual Private Cloud (VPC) operation. Therefore, you must use `vpc.aliyuncs.com` as the domain name when you call this operation. The API version is `2016-04-28`.
 * *   You cannot repeatedly call the **RevokeInstanceFromCen** operation to revoke the permissions on a network instance that is attached to a CEN instance within the specified period of time. The network instance can be a VPC, virtual border router (VBR), or a Cloud Connect Network (CCN) instance.
 *
 * @param request RevokeInstanceFromCenRequest
 * @return RevokeInstanceFromCenResponse
 */
RevokeInstanceFromCenResponse Client::revokeInstanceFromCen(const RevokeInstanceFromCenRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return revokeInstanceFromCenWithOptions(request, runtime);
}

/**
 * @summary Revokes the permissions granted to a virtual border router (VBR) on a virtual private cloud (VPC).
 *
 * @param tmpReq RevokeInstanceFromVbrRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokeInstanceFromVbrResponse
 */
RevokeInstanceFromVbrResponse Client::revokeInstanceFromVbrWithOptions(const RevokeInstanceFromVbrRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  RevokeInstanceFromVbrShrinkRequest request = RevokeInstanceFromVbrShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasVbrInstanceIds()) {
    request.setVbrInstanceIdsShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.vbrInstanceIds(), "VbrInstanceIds", "simple"));
  }

  json query = {};
  if (!!request.hasGrantType()) {
    query["GrantType"] = request.grantType();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasVbrInstanceIdsShrink()) {
    query["VbrInstanceIds"] = request.vbrInstanceIdsShrink();
  }

  if (!!request.hasVbrOwnerUid()) {
    query["VbrOwnerUid"] = request.vbrOwnerUid();
  }

  if (!!request.hasVbrRegionNo()) {
    query["VbrRegionNo"] = request.vbrRegionNo();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "RevokeInstanceFromVbr"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<RevokeInstanceFromVbrResponse>();
}

/**
 * @summary Revokes the permissions granted to a virtual border router (VBR) on a virtual private cloud (VPC).
 *
 * @param request RevokeInstanceFromVbrRequest
 * @return RevokeInstanceFromVbrResponse
 */
RevokeInstanceFromVbrResponse Client::revokeInstanceFromVbr(const RevokeInstanceFromVbrRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return revokeInstanceFromVbrWithOptions(request, runtime);
}

/**
 * @summary If your application for a Letter of Authorization (LOA) by calling the ApplyPhysicalConnectionLOA operation is denied, you can call this operation to apply again.
 *
 * @param request SecondApplyPhysicalConnectionLOARequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SecondApplyPhysicalConnectionLOAResponse
 */
SecondApplyPhysicalConnectionLOAResponse Client::secondApplyPhysicalConnectionLOAWithOptions(const SecondApplyPhysicalConnectionLOARequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasCompanyName()) {
    query["CompanyName"] = request.companyName();
  }

  if (!!request.hasConstructionTime()) {
    query["ConstructionTime"] = request.constructionTime();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasLineType()) {
    query["LineType"] = request.lineType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPMInfo()) {
    query["PMInfo"] = request.PMInfo();
  }

  if (!!request.hasPeerLocation()) {
    query["PeerLocation"] = request.peerLocation();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSi()) {
    query["Si"] = request.si();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "SecondApplyPhysicalConnectionLOA"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<SecondApplyPhysicalConnectionLOAResponse>();
}

/**
 * @summary If your application for a Letter of Authorization (LOA) by calling the ApplyPhysicalConnectionLOA operation is denied, you can call this operation to apply again.
 *
 * @param request SecondApplyPhysicalConnectionLOARequest
 * @return SecondApplyPhysicalConnectionLOAResponse
 */
SecondApplyPhysicalConnectionLOAResponse Client::secondApplyPhysicalConnectionLOA(const SecondApplyPhysicalConnectionLOARequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return secondApplyPhysicalConnectionLOAWithOptions(request, runtime);
}

/**
 * @summary Configures fine-grained monitoring for an elastic IP address (EIP).
 *
 * @description You cannot repeatedly call **SetHighDefinitionMonitorLogStatus** within a specific period of time.
 *
 * @param request SetHighDefinitionMonitorLogStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetHighDefinitionMonitorLogStatusResponse
 */
SetHighDefinitionMonitorLogStatusResponse Client::setHighDefinitionMonitorLogStatusWithOptions(const SetHighDefinitionMonitorLogStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasInstanceType()) {
    query["InstanceType"] = request.instanceType();
  }

  if (!!request.hasLogProject()) {
    query["LogProject"] = request.logProject();
  }

  if (!!request.hasLogStore()) {
    query["LogStore"] = request.logStore();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "SetHighDefinitionMonitorLogStatus"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<SetHighDefinitionMonitorLogStatusResponse>();
}

/**
 * @summary Configures fine-grained monitoring for an elastic IP address (EIP).
 *
 * @description You cannot repeatedly call **SetHighDefinitionMonitorLogStatus** within a specific period of time.
 *
 * @param request SetHighDefinitionMonitorLogStatusRequest
 * @return SetHighDefinitionMonitorLogStatusResponse
 */
SetHighDefinitionMonitorLogStatusResponse Client::setHighDefinitionMonitorLogStatus(const SetHighDefinitionMonitorLogStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return setHighDefinitionMonitorLogStatusWithOptions(request, runtime);
}

/**
 * @summary Performs a failover test.
 *
 * @description You can perform only failover tests that are in the **Pending** state.
 *
 * @param request StartFailoverTestJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartFailoverTestJobResponse
 */
StartFailoverTestJobResponse Client::startFailoverTestJobWithOptions(const StartFailoverTestJobRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasJobId()) {
    query["JobId"] = request.jobId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "StartFailoverTestJob"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<StartFailoverTestJobResponse>();
}

/**
 * @summary Performs a failover test.
 *
 * @description You can perform only failover tests that are in the **Pending** state.
 *
 * @param request StartFailoverTestJobRequest
 * @return StartFailoverTestJobResponse
 */
StartFailoverTestJobResponse Client::startFailoverTestJob(const StartFailoverTestJobRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return startFailoverTestJobWithOptions(request, runtime);
}

/**
 * @summary Terminates a failover test.
 *
 * @param request StopFailoverTestJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopFailoverTestJobResponse
 */
StopFailoverTestJobResponse Client::stopFailoverTestJobWithOptions(const StopFailoverTestJobRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasJobId()) {
    query["JobId"] = request.jobId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "StopFailoverTestJob"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<StopFailoverTestJobResponse>();
}

/**
 * @summary Terminates a failover test.
 *
 * @param request StopFailoverTestJobRequest
 * @return StopFailoverTestJobResponse
 */
StopFailoverTestJobResponse Client::stopFailoverTestJob(const StopFailoverTestJobRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return stopFailoverTestJobWithOptions(request, runtime);
}

/**
 * @summary Creates and adds tags to resources.
 *
 * @description Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following limits:
 * *   The keys of tags that are added to the same instance must be unique.
 * *   You cannot create tags without adding them to instances. All tags must be added to instances.
 * *   Tag information is not shared across regions.
 *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
 * *   Virtual private clouds (VPCs), route tables, vSwitches, and elastic IP addresses (EIPs) that belong to the same Alibaba Cloud account and are deployed in the same region share tag information with each other.
 *     For example, if you added a tag to a VPC, the tag is available to vSwitches, route tables, and EIPs that belong to the same account and are deployed in the same region in which the VPC is created. You can select this tag from the editing page without the need to enter the tag again. You can modify the key and the value of a tag or remove a tag from an instance. After you delete an instance, all tags that are added to the instance are deleted.
 * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
 *
 * @param request TagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
TagResourcesResponse Client::tagResourcesWithOptions(const TagResourcesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceId()) {
    query["ResourceId"] = request.resourceId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasResourceType()) {
    query["ResourceType"] = request.resourceType();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "TagResources"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<TagResourcesResponse>();
}

/**
 * @summary Creates and adds tags to resources.
 *
 * @description Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following limits:
 * *   The keys of tags that are added to the same instance must be unique.
 * *   You cannot create tags without adding them to instances. All tags must be added to instances.
 * *   Tag information is not shared across regions.
 *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
 * *   Virtual private clouds (VPCs), route tables, vSwitches, and elastic IP addresses (EIPs) that belong to the same Alibaba Cloud account and are deployed in the same region share tag information with each other.
 *     For example, if you added a tag to a VPC, the tag is available to vSwitches, route tables, and EIPs that belong to the same account and are deployed in the same region in which the VPC is created. You can select this tag from the editing page without the need to enter the tag again. You can modify the key and the value of a tag or remove a tag from an instance. After you delete an instance, all tags that are added to the instance are deleted.
 * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
TagResourcesResponse Client::tagResources(const TagResourcesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return tagResourcesWithOptions(request, runtime);
}

/**
 * @summary Creates tags and adds the tags to an Express Connect circuit.
 *
 * @description ## [](#)
 * Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following items:
 * *   Each tag key that is added to an instance must be unique.
 * *   You cannot create tags without adding them to instances. All tags must be added to instances.
 * *   Tag information is not shared across regions.
 *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
 * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
 *
 * @param request TagResourcesForExpressConnectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesForExpressConnectResponse
 */
TagResourcesForExpressConnectResponse Client::tagResourcesForExpressConnectWithOptions(const TagResourcesForExpressConnectRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceId()) {
    query["ResourceId"] = request.resourceId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasResourceType()) {
    query["ResourceType"] = request.resourceType();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "TagResourcesForExpressConnect"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<TagResourcesForExpressConnectResponse>();
}

/**
 * @summary Creates tags and adds the tags to an Express Connect circuit.
 *
 * @description ## [](#)
 * Tags are used to classify instances. Each tag consists of a key-value pair. Before you use tags, take note of the following items:
 * *   Each tag key that is added to an instance must be unique.
 * *   You cannot create tags without adding them to instances. All tags must be added to instances.
 * *   Tag information is not shared across regions.
 *     For example, you cannot view the tags that are created in the China (Hangzhou) region from the China (Shanghai) region.
 * *   You can add up to 20 tags to each instance. Before you add a tag to an instance, the system automatically checks the number of existing tags. An error message is returned if the maximum number of tags is reached.
 *
 * @param request TagResourcesForExpressConnectRequest
 * @return TagResourcesForExpressConnectResponse
 */
TagResourcesForExpressConnectResponse Client::tagResourcesForExpressConnect(const TagResourcesForExpressConnectRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return tagResourcesForExpressConnectWithOptions(request, runtime);
}

/**
 * @summary Disables an Express Connect circuit after it is enabled.
 *
 * @description After you call this operation, the specified Express Connect circuit changes to the **Terminating** state. After the Express Connect circuit is disabled, it changes to the **Terminated** state. When you call this operation, take note of the following limits:
 * *   You can only disable an Express Connect circuit that is in the **Enabled** state.
 * *   Before you disable an Express Connect circuit, you must delete the virtual border routers (VBRs) associated with it.
 *
 * @param request TerminatePhysicalConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TerminatePhysicalConnectionResponse
 */
TerminatePhysicalConnectionResponse Client::terminatePhysicalConnectionWithOptions(const TerminatePhysicalConnectionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPhysicalConnectionId()) {
    query["PhysicalConnectionId"] = request.physicalConnectionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "TerminatePhysicalConnection"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<TerminatePhysicalConnectionResponse>();
}

/**
 * @summary Disables an Express Connect circuit after it is enabled.
 *
 * @description After you call this operation, the specified Express Connect circuit changes to the **Terminating** state. After the Express Connect circuit is disabled, it changes to the **Terminated** state. When you call this operation, take note of the following limits:
 * *   You can only disable an Express Connect circuit that is in the **Enabled** state.
 * *   Before you disable an Express Connect circuit, you must delete the virtual border routers (VBRs) associated with it.
 *
 * @param request TerminatePhysicalConnectionRequest
 * @return TerminatePhysicalConnectionResponse
 */
TerminatePhysicalConnectionResponse Client::terminatePhysicalConnection(const TerminatePhysicalConnectionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return terminatePhysicalConnectionWithOptions(request, runtime);
}

/**
 * @summary Terminates a virtual border router (VBR).
 *
 * @description After you call this operation, the VBR enters the **terminating** state from the **active** state. After the VBR is terminated, the VBR enters the **terminated** state.
 * >  Only the owner of an Express Connect circuit can call this operation.
 *
 * @param request TerminateVirtualBorderRouterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TerminateVirtualBorderRouterResponse
 */
TerminateVirtualBorderRouterResponse Client::terminateVirtualBorderRouterWithOptions(const TerminateVirtualBorderRouterRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVbrId()) {
    query["VbrId"] = request.vbrId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "TerminateVirtualBorderRouter"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<TerminateVirtualBorderRouterResponse>();
}

/**
 * @summary Terminates a virtual border router (VBR).
 *
 * @description After you call this operation, the VBR enters the **terminating** state from the **active** state. After the VBR is terminated, the VBR enters the **terminated** state.
 * >  Only the owner of an Express Connect circuit can call this operation.
 *
 * @param request TerminateVirtualBorderRouterRequest
 * @return TerminateVirtualBorderRouterResponse
 */
TerminateVirtualBorderRouterResponse Client::terminateVirtualBorderRouter(const TerminateVirtualBorderRouterRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return terminateVirtualBorderRouterWithOptions(request, runtime);
}

/**
 * @summary Migrate contiguous EIP groups to IP address pool by calling TransformEipSegmentToPublicIpAddressPool.
 *
 * @param request TransformEipSegmentToPublicIpAddressPoolRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TransformEipSegmentToPublicIpAddressPoolResponse
 */
TransformEipSegmentToPublicIpAddressPoolResponse Client::transformEipSegmentToPublicIpAddressPoolWithOptions(const TransformEipSegmentToPublicIpAddressPoolRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceGroupId()) {
    query["ResourceGroupId"] = request.resourceGroupId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "TransformEipSegmentToPublicIpAddressPool"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<TransformEipSegmentToPublicIpAddressPoolResponse>();
}

/**
 * @summary Migrate contiguous EIP groups to IP address pool by calling TransformEipSegmentToPublicIpAddressPool.
 *
 * @param request TransformEipSegmentToPublicIpAddressPoolRequest
 * @return TransformEipSegmentToPublicIpAddressPoolResponse
 */
TransformEipSegmentToPublicIpAddressPoolResponse Client::transformEipSegmentToPublicIpAddressPool(const TransformEipSegmentToPublicIpAddressPoolRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return transformEipSegmentToPublicIpAddressPoolWithOptions(request, runtime);
}

/**
 * @summary Removes tags from resources.
 *
 * @param request UnTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnTagResourcesResponse
 */
UnTagResourcesResponse Client::unTagResourcesWithOptions(const UnTagResourcesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAll()) {
    query["All"] = request.all();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceId()) {
    query["ResourceId"] = request.resourceId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasResourceType()) {
    query["ResourceType"] = request.resourceType();
  }

  if (!!request.hasTagKey()) {
    query["TagKey"] = request.tagKey();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UnTagResources"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UnTagResourcesResponse>();
}

/**
 * @summary Removes tags from resources.
 *
 * @param request UnTagResourcesRequest
 * @return UnTagResourcesResponse
 */
UnTagResourcesResponse Client::unTagResources(const UnTagResourcesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return unTagResourcesWithOptions(request, runtime);
}

/**
 * @summary Disassociates an elastic IP address (EIP) from a cloud resource.
 *
 * @description *   **UnassociateEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
 *     *   If the EIP is in the **Unassociating** state, the EIP is being disassociated. In this state, you can only query the EIP and cannot perform other operations.
 *     *   If the EIP is in the **Available** state, the EIP is disassociated.
 * *   You cannot repeatedly call the **UnassociateEipAddress** operation within the specified period of time.
 *
 * @param request UnassociateEipAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnassociateEipAddressResponse
 */
UnassociateEipAddressResponse Client::unassociateEipAddressWithOptions(const UnassociateEipAddressRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAllocationId()) {
    query["AllocationId"] = request.allocationId();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasForce()) {
    query["Force"] = request.force();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasInstanceType()) {
    query["InstanceType"] = request.instanceType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPrivateIpAddress()) {
    query["PrivateIpAddress"] = request.privateIpAddress();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UnassociateEipAddress"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UnassociateEipAddressResponse>();
}

/**
 * @summary Disassociates an elastic IP address (EIP) from a cloud resource.
 *
 * @description *   **UnassociateEipAddress** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEipAddresses](https://help.aliyun.com/document_detail/120193.html) operation to query the status of the task.
 *     *   If the EIP is in the **Unassociating** state, the EIP is being disassociated. In this state, you can only query the EIP and cannot perform other operations.
 *     *   If the EIP is in the **Available** state, the EIP is disassociated.
 * *   You cannot repeatedly call the **UnassociateEipAddress** operation within the specified period of time.
 *
 * @param request UnassociateEipAddressRequest
 * @return UnassociateEipAddressResponse
 */
UnassociateEipAddressResponse Client::unassociateEipAddress(const UnassociateEipAddressRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return unassociateEipAddressWithOptions(request, runtime);
}

/**
 * @summary Disassociates a Global Accelerator (GA) instance from a backend server.
 *
 * @param request UnassociateGlobalAccelerationInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnassociateGlobalAccelerationInstanceResponse
 */
UnassociateGlobalAccelerationInstanceResponse Client::unassociateGlobalAccelerationInstanceWithOptions(const UnassociateGlobalAccelerationInstanceRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasGlobalAccelerationInstanceId()) {
    query["GlobalAccelerationInstanceId"] = request.globalAccelerationInstanceId();
  }

  if (!!request.hasInstanceType()) {
    query["InstanceType"] = request.instanceType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UnassociateGlobalAccelerationInstance"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UnassociateGlobalAccelerationInstanceResponse>();
}

/**
 * @summary Disassociates a Global Accelerator (GA) instance from a backend server.
 *
 * @param request UnassociateGlobalAccelerationInstanceRequest
 * @return UnassociateGlobalAccelerationInstanceResponse
 */
UnassociateGlobalAccelerationInstanceResponse Client::unassociateGlobalAccelerationInstance(const UnassociateGlobalAccelerationInstanceRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return unassociateGlobalAccelerationInstanceWithOptions(request, runtime);
}

/**
 * @summary Disassociates a high-availability virtual IP address (HaVip) from an Elastic Compute Service (ECS) in a virtual private cloud (VPC) or from an elastic network interface (ENI).
 *
 * @description ## [](#)
 * When you call this operation, take note of the following limits:
 * *   The ECS instance must be in the **Running** or **Stopped** state.
 * *   The HaVip must be in the **Available** or **InUse** state.
 * *   **UnassociateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and an instance ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
 *     *   If the HaVip is in the **Unassociating** state, the HaVip is being disassociated.
 *     *   If the HaVip is in the **Inuse** or **Available** state, the HaVip is disassociated.
 * *   You cannot repeatedly call the **UnassociateHaVip** operation to disassociate an HaVip within the specified period of time.
 *
 * @param request UnassociateHaVipRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnassociateHaVipResponse
 */
UnassociateHaVipResponse Client::unassociateHaVipWithOptions(const UnassociateHaVipRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasForce()) {
    query["Force"] = request.force();
  }

  if (!!request.hasHaVipId()) {
    query["HaVipId"] = request.haVipId();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasInstanceType()) {
    query["InstanceType"] = request.instanceType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UnassociateHaVip"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UnassociateHaVipResponse>();
}

/**
 * @summary Disassociates a high-availability virtual IP address (HaVip) from an Elastic Compute Service (ECS) in a virtual private cloud (VPC) or from an elastic network interface (ENI).
 *
 * @description ## [](#)
 * When you call this operation, take note of the following limits:
 * *   The ECS instance must be in the **Running** or **Stopped** state.
 * *   The HaVip must be in the **Available** or **InUse** state.
 * *   **UnassociateHaVip** is an asynchronous operation. After a request is sent, the system returns a request ID and an instance ID and runs the task in the background. You can call the [DescribeHaVips](https://help.aliyun.com/document_detail/114611.html) operation to query the status of an HaVip:
 *     *   If the HaVip is in the **Unassociating** state, the HaVip is being disassociated.
 *     *   If the HaVip is in the **Inuse** or **Available** state, the HaVip is disassociated.
 * *   You cannot repeatedly call the **UnassociateHaVip** operation to disassociate an HaVip within the specified period of time.
 *
 * @param request UnassociateHaVipRequest
 * @return UnassociateHaVipResponse
 */
UnassociateHaVipResponse Client::unassociateHaVip(const UnassociateHaVipRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return unassociateHaVipWithOptions(request, runtime);
}

/**
 * @summary Disassociates a network access control list (ACL) from a vSwitch.
 *
 * @description ## [](#)Description
 * *   **UnassociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
 *     *   If the network ACL is in the **UNBINDING** state, the network ACL is being disassociated from the vSwitch.
 *     *   If the network ACL is in the **UNBINDED** state, the network ACL is disassociated from the vSwitch.
 * *   You cannot repeatedly call the **UnassociateNetworkAcl** operation to disassociate a network ACL from a vSwitch within the specified period of time.
 *
 * @param request UnassociateNetworkAclRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnassociateNetworkAclResponse
 */
UnassociateNetworkAclResponse Client::unassociateNetworkAclWithOptions(const UnassociateNetworkAclRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasNetworkAclId()) {
    query["NetworkAclId"] = request.networkAclId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResource()) {
    query["Resource"] = request.resource();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UnassociateNetworkAcl"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UnassociateNetworkAclResponse>();
}

/**
 * @summary Disassociates a network access control list (ACL) from a vSwitch.
 *
 * @description ## [](#)Description
 * *   **UnassociateNetworkAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of the task.
 *     *   If the network ACL is in the **UNBINDING** state, the network ACL is being disassociated from the vSwitch.
 *     *   If the network ACL is in the **UNBINDED** state, the network ACL is disassociated from the vSwitch.
 * *   You cannot repeatedly call the **UnassociateNetworkAcl** operation to disassociate a network ACL from a vSwitch within the specified period of time.
 *
 * @param request UnassociateNetworkAclRequest
 * @return UnassociateNetworkAclResponse
 */
UnassociateNetworkAclResponse Client::unassociateNetworkAcl(const UnassociateNetworkAclRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return unassociateNetworkAclWithOptions(request, runtime);
}

/**
 * @summary Disassociates a virtual border router (VBR) from an Express Connect circuit.
 *
 * @param request UnassociatePhysicalConnectionFromVirtualBorderRouterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnassociatePhysicalConnectionFromVirtualBorderRouterResponse
 */
UnassociatePhysicalConnectionFromVirtualBorderRouterResponse Client::unassociatePhysicalConnectionFromVirtualBorderRouterWithOptions(const UnassociatePhysicalConnectionFromVirtualBorderRouterRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPhysicalConnectionId()) {
    query["PhysicalConnectionId"] = request.physicalConnectionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVbrId()) {
    query["VbrId"] = request.vbrId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UnassociatePhysicalConnectionFromVirtualBorderRouter"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UnassociatePhysicalConnectionFromVirtualBorderRouterResponse>();
}

/**
 * @summary Disassociates a virtual border router (VBR) from an Express Connect circuit.
 *
 * @param request UnassociatePhysicalConnectionFromVirtualBorderRouterRequest
 * @return UnassociatePhysicalConnectionFromVirtualBorderRouterResponse
 */
UnassociatePhysicalConnectionFromVirtualBorderRouterResponse Client::unassociatePhysicalConnectionFromVirtualBorderRouter(const UnassociatePhysicalConnectionFromVirtualBorderRouterRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return unassociatePhysicalConnectionFromVirtualBorderRouterWithOptions(request, runtime);
}

/**
 * @summary Disassociates a route table from a vSwitch.
 *
 * @description ## [](#)References
 * *   **UnassociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task.
 *     *   If the vSwitch is in the **Pending** state, the route table is being disassociated.
 *     *   If the vSwitch is in the **Available** state, the route table is disassociated.
 * *   You cannot repeatedly call the **UnassociateRouteTable** operation to disassociate a route table from a vSwitch within the specified period of time.
 *
 * @param request UnassociateRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnassociateRouteTableResponse
 */
UnassociateRouteTableResponse Client::unassociateRouteTableWithOptions(const UnassociateRouteTableRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteTableId()) {
    query["RouteTableId"] = request.routeTableId();
  }

  if (!!request.hasVSwitchId()) {
    query["VSwitchId"] = request.vSwitchId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UnassociateRouteTable"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UnassociateRouteTableResponse>();
}

/**
 * @summary Disassociates a route table from a vSwitch.
 *
 * @description ## [](#)References
 * *   **UnassociateRouteTable** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVSwitchAttributes](https://help.aliyun.com/document_detail/94567.html) operation to query the status of the task.
 *     *   If the vSwitch is in the **Pending** state, the route table is being disassociated.
 *     *   If the vSwitch is in the **Available** state, the route table is disassociated.
 * *   You cannot repeatedly call the **UnassociateRouteTable** operation to disassociate a route table from a vSwitch within the specified period of time.
 *
 * @param request UnassociateRouteTableRequest
 * @return UnassociateRouteTableResponse
 */
UnassociateRouteTableResponse Client::unassociateRouteTable(const UnassociateRouteTableRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return unassociateRouteTableWithOptions(request, runtime);
}

/**
 * @summary Removes a secondary CIDR block from a virtual private cloud (VPC).
 *
 * @description *   Before you delete a secondary CIDR block from a VPC, delete the vSwitch which is created with the CIDR block. For more information, see [DeleteVSwitch](https://help.aliyun.com/document_detail/35746.html).
 * *   You cannot repeatedly call the **UnassociateVpcCidrBlock** operation to delete a secondary CIDR block from a VPC within the specified period of time.
 *
 * @param request UnassociateVpcCidrBlockRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnassociateVpcCidrBlockResponse
 */
UnassociateVpcCidrBlockResponse Client::unassociateVpcCidrBlockWithOptions(const UnassociateVpcCidrBlockRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIPv6CidrBlock()) {
    query["IPv6CidrBlock"] = request.IPv6CidrBlock();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSecondaryCidrBlock()) {
    query["SecondaryCidrBlock"] = request.secondaryCidrBlock();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UnassociateVpcCidrBlock"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UnassociateVpcCidrBlockResponse>();
}

/**
 * @summary Removes a secondary CIDR block from a virtual private cloud (VPC).
 *
 * @description *   Before you delete a secondary CIDR block from a VPC, delete the vSwitch which is created with the CIDR block. For more information, see [DeleteVSwitch](https://help.aliyun.com/document_detail/35746.html).
 * *   You cannot repeatedly call the **UnassociateVpcCidrBlock** operation to delete a secondary CIDR block from a VPC within the specified period of time.
 *
 * @param request UnassociateVpcCidrBlockRequest
 * @return UnassociateVpcCidrBlockResponse
 */
UnassociateVpcCidrBlockResponse Client::unassociateVpcCidrBlock(const UnassociateVpcCidrBlockRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return unassociateVpcCidrBlockWithOptions(request, runtime);
}

/**
 * @summary Removes tags from an Express Connect circuit at a time.
 *
 * @param request UntagResourcesForExpressConnectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UntagResourcesForExpressConnectResponse
 */
UntagResourcesForExpressConnectResponse Client::untagResourcesForExpressConnectWithOptions(const UntagResourcesForExpressConnectRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAll()) {
    query["All"] = request.all();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceId()) {
    query["ResourceId"] = request.resourceId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasResourceType()) {
    query["ResourceType"] = request.resourceType();
  }

  if (!!request.hasTagKey()) {
    query["TagKey"] = request.tagKey();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UntagResourcesForExpressConnect"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UntagResourcesForExpressConnectResponse>();
}

/**
 * @summary Removes tags from an Express Connect circuit at a time.
 *
 * @param request UntagResourcesForExpressConnectRequest
 * @return UntagResourcesForExpressConnectResponse
 */
UntagResourcesForExpressConnectResponse Client::untagResourcesForExpressConnect(const UntagResourcesForExpressConnectRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return untagResourcesForExpressConnectWithOptions(request, runtime);
}

/**
 * @summary 修改Dhcp选项集信息
 *
 * @param request UpdateDhcpOptionsSetAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDhcpOptionsSetAttributeResponse
 */
UpdateDhcpOptionsSetAttributeResponse Client::updateDhcpOptionsSetAttributeWithOptions(const UpdateDhcpOptionsSetAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDhcpOptionsSetDescription()) {
    query["DhcpOptionsSetDescription"] = request.dhcpOptionsSetDescription();
  }

  if (!!request.hasDhcpOptionsSetId()) {
    query["DhcpOptionsSetId"] = request.dhcpOptionsSetId();
  }

  if (!!request.hasDhcpOptionsSetName()) {
    query["DhcpOptionsSetName"] = request.dhcpOptionsSetName();
  }

  if (!!request.hasDomainName()) {
    query["DomainName"] = request.domainName();
  }

  if (!!request.hasDomainNameServers()) {
    query["DomainNameServers"] = request.domainNameServers();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIpv6LeaseTime()) {
    query["Ipv6LeaseTime"] = request.ipv6LeaseTime();
  }

  if (!!request.hasLeaseTime()) {
    query["LeaseTime"] = request.leaseTime();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateDhcpOptionsSetAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateDhcpOptionsSetAttributeResponse>();
}

/**
 * @summary 修改Dhcp选项集信息
 *
 * @param request UpdateDhcpOptionsSetAttributeRequest
 * @return UpdateDhcpOptionsSetAttributeResponse
 */
UpdateDhcpOptionsSetAttributeResponse Client::updateDhcpOptionsSetAttribute(const UpdateDhcpOptionsSetAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateDhcpOptionsSetAttributeWithOptions(request, runtime);
}

/**
 * @summary Updates a failover test.
 *
 * @param request UpdateFailoverTestJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFailoverTestJobResponse
 */
UpdateFailoverTestJobResponse Client::updateFailoverTestJobWithOptions(const UpdateFailoverTestJobRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasJobDuration()) {
    query["JobDuration"] = request.jobDuration();
  }

  if (!!request.hasJobId()) {
    query["JobId"] = request.jobId();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceId()) {
    query["ResourceId"] = request.resourceId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateFailoverTestJob"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateFailoverTestJobResponse>();
}

/**
 * @summary Updates a failover test.
 *
 * @param request UpdateFailoverTestJobRequest
 * @return UpdateFailoverTestJobResponse
 */
UpdateFailoverTestJobResponse Client::updateFailoverTestJob(const UpdateFailoverTestJobRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateFailoverTestJobWithOptions(request, runtime);
}

/**
 * @summary Modifies the next hop type and next hop of the route entry in a gateway route table.
 *
 * @param request UpdateGatewayRouteTableEntryAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateGatewayRouteTableEntryAttributeResponse
 */
UpdateGatewayRouteTableEntryAttributeResponse Client::updateGatewayRouteTableEntryAttributeWithOptions(const UpdateGatewayRouteTableEntryAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDestinationCidrBlock()) {
    query["DestinationCidrBlock"] = request.destinationCidrBlock();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasGatewayRouteTableId()) {
    query["GatewayRouteTableId"] = request.gatewayRouteTableId();
  }

  if (!!request.hasIPv4GatewayRouteTableId()) {
    query["IPv4GatewayRouteTableId"] = request.IPv4GatewayRouteTableId();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasNextHopId()) {
    query["NextHopId"] = request.nextHopId();
  }

  if (!!request.hasNextHopType()) {
    query["NextHopType"] = request.nextHopType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateGatewayRouteTableEntryAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateGatewayRouteTableEntryAttributeResponse>();
}

/**
 * @summary Modifies the next hop type and next hop of the route entry in a gateway route table.
 *
 * @param request UpdateGatewayRouteTableEntryAttributeRequest
 * @return UpdateGatewayRouteTableEntryAttributeResponse
 */
UpdateGatewayRouteTableEntryAttributeResponse Client::updateGatewayRouteTableEntryAttribute(const UpdateGatewayRouteTableEntryAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateGatewayRouteTableEntryAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the configuration of an IPsec server.
 *
 * @description *   If you modify only **IpsecServerName** of the IPsec server, this operation is synchronous. If you modify other parameters besides **IpsecServerName**, this operation is asynchronous.
 * *   If **UpdateIpsecServer** is an asynchronous operation, after a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the IPsec server is being modified.
 *     *   If the VPN gateway is in the **active** state, the IPsec server is modified.
 * *   You cannot repeatedly call **UpdateIpsecServer** within the specified period of time.
 *
 * @param request UpdateIpsecServerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateIpsecServerResponse
 */
UpdateIpsecServerResponse Client::updateIpsecServerWithOptions(const UpdateIpsecServerRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientIpPool()) {
    query["ClientIpPool"] = request.clientIpPool();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEffectImmediately()) {
    query["EffectImmediately"] = request.effectImmediately();
  }

  if (!!request.hasIkeConfig()) {
    query["IkeConfig"] = request.ikeConfig();
  }

  if (!!request.hasIpsecConfig()) {
    query["IpsecConfig"] = request.ipsecConfig();
  }

  if (!!request.hasIpsecServerId()) {
    query["IpsecServerId"] = request.ipsecServerId();
  }

  if (!!request.hasIpsecServerName()) {
    query["IpsecServerName"] = request.ipsecServerName();
  }

  if (!!request.hasLocalSubnet()) {
    query["LocalSubnet"] = request.localSubnet();
  }

  if (!!request.hasPsk()) {
    query["Psk"] = request.psk();
  }

  if (!!request.hasPskEnabled()) {
    query["PskEnabled"] = request.pskEnabled();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateIpsecServer"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateIpsecServerResponse>();
}

/**
 * @summary Modifies the configuration of an IPsec server.
 *
 * @description *   If you modify only **IpsecServerName** of the IPsec server, this operation is synchronous. If you modify other parameters besides **IpsecServerName**, this operation is asynchronous.
 * *   If **UpdateIpsecServer** is an asynchronous operation, after a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeVpnGateway](https://help.aliyun.com/document_detail/2794055.html) operation to query the status of the task.
 *     *   If the VPN gateway is in the **updating** state, the IPsec server is being modified.
 *     *   If the VPN gateway is in the **active** state, the IPsec server is modified.
 * *   You cannot repeatedly call **UpdateIpsecServer** within the specified period of time.
 *
 * @param request UpdateIpsecServerRequest
 * @return UpdateIpsecServerResponse
 */
UpdateIpsecServerResponse Client::updateIpsecServer(const UpdateIpsecServerRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateIpsecServerWithOptions(request, runtime);
}

/**
 * @summary Modifies the description or name of an IPv4 gateway.
 *
 * @description You cannot repeatedly call the **UpdateIpv4GatewayAttribute** operation to modify the name or description of an IPv4 gateway within the specified period of time.
 *
 * @param request UpdateIpv4GatewayAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateIpv4GatewayAttributeResponse
 */
UpdateIpv4GatewayAttributeResponse Client::updateIpv4GatewayAttributeWithOptions(const UpdateIpv4GatewayAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasIpv4GatewayDescription()) {
    query["Ipv4GatewayDescription"] = request.ipv4GatewayDescription();
  }

  if (!!request.hasIpv4GatewayId()) {
    query["Ipv4GatewayId"] = request.ipv4GatewayId();
  }

  if (!!request.hasIpv4GatewayName()) {
    query["Ipv4GatewayName"] = request.ipv4GatewayName();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateIpv4GatewayAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateIpv4GatewayAttributeResponse>();
}

/**
 * @summary Modifies the description or name of an IPv4 gateway.
 *
 * @description You cannot repeatedly call the **UpdateIpv4GatewayAttribute** operation to modify the name or description of an IPv4 gateway within the specified period of time.
 *
 * @param request UpdateIpv4GatewayAttributeRequest
 * @return UpdateIpv4GatewayAttributeResponse
 */
UpdateIpv4GatewayAttributeResponse Client::updateIpv4GatewayAttribute(const UpdateIpv4GatewayAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateIpv4GatewayAttributeWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI UpdateNatGatewayNatType is deprecated
 *
 * @summary Upgrades a standard NAT gateway to an enhanced NAT gateway.
 *
 * @description Before you call this operation, take note of the following limits:
 * *   **UpdateNatGatewayNatType** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the NAT gateway is still being upgraded in the backend. You can call the GetNatGatewayConvertStatus operation to query the upgrade progress of a NAT gateway. For more information, see [GetNatGatewayConvertStatus](https://help.aliyun.com/document_detail/184744.html).
 *     *   If the NAT gateway is in the **processing** state, the NAT gateway is being upgraded. You can only query the status of the NAT gateway but cannot perform other operations.
 *     *   If the NAT gateway is in the **successful** state, the NAT gateway is upgraded.
 *     *   If the NAT gateway is in the **failed** state, the system failed to upgrade the NAT gateway.
 * *   You cannot repeatedly call the **UpdateNatGatewayNatType** operation for the same VPN gateway within the specified period of time.
 * *   The billing method and billable items remain the same after the upgrade.
 * *   It takes about five minutes to upgrade a standard NAT gateway to an enhanced NAT gateway. During the upgrade, transient connection errors may occur once or twice. The service can be recovered by reconnection. You can determine whether to enable automatic reconnection or use manual reconnection based on your business requirements.
 * *   You can only upgrade standard NAT gateways to enhanced NAT gateways. You are not allowed to downgrade enhanced NAT gateways to standard NAT gateways.
 *
 * @param request UpdateNatGatewayNatTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateNatGatewayNatTypeResponse
 */
UpdateNatGatewayNatTypeResponse Client::updateNatGatewayNatTypeWithOptions(const UpdateNatGatewayNatTypeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasNatType()) {
    query["NatType"] = request.natType();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVSwitchId()) {
    query["VSwitchId"] = request.vSwitchId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateNatGatewayNatType"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateNatGatewayNatTypeResponse>();
}

/**
 * @deprecated OpenAPI UpdateNatGatewayNatType is deprecated
 *
 * @summary Upgrades a standard NAT gateway to an enhanced NAT gateway.
 *
 * @description Before you call this operation, take note of the following limits:
 * *   **UpdateNatGatewayNatType** is an asynchronous operation. After you send a request to call this operation, the system returns a request ID and the NAT gateway is still being upgraded in the backend. You can call the GetNatGatewayConvertStatus operation to query the upgrade progress of a NAT gateway. For more information, see [GetNatGatewayConvertStatus](https://help.aliyun.com/document_detail/184744.html).
 *     *   If the NAT gateway is in the **processing** state, the NAT gateway is being upgraded. You can only query the status of the NAT gateway but cannot perform other operations.
 *     *   If the NAT gateway is in the **successful** state, the NAT gateway is upgraded.
 *     *   If the NAT gateway is in the **failed** state, the system failed to upgrade the NAT gateway.
 * *   You cannot repeatedly call the **UpdateNatGatewayNatType** operation for the same VPN gateway within the specified period of time.
 * *   The billing method and billable items remain the same after the upgrade.
 * *   It takes about five minutes to upgrade a standard NAT gateway to an enhanced NAT gateway. During the upgrade, transient connection errors may occur once or twice. The service can be recovered by reconnection. You can determine whether to enable automatic reconnection or use manual reconnection based on your business requirements.
 * *   You can only upgrade standard NAT gateways to enhanced NAT gateways. You are not allowed to downgrade enhanced NAT gateways to standard NAT gateways.
 *
 * @param request UpdateNatGatewayNatTypeRequest
 * @return UpdateNatGatewayNatTypeResponse
 */
UpdateNatGatewayNatTypeResponse Client::updateNatGatewayNatType(const UpdateNatGatewayNatTypeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateNatGatewayNatTypeWithOptions(request, runtime);
}

/**
 * @summary Updates the rules of a network access control list (ACL).
 *
 * @description *   **UpdateNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of a network ACL:
 *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being updated.
 *     *   If the network ACL is in the **Available** state, the rules of the network ACL are updated.
 * *   You cannot repeatedly call the **UpdateNetworkAclEntries** operation to update the rules of a network ACL within the specified period of time.
 *
 * @param request UpdateNetworkAclEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateNetworkAclEntriesResponse
 */
UpdateNetworkAclEntriesResponse Client::updateNetworkAclEntriesWithOptions(const UpdateNetworkAclEntriesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEgressAclEntries()) {
    query["EgressAclEntries"] = request.egressAclEntries();
  }

  if (!!request.hasIngressAclEntries()) {
    query["IngressAclEntries"] = request.ingressAclEntries();
  }

  if (!!request.hasNetworkAclId()) {
    query["NetworkAclId"] = request.networkAclId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasUpdateEgressAclEntries()) {
    query["UpdateEgressAclEntries"] = request.updateEgressAclEntries();
  }

  if (!!request.hasUpdateIngressAclEntries()) {
    query["UpdateIngressAclEntries"] = request.updateIngressAclEntries();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateNetworkAclEntries"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateNetworkAclEntriesResponse>();
}

/**
 * @summary Updates the rules of a network access control list (ACL).
 *
 * @description *   **UpdateNetworkAclEntries** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeNetworkAclAttributes](https://help.aliyun.com/document_detail/116542.html) operation to query the status of a network ACL:
 *     *   If the network ACL is in the **Modifying** state, the rules of the network ACL are being updated.
 *     *   If the network ACL is in the **Available** state, the rules of the network ACL are updated.
 * *   You cannot repeatedly call the **UpdateNetworkAclEntries** operation to update the rules of a network ACL within the specified period of time.
 *
 * @param request UpdateNetworkAclEntriesRequest
 * @return UpdateNetworkAclEntriesResponse
 */
UpdateNetworkAclEntriesResponse Client::updateNetworkAclEntries(const UpdateNetworkAclEntriesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateNetworkAclEntriesWithOptions(request, runtime);
}

/**
 * @summary Modifies the attributes of an IP address pool.
 *
 * @description You cannot repeatedly call the **UpdatePublicIpAddressPoolAttribute** operation to modify the attributes of an IP address pool within the specified period of time.
 *
 * @param request UpdatePublicIpAddressPoolAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePublicIpAddressPoolAttributeResponse
 */
UpdatePublicIpAddressPoolAttributeResponse Client::updatePublicIpAddressPoolAttributeWithOptions(const UpdatePublicIpAddressPoolAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPublicIpAddressPoolId()) {
    query["PublicIpAddressPoolId"] = request.publicIpAddressPoolId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdatePublicIpAddressPoolAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdatePublicIpAddressPoolAttributeResponse>();
}

/**
 * @summary Modifies the attributes of an IP address pool.
 *
 * @description You cannot repeatedly call the **UpdatePublicIpAddressPoolAttribute** operation to modify the attributes of an IP address pool within the specified period of time.
 *
 * @param request UpdatePublicIpAddressPoolAttributeRequest
 * @return UpdatePublicIpAddressPoolAttributeResponse
 */
UpdatePublicIpAddressPoolAttributeResponse Client::updatePublicIpAddressPoolAttribute(const UpdatePublicIpAddressPoolAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updatePublicIpAddressPoolAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the configuration of a filter for traffic mirror.
 *
 * @description You cannot repeatedly call the **UpdateTrafficMirrorFilterAttribute** operation to modify the configuration of a filter for traffic mirror within the specified period of time.
 *
 * @param request UpdateTrafficMirrorFilterAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTrafficMirrorFilterAttributeResponse
 */
UpdateTrafficMirrorFilterAttributeResponse Client::updateTrafficMirrorFilterAttributeWithOptions(const UpdateTrafficMirrorFilterAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTrafficMirrorFilterDescription()) {
    query["TrafficMirrorFilterDescription"] = request.trafficMirrorFilterDescription();
  }

  if (!!request.hasTrafficMirrorFilterId()) {
    query["TrafficMirrorFilterId"] = request.trafficMirrorFilterId();
  }

  if (!!request.hasTrafficMirrorFilterName()) {
    query["TrafficMirrorFilterName"] = request.trafficMirrorFilterName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateTrafficMirrorFilterAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateTrafficMirrorFilterAttributeResponse>();
}

/**
 * @summary Modifies the configuration of a filter for traffic mirror.
 *
 * @description You cannot repeatedly call the **UpdateTrafficMirrorFilterAttribute** operation to modify the configuration of a filter for traffic mirror within the specified period of time.
 *
 * @param request UpdateTrafficMirrorFilterAttributeRequest
 * @return UpdateTrafficMirrorFilterAttributeResponse
 */
UpdateTrafficMirrorFilterAttributeResponse Client::updateTrafficMirrorFilterAttribute(const UpdateTrafficMirrorFilterAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateTrafficMirrorFilterAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the configuration of an inbound or outbound rule for traffic mirroring.
 *
 * @description *   The **UpdateTrafficMirrorFilterRuleAttribute** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of an inbound or outbound rule:
 *     *   If the rule is in the **Modifying** state, the rule is being modified.
 *     *   If the rule is in the **Created** state, the rule is modified.
 * *   You cannot repeatedly call the **UpdateTrafficMirrorFilterRuleAttribute** operation to modify an inbound or outbound rule within the specified period of time.
 *
 * @param request UpdateTrafficMirrorFilterRuleAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTrafficMirrorFilterRuleAttributeResponse
 */
UpdateTrafficMirrorFilterRuleAttributeResponse Client::updateTrafficMirrorFilterRuleAttributeWithOptions(const UpdateTrafficMirrorFilterRuleAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDestinationCidrBlock()) {
    query["DestinationCidrBlock"] = request.destinationCidrBlock();
  }

  if (!!request.hasDestinationPortRange()) {
    query["DestinationPortRange"] = request.destinationPortRange();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPriority()) {
    query["Priority"] = request.priority();
  }

  if (!!request.hasProtocol()) {
    query["Protocol"] = request.protocol();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRuleAction()) {
    query["RuleAction"] = request.ruleAction();
  }

  if (!!request.hasSourceCidrBlock()) {
    query["SourceCidrBlock"] = request.sourceCidrBlock();
  }

  if (!!request.hasSourcePortRange()) {
    query["SourcePortRange"] = request.sourcePortRange();
  }

  if (!!request.hasTrafficMirrorFilterRuleId()) {
    query["TrafficMirrorFilterRuleId"] = request.trafficMirrorFilterRuleId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateTrafficMirrorFilterRuleAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateTrafficMirrorFilterRuleAttributeResponse>();
}

/**
 * @summary Modifies the configuration of an inbound or outbound rule for traffic mirroring.
 *
 * @description *   The **UpdateTrafficMirrorFilterRuleAttribute** operation is asynchronous. After you send the request, the system returns a request ID. However, the operation is still being performed in the system background. You can call the [ListTrafficMirrorFilters](https://help.aliyun.com/document_detail/261353.html) operation to query the status of an inbound or outbound rule:
 *     *   If the rule is in the **Modifying** state, the rule is being modified.
 *     *   If the rule is in the **Created** state, the rule is modified.
 * *   You cannot repeatedly call the **UpdateTrafficMirrorFilterRuleAttribute** operation to modify an inbound or outbound rule within the specified period of time.
 *
 * @param request UpdateTrafficMirrorFilterRuleAttributeRequest
 * @return UpdateTrafficMirrorFilterRuleAttributeResponse
 */
UpdateTrafficMirrorFilterRuleAttributeResponse Client::updateTrafficMirrorFilterRuleAttribute(const UpdateTrafficMirrorFilterRuleAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateTrafficMirrorFilterRuleAttributeWithOptions(request, runtime);
}

/**
 * @summary Modifies the configuration of a traffic mirror session.
 *
 * @description ## Usage notes
 * *   **UpdateTrafficMirrorSessionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
 *     *   If the traffic mirror session is in the **Modifying** state, the configuration of the traffic mirror session is being modified.
 *     *   If the traffic mirror session is in the **Created** state, the configuration of the traffic mirror session is modified.
 * *   You cannot repeatedly call the **UpdateTrafficMirrorSessionAttribute** operation within a specific period of time.
 *
 * @param request UpdateTrafficMirrorSessionAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTrafficMirrorSessionAttributeResponse
 */
UpdateTrafficMirrorSessionAttributeResponse Client::updateTrafficMirrorSessionAttributeWithOptions(const UpdateTrafficMirrorSessionAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEnabled()) {
    query["Enabled"] = request.enabled();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPacketLength()) {
    query["PacketLength"] = request.packetLength();
  }

  if (!!request.hasPriority()) {
    query["Priority"] = request.priority();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasTrafficMirrorFilterId()) {
    query["TrafficMirrorFilterId"] = request.trafficMirrorFilterId();
  }

  if (!!request.hasTrafficMirrorSessionDescription()) {
    query["TrafficMirrorSessionDescription"] = request.trafficMirrorSessionDescription();
  }

  if (!!request.hasTrafficMirrorSessionId()) {
    query["TrafficMirrorSessionId"] = request.trafficMirrorSessionId();
  }

  if (!!request.hasTrafficMirrorSessionName()) {
    query["TrafficMirrorSessionName"] = request.trafficMirrorSessionName();
  }

  if (!!request.hasTrafficMirrorTargetId()) {
    query["TrafficMirrorTargetId"] = request.trafficMirrorTargetId();
  }

  if (!!request.hasTrafficMirrorTargetType()) {
    query["TrafficMirrorTargetType"] = request.trafficMirrorTargetType();
  }

  if (!!request.hasVirtualNetworkId()) {
    query["VirtualNetworkId"] = request.virtualNetworkId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateTrafficMirrorSessionAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateTrafficMirrorSessionAttributeResponse>();
}

/**
 * @summary Modifies the configuration of a traffic mirror session.
 *
 * @description ## Usage notes
 * *   **UpdateTrafficMirrorSessionAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListTrafficMirrorSessions](https://help.aliyun.com/document_detail/261367.html) operation to query the status of the task.
 *     *   If the traffic mirror session is in the **Modifying** state, the configuration of the traffic mirror session is being modified.
 *     *   If the traffic mirror session is in the **Created** state, the configuration of the traffic mirror session is modified.
 * *   You cannot repeatedly call the **UpdateTrafficMirrorSessionAttribute** operation within a specific period of time.
 *
 * @param request UpdateTrafficMirrorSessionAttributeRequest
 * @return UpdateTrafficMirrorSessionAttributeResponse
 */
UpdateTrafficMirrorSessionAttributeResponse Client::updateTrafficMirrorSessionAttribute(const UpdateTrafficMirrorSessionAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateTrafficMirrorSessionAttributeWithOptions(request, runtime);
}

/**
 * @summary Updates the maximum bandwidth value of outbound data transfer for a virtual border router (VBR).
 *
 * @param request UpdateVirtualBorderBandwidthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateVirtualBorderBandwidthResponse
 */
UpdateVirtualBorderBandwidthResponse Client::updateVirtualBorderBandwidthWithOptions(const UpdateVirtualBorderBandwidthRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBandwidth()) {
    query["Bandwidth"] = request.bandwidth();
  }

  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasVirtualBorderRouterId()) {
    query["VirtualBorderRouterId"] = request.virtualBorderRouterId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateVirtualBorderBandwidth"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateVirtualBorderBandwidthResponse>();
}

/**
 * @summary Updates the maximum bandwidth value of outbound data transfer for a virtual border router (VBR).
 *
 * @param request UpdateVirtualBorderBandwidthRequest
 * @return UpdateVirtualBorderBandwidthResponse
 */
UpdateVirtualBorderBandwidthResponse Client::updateVirtualBorderBandwidth(const UpdateVirtualBorderBandwidthRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateVirtualBorderBandwidthWithOptions(request, runtime);
}

/**
 * @summary Changes the virtual local area network (VLAN) ID of a hosted connection over Express Connect circuit.
 *
 * @param request UpdateVirtualPhysicalConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateVirtualPhysicalConnectionResponse
 */
UpdateVirtualPhysicalConnectionResponse Client::updateVirtualPhysicalConnectionWithOptions(const UpdateVirtualPhysicalConnectionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasExpectSpec()) {
    query["ExpectSpec"] = request.expectSpec();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasToken()) {
    query["Token"] = request.token();
  }

  if (!!request.hasVlanId()) {
    query["VlanId"] = request.vlanId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateVirtualPhysicalConnection"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateVirtualPhysicalConnectionResponse>();
}

/**
 * @summary Changes the virtual local area network (VLAN) ID of a hosted connection over Express Connect circuit.
 *
 * @param request UpdateVirtualPhysicalConnectionRequest
 * @return UpdateVirtualPhysicalConnectionResponse
 */
UpdateVirtualPhysicalConnectionResponse Client::updateVirtualPhysicalConnection(const UpdateVirtualPhysicalConnectionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateVirtualPhysicalConnectionWithOptions(request, runtime);
}

/**
 * @summary Modifies the configuration of a gateway endpoint.
 *
 * @description *   **UpdateVpcGatewayEndpointAttribute** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query the status of the task.
 *     *   If the gateway endpoint is in the **Updating** state, it is being modified.
 *     *   If the gateway endpoint is in the **Created** state, it is modified.
 * *   You cannot call the **UpdateVpcGatewayEndpointAttribute** operation within a specific period of time.
 *
 * @param request UpdateVpcGatewayEndpointAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateVpcGatewayEndpointAttributeResponse
 */
UpdateVpcGatewayEndpointAttributeResponse Client::updateVpcGatewayEndpointAttributeWithOptions(const UpdateVpcGatewayEndpointAttributeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasEndpointDescription()) {
    query["EndpointDescription"] = request.endpointDescription();
  }

  if (!!request.hasEndpointId()) {
    query["EndpointId"] = request.endpointId();
  }

  if (!!request.hasEndpointName()) {
    query["EndpointName"] = request.endpointName();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasPolicyDocument()) {
    query["PolicyDocument"] = request.policyDocument();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateVpcGatewayEndpointAttribute"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateVpcGatewayEndpointAttributeResponse>();
}

/**
 * @summary Modifies the configuration of a gateway endpoint.
 *
 * @description *   **UpdateVpcGatewayEndpointAttribute** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the [GetVpcGatewayEndpointAttribute](https://help.aliyun.com/document_detail/311017.html) operation to query the status of the task.
 *     *   If the gateway endpoint is in the **Updating** state, it is being modified.
 *     *   If the gateway endpoint is in the **Created** state, it is modified.
 * *   You cannot call the **UpdateVpcGatewayEndpointAttribute** operation within a specific period of time.
 *
 * @param request UpdateVpcGatewayEndpointAttributeRequest
 * @return UpdateVpcGatewayEndpointAttributeResponse
 */
UpdateVpcGatewayEndpointAttributeResponse Client::updateVpcGatewayEndpointAttribute(const UpdateVpcGatewayEndpointAttributeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateVpcGatewayEndpointAttributeWithOptions(request, runtime);
}

/**
 * @summary 查看eni quota
 *
 * @description Before you call this operation, make sure that a VPC NAT gateway is created. For more information, see [CreateNatGateway](https://help.aliyun.com/document_detail/120219.html).
 *
 * @param request VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse
 */
VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse Client::vpcDescribeVpcNatGatewayNetworkInterfaceQuotaWithOptions(const VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClientToken()) {
    query["ClientToken"] = request.clientToken();
  }

  if (!!request.hasNatGatewayId()) {
    query["NatGatewayId"] = request.natGatewayId();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasResourceUid()) {
    query["ResourceUid"] = request.resourceUid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "VpcDescribeVpcNatGatewayNetworkInterfaceQuota"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse>();
}

/**
 * @summary 查看eni quota
 *
 * @description Before you call this operation, make sure that a VPC NAT gateway is created. For more information, see [CreateNatGateway](https://help.aliyun.com/document_detail/120219.html).
 *
 * @param request VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest
 * @return VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse
 */
VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse Client::vpcDescribeVpcNatGatewayNetworkInterfaceQuota(const VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return vpcDescribeVpcNatGatewayNetworkInterfaceQuotaWithOptions(request, runtime);
}

/**
 * @summary Withdraw advertised Virtual Private Cloud (VPC) routes.
 *
 * @param request WithdrawVpcPublishedRouteEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return WithdrawVpcPublishedRouteEntriesResponse
 */
WithdrawVpcPublishedRouteEntriesResponse Client::withdrawVpcPublishedRouteEntriesWithOptions(const WithdrawVpcPublishedRouteEntriesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDryRun()) {
    query["DryRun"] = request.dryRun();
  }

  if (!!request.hasOwnerAccount()) {
    query["OwnerAccount"] = request.ownerAccount();
  }

  if (!!request.hasOwnerId()) {
    query["OwnerId"] = request.ownerId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceOwnerAccount()) {
    query["ResourceOwnerAccount"] = request.resourceOwnerAccount();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRouteEntries()) {
    query["RouteEntries"] = request.routeEntries();
  }

  if (!!request.hasTargetInstanceId()) {
    query["TargetInstanceId"] = request.targetInstanceId();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "WithdrawVpcPublishedRouteEntries"},
    {"version" , "2016-04-28"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<WithdrawVpcPublishedRouteEntriesResponse>();
}

/**
 * @summary Withdraw advertised Virtual Private Cloud (VPC) routes.
 *
 * @param request WithdrawVpcPublishedRouteEntriesRequest
 * @return WithdrawVpcPublishedRouteEntriesResponse
 */
WithdrawVpcPublishedRouteEntriesResponse Client::withdrawVpcPublishedRouteEntries(const WithdrawVpcPublishedRouteEntriesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return withdrawVpcPublishedRouteEntriesWithOptions(request, runtime);
}
} // namespace AlibabaCloud
} // namespace Vpc20160428