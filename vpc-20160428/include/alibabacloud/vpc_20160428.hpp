// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_VPC20160428_H_
#define ALIBABACLOUD_VPC20160428_H_

#include <alibabacloud/open_api.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Vpc20160428 {
class ActivateRouterInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routerInterfaceId{};

  ActivateRouterInterfaceRequest() {}

  explicit ActivateRouterInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routerInterfaceId) {
      res["RouterInterfaceId"] = boost::any(*routerInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouterInterfaceId") != m.end() && !m["RouterInterfaceId"].empty()) {
      routerInterfaceId = make_shared<string>(boost::any_cast<string>(m["RouterInterfaceId"]));
    }
  }


  virtual ~ActivateRouterInterfaceRequest() = default;
};
class ActivateRouterInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ActivateRouterInterfaceResponseBody() {}

  explicit ActivateRouterInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ActivateRouterInterfaceResponseBody() = default;
};
class ActivateRouterInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ActivateRouterInterfaceResponseBody> body{};

  ActivateRouterInterfaceResponse() {}

  explicit ActivateRouterInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ActivateRouterInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ActivateRouterInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~ActivateRouterInterfaceResponse() = default;
};
class ActiveFlowLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowLogId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ActiveFlowLogRequest() {}

  explicit ActiveFlowLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowLogId) {
      res["FlowLogId"] = boost::any(*flowLogId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowLogId") != m.end() && !m["FlowLogId"].empty()) {
      flowLogId = make_shared<string>(boost::any_cast<string>(m["FlowLogId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ActiveFlowLogRequest() = default;
};
class ActiveFlowLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ActiveFlowLogResponseBody() {}

  explicit ActiveFlowLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ActiveFlowLogResponseBody() = default;
};
class ActiveFlowLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ActiveFlowLogResponseBody> body{};

  ActiveFlowLogResponse() {}

  explicit ActiveFlowLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ActiveFlowLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ActiveFlowLogResponseBody>(model1);
      }
    }
  }


  virtual ~ActiveFlowLogResponse() = default;
};
class AddBgpNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> dstCidrBlock{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routerId{};
  shared_ptr<string> vpcId{};

  AddBgpNetworkRequest() {}

  explicit AddBgpNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dstCidrBlock) {
      res["DstCidrBlock"] = boost::any(*dstCidrBlock);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DstCidrBlock") != m.end() && !m["DstCidrBlock"].empty()) {
      dstCidrBlock = make_shared<string>(boost::any_cast<string>(m["DstCidrBlock"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~AddBgpNetworkRequest() = default;
};
class AddBgpNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddBgpNetworkResponseBody() {}

  explicit AddBgpNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddBgpNetworkResponseBody() = default;
};
class AddBgpNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddBgpNetworkResponseBody> body{};

  AddBgpNetworkResponse() {}

  explicit AddBgpNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddBgpNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddBgpNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~AddBgpNetworkResponse() = default;
};
class AddCommonBandwidthPackageIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ipInstanceId{};
  shared_ptr<string> ipType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  AddCommonBandwidthPackageIpRequest() {}

  explicit AddCommonBandwidthPackageIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ipInstanceId) {
      res["IpInstanceId"] = boost::any(*ipInstanceId);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("IpInstanceId") != m.end() && !m["IpInstanceId"].empty()) {
      ipInstanceId = make_shared<string>(boost::any_cast<string>(m["IpInstanceId"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<string>(boost::any_cast<string>(m["IpType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~AddCommonBandwidthPackageIpRequest() = default;
};
class AddCommonBandwidthPackageIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddCommonBandwidthPackageIpResponseBody() {}

  explicit AddCommonBandwidthPackageIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCommonBandwidthPackageIpResponseBody() = default;
};
class AddCommonBandwidthPackageIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCommonBandwidthPackageIpResponseBody> body{};

  AddCommonBandwidthPackageIpResponse() {}

  explicit AddCommonBandwidthPackageIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCommonBandwidthPackageIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCommonBandwidthPackageIpResponseBody>(model1);
      }
    }
  }


  virtual ~AddCommonBandwidthPackageIpResponse() = default;
};
class AddCommonBandwidthPackageIpsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> ipInstanceIds{};
  shared_ptr<string> ipType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  AddCommonBandwidthPackageIpsRequest() {}

  explicit AddCommonBandwidthPackageIpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ipInstanceIds) {
      res["IpInstanceIds"] = boost::any(*ipInstanceIds);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("IpInstanceIds") != m.end() && !m["IpInstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpInstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpInstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipInstanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<string>(boost::any_cast<string>(m["IpType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~AddCommonBandwidthPackageIpsRequest() = default;
};
class AddCommonBandwidthPackageIpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddCommonBandwidthPackageIpsResponseBody() {}

  explicit AddCommonBandwidthPackageIpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCommonBandwidthPackageIpsResponseBody() = default;
};
class AddCommonBandwidthPackageIpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCommonBandwidthPackageIpsResponseBody> body{};

  AddCommonBandwidthPackageIpsResponse() {}

  explicit AddCommonBandwidthPackageIpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCommonBandwidthPackageIpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCommonBandwidthPackageIpsResponseBody>(model1);
      }
    }
  }


  virtual ~AddCommonBandwidthPackageIpsResponse() = default;
};
class AddGlobalAccelerationInstanceIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> globalAccelerationInstanceId{};
  shared_ptr<string> ipInstanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  AddGlobalAccelerationInstanceIpRequest() {}

  explicit AddGlobalAccelerationInstanceIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalAccelerationInstanceId) {
      res["GlobalAccelerationInstanceId"] = boost::any(*globalAccelerationInstanceId);
    }
    if (ipInstanceId) {
      res["IpInstanceId"] = boost::any(*ipInstanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalAccelerationInstanceId") != m.end() && !m["GlobalAccelerationInstanceId"].empty()) {
      globalAccelerationInstanceId = make_shared<string>(boost::any_cast<string>(m["GlobalAccelerationInstanceId"]));
    }
    if (m.find("IpInstanceId") != m.end() && !m["IpInstanceId"].empty()) {
      ipInstanceId = make_shared<string>(boost::any_cast<string>(m["IpInstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~AddGlobalAccelerationInstanceIpRequest() = default;
};
class AddGlobalAccelerationInstanceIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddGlobalAccelerationInstanceIpResponseBody() {}

  explicit AddGlobalAccelerationInstanceIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddGlobalAccelerationInstanceIpResponseBody() = default;
};
class AddGlobalAccelerationInstanceIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddGlobalAccelerationInstanceIpResponseBody> body{};

  AddGlobalAccelerationInstanceIpResponse() {}

  explicit AddGlobalAccelerationInstanceIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddGlobalAccelerationInstanceIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddGlobalAccelerationInstanceIpResponseBody>(model1);
      }
    }
  }


  virtual ~AddGlobalAccelerationInstanceIpResponse() = default;
};
class AddIPv6TranslatorAclListEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclEntryComment{};
  shared_ptr<string> aclEntryIp{};
  shared_ptr<string> aclId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  AddIPv6TranslatorAclListEntryRequest() {}

  explicit AddIPv6TranslatorAclListEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntryComment) {
      res["AclEntryComment"] = boost::any(*aclEntryComment);
    }
    if (aclEntryIp) {
      res["AclEntryIp"] = boost::any(*aclEntryIp);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclEntryComment") != m.end() && !m["AclEntryComment"].empty()) {
      aclEntryComment = make_shared<string>(boost::any_cast<string>(m["AclEntryComment"]));
    }
    if (m.find("AclEntryIp") != m.end() && !m["AclEntryIp"].empty()) {
      aclEntryIp = make_shared<string>(boost::any_cast<string>(m["AclEntryIp"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~AddIPv6TranslatorAclListEntryRequest() = default;
};
class AddIPv6TranslatorAclListEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aclEntryId{};
  shared_ptr<string> requestId{};

  AddIPv6TranslatorAclListEntryResponseBody() {}

  explicit AddIPv6TranslatorAclListEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntryId) {
      res["AclEntryId"] = boost::any(*aclEntryId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclEntryId") != m.end() && !m["AclEntryId"].empty()) {
      aclEntryId = make_shared<string>(boost::any_cast<string>(m["AclEntryId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddIPv6TranslatorAclListEntryResponseBody() = default;
};
class AddIPv6TranslatorAclListEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddIPv6TranslatorAclListEntryResponseBody> body{};

  AddIPv6TranslatorAclListEntryResponse() {}

  explicit AddIPv6TranslatorAclListEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddIPv6TranslatorAclListEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddIPv6TranslatorAclListEntryResponseBody>(model1);
      }
    }
  }


  virtual ~AddIPv6TranslatorAclListEntryResponse() = default;
};
class AddPublicIpAddressPoolCidrBlockRequest : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<long> cidrMask{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> publicIpAddressPoolId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  AddPublicIpAddressPoolCidrBlockRequest() {}

  explicit AddPublicIpAddressPoolCidrBlockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (cidrMask) {
      res["CidrMask"] = boost::any(*cidrMask);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (publicIpAddressPoolId) {
      res["PublicIpAddressPoolId"] = boost::any(*publicIpAddressPoolId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("CidrMask") != m.end() && !m["CidrMask"].empty()) {
      cidrMask = make_shared<long>(boost::any_cast<long>(m["CidrMask"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PublicIpAddressPoolId") != m.end() && !m["PublicIpAddressPoolId"].empty()) {
      publicIpAddressPoolId = make_shared<string>(boost::any_cast<string>(m["PublicIpAddressPoolId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~AddPublicIpAddressPoolCidrBlockRequest() = default;
};
class AddPublicIpAddressPoolCidrBlockResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> requestId{};

  AddPublicIpAddressPoolCidrBlockResponseBody() {}

  explicit AddPublicIpAddressPoolCidrBlockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddPublicIpAddressPoolCidrBlockResponseBody() = default;
};
class AddPublicIpAddressPoolCidrBlockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPublicIpAddressPoolCidrBlockResponseBody> body{};

  AddPublicIpAddressPoolCidrBlockResponse() {}

  explicit AddPublicIpAddressPoolCidrBlockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPublicIpAddressPoolCidrBlockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPublicIpAddressPoolCidrBlockResponseBody>(model1);
      }
    }
  }


  virtual ~AddPublicIpAddressPoolCidrBlockResponse() = default;
};
class AddSourcesToTrafficMirrorSessionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> trafficMirrorSessionId{};
  shared_ptr<vector<string>> trafficMirrorSourceIds{};

  AddSourcesToTrafficMirrorSessionRequest() {}

  explicit AddSourcesToTrafficMirrorSessionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (trafficMirrorSessionId) {
      res["TrafficMirrorSessionId"] = boost::any(*trafficMirrorSessionId);
    }
    if (trafficMirrorSourceIds) {
      res["TrafficMirrorSourceIds"] = boost::any(*trafficMirrorSourceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TrafficMirrorSessionId") != m.end() && !m["TrafficMirrorSessionId"].empty()) {
      trafficMirrorSessionId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorSessionId"]));
    }
    if (m.find("TrafficMirrorSourceIds") != m.end() && !m["TrafficMirrorSourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TrafficMirrorSourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TrafficMirrorSourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      trafficMirrorSourceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddSourcesToTrafficMirrorSessionRequest() = default;
};
class AddSourcesToTrafficMirrorSessionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddSourcesToTrafficMirrorSessionResponseBody() {}

  explicit AddSourcesToTrafficMirrorSessionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddSourcesToTrafficMirrorSessionResponseBody() = default;
};
class AddSourcesToTrafficMirrorSessionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddSourcesToTrafficMirrorSessionResponseBody> body{};

  AddSourcesToTrafficMirrorSessionResponse() {}

  explicit AddSourcesToTrafficMirrorSessionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddSourcesToTrafficMirrorSessionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddSourcesToTrafficMirrorSessionResponseBody>(model1);
      }
    }
  }


  virtual ~AddSourcesToTrafficMirrorSessionResponse() = default;
};
class AllocateEipAddressRequest : public Darabonba::Model {
public:
  shared_ptr<long> activityId{};
  shared_ptr<bool> autoPay{};
  shared_ptr<string> bandwidth{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> ISP{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> name{};
  shared_ptr<string> netmode{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> period{};
  shared_ptr<string> pricingCycle{};
  shared_ptr<string> publicIpAddressPoolId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> securityProtectionTypes{};
  shared_ptr<string> zone{};

  AllocateEipAddressRequest() {}

  explicit AllocateEipAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (netmode) {
      res["Netmode"] = boost::any(*netmode);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (pricingCycle) {
      res["PricingCycle"] = boost::any(*pricingCycle);
    }
    if (publicIpAddressPoolId) {
      res["PublicIpAddressPoolId"] = boost::any(*publicIpAddressPoolId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityProtectionTypes) {
      res["SecurityProtectionTypes"] = boost::any(*securityProtectionTypes);
    }
    if (zone) {
      res["Zone"] = boost::any(*zone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<long>(boost::any_cast<long>(m["ActivityId"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Netmode") != m.end() && !m["Netmode"].empty()) {
      netmode = make_shared<string>(boost::any_cast<string>(m["Netmode"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PricingCycle") != m.end() && !m["PricingCycle"].empty()) {
      pricingCycle = make_shared<string>(boost::any_cast<string>(m["PricingCycle"]));
    }
    if (m.find("PublicIpAddressPoolId") != m.end() && !m["PublicIpAddressPoolId"].empty()) {
      publicIpAddressPoolId = make_shared<string>(boost::any_cast<string>(m["PublicIpAddressPoolId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityProtectionTypes") != m.end() && !m["SecurityProtectionTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityProtectionTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityProtectionTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityProtectionTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Zone") != m.end() && !m["Zone"].empty()) {
      zone = make_shared<string>(boost::any_cast<string>(m["Zone"]));
    }
  }


  virtual ~AllocateEipAddressRequest() = default;
};
class AllocateEipAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> eipAddress{};
  shared_ptr<long> orderId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};

  AllocateEipAddressResponseBody() {}

  explicit AllocateEipAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (eipAddress) {
      res["EipAddress"] = boost::any(*eipAddress);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("EipAddress") != m.end() && !m["EipAddress"].empty()) {
      eipAddress = make_shared<string>(boost::any_cast<string>(m["EipAddress"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~AllocateEipAddressResponseBody() = default;
};
class AllocateEipAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AllocateEipAddressResponseBody> body{};

  AllocateEipAddressResponse() {}

  explicit AllocateEipAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AllocateEipAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AllocateEipAddressResponseBody>(model1);
      }
    }
  }


  virtual ~AllocateEipAddressResponse() = default;
};
class AllocateEipAddressProRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<string> bandwidth{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ISP{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> netmode{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> period{};
  shared_ptr<string> pricingCycle{};
  shared_ptr<string> publicIpAddressPoolId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> securityProtectionTypes{};

  AllocateEipAddressProRequest() {}

  explicit AllocateEipAddressProRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (netmode) {
      res["Netmode"] = boost::any(*netmode);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (pricingCycle) {
      res["PricingCycle"] = boost::any(*pricingCycle);
    }
    if (publicIpAddressPoolId) {
      res["PublicIpAddressPoolId"] = boost::any(*publicIpAddressPoolId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityProtectionTypes) {
      res["SecurityProtectionTypes"] = boost::any(*securityProtectionTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Netmode") != m.end() && !m["Netmode"].empty()) {
      netmode = make_shared<string>(boost::any_cast<string>(m["Netmode"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PricingCycle") != m.end() && !m["PricingCycle"].empty()) {
      pricingCycle = make_shared<string>(boost::any_cast<string>(m["PricingCycle"]));
    }
    if (m.find("PublicIpAddressPoolId") != m.end() && !m["PublicIpAddressPoolId"].empty()) {
      publicIpAddressPoolId = make_shared<string>(boost::any_cast<string>(m["PublicIpAddressPoolId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityProtectionTypes") != m.end() && !m["SecurityProtectionTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityProtectionTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityProtectionTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityProtectionTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AllocateEipAddressProRequest() = default;
};
class AllocateEipAddressProResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> eipAddress{};
  shared_ptr<long> orderId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};

  AllocateEipAddressProResponseBody() {}

  explicit AllocateEipAddressProResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (eipAddress) {
      res["EipAddress"] = boost::any(*eipAddress);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("EipAddress") != m.end() && !m["EipAddress"].empty()) {
      eipAddress = make_shared<string>(boost::any_cast<string>(m["EipAddress"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~AllocateEipAddressProResponseBody() = default;
};
class AllocateEipAddressProResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AllocateEipAddressProResponseBody> body{};

  AllocateEipAddressProResponse() {}

  explicit AllocateEipAddressProResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AllocateEipAddressProResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AllocateEipAddressProResponseBody>(model1);
      }
    }
  }


  virtual ~AllocateEipAddressProResponse() = default;
};
class AllocateEipSegmentAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidth{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> eipMask{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> isp{};
  shared_ptr<string> netmode{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> zone{};

  AllocateEipSegmentAddressRequest() {}

  explicit AllocateEipSegmentAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (eipMask) {
      res["EipMask"] = boost::any(*eipMask);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (netmode) {
      res["Netmode"] = boost::any(*netmode);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (zone) {
      res["Zone"] = boost::any(*zone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EipMask") != m.end() && !m["EipMask"].empty()) {
      eipMask = make_shared<string>(boost::any_cast<string>(m["EipMask"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("Netmode") != m.end() && !m["Netmode"].empty()) {
      netmode = make_shared<string>(boost::any_cast<string>(m["Netmode"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Zone") != m.end() && !m["Zone"].empty()) {
      zone = make_shared<string>(boost::any_cast<string>(m["Zone"]));
    }
  }


  virtual ~AllocateEipSegmentAddressRequest() = default;
};
class AllocateEipSegmentAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eipSegmentInstanceId{};
  shared_ptr<string> requestId{};

  AllocateEipSegmentAddressResponseBody() {}

  explicit AllocateEipSegmentAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipSegmentInstanceId) {
      res["EipSegmentInstanceId"] = boost::any(*eipSegmentInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipSegmentInstanceId") != m.end() && !m["EipSegmentInstanceId"].empty()) {
      eipSegmentInstanceId = make_shared<string>(boost::any_cast<string>(m["EipSegmentInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AllocateEipSegmentAddressResponseBody() = default;
};
class AllocateEipSegmentAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AllocateEipSegmentAddressResponseBody> body{};

  AllocateEipSegmentAddressResponse() {}

  explicit AllocateEipSegmentAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AllocateEipSegmentAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AllocateEipSegmentAddressResponseBody>(model1);
      }
    }
  }


  virtual ~AllocateEipSegmentAddressResponse() = default;
};
class AllocateIpv6AddressRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  AllocateIpv6AddressRequestTag() {}

  explicit AllocateIpv6AddressRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AllocateIpv6AddressRequestTag() = default;
};
class AllocateIpv6AddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ipv6Address{};
  shared_ptr<string> ipv6AddressDescription{};
  shared_ptr<string> ipv6AddressName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<AllocateIpv6AddressRequestTag>> tag{};
  shared_ptr<string> vSwitchId{};

  AllocateIpv6AddressRequest() {}

  explicit AllocateIpv6AddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    if (ipv6AddressDescription) {
      res["Ipv6AddressDescription"] = boost::any(*ipv6AddressDescription);
    }
    if (ipv6AddressName) {
      res["Ipv6AddressName"] = boost::any(*ipv6AddressName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      ipv6Address = make_shared<string>(boost::any_cast<string>(m["Ipv6Address"]));
    }
    if (m.find("Ipv6AddressDescription") != m.end() && !m["Ipv6AddressDescription"].empty()) {
      ipv6AddressDescription = make_shared<string>(boost::any_cast<string>(m["Ipv6AddressDescription"]));
    }
    if (m.find("Ipv6AddressName") != m.end() && !m["Ipv6AddressName"].empty()) {
      ipv6AddressName = make_shared<string>(boost::any_cast<string>(m["Ipv6AddressName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<AllocateIpv6AddressRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AllocateIpv6AddressRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<AllocateIpv6AddressRequestTag>>(expect1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~AllocateIpv6AddressRequest() = default;
};
class AllocateIpv6AddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ipv6Address{};
  shared_ptr<string> ipv6AddressId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};

  AllocateIpv6AddressResponseBody() {}

  explicit AllocateIpv6AddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    if (ipv6AddressId) {
      res["Ipv6AddressId"] = boost::any(*ipv6AddressId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      ipv6Address = make_shared<string>(boost::any_cast<string>(m["Ipv6Address"]));
    }
    if (m.find("Ipv6AddressId") != m.end() && !m["Ipv6AddressId"].empty()) {
      ipv6AddressId = make_shared<string>(boost::any_cast<string>(m["Ipv6AddressId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~AllocateIpv6AddressResponseBody() = default;
};
class AllocateIpv6AddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AllocateIpv6AddressResponseBody> body{};

  AllocateIpv6AddressResponse() {}

  explicit AllocateIpv6AddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AllocateIpv6AddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AllocateIpv6AddressResponseBody>(model1);
      }
    }
  }


  virtual ~AllocateIpv6AddressResponse() = default;
};
class AllocateIpv6InternetBandwidthRequest : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> ipv6AddressId{};
  shared_ptr<string> ipv6GatewayId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  AllocateIpv6InternetBandwidthRequest() {}

  explicit AllocateIpv6InternetBandwidthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (ipv6AddressId) {
      res["Ipv6AddressId"] = boost::any(*ipv6AddressId);
    }
    if (ipv6GatewayId) {
      res["Ipv6GatewayId"] = boost::any(*ipv6GatewayId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("Ipv6AddressId") != m.end() && !m["Ipv6AddressId"].empty()) {
      ipv6AddressId = make_shared<string>(boost::any_cast<string>(m["Ipv6AddressId"]));
    }
    if (m.find("Ipv6GatewayId") != m.end() && !m["Ipv6GatewayId"].empty()) {
      ipv6GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv6GatewayId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~AllocateIpv6InternetBandwidthRequest() = default;
};
class AllocateIpv6InternetBandwidthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> internetBandwidthId{};
  shared_ptr<string> ipv6AddressId{};
  shared_ptr<string> requestId{};

  AllocateIpv6InternetBandwidthResponseBody() {}

  explicit AllocateIpv6InternetBandwidthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (internetBandwidthId) {
      res["InternetBandwidthId"] = boost::any(*internetBandwidthId);
    }
    if (ipv6AddressId) {
      res["Ipv6AddressId"] = boost::any(*ipv6AddressId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InternetBandwidthId") != m.end() && !m["InternetBandwidthId"].empty()) {
      internetBandwidthId = make_shared<string>(boost::any_cast<string>(m["InternetBandwidthId"]));
    }
    if (m.find("Ipv6AddressId") != m.end() && !m["Ipv6AddressId"].empty()) {
      ipv6AddressId = make_shared<string>(boost::any_cast<string>(m["Ipv6AddressId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AllocateIpv6InternetBandwidthResponseBody() = default;
};
class AllocateIpv6InternetBandwidthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AllocateIpv6InternetBandwidthResponseBody> body{};

  AllocateIpv6InternetBandwidthResponse() {}

  explicit AllocateIpv6InternetBandwidthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AllocateIpv6InternetBandwidthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AllocateIpv6InternetBandwidthResponseBody>(model1);
      }
    }
  }


  virtual ~AllocateIpv6InternetBandwidthResponse() = default;
};
class AllocateVpcIpv6CidrRequest : public Darabonba::Model {
public:
  shared_ptr<string> addressPoolType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ipv6CidrBlock{};
  shared_ptr<string> ipv6Isp{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  AllocateVpcIpv6CidrRequest() {}

  explicit AllocateVpcIpv6CidrRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressPoolType) {
      res["AddressPoolType"] = boost::any(*addressPoolType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ipv6CidrBlock) {
      res["Ipv6CidrBlock"] = boost::any(*ipv6CidrBlock);
    }
    if (ipv6Isp) {
      res["Ipv6Isp"] = boost::any(*ipv6Isp);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressPoolType") != m.end() && !m["AddressPoolType"].empty()) {
      addressPoolType = make_shared<string>(boost::any_cast<string>(m["AddressPoolType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Ipv6CidrBlock") != m.end() && !m["Ipv6CidrBlock"].empty()) {
      ipv6CidrBlock = make_shared<string>(boost::any_cast<string>(m["Ipv6CidrBlock"]));
    }
    if (m.find("Ipv6Isp") != m.end() && !m["Ipv6Isp"].empty()) {
      ipv6Isp = make_shared<string>(boost::any_cast<string>(m["Ipv6Isp"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~AllocateVpcIpv6CidrRequest() = default;
};
class AllocateVpcIpv6CidrResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ipv6CidrBlock{};
  shared_ptr<string> requestId{};

  AllocateVpcIpv6CidrResponseBody() {}

  explicit AllocateVpcIpv6CidrResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6CidrBlock) {
      res["Ipv6CidrBlock"] = boost::any(*ipv6CidrBlock);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6CidrBlock") != m.end() && !m["Ipv6CidrBlock"].empty()) {
      ipv6CidrBlock = make_shared<string>(boost::any_cast<string>(m["Ipv6CidrBlock"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AllocateVpcIpv6CidrResponseBody() = default;
};
class AllocateVpcIpv6CidrResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AllocateVpcIpv6CidrResponseBody> body{};

  AllocateVpcIpv6CidrResponse() {}

  explicit AllocateVpcIpv6CidrResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AllocateVpcIpv6CidrResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AllocateVpcIpv6CidrResponseBody>(model1);
      }
    }
  }


  virtual ~AllocateVpcIpv6CidrResponse() = default;
};
class ApplyPhysicalConnectionLOARequestPMInfo : public Darabonba::Model {
public:
  shared_ptr<string> PMCertificateNo{};
  shared_ptr<string> PMCertificateType{};
  shared_ptr<string> PMContactInfo{};
  shared_ptr<string> PMGender{};
  shared_ptr<string> PMName{};

  ApplyPhysicalConnectionLOARequestPMInfo() {}

  explicit ApplyPhysicalConnectionLOARequestPMInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (PMCertificateNo) {
      res["PMCertificateNo"] = boost::any(*PMCertificateNo);
    }
    if (PMCertificateType) {
      res["PMCertificateType"] = boost::any(*PMCertificateType);
    }
    if (PMContactInfo) {
      res["PMContactInfo"] = boost::any(*PMContactInfo);
    }
    if (PMGender) {
      res["PMGender"] = boost::any(*PMGender);
    }
    if (PMName) {
      res["PMName"] = boost::any(*PMName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PMCertificateNo") != m.end() && !m["PMCertificateNo"].empty()) {
      PMCertificateNo = make_shared<string>(boost::any_cast<string>(m["PMCertificateNo"]));
    }
    if (m.find("PMCertificateType") != m.end() && !m["PMCertificateType"].empty()) {
      PMCertificateType = make_shared<string>(boost::any_cast<string>(m["PMCertificateType"]));
    }
    if (m.find("PMContactInfo") != m.end() && !m["PMContactInfo"].empty()) {
      PMContactInfo = make_shared<string>(boost::any_cast<string>(m["PMContactInfo"]));
    }
    if (m.find("PMGender") != m.end() && !m["PMGender"].empty()) {
      PMGender = make_shared<string>(boost::any_cast<string>(m["PMGender"]));
    }
    if (m.find("PMName") != m.end() && !m["PMName"].empty()) {
      PMName = make_shared<string>(boost::any_cast<string>(m["PMName"]));
    }
  }


  virtual ~ApplyPhysicalConnectionLOARequestPMInfo() = default;
};
class ApplyPhysicalConnectionLOARequest : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> companyName{};
  shared_ptr<string> constructionTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lineType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<ApplyPhysicalConnectionLOARequestPMInfo>> PMInfo{};
  shared_ptr<string> peerLocation{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> si{};

  ApplyPhysicalConnectionLOARequest() {}

  explicit ApplyPhysicalConnectionLOARequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (companyName) {
      res["CompanyName"] = boost::any(*companyName);
    }
    if (constructionTime) {
      res["ConstructionTime"] = boost::any(*constructionTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lineType) {
      res["LineType"] = boost::any(*lineType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (PMInfo) {
      vector<boost::any> temp1;
      for(auto item1:*PMInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PMInfo"] = boost::any(temp1);
    }
    if (peerLocation) {
      res["PeerLocation"] = boost::any(*peerLocation);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (si) {
      res["Si"] = boost::any(*si);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CompanyName") != m.end() && !m["CompanyName"].empty()) {
      companyName = make_shared<string>(boost::any_cast<string>(m["CompanyName"]));
    }
    if (m.find("ConstructionTime") != m.end() && !m["ConstructionTime"].empty()) {
      constructionTime = make_shared<string>(boost::any_cast<string>(m["ConstructionTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LineType") != m.end() && !m["LineType"].empty()) {
      lineType = make_shared<string>(boost::any_cast<string>(m["LineType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PMInfo") != m.end() && !m["PMInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PMInfo"].type()) {
        vector<ApplyPhysicalConnectionLOARequestPMInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PMInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyPhysicalConnectionLOARequestPMInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        PMInfo = make_shared<vector<ApplyPhysicalConnectionLOARequestPMInfo>>(expect1);
      }
    }
    if (m.find("PeerLocation") != m.end() && !m["PeerLocation"].empty()) {
      peerLocation = make_shared<string>(boost::any_cast<string>(m["PeerLocation"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Si") != m.end() && !m["Si"].empty()) {
      si = make_shared<string>(boost::any_cast<string>(m["Si"]));
    }
  }


  virtual ~ApplyPhysicalConnectionLOARequest() = default;
};
class ApplyPhysicalConnectionLOAResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ApplyPhysicalConnectionLOAResponseBody() {}

  explicit ApplyPhysicalConnectionLOAResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ApplyPhysicalConnectionLOAResponseBody() = default;
};
class ApplyPhysicalConnectionLOAResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyPhysicalConnectionLOAResponseBody> body{};

  ApplyPhysicalConnectionLOAResponse() {}

  explicit ApplyPhysicalConnectionLOAResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyPhysicalConnectionLOAResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyPhysicalConnectionLOAResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyPhysicalConnectionLOAResponse() = default;
};
class AssociateEipAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceRegionId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> mode{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpcId{};

  AssociateEipAddressRequest() {}

  explicit AssociateEipAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceRegionId) {
      res["InstanceRegionId"] = boost::any(*instanceRegionId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceRegionId") != m.end() && !m["InstanceRegionId"].empty()) {
      instanceRegionId = make_shared<string>(boost::any_cast<string>(m["InstanceRegionId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~AssociateEipAddressRequest() = default;
};
class AssociateEipAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateEipAddressResponseBody() {}

  explicit AssociateEipAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateEipAddressResponseBody() = default;
};
class AssociateEipAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssociateEipAddressResponseBody> body{};

  AssociateEipAddressResponse() {}

  explicit AssociateEipAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateEipAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateEipAddressResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateEipAddressResponse() = default;
};
class AssociateEipAddressBatchRequest : public Darabonba::Model {
public:
  shared_ptr<string> bindedInstanceId{};
  shared_ptr<string> bindedInstanceType{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> mode{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  AssociateEipAddressBatchRequest() {}

  explicit AssociateEipAddressBatchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindedInstanceId) {
      res["BindedInstanceId"] = boost::any(*bindedInstanceId);
    }
    if (bindedInstanceType) {
      res["BindedInstanceType"] = boost::any(*bindedInstanceType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindedInstanceId") != m.end() && !m["BindedInstanceId"].empty()) {
      bindedInstanceId = make_shared<string>(boost::any_cast<string>(m["BindedInstanceId"]));
    }
    if (m.find("BindedInstanceType") != m.end() && !m["BindedInstanceType"].empty()) {
      bindedInstanceType = make_shared<string>(boost::any_cast<string>(m["BindedInstanceType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~AssociateEipAddressBatchRequest() = default;
};
class AssociateEipAddressBatchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateEipAddressBatchResponseBody() {}

  explicit AssociateEipAddressBatchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateEipAddressBatchResponseBody() = default;
};
class AssociateEipAddressBatchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssociateEipAddressBatchResponseBody> body{};

  AssociateEipAddressBatchResponse() {}

  explicit AssociateEipAddressBatchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateEipAddressBatchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateEipAddressBatchResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateEipAddressBatchResponse() = default;
};
class AssociateHaVipRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> haVipId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  AssociateHaVipRequest() {}

  explicit AssociateHaVipRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (haVipId) {
      res["HaVipId"] = boost::any(*haVipId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("HaVipId") != m.end() && !m["HaVipId"].empty()) {
      haVipId = make_shared<string>(boost::any_cast<string>(m["HaVipId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~AssociateHaVipRequest() = default;
};
class AssociateHaVipResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateHaVipResponseBody() {}

  explicit AssociateHaVipResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateHaVipResponseBody() = default;
};
class AssociateHaVipResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssociateHaVipResponseBody> body{};

  AssociateHaVipResponse() {}

  explicit AssociateHaVipResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateHaVipResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateHaVipResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateHaVipResponse() = default;
};
class AssociateNetworkAclRequestResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  AssociateNetworkAclRequestResource() {}

  explicit AssociateNetworkAclRequestResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~AssociateNetworkAclRequestResource() = default;
};
class AssociateNetworkAclRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> networkAclId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<AssociateNetworkAclRequestResource>> resource{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  AssociateNetworkAclRequest() {}

  explicit AssociateNetworkAclRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<AssociateNetworkAclRequestResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AssociateNetworkAclRequestResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<AssociateNetworkAclRequestResource>>(expect1);
      }
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~AssociateNetworkAclRequest() = default;
};
class AssociateNetworkAclResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateNetworkAclResponseBody() {}

  explicit AssociateNetworkAclResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateNetworkAclResponseBody() = default;
};
class AssociateNetworkAclResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssociateNetworkAclResponseBody> body{};

  AssociateNetworkAclResponse() {}

  explicit AssociateNetworkAclResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateNetworkAclResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateNetworkAclResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateNetworkAclResponse() = default;
};
class AssociatePhysicalConnectionToVirtualBorderRouterRequest : public Darabonba::Model {
public:
  shared_ptr<string> circuitCode{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> enableIpv6{};
  shared_ptr<string> localGatewayIp{};
  shared_ptr<string> localIpv6GatewayIp{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> peerGatewayIp{};
  shared_ptr<string> peerIpv6GatewayIp{};
  shared_ptr<string> peeringIpv6SubnetMask{};
  shared_ptr<string> peeringSubnetMask{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vbrId{};
  shared_ptr<string> vlanId{};

  AssociatePhysicalConnectionToVirtualBorderRouterRequest() {}

  explicit AssociatePhysicalConnectionToVirtualBorderRouterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (circuitCode) {
      res["CircuitCode"] = boost::any(*circuitCode);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (enableIpv6) {
      res["EnableIpv6"] = boost::any(*enableIpv6);
    }
    if (localGatewayIp) {
      res["LocalGatewayIp"] = boost::any(*localGatewayIp);
    }
    if (localIpv6GatewayIp) {
      res["LocalIpv6GatewayIp"] = boost::any(*localIpv6GatewayIp);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (peerGatewayIp) {
      res["PeerGatewayIp"] = boost::any(*peerGatewayIp);
    }
    if (peerIpv6GatewayIp) {
      res["PeerIpv6GatewayIp"] = boost::any(*peerIpv6GatewayIp);
    }
    if (peeringIpv6SubnetMask) {
      res["PeeringIpv6SubnetMask"] = boost::any(*peeringIpv6SubnetMask);
    }
    if (peeringSubnetMask) {
      res["PeeringSubnetMask"] = boost::any(*peeringSubnetMask);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    if (vlanId) {
      res["VlanId"] = boost::any(*vlanId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CircuitCode") != m.end() && !m["CircuitCode"].empty()) {
      circuitCode = make_shared<string>(boost::any_cast<string>(m["CircuitCode"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EnableIpv6") != m.end() && !m["EnableIpv6"].empty()) {
      enableIpv6 = make_shared<string>(boost::any_cast<string>(m["EnableIpv6"]));
    }
    if (m.find("LocalGatewayIp") != m.end() && !m["LocalGatewayIp"].empty()) {
      localGatewayIp = make_shared<string>(boost::any_cast<string>(m["LocalGatewayIp"]));
    }
    if (m.find("LocalIpv6GatewayIp") != m.end() && !m["LocalIpv6GatewayIp"].empty()) {
      localIpv6GatewayIp = make_shared<string>(boost::any_cast<string>(m["LocalIpv6GatewayIp"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PeerGatewayIp") != m.end() && !m["PeerGatewayIp"].empty()) {
      peerGatewayIp = make_shared<string>(boost::any_cast<string>(m["PeerGatewayIp"]));
    }
    if (m.find("PeerIpv6GatewayIp") != m.end() && !m["PeerIpv6GatewayIp"].empty()) {
      peerIpv6GatewayIp = make_shared<string>(boost::any_cast<string>(m["PeerIpv6GatewayIp"]));
    }
    if (m.find("PeeringIpv6SubnetMask") != m.end() && !m["PeeringIpv6SubnetMask"].empty()) {
      peeringIpv6SubnetMask = make_shared<string>(boost::any_cast<string>(m["PeeringIpv6SubnetMask"]));
    }
    if (m.find("PeeringSubnetMask") != m.end() && !m["PeeringSubnetMask"].empty()) {
      peeringSubnetMask = make_shared<string>(boost::any_cast<string>(m["PeeringSubnetMask"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
    if (m.find("VlanId") != m.end() && !m["VlanId"].empty()) {
      vlanId = make_shared<string>(boost::any_cast<string>(m["VlanId"]));
    }
  }


  virtual ~AssociatePhysicalConnectionToVirtualBorderRouterRequest() = default;
};
class AssociatePhysicalConnectionToVirtualBorderRouterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociatePhysicalConnectionToVirtualBorderRouterResponseBody() {}

  explicit AssociatePhysicalConnectionToVirtualBorderRouterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociatePhysicalConnectionToVirtualBorderRouterResponseBody() = default;
};
class AssociatePhysicalConnectionToVirtualBorderRouterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssociatePhysicalConnectionToVirtualBorderRouterResponseBody> body{};

  AssociatePhysicalConnectionToVirtualBorderRouterResponse() {}

  explicit AssociatePhysicalConnectionToVirtualBorderRouterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociatePhysicalConnectionToVirtualBorderRouterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociatePhysicalConnectionToVirtualBorderRouterResponseBody>(model1);
      }
    }
  }


  virtual ~AssociatePhysicalConnectionToVirtualBorderRouterResponse() = default;
};
class AssociateRouteTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> vSwitchId{};

  AssociateRouteTableRequest() {}

  explicit AssociateRouteTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~AssociateRouteTableRequest() = default;
};
class AssociateRouteTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateRouteTableResponseBody() {}

  explicit AssociateRouteTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateRouteTableResponseBody() = default;
};
class AssociateRouteTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssociateRouteTableResponseBody> body{};

  AssociateRouteTableResponse() {}

  explicit AssociateRouteTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateRouteTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateRouteTableResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateRouteTableResponse() = default;
};
class AssociateRouteTableWithGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> gatewayId{};
  shared_ptr<string> gatewayType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeTableId{};

  AssociateRouteTableWithGatewayRequest() {}

  explicit AssociateRouteTableWithGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayType) {
      res["GatewayType"] = boost::any(*gatewayType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<string>(boost::any_cast<string>(m["GatewayId"]));
    }
    if (m.find("GatewayType") != m.end() && !m["GatewayType"].empty()) {
      gatewayType = make_shared<string>(boost::any_cast<string>(m["GatewayType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
  }


  virtual ~AssociateRouteTableWithGatewayRequest() = default;
};
class AssociateRouteTableWithGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateRouteTableWithGatewayResponseBody() {}

  explicit AssociateRouteTableWithGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateRouteTableWithGatewayResponseBody() = default;
};
class AssociateRouteTableWithGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssociateRouteTableWithGatewayResponseBody> body{};

  AssociateRouteTableWithGatewayResponse() {}

  explicit AssociateRouteTableWithGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateRouteTableWithGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateRouteTableWithGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateRouteTableWithGatewayResponse() = default;
};
class AssociateRouteTablesWithVpcGatewayEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> routeTableIds{};

  AssociateRouteTablesWithVpcGatewayEndpointRequest() {}

  explicit AssociateRouteTablesWithVpcGatewayEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeTableIds) {
      res["RouteTableIds"] = boost::any(*routeTableIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteTableIds") != m.end() && !m["RouteTableIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RouteTableIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RouteTableIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      routeTableIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AssociateRouteTablesWithVpcGatewayEndpointRequest() = default;
};
class AssociateRouteTablesWithVpcGatewayEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateRouteTablesWithVpcGatewayEndpointResponseBody() {}

  explicit AssociateRouteTablesWithVpcGatewayEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateRouteTablesWithVpcGatewayEndpointResponseBody() = default;
};
class AssociateRouteTablesWithVpcGatewayEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssociateRouteTablesWithVpcGatewayEndpointResponseBody> body{};

  AssociateRouteTablesWithVpcGatewayEndpointResponse() {}

  explicit AssociateRouteTablesWithVpcGatewayEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateRouteTablesWithVpcGatewayEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateRouteTablesWithVpcGatewayEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateRouteTablesWithVpcGatewayEndpointResponse() = default;
};
class AssociateVpcCidrBlockRequest : public Darabonba::Model {
public:
  shared_ptr<string> IPv6CidrBlock{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> ipamPoolId{};
  shared_ptr<string> ipv6Isp{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> secondaryCidrBlock{};
  shared_ptr<long> secondaryCidrMask{};
  shared_ptr<string> vpcId{};

  AssociateVpcCidrBlockRequest() {}

  explicit AssociateVpcCidrBlockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IPv6CidrBlock) {
      res["IPv6CidrBlock"] = boost::any(*IPv6CidrBlock);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (ipamPoolId) {
      res["IpamPoolId"] = boost::any(*ipamPoolId);
    }
    if (ipv6Isp) {
      res["Ipv6Isp"] = boost::any(*ipv6Isp);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (secondaryCidrBlock) {
      res["SecondaryCidrBlock"] = boost::any(*secondaryCidrBlock);
    }
    if (secondaryCidrMask) {
      res["SecondaryCidrMask"] = boost::any(*secondaryCidrMask);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IPv6CidrBlock") != m.end() && !m["IPv6CidrBlock"].empty()) {
      IPv6CidrBlock = make_shared<string>(boost::any_cast<string>(m["IPv6CidrBlock"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("IpamPoolId") != m.end() && !m["IpamPoolId"].empty()) {
      ipamPoolId = make_shared<string>(boost::any_cast<string>(m["IpamPoolId"]));
    }
    if (m.find("Ipv6Isp") != m.end() && !m["Ipv6Isp"].empty()) {
      ipv6Isp = make_shared<string>(boost::any_cast<string>(m["Ipv6Isp"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecondaryCidrBlock") != m.end() && !m["SecondaryCidrBlock"].empty()) {
      secondaryCidrBlock = make_shared<string>(boost::any_cast<string>(m["SecondaryCidrBlock"]));
    }
    if (m.find("SecondaryCidrMask") != m.end() && !m["SecondaryCidrMask"].empty()) {
      secondaryCidrMask = make_shared<long>(boost::any_cast<long>(m["SecondaryCidrMask"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~AssociateVpcCidrBlockRequest() = default;
};
class AssociateVpcCidrBlockResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateVpcCidrBlockResponseBody() {}

  explicit AssociateVpcCidrBlockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateVpcCidrBlockResponseBody() = default;
};
class AssociateVpcCidrBlockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssociateVpcCidrBlockResponseBody> body{};

  AssociateVpcCidrBlockResponse() {}

  explicit AssociateVpcCidrBlockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateVpcCidrBlockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateVpcCidrBlockResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateVpcCidrBlockResponse() = default;
};
class AssociateVpnGatewayWithCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> certificateId{};
  shared_ptr<string> certificateType{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vpnGatewayId{};

  AssociateVpnGatewayWithCertificateRequest() {}

  explicit AssociateVpnGatewayWithCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    if (certificateType) {
      res["CertificateType"] = boost::any(*certificateType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
    if (m.find("CertificateType") != m.end() && !m["CertificateType"].empty()) {
      certificateType = make_shared<string>(boost::any_cast<string>(m["CertificateType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~AssociateVpnGatewayWithCertificateRequest() = default;
};
class AssociateVpnGatewayWithCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateVpnGatewayWithCertificateResponseBody() {}

  explicit AssociateVpnGatewayWithCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateVpnGatewayWithCertificateResponseBody() = default;
};
class AssociateVpnGatewayWithCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssociateVpnGatewayWithCertificateResponseBody> body{};

  AssociateVpnGatewayWithCertificateResponse() {}

  explicit AssociateVpnGatewayWithCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateVpnGatewayWithCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateVpnGatewayWithCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateVpnGatewayWithCertificateResponse() = default;
};
class AttachDhcpOptionsSetToVpcRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> dhcpOptionsSetId{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpcId{};

  AttachDhcpOptionsSetToVpcRequest() {}

  explicit AttachDhcpOptionsSetToVpcRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dhcpOptionsSetId) {
      res["DhcpOptionsSetId"] = boost::any(*dhcpOptionsSetId);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DhcpOptionsSetId") != m.end() && !m["DhcpOptionsSetId"].empty()) {
      dhcpOptionsSetId = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetId"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~AttachDhcpOptionsSetToVpcRequest() = default;
};
class AttachDhcpOptionsSetToVpcResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AttachDhcpOptionsSetToVpcResponseBody() {}

  explicit AttachDhcpOptionsSetToVpcResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachDhcpOptionsSetToVpcResponseBody() = default;
};
class AttachDhcpOptionsSetToVpcResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachDhcpOptionsSetToVpcResponseBody> body{};

  AttachDhcpOptionsSetToVpcResponse() {}

  explicit AttachDhcpOptionsSetToVpcResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachDhcpOptionsSetToVpcResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachDhcpOptionsSetToVpcResponseBody>(model1);
      }
    }
  }


  virtual ~AttachDhcpOptionsSetToVpcResponse() = default;
};
class AttachVbrToVpconnRequest : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<string> regionId{};
  shared_ptr<string> token{};
  shared_ptr<string> vbrId{};
  shared_ptr<string> vpconnId{};

  AttachVbrToVpconnRequest() {}

  explicit AttachVbrToVpconnRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    if (vpconnId) {
      res["VpconnId"] = boost::any(*vpconnId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
    if (m.find("VpconnId") != m.end() && !m["VpconnId"].empty()) {
      vpconnId = make_shared<string>(boost::any_cast<string>(m["VpconnId"]));
    }
  }


  virtual ~AttachVbrToVpconnRequest() = default;
};
class AttachVbrToVpconnResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> virtualPhysicalConnection{};

  AttachVbrToVpconnResponseBody() {}

  explicit AttachVbrToVpconnResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (virtualPhysicalConnection) {
      res["VirtualPhysicalConnection"] = boost::any(*virtualPhysicalConnection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VirtualPhysicalConnection") != m.end() && !m["VirtualPhysicalConnection"].empty()) {
      virtualPhysicalConnection = make_shared<string>(boost::any_cast<string>(m["VirtualPhysicalConnection"]));
    }
  }


  virtual ~AttachVbrToVpconnResponseBody() = default;
};
class AttachVbrToVpconnResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachVbrToVpconnResponseBody> body{};

  AttachVbrToVpconnResponse() {}

  explicit AttachVbrToVpconnResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachVbrToVpconnResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachVbrToVpconnResponseBody>(model1);
      }
    }
  }


  virtual ~AttachVbrToVpconnResponse() = default;
};
class CancelCommonBandwidthPackageIpBandwidthRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> eipId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CancelCommonBandwidthPackageIpBandwidthRequest() {}

  explicit CancelCommonBandwidthPackageIpBandwidthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (eipId) {
      res["EipId"] = boost::any(*eipId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("EipId") != m.end() && !m["EipId"].empty()) {
      eipId = make_shared<string>(boost::any_cast<string>(m["EipId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CancelCommonBandwidthPackageIpBandwidthRequest() = default;
};
class CancelCommonBandwidthPackageIpBandwidthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CancelCommonBandwidthPackageIpBandwidthResponseBody() {}

  explicit CancelCommonBandwidthPackageIpBandwidthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelCommonBandwidthPackageIpBandwidthResponseBody() = default;
};
class CancelCommonBandwidthPackageIpBandwidthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelCommonBandwidthPackageIpBandwidthResponseBody> body{};

  CancelCommonBandwidthPackageIpBandwidthResponse() {}

  explicit CancelCommonBandwidthPackageIpBandwidthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelCommonBandwidthPackageIpBandwidthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelCommonBandwidthPackageIpBandwidthResponseBody>(model1);
      }
    }
  }


  virtual ~CancelCommonBandwidthPackageIpBandwidthResponse() = default;
};
class CancelPhysicalConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CancelPhysicalConnectionRequest() {}

  explicit CancelPhysicalConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CancelPhysicalConnectionRequest() = default;
};
class CancelPhysicalConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CancelPhysicalConnectionResponseBody() {}

  explicit CancelPhysicalConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelPhysicalConnectionResponseBody() = default;
};
class CancelPhysicalConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelPhysicalConnectionResponseBody> body{};

  CancelPhysicalConnectionResponse() {}

  explicit CancelPhysicalConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelPhysicalConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelPhysicalConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~CancelPhysicalConnectionResponse() = default;
};
class ChangeResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> newResourceGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  ChangeResourceGroupRequest() {}

  explicit ChangeResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (newResourceGroupId) {
      res["NewResourceGroupId"] = boost::any(*newResourceGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NewResourceGroupId") != m.end() && !m["NewResourceGroupId"].empty()) {
      newResourceGroupId = make_shared<string>(boost::any_cast<string>(m["NewResourceGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ChangeResourceGroupRequest() = default;
};
class ChangeResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ChangeResourceGroupResponseBody() {}

  explicit ChangeResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ChangeResourceGroupResponseBody() = default;
};
class ChangeResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeResourceGroupResponseBody> body{};

  ChangeResourceGroupResponse() {}

  explicit ChangeResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeResourceGroupResponse() = default;
};
class CheckCanAllocateVpcPrivateIpAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipVersion{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vSwitchId{};

  CheckCanAllocateVpcPrivateIpAddressRequest() {}

  explicit CheckCanAllocateVpcPrivateIpAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CheckCanAllocateVpcPrivateIpAddressRequest() = default;
};
class CheckCanAllocateVpcPrivateIpAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> canAllocate{};
  shared_ptr<string> requestId{};

  CheckCanAllocateVpcPrivateIpAddressResponseBody() {}

  explicit CheckCanAllocateVpcPrivateIpAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canAllocate) {
      res["CanAllocate"] = boost::any(*canAllocate);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanAllocate") != m.end() && !m["CanAllocate"].empty()) {
      canAllocate = make_shared<bool>(boost::any_cast<bool>(m["CanAllocate"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckCanAllocateVpcPrivateIpAddressResponseBody() = default;
};
class CheckCanAllocateVpcPrivateIpAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckCanAllocateVpcPrivateIpAddressResponseBody> body{};

  CheckCanAllocateVpcPrivateIpAddressResponse() {}

  explicit CheckCanAllocateVpcPrivateIpAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckCanAllocateVpcPrivateIpAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckCanAllocateVpcPrivateIpAddressResponseBody>(model1);
      }
    }
  }


  virtual ~CheckCanAllocateVpcPrivateIpAddressResponse() = default;
};
class CheckVpnBgpEnabledRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CheckVpnBgpEnabledRequest() {}

  explicit CheckVpnBgpEnabledRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CheckVpnBgpEnabledRequest() = default;
};
class CheckVpnBgpEnabledResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> bgpEnabled{};
  shared_ptr<string> requestId{};

  CheckVpnBgpEnabledResponseBody() {}

  explicit CheckVpnBgpEnabledResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgpEnabled) {
      res["BgpEnabled"] = boost::any(*bgpEnabled);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgpEnabled") != m.end() && !m["BgpEnabled"].empty()) {
      bgpEnabled = make_shared<bool>(boost::any_cast<bool>(m["BgpEnabled"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckVpnBgpEnabledResponseBody() = default;
};
class CheckVpnBgpEnabledResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckVpnBgpEnabledResponseBody> body{};

  CheckVpnBgpEnabledResponse() {}

  explicit CheckVpnBgpEnabledResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckVpnBgpEnabledResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckVpnBgpEnabledResponseBody>(model1);
      }
    }
  }


  virtual ~CheckVpnBgpEnabledResponse() = default;
};
class CompletePhysicalConnectionLOARequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> finishWork{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lineCode{};
  shared_ptr<string> lineLabel{};
  shared_ptr<string> lineSPContactInfo{};
  shared_ptr<string> lineServiceProvider{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CompletePhysicalConnectionLOARequest() {}

  explicit CompletePhysicalConnectionLOARequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (finishWork) {
      res["FinishWork"] = boost::any(*finishWork);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lineCode) {
      res["LineCode"] = boost::any(*lineCode);
    }
    if (lineLabel) {
      res["LineLabel"] = boost::any(*lineLabel);
    }
    if (lineSPContactInfo) {
      res["LineSPContactInfo"] = boost::any(*lineSPContactInfo);
    }
    if (lineServiceProvider) {
      res["LineServiceProvider"] = boost::any(*lineServiceProvider);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("FinishWork") != m.end() && !m["FinishWork"].empty()) {
      finishWork = make_shared<bool>(boost::any_cast<bool>(m["FinishWork"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LineCode") != m.end() && !m["LineCode"].empty()) {
      lineCode = make_shared<string>(boost::any_cast<string>(m["LineCode"]));
    }
    if (m.find("LineLabel") != m.end() && !m["LineLabel"].empty()) {
      lineLabel = make_shared<string>(boost::any_cast<string>(m["LineLabel"]));
    }
    if (m.find("LineSPContactInfo") != m.end() && !m["LineSPContactInfo"].empty()) {
      lineSPContactInfo = make_shared<string>(boost::any_cast<string>(m["LineSPContactInfo"]));
    }
    if (m.find("LineServiceProvider") != m.end() && !m["LineServiceProvider"].empty()) {
      lineServiceProvider = make_shared<string>(boost::any_cast<string>(m["LineServiceProvider"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CompletePhysicalConnectionLOARequest() = default;
};
class CompletePhysicalConnectionLOAResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CompletePhysicalConnectionLOAResponseBody() {}

  explicit CompletePhysicalConnectionLOAResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CompletePhysicalConnectionLOAResponseBody() = default;
};
class CompletePhysicalConnectionLOAResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CompletePhysicalConnectionLOAResponseBody> body{};

  CompletePhysicalConnectionLOAResponse() {}

  explicit CompletePhysicalConnectionLOAResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CompletePhysicalConnectionLOAResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CompletePhysicalConnectionLOAResponseBody>(model1);
      }
    }
  }


  virtual ~CompletePhysicalConnectionLOAResponse() = default;
};
class ConfirmPhysicalConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ConfirmPhysicalConnectionRequest() {}

  explicit ConfirmPhysicalConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ConfirmPhysicalConnectionRequest() = default;
};
class ConfirmPhysicalConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConfirmPhysicalConnectionResponseBody() {}

  explicit ConfirmPhysicalConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfirmPhysicalConnectionResponseBody() = default;
};
class ConfirmPhysicalConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfirmPhysicalConnectionResponseBody> body{};

  ConfirmPhysicalConnectionResponse() {}

  explicit ConfirmPhysicalConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfirmPhysicalConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfirmPhysicalConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~ConfirmPhysicalConnectionResponse() = default;
};
class ConnectRouterInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routerInterfaceId{};

  ConnectRouterInterfaceRequest() {}

  explicit ConnectRouterInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routerInterfaceId) {
      res["RouterInterfaceId"] = boost::any(*routerInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouterInterfaceId") != m.end() && !m["RouterInterfaceId"].empty()) {
      routerInterfaceId = make_shared<string>(boost::any_cast<string>(m["RouterInterfaceId"]));
    }
  }


  virtual ~ConnectRouterInterfaceRequest() = default;
};
class ConnectRouterInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConnectRouterInterfaceResponseBody() {}

  explicit ConnectRouterInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConnectRouterInterfaceResponseBody() = default;
};
class ConnectRouterInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConnectRouterInterfaceResponseBody> body{};

  ConnectRouterInterfaceResponse() {}

  explicit ConnectRouterInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConnectRouterInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConnectRouterInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~ConnectRouterInterfaceResponse() = default;
};
class ConvertBandwidthPackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ConvertBandwidthPackageRequest() {}

  explicit ConvertBandwidthPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ConvertBandwidthPackageRequest() = default;
};
class ConvertBandwidthPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> convertInstanceId{};
  shared_ptr<string> requestId{};

  ConvertBandwidthPackageResponseBody() {}

  explicit ConvertBandwidthPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (convertInstanceId) {
      res["ConvertInstanceId"] = boost::any(*convertInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConvertInstanceId") != m.end() && !m["ConvertInstanceId"].empty()) {
      convertInstanceId = make_shared<string>(boost::any_cast<string>(m["ConvertInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConvertBandwidthPackageResponseBody() = default;
};
class ConvertBandwidthPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConvertBandwidthPackageResponseBody> body{};

  ConvertBandwidthPackageResponse() {}

  explicit ConvertBandwidthPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConvertBandwidthPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConvertBandwidthPackageResponseBody>(model1);
      }
    }
  }


  virtual ~ConvertBandwidthPackageResponse() = default;
};
class CopyNetworkAclEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> networkAclId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceNetworkAclId{};

  CopyNetworkAclEntriesRequest() {}

  explicit CopyNetworkAclEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceNetworkAclId) {
      res["SourceNetworkAclId"] = boost::any(*sourceNetworkAclId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceNetworkAclId") != m.end() && !m["SourceNetworkAclId"].empty()) {
      sourceNetworkAclId = make_shared<string>(boost::any_cast<string>(m["SourceNetworkAclId"]));
    }
  }


  virtual ~CopyNetworkAclEntriesRequest() = default;
};
class CopyNetworkAclEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CopyNetworkAclEntriesResponseBody() {}

  explicit CopyNetworkAclEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CopyNetworkAclEntriesResponseBody() = default;
};
class CopyNetworkAclEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CopyNetworkAclEntriesResponseBody> body{};

  CopyNetworkAclEntriesResponse() {}

  explicit CopyNetworkAclEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyNetworkAclEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyNetworkAclEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~CopyNetworkAclEntriesResponse() = default;
};
class CreateBgpGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> authKey{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> ipVersion{};
  shared_ptr<bool> isFakeAsn{};
  shared_ptr<long> localAsn{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> peerAsn{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> routeQuota{};
  shared_ptr<string> routerId{};

  CreateBgpGroupRequest() {}

  explicit CreateBgpGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (isFakeAsn) {
      res["IsFakeAsn"] = boost::any(*isFakeAsn);
    }
    if (localAsn) {
      res["LocalAsn"] = boost::any(*localAsn);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (peerAsn) {
      res["PeerAsn"] = boost::any(*peerAsn);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeQuota) {
      res["RouteQuota"] = boost::any(*routeQuota);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("IsFakeAsn") != m.end() && !m["IsFakeAsn"].empty()) {
      isFakeAsn = make_shared<bool>(boost::any_cast<bool>(m["IsFakeAsn"]));
    }
    if (m.find("LocalAsn") != m.end() && !m["LocalAsn"].empty()) {
      localAsn = make_shared<long>(boost::any_cast<long>(m["LocalAsn"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PeerAsn") != m.end() && !m["PeerAsn"].empty()) {
      peerAsn = make_shared<long>(boost::any_cast<long>(m["PeerAsn"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteQuota") != m.end() && !m["RouteQuota"].empty()) {
      routeQuota = make_shared<long>(boost::any_cast<long>(m["RouteQuota"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
  }


  virtual ~CreateBgpGroupRequest() = default;
};
class CreateBgpGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bgpGroupId{};
  shared_ptr<string> requestId{};

  CreateBgpGroupResponseBody() {}

  explicit CreateBgpGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgpGroupId) {
      res["BgpGroupId"] = boost::any(*bgpGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgpGroupId") != m.end() && !m["BgpGroupId"].empty()) {
      bgpGroupId = make_shared<string>(boost::any_cast<string>(m["BgpGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateBgpGroupResponseBody() = default;
};
class CreateBgpGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBgpGroupResponseBody> body{};

  CreateBgpGroupResponse() {}

  explicit CreateBgpGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBgpGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBgpGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBgpGroupResponse() = default;
};
class CreateBgpPeerRequest : public Darabonba::Model {
public:
  shared_ptr<long> bfdMultiHop{};
  shared_ptr<string> bgpGroupId{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> enableBfd{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> peerIpAddress{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateBgpPeerRequest() {}

  explicit CreateBgpPeerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bfdMultiHop) {
      res["BfdMultiHop"] = boost::any(*bfdMultiHop);
    }
    if (bgpGroupId) {
      res["BgpGroupId"] = boost::any(*bgpGroupId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (enableBfd) {
      res["EnableBfd"] = boost::any(*enableBfd);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (peerIpAddress) {
      res["PeerIpAddress"] = boost::any(*peerIpAddress);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BfdMultiHop") != m.end() && !m["BfdMultiHop"].empty()) {
      bfdMultiHop = make_shared<long>(boost::any_cast<long>(m["BfdMultiHop"]));
    }
    if (m.find("BgpGroupId") != m.end() && !m["BgpGroupId"].empty()) {
      bgpGroupId = make_shared<string>(boost::any_cast<string>(m["BgpGroupId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EnableBfd") != m.end() && !m["EnableBfd"].empty()) {
      enableBfd = make_shared<bool>(boost::any_cast<bool>(m["EnableBfd"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PeerIpAddress") != m.end() && !m["PeerIpAddress"].empty()) {
      peerIpAddress = make_shared<string>(boost::any_cast<string>(m["PeerIpAddress"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateBgpPeerRequest() = default;
};
class CreateBgpPeerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bgpPeerId{};
  shared_ptr<string> requestId{};

  CreateBgpPeerResponseBody() {}

  explicit CreateBgpPeerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgpPeerId) {
      res["BgpPeerId"] = boost::any(*bgpPeerId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgpPeerId") != m.end() && !m["BgpPeerId"].empty()) {
      bgpPeerId = make_shared<string>(boost::any_cast<string>(m["BgpPeerId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateBgpPeerResponseBody() = default;
};
class CreateBgpPeerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBgpPeerResponseBody> body{};

  CreateBgpPeerResponse() {}

  explicit CreateBgpPeerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBgpPeerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBgpPeerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBgpPeerResponse() = default;
};
class CreateCommonBandwidthPackageRequest : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> ISP{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> ratio{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> securityProtectionTypes{};
  shared_ptr<string> zone{};

  CreateCommonBandwidthPackageRequest() {}

  explicit CreateCommonBandwidthPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ratio) {
      res["Ratio"] = boost::any(*ratio);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityProtectionTypes) {
      res["SecurityProtectionTypes"] = boost::any(*securityProtectionTypes);
    }
    if (zone) {
      res["Zone"] = boost::any(*zone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Ratio") != m.end() && !m["Ratio"].empty()) {
      ratio = make_shared<long>(boost::any_cast<long>(m["Ratio"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityProtectionTypes") != m.end() && !m["SecurityProtectionTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityProtectionTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityProtectionTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityProtectionTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Zone") != m.end() && !m["Zone"].empty()) {
      zone = make_shared<string>(boost::any_cast<string>(m["Zone"]));
    }
  }


  virtual ~CreateCommonBandwidthPackageRequest() = default;
};
class CreateCommonBandwidthPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};

  CreateCommonBandwidthPackageResponseBody() {}

  explicit CreateCommonBandwidthPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateCommonBandwidthPackageResponseBody() = default;
};
class CreateCommonBandwidthPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCommonBandwidthPackageResponseBody> body{};

  CreateCommonBandwidthPackageResponse() {}

  explicit CreateCommonBandwidthPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCommonBandwidthPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCommonBandwidthPackageResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCommonBandwidthPackageResponse() = default;
};
class CreateCustomerGatewayRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateCustomerGatewayRequestTags() {}

  explicit CreateCustomerGatewayRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateCustomerGatewayRequestTags() = default;
};
class CreateCustomerGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> asn{};
  shared_ptr<string> authKey{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateCustomerGatewayRequestTags>> tags{};

  CreateCustomerGatewayRequest() {}

  explicit CreateCustomerGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asn) {
      res["Asn"] = boost::any(*asn);
    }
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asn") != m.end() && !m["Asn"].empty()) {
      asn = make_shared<string>(boost::any_cast<string>(m["Asn"]));
    }
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreateCustomerGatewayRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCustomerGatewayRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateCustomerGatewayRequestTags>>(expect1);
      }
    }
  }


  virtual ~CreateCustomerGatewayRequest() = default;
};
class CreateCustomerGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> customerGatewayId{};
  shared_ptr<string> description{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};

  CreateCustomerGatewayResponseBody() {}

  explicit CreateCustomerGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCustomerGatewayResponseBody() = default;
};
class CreateCustomerGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCustomerGatewayResponseBody> body{};

  CreateCustomerGatewayResponse() {}

  explicit CreateCustomerGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomerGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomerGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomerGatewayResponse() = default;
};
class CreateDefaultVSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> ipv6CidrBlock{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> zoneId{};

  CreateDefaultVSwitchRequest() {}

  explicit CreateDefaultVSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ipv6CidrBlock) {
      res["Ipv6CidrBlock"] = boost::any(*ipv6CidrBlock);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Ipv6CidrBlock") != m.end() && !m["Ipv6CidrBlock"].empty()) {
      ipv6CidrBlock = make_shared<long>(boost::any_cast<long>(m["Ipv6CidrBlock"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateDefaultVSwitchRequest() = default;
};
class CreateDefaultVSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vSwitchId{};

  CreateDefaultVSwitchResponseBody() {}

  explicit CreateDefaultVSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateDefaultVSwitchResponseBody() = default;
};
class CreateDefaultVSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDefaultVSwitchResponseBody> body{};

  CreateDefaultVSwitchResponse() {}

  explicit CreateDefaultVSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDefaultVSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDefaultVSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDefaultVSwitchResponse() = default;
};
class CreateDefaultVpcRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> enableIpv6{};
  shared_ptr<string> ipv6CidrBlock{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateDefaultVpcRequest() {}

  explicit CreateDefaultVpcRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (enableIpv6) {
      res["EnableIpv6"] = boost::any(*enableIpv6);
    }
    if (ipv6CidrBlock) {
      res["Ipv6CidrBlock"] = boost::any(*ipv6CidrBlock);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EnableIpv6") != m.end() && !m["EnableIpv6"].empty()) {
      enableIpv6 = make_shared<bool>(boost::any_cast<bool>(m["EnableIpv6"]));
    }
    if (m.find("Ipv6CidrBlock") != m.end() && !m["Ipv6CidrBlock"].empty()) {
      ipv6CidrBlock = make_shared<string>(boost::any_cast<string>(m["Ipv6CidrBlock"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateDefaultVpcRequest() = default;
};
class CreateDefaultVpcResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> VRouterId{};
  shared_ptr<string> vpcId{};

  CreateDefaultVpcResponseBody() {}

  explicit CreateDefaultVpcResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (VRouterId) {
      res["VRouterId"] = boost::any(*VRouterId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("VRouterId") != m.end() && !m["VRouterId"].empty()) {
      VRouterId = make_shared<string>(boost::any_cast<string>(m["VRouterId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreateDefaultVpcResponseBody() = default;
};
class CreateDefaultVpcResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDefaultVpcResponseBody> body{};

  CreateDefaultVpcResponse() {}

  explicit CreateDefaultVpcResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDefaultVpcResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDefaultVpcResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDefaultVpcResponse() = default;
};
class CreateDhcpOptionsSetRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateDhcpOptionsSetRequestTag() {}

  explicit CreateDhcpOptionsSetRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDhcpOptionsSetRequestTag() = default;
};
class CreateDhcpOptionsSetRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> dhcpOptionsSetDescription{};
  shared_ptr<string> dhcpOptionsSetName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainNameServers{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ipv6LeaseTime{};
  shared_ptr<string> leaseTime{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateDhcpOptionsSetRequestTag>> tag{};

  CreateDhcpOptionsSetRequest() {}

  explicit CreateDhcpOptionsSetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dhcpOptionsSetDescription) {
      res["DhcpOptionsSetDescription"] = boost::any(*dhcpOptionsSetDescription);
    }
    if (dhcpOptionsSetName) {
      res["DhcpOptionsSetName"] = boost::any(*dhcpOptionsSetName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainNameServers) {
      res["DomainNameServers"] = boost::any(*domainNameServers);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ipv6LeaseTime) {
      res["Ipv6LeaseTime"] = boost::any(*ipv6LeaseTime);
    }
    if (leaseTime) {
      res["LeaseTime"] = boost::any(*leaseTime);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DhcpOptionsSetDescription") != m.end() && !m["DhcpOptionsSetDescription"].empty()) {
      dhcpOptionsSetDescription = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetDescription"]));
    }
    if (m.find("DhcpOptionsSetName") != m.end() && !m["DhcpOptionsSetName"].empty()) {
      dhcpOptionsSetName = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainNameServers") != m.end() && !m["DomainNameServers"].empty()) {
      domainNameServers = make_shared<string>(boost::any_cast<string>(m["DomainNameServers"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("Ipv6LeaseTime") != m.end() && !m["Ipv6LeaseTime"].empty()) {
      ipv6LeaseTime = make_shared<string>(boost::any_cast<string>(m["Ipv6LeaseTime"]));
    }
    if (m.find("LeaseTime") != m.end() && !m["LeaseTime"].empty()) {
      leaseTime = make_shared<string>(boost::any_cast<string>(m["LeaseTime"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateDhcpOptionsSetRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDhcpOptionsSetRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateDhcpOptionsSetRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateDhcpOptionsSetRequest() = default;
};
class CreateDhcpOptionsSetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dhcpOptionsSetId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};

  CreateDhcpOptionsSetResponseBody() {}

  explicit CreateDhcpOptionsSetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dhcpOptionsSetId) {
      res["DhcpOptionsSetId"] = boost::any(*dhcpOptionsSetId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DhcpOptionsSetId") != m.end() && !m["DhcpOptionsSetId"].empty()) {
      dhcpOptionsSetId = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateDhcpOptionsSetResponseBody() = default;
};
class CreateDhcpOptionsSetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDhcpOptionsSetResponseBody> body{};

  CreateDhcpOptionsSetResponse() {}

  explicit CreateDhcpOptionsSetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDhcpOptionsSetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDhcpOptionsSetResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDhcpOptionsSetResponse() = default;
};
class CreateExpressCloudConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> contactMail{};
  shared_ptr<string> contactTel{};
  shared_ptr<string> description{};
  shared_ptr<string> IDCardNo{};
  shared_ptr<string> idcSP{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> peerCity{};
  shared_ptr<string> peerLocation{};
  shared_ptr<string> portType{};
  shared_ptr<string> redundantEccId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateExpressCloudConnectionRequest() {}

  explicit CreateExpressCloudConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (contactMail) {
      res["ContactMail"] = boost::any(*contactMail);
    }
    if (contactTel) {
      res["ContactTel"] = boost::any(*contactTel);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (IDCardNo) {
      res["IDCardNo"] = boost::any(*IDCardNo);
    }
    if (idcSP) {
      res["IdcSP"] = boost::any(*idcSP);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (peerCity) {
      res["PeerCity"] = boost::any(*peerCity);
    }
    if (peerLocation) {
      res["PeerLocation"] = boost::any(*peerLocation);
    }
    if (portType) {
      res["PortType"] = boost::any(*portType);
    }
    if (redundantEccId) {
      res["RedundantEccId"] = boost::any(*redundantEccId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("ContactMail") != m.end() && !m["ContactMail"].empty()) {
      contactMail = make_shared<string>(boost::any_cast<string>(m["ContactMail"]));
    }
    if (m.find("ContactTel") != m.end() && !m["ContactTel"].empty()) {
      contactTel = make_shared<string>(boost::any_cast<string>(m["ContactTel"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IDCardNo") != m.end() && !m["IDCardNo"].empty()) {
      IDCardNo = make_shared<string>(boost::any_cast<string>(m["IDCardNo"]));
    }
    if (m.find("IdcSP") != m.end() && !m["IdcSP"].empty()) {
      idcSP = make_shared<string>(boost::any_cast<string>(m["IdcSP"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PeerCity") != m.end() && !m["PeerCity"].empty()) {
      peerCity = make_shared<string>(boost::any_cast<string>(m["PeerCity"]));
    }
    if (m.find("PeerLocation") != m.end() && !m["PeerLocation"].empty()) {
      peerLocation = make_shared<string>(boost::any_cast<string>(m["PeerLocation"]));
    }
    if (m.find("PortType") != m.end() && !m["PortType"].empty()) {
      portType = make_shared<string>(boost::any_cast<string>(m["PortType"]));
    }
    if (m.find("RedundantEccId") != m.end() && !m["RedundantEccId"].empty()) {
      redundantEccId = make_shared<string>(boost::any_cast<string>(m["RedundantEccId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateExpressCloudConnectionRequest() = default;
};
class CreateExpressCloudConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eccId{};
  shared_ptr<string> requestId{};

  CreateExpressCloudConnectionResponseBody() {}

  explicit CreateExpressCloudConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eccId) {
      res["EccId"] = boost::any(*eccId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EccId") != m.end() && !m["EccId"].empty()) {
      eccId = make_shared<string>(boost::any_cast<string>(m["EccId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateExpressCloudConnectionResponseBody() = default;
};
class CreateExpressCloudConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateExpressCloudConnectionResponseBody> body{};

  CreateExpressCloudConnectionResponse() {}

  explicit CreateExpressCloudConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateExpressCloudConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateExpressCloudConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateExpressCloudConnectionResponse() = default;
};
class CreateExpressConnectTrafficQosRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> qosDescription{};
  shared_ptr<string> qosName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};

  CreateExpressConnectTrafficQosRequest() {}

  explicit CreateExpressConnectTrafficQosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (qosDescription) {
      res["QosDescription"] = boost::any(*qosDescription);
    }
    if (qosName) {
      res["QosName"] = boost::any(*qosName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QosDescription") != m.end() && !m["QosDescription"].empty()) {
      qosDescription = make_shared<string>(boost::any_cast<string>(m["QosDescription"]));
    }
    if (m.find("QosName") != m.end() && !m["QosName"].empty()) {
      qosName = make_shared<string>(boost::any_cast<string>(m["QosName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~CreateExpressConnectTrafficQosRequest() = default;
};
class CreateExpressConnectTrafficQosResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> qosId{};
  shared_ptr<string> requestId{};

  CreateExpressConnectTrafficQosResponseBody() {}

  explicit CreateExpressConnectTrafficQosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateExpressConnectTrafficQosResponseBody() = default;
};
class CreateExpressConnectTrafficQosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateExpressConnectTrafficQosResponseBody> body{};

  CreateExpressConnectTrafficQosResponse() {}

  explicit CreateExpressConnectTrafficQosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateExpressConnectTrafficQosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateExpressConnectTrafficQosResponseBody>(model1);
      }
    }
  }


  virtual ~CreateExpressConnectTrafficQosResponse() = default;
};
class CreateExpressConnectTrafficQosQueueRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthPercent{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> qosId{};
  shared_ptr<string> queueDescription{};
  shared_ptr<string> queueName{};
  shared_ptr<string> queueType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};

  CreateExpressConnectTrafficQosQueueRequest() {}

  explicit CreateExpressConnectTrafficQosQueueRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPercent) {
      res["BandwidthPercent"] = boost::any(*bandwidthPercent);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (queueDescription) {
      res["QueueDescription"] = boost::any(*queueDescription);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (queueType) {
      res["QueueType"] = boost::any(*queueType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPercent") != m.end() && !m["BandwidthPercent"].empty()) {
      bandwidthPercent = make_shared<string>(boost::any_cast<string>(m["BandwidthPercent"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QueueDescription") != m.end() && !m["QueueDescription"].empty()) {
      queueDescription = make_shared<string>(boost::any_cast<string>(m["QueueDescription"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("QueueType") != m.end() && !m["QueueType"].empty()) {
      queueType = make_shared<string>(boost::any_cast<string>(m["QueueType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~CreateExpressConnectTrafficQosQueueRequest() = default;
};
class CreateExpressConnectTrafficQosQueueResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> qosId{};
  shared_ptr<string> queueId{};
  shared_ptr<string> requestId{};

  CreateExpressConnectTrafficQosQueueResponseBody() {}

  explicit CreateExpressConnectTrafficQosQueueResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateExpressConnectTrafficQosQueueResponseBody() = default;
};
class CreateExpressConnectTrafficQosQueueResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateExpressConnectTrafficQosQueueResponseBody> body{};

  CreateExpressConnectTrafficQosQueueResponse() {}

  explicit CreateExpressConnectTrafficQosQueueResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateExpressConnectTrafficQosQueueResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateExpressConnectTrafficQosQueueResponseBody>(model1);
      }
    }
  }


  virtual ~CreateExpressConnectTrafficQosQueueResponse() = default;
};
class CreateExpressConnectTrafficQosRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> dstCidr{};
  shared_ptr<string> dstIPv6Cidr{};
  shared_ptr<string> dstPortRange{};
  shared_ptr<long> matchDscp{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> priority{};
  shared_ptr<string> protocol{};
  shared_ptr<string> qosId{};
  shared_ptr<string> queueId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> remarkingDscp{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> ruleDescription{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> srcCidr{};
  shared_ptr<string> srcIPv6Cidr{};
  shared_ptr<string> srcPortRange{};

  CreateExpressConnectTrafficQosRuleRequest() {}

  explicit CreateExpressConnectTrafficQosRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dstCidr) {
      res["DstCidr"] = boost::any(*dstCidr);
    }
    if (dstIPv6Cidr) {
      res["DstIPv6Cidr"] = boost::any(*dstIPv6Cidr);
    }
    if (dstPortRange) {
      res["DstPortRange"] = boost::any(*dstPortRange);
    }
    if (matchDscp) {
      res["MatchDscp"] = boost::any(*matchDscp);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (remarkingDscp) {
      res["RemarkingDscp"] = boost::any(*remarkingDscp);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (ruleDescription) {
      res["RuleDescription"] = boost::any(*ruleDescription);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (srcCidr) {
      res["SrcCidr"] = boost::any(*srcCidr);
    }
    if (srcIPv6Cidr) {
      res["SrcIPv6Cidr"] = boost::any(*srcIPv6Cidr);
    }
    if (srcPortRange) {
      res["SrcPortRange"] = boost::any(*srcPortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DstCidr") != m.end() && !m["DstCidr"].empty()) {
      dstCidr = make_shared<string>(boost::any_cast<string>(m["DstCidr"]));
    }
    if (m.find("DstIPv6Cidr") != m.end() && !m["DstIPv6Cidr"].empty()) {
      dstIPv6Cidr = make_shared<string>(boost::any_cast<string>(m["DstIPv6Cidr"]));
    }
    if (m.find("DstPortRange") != m.end() && !m["DstPortRange"].empty()) {
      dstPortRange = make_shared<string>(boost::any_cast<string>(m["DstPortRange"]));
    }
    if (m.find("MatchDscp") != m.end() && !m["MatchDscp"].empty()) {
      matchDscp = make_shared<long>(boost::any_cast<long>(m["MatchDscp"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemarkingDscp") != m.end() && !m["RemarkingDscp"].empty()) {
      remarkingDscp = make_shared<long>(boost::any_cast<long>(m["RemarkingDscp"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("RuleDescription") != m.end() && !m["RuleDescription"].empty()) {
      ruleDescription = make_shared<string>(boost::any_cast<string>(m["RuleDescription"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SrcCidr") != m.end() && !m["SrcCidr"].empty()) {
      srcCidr = make_shared<string>(boost::any_cast<string>(m["SrcCidr"]));
    }
    if (m.find("SrcIPv6Cidr") != m.end() && !m["SrcIPv6Cidr"].empty()) {
      srcIPv6Cidr = make_shared<string>(boost::any_cast<string>(m["SrcIPv6Cidr"]));
    }
    if (m.find("SrcPortRange") != m.end() && !m["SrcPortRange"].empty()) {
      srcPortRange = make_shared<string>(boost::any_cast<string>(m["SrcPortRange"]));
    }
  }


  virtual ~CreateExpressConnectTrafficQosRuleRequest() = default;
};
class CreateExpressConnectTrafficQosRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> qosId{};
  shared_ptr<string> queueId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> ruleId{};

  CreateExpressConnectTrafficQosRuleResponseBody() {}

  explicit CreateExpressConnectTrafficQosRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~CreateExpressConnectTrafficQosRuleResponseBody() = default;
};
class CreateExpressConnectTrafficQosRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateExpressConnectTrafficQosRuleResponseBody> body{};

  CreateExpressConnectTrafficQosRuleResponse() {}

  explicit CreateExpressConnectTrafficQosRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateExpressConnectTrafficQosRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateExpressConnectTrafficQosRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateExpressConnectTrafficQosRuleResponse() = default;
};
class CreateFailoverTestJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<long> jobDuration{};
  shared_ptr<string> jobType{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceType{};

  CreateFailoverTestJobRequest() {}

  explicit CreateFailoverTestJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (jobDuration) {
      res["JobDuration"] = boost::any(*jobDuration);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("JobDuration") != m.end() && !m["JobDuration"].empty()) {
      jobDuration = make_shared<long>(boost::any_cast<long>(m["JobDuration"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~CreateFailoverTestJobRequest() = default;
};
class CreateFailoverTestJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  CreateFailoverTestJobResponseBody() {}

  explicit CreateFailoverTestJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFailoverTestJobResponseBody() = default;
};
class CreateFailoverTestJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFailoverTestJobResponseBody> body{};

  CreateFailoverTestJobResponse() {}

  explicit CreateFailoverTestJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFailoverTestJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFailoverTestJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFailoverTestJobResponse() = default;
};
class CreateFlowLogRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateFlowLogRequestTag() {}

  explicit CreateFlowLogRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateFlowLogRequestTag() = default;
};
class CreateFlowLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> aggregationInterval{};
  shared_ptr<string> description{};
  shared_ptr<string> flowLogName{};
  shared_ptr<string> logStoreName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<CreateFlowLogRequestTag>> tag{};
  shared_ptr<vector<string>> trafficPath{};
  shared_ptr<string> trafficType{};

  CreateFlowLogRequest() {}

  explicit CreateFlowLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregationInterval) {
      res["AggregationInterval"] = boost::any(*aggregationInterval);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (flowLogName) {
      res["FlowLogName"] = boost::any(*flowLogName);
    }
    if (logStoreName) {
      res["LogStoreName"] = boost::any(*logStoreName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (trafficPath) {
      res["TrafficPath"] = boost::any(*trafficPath);
    }
    if (trafficType) {
      res["TrafficType"] = boost::any(*trafficType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregationInterval") != m.end() && !m["AggregationInterval"].empty()) {
      aggregationInterval = make_shared<long>(boost::any_cast<long>(m["AggregationInterval"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FlowLogName") != m.end() && !m["FlowLogName"].empty()) {
      flowLogName = make_shared<string>(boost::any_cast<string>(m["FlowLogName"]));
    }
    if (m.find("LogStoreName") != m.end() && !m["LogStoreName"].empty()) {
      logStoreName = make_shared<string>(boost::any_cast<string>(m["LogStoreName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateFlowLogRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateFlowLogRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateFlowLogRequestTag>>(expect1);
      }
    }
    if (m.find("TrafficPath") != m.end() && !m["TrafficPath"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TrafficPath"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TrafficPath"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      trafficPath = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TrafficType") != m.end() && !m["TrafficType"].empty()) {
      trafficType = make_shared<string>(boost::any_cast<string>(m["TrafficType"]));
    }
  }


  virtual ~CreateFlowLogRequest() = default;
};
class CreateFlowLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> flowLogId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> success{};

  CreateFlowLogResponseBody() {}

  explicit CreateFlowLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowLogId) {
      res["FlowLogId"] = boost::any(*flowLogId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowLogId") != m.end() && !m["FlowLogId"].empty()) {
      flowLogId = make_shared<string>(boost::any_cast<string>(m["FlowLogId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateFlowLogResponseBody() = default;
};
class CreateFlowLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFlowLogResponseBody> body{};

  CreateFlowLogResponse() {}

  explicit CreateFlowLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowLogResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowLogResponse() = default;
};
class CreateForwardEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> externalIp{};
  shared_ptr<string> externalPort{};
  shared_ptr<string> forwardEntryName{};
  shared_ptr<string> forwardTableId{};
  shared_ptr<string> internalIp{};
  shared_ptr<string> internalPort{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<bool> portBreak{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateForwardEntryRequest() {}

  explicit CreateForwardEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (externalIp) {
      res["ExternalIp"] = boost::any(*externalIp);
    }
    if (externalPort) {
      res["ExternalPort"] = boost::any(*externalPort);
    }
    if (forwardEntryName) {
      res["ForwardEntryName"] = boost::any(*forwardEntryName);
    }
    if (forwardTableId) {
      res["ForwardTableId"] = boost::any(*forwardTableId);
    }
    if (internalIp) {
      res["InternalIp"] = boost::any(*internalIp);
    }
    if (internalPort) {
      res["InternalPort"] = boost::any(*internalPort);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (portBreak) {
      res["PortBreak"] = boost::any(*portBreak);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ExternalIp") != m.end() && !m["ExternalIp"].empty()) {
      externalIp = make_shared<string>(boost::any_cast<string>(m["ExternalIp"]));
    }
    if (m.find("ExternalPort") != m.end() && !m["ExternalPort"].empty()) {
      externalPort = make_shared<string>(boost::any_cast<string>(m["ExternalPort"]));
    }
    if (m.find("ForwardEntryName") != m.end() && !m["ForwardEntryName"].empty()) {
      forwardEntryName = make_shared<string>(boost::any_cast<string>(m["ForwardEntryName"]));
    }
    if (m.find("ForwardTableId") != m.end() && !m["ForwardTableId"].empty()) {
      forwardTableId = make_shared<string>(boost::any_cast<string>(m["ForwardTableId"]));
    }
    if (m.find("InternalIp") != m.end() && !m["InternalIp"].empty()) {
      internalIp = make_shared<string>(boost::any_cast<string>(m["InternalIp"]));
    }
    if (m.find("InternalPort") != m.end() && !m["InternalPort"].empty()) {
      internalPort = make_shared<string>(boost::any_cast<string>(m["InternalPort"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PortBreak") != m.end() && !m["PortBreak"].empty()) {
      portBreak = make_shared<bool>(boost::any_cast<bool>(m["PortBreak"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateForwardEntryRequest() = default;
};
class CreateForwardEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> forwardEntryId{};
  shared_ptr<string> requestId{};

  CreateForwardEntryResponseBody() {}

  explicit CreateForwardEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardEntryId) {
      res["ForwardEntryId"] = boost::any(*forwardEntryId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardEntryId") != m.end() && !m["ForwardEntryId"].empty()) {
      forwardEntryId = make_shared<string>(boost::any_cast<string>(m["ForwardEntryId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateForwardEntryResponseBody() = default;
};
class CreateForwardEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateForwardEntryResponseBody> body{};

  CreateForwardEntryResponse() {}

  explicit CreateForwardEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateForwardEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateForwardEntryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateForwardEntryResponse() = default;
};
class CreateFullNatEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessIp{};
  shared_ptr<string> accessPort{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> fullNatEntryDescription{};
  shared_ptr<string> fullNatEntryName{};
  shared_ptr<string> fullNatTableId{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> natIp{};
  shared_ptr<string> natIpPort{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateFullNatEntryRequest() {}

  explicit CreateFullNatEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessIp) {
      res["AccessIp"] = boost::any(*accessIp);
    }
    if (accessPort) {
      res["AccessPort"] = boost::any(*accessPort);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (fullNatEntryDescription) {
      res["FullNatEntryDescription"] = boost::any(*fullNatEntryDescription);
    }
    if (fullNatEntryName) {
      res["FullNatEntryName"] = boost::any(*fullNatEntryName);
    }
    if (fullNatTableId) {
      res["FullNatTableId"] = boost::any(*fullNatTableId);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (natIp) {
      res["NatIp"] = boost::any(*natIp);
    }
    if (natIpPort) {
      res["NatIpPort"] = boost::any(*natIpPort);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessIp") != m.end() && !m["AccessIp"].empty()) {
      accessIp = make_shared<string>(boost::any_cast<string>(m["AccessIp"]));
    }
    if (m.find("AccessPort") != m.end() && !m["AccessPort"].empty()) {
      accessPort = make_shared<string>(boost::any_cast<string>(m["AccessPort"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("FullNatEntryDescription") != m.end() && !m["FullNatEntryDescription"].empty()) {
      fullNatEntryDescription = make_shared<string>(boost::any_cast<string>(m["FullNatEntryDescription"]));
    }
    if (m.find("FullNatEntryName") != m.end() && !m["FullNatEntryName"].empty()) {
      fullNatEntryName = make_shared<string>(boost::any_cast<string>(m["FullNatEntryName"]));
    }
    if (m.find("FullNatTableId") != m.end() && !m["FullNatTableId"].empty()) {
      fullNatTableId = make_shared<string>(boost::any_cast<string>(m["FullNatTableId"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("NatIp") != m.end() && !m["NatIp"].empty()) {
      natIp = make_shared<string>(boost::any_cast<string>(m["NatIp"]));
    }
    if (m.find("NatIpPort") != m.end() && !m["NatIpPort"].empty()) {
      natIpPort = make_shared<string>(boost::any_cast<string>(m["NatIpPort"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateFullNatEntryRequest() = default;
};
class CreateFullNatEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> fullNatEntryId{};
  shared_ptr<string> requestId{};

  CreateFullNatEntryResponseBody() {}

  explicit CreateFullNatEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fullNatEntryId) {
      res["FullNatEntryId"] = boost::any(*fullNatEntryId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FullNatEntryId") != m.end() && !m["FullNatEntryId"].empty()) {
      fullNatEntryId = make_shared<string>(boost::any_cast<string>(m["FullNatEntryId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFullNatEntryResponseBody() = default;
};
class CreateFullNatEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFullNatEntryResponseBody> body{};

  CreateFullNatEntryResponse() {}

  explicit CreateFullNatEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFullNatEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFullNatEntryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFullNatEntryResponse() = default;
};
class CreateGlobalAccelerationInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidth{};
  shared_ptr<string> bandwidthType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serviceLocation{};

  CreateGlobalAccelerationInstanceRequest() {}

  explicit CreateGlobalAccelerationInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (bandwidthType) {
      res["BandwidthType"] = boost::any(*bandwidthType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceLocation) {
      res["ServiceLocation"] = boost::any(*serviceLocation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("BandwidthType") != m.end() && !m["BandwidthType"].empty()) {
      bandwidthType = make_shared<string>(boost::any_cast<string>(m["BandwidthType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceLocation") != m.end() && !m["ServiceLocation"].empty()) {
      serviceLocation = make_shared<string>(boost::any_cast<string>(m["ServiceLocation"]));
    }
  }


  virtual ~CreateGlobalAccelerationInstanceRequest() = default;
};
class CreateGlobalAccelerationInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> globalAccelerationInstanceId{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> requestId{};

  CreateGlobalAccelerationInstanceResponseBody() {}

  explicit CreateGlobalAccelerationInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalAccelerationInstanceId) {
      res["GlobalAccelerationInstanceId"] = boost::any(*globalAccelerationInstanceId);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalAccelerationInstanceId") != m.end() && !m["GlobalAccelerationInstanceId"].empty()) {
      globalAccelerationInstanceId = make_shared<string>(boost::any_cast<string>(m["GlobalAccelerationInstanceId"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateGlobalAccelerationInstanceResponseBody() = default;
};
class CreateGlobalAccelerationInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateGlobalAccelerationInstanceResponseBody> body{};

  CreateGlobalAccelerationInstanceResponse() {}

  explicit CreateGlobalAccelerationInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateGlobalAccelerationInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateGlobalAccelerationInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateGlobalAccelerationInstanceResponse() = default;
};
class CreateHaVipRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateHaVipRequestTag() {}

  explicit CreateHaVipRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateHaVipRequestTag() = default;
};
class CreateHaVipRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateHaVipRequestTag>> tag{};
  shared_ptr<string> vSwitchId{};

  CreateHaVipRequest() {}

  explicit CreateHaVipRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateHaVipRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateHaVipRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateHaVipRequestTag>>(expect1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateHaVipRequest() = default;
};
class CreateHaVipResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> haVipId{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> requestId{};

  CreateHaVipResponseBody() {}

  explicit CreateHaVipResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (haVipId) {
      res["HaVipId"] = boost::any(*haVipId);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HaVipId") != m.end() && !m["HaVipId"].empty()) {
      haVipId = make_shared<string>(boost::any_cast<string>(m["HaVipId"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateHaVipResponseBody() = default;
};
class CreateHaVipResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateHaVipResponseBody> body{};

  CreateHaVipResponse() {}

  explicit CreateHaVipResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHaVipResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHaVipResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHaVipResponse() = default;
};
class CreateHighReliablePhysicalConnectionRequestApList : public Darabonba::Model {
public:
  shared_ptr<string> accessPointId{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> circuitCode{};
  shared_ptr<string> description{};
  shared_ptr<string> lineOperator{};
  shared_ptr<string> name{};
  shared_ptr<string> peerLocation{};
  shared_ptr<long> portNum{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  CreateHighReliablePhysicalConnectionRequestApList() {}

  explicit CreateHighReliablePhysicalConnectionRequestApList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (circuitCode) {
      res["CircuitCode"] = boost::any(*circuitCode);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (lineOperator) {
      res["LineOperator"] = boost::any(*lineOperator);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (peerLocation) {
      res["PeerLocation"] = boost::any(*peerLocation);
    }
    if (portNum) {
      res["PortNum"] = boost::any(*portNum);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<string>(boost::any_cast<string>(m["AccessPointId"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("CircuitCode") != m.end() && !m["CircuitCode"].empty()) {
      circuitCode = make_shared<string>(boost::any_cast<string>(m["CircuitCode"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("LineOperator") != m.end() && !m["LineOperator"].empty()) {
      lineOperator = make_shared<string>(boost::any_cast<string>(m["LineOperator"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PeerLocation") != m.end() && !m["PeerLocation"].empty()) {
      peerLocation = make_shared<string>(boost::any_cast<string>(m["PeerLocation"]));
    }
    if (m.find("PortNum") != m.end() && !m["PortNum"].empty()) {
      portNum = make_shared<long>(boost::any_cast<long>(m["PortNum"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateHighReliablePhysicalConnectionRequestApList() = default;
};
class CreateHighReliablePhysicalConnectionRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateHighReliablePhysicalConnectionRequestTag() {}

  explicit CreateHighReliablePhysicalConnectionRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateHighReliablePhysicalConnectionRequestTag() = default;
};
class CreateHighReliablePhysicalConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<vector<CreateHighReliablePhysicalConnectionRequestApList>> apList{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> deviceAdvancedCapacity{};
  shared_ptr<string> dryRun{};
  shared_ptr<string> highReliableType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> portType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateHighReliablePhysicalConnectionRequestTag>> tag{};

  CreateHighReliablePhysicalConnectionRequest() {}

  explicit CreateHighReliablePhysicalConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (apList) {
      vector<boost::any> temp1;
      for(auto item1:*apList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApList"] = boost::any(temp1);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (deviceAdvancedCapacity) {
      res["DeviceAdvancedCapacity"] = boost::any(*deviceAdvancedCapacity);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (highReliableType) {
      res["HighReliableType"] = boost::any(*highReliableType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (portType) {
      res["PortType"] = boost::any(*portType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ApList") != m.end() && !m["ApList"].empty()) {
      if (typeid(vector<boost::any>) == m["ApList"].type()) {
        vector<CreateHighReliablePhysicalConnectionRequestApList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateHighReliablePhysicalConnectionRequestApList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apList = make_shared<vector<CreateHighReliablePhysicalConnectionRequestApList>>(expect1);
      }
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DeviceAdvancedCapacity") != m.end() && !m["DeviceAdvancedCapacity"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceAdvancedCapacity"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceAdvancedCapacity"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceAdvancedCapacity = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<string>(boost::any_cast<string>(m["DryRun"]));
    }
    if (m.find("HighReliableType") != m.end() && !m["HighReliableType"].empty()) {
      highReliableType = make_shared<string>(boost::any_cast<string>(m["HighReliableType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PortType") != m.end() && !m["PortType"].empty()) {
      portType = make_shared<string>(boost::any_cast<string>(m["PortType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateHighReliablePhysicalConnectionRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateHighReliablePhysicalConnectionRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateHighReliablePhysicalConnectionRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateHighReliablePhysicalConnectionRequest() = default;
};
class CreateHighReliablePhysicalConnectionResponseBodyErrorInfoListErrorInfoList : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> instanceId{};

  CreateHighReliablePhysicalConnectionResponseBodyErrorInfoListErrorInfoList() {}

  explicit CreateHighReliablePhysicalConnectionResponseBodyErrorInfoListErrorInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateHighReliablePhysicalConnectionResponseBodyErrorInfoListErrorInfoList() = default;
};
class CreateHighReliablePhysicalConnectionResponseBodyErrorInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<CreateHighReliablePhysicalConnectionResponseBodyErrorInfoListErrorInfoList>> errorInfoList{};

  CreateHighReliablePhysicalConnectionResponseBodyErrorInfoList() {}

  explicit CreateHighReliablePhysicalConnectionResponseBodyErrorInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*errorInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["errorInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorInfoList") != m.end() && !m["errorInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["errorInfoList"].type()) {
        vector<CreateHighReliablePhysicalConnectionResponseBodyErrorInfoListErrorInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["errorInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateHighReliablePhysicalConnectionResponseBodyErrorInfoListErrorInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorInfoList = make_shared<vector<CreateHighReliablePhysicalConnectionResponseBodyErrorInfoListErrorInfoList>>(expect1);
      }
    }
  }


  virtual ~CreateHighReliablePhysicalConnectionResponseBodyErrorInfoList() = default;
};
class CreateHighReliablePhysicalConnectionResponseBodyPhysicalConnectionListPhysicalConnectionList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionNo{};

  CreateHighReliablePhysicalConnectionResponseBodyPhysicalConnectionListPhysicalConnectionList() {}

  explicit CreateHighReliablePhysicalConnectionResponseBodyPhysicalConnectionListPhysicalConnectionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionNo) {
      res["RegionNo"] = boost::any(*regionNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionNo") != m.end() && !m["RegionNo"].empty()) {
      regionNo = make_shared<string>(boost::any_cast<string>(m["RegionNo"]));
    }
  }


  virtual ~CreateHighReliablePhysicalConnectionResponseBodyPhysicalConnectionListPhysicalConnectionList() = default;
};
class CreateHighReliablePhysicalConnectionResponseBodyPhysicalConnectionList : public Darabonba::Model {
public:
  shared_ptr<vector<CreateHighReliablePhysicalConnectionResponseBodyPhysicalConnectionListPhysicalConnectionList>> physicalConnectionList{};

  CreateHighReliablePhysicalConnectionResponseBodyPhysicalConnectionList() {}

  explicit CreateHighReliablePhysicalConnectionResponseBodyPhysicalConnectionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (physicalConnectionList) {
      vector<boost::any> temp1;
      for(auto item1:*physicalConnectionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["physicalConnectionList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("physicalConnectionList") != m.end() && !m["physicalConnectionList"].empty()) {
      if (typeid(vector<boost::any>) == m["physicalConnectionList"].type()) {
        vector<CreateHighReliablePhysicalConnectionResponseBodyPhysicalConnectionListPhysicalConnectionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["physicalConnectionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateHighReliablePhysicalConnectionResponseBodyPhysicalConnectionListPhysicalConnectionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        physicalConnectionList = make_shared<vector<CreateHighReliablePhysicalConnectionResponseBodyPhysicalConnectionListPhysicalConnectionList>>(expect1);
      }
    }
  }


  virtual ~CreateHighReliablePhysicalConnectionResponseBodyPhysicalConnectionList() = default;
};
class CreateHighReliablePhysicalConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateHighReliablePhysicalConnectionResponseBodyErrorInfoList> errorInfoList{};
  shared_ptr<CreateHighReliablePhysicalConnectionResponseBodyPhysicalConnectionList> physicalConnectionList{};
  shared_ptr<string> requestId{};

  CreateHighReliablePhysicalConnectionResponseBody() {}

  explicit CreateHighReliablePhysicalConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorInfoList) {
      res["ErrorInfoList"] = errorInfoList ? boost::any(errorInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (physicalConnectionList) {
      res["PhysicalConnectionList"] = physicalConnectionList ? boost::any(physicalConnectionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorInfoList") != m.end() && !m["ErrorInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorInfoList"].type()) {
        CreateHighReliablePhysicalConnectionResponseBodyErrorInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorInfoList"]));
        errorInfoList = make_shared<CreateHighReliablePhysicalConnectionResponseBodyErrorInfoList>(model1);
      }
    }
    if (m.find("PhysicalConnectionList") != m.end() && !m["PhysicalConnectionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PhysicalConnectionList"].type()) {
        CreateHighReliablePhysicalConnectionResponseBodyPhysicalConnectionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PhysicalConnectionList"]));
        physicalConnectionList = make_shared<CreateHighReliablePhysicalConnectionResponseBodyPhysicalConnectionList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateHighReliablePhysicalConnectionResponseBody() = default;
};
class CreateHighReliablePhysicalConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateHighReliablePhysicalConnectionResponseBody> body{};

  CreateHighReliablePhysicalConnectionResponse() {}

  explicit CreateHighReliablePhysicalConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHighReliablePhysicalConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHighReliablePhysicalConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHighReliablePhysicalConnectionResponse() = default;
};
class CreateIPv6TranslatorRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> duration{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> payType{};
  shared_ptr<string> pricingCycle{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> spec{};

  CreateIPv6TranslatorRequest() {}

  explicit CreateIPv6TranslatorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (pricingCycle) {
      res["PricingCycle"] = boost::any(*pricingCycle);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("PricingCycle") != m.end() && !m["PricingCycle"].empty()) {
      pricingCycle = make_shared<string>(boost::any_cast<string>(m["PricingCycle"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~CreateIPv6TranslatorRequest() = default;
};
class CreateIPv6TranslatorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ipv6TranslatorId{};
  shared_ptr<string> name{};
  shared_ptr<long> orderId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> spec{};

  CreateIPv6TranslatorResponseBody() {}

  explicit CreateIPv6TranslatorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6TranslatorId) {
      res["Ipv6TranslatorId"] = boost::any(*ipv6TranslatorId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6TranslatorId") != m.end() && !m["Ipv6TranslatorId"].empty()) {
      ipv6TranslatorId = make_shared<string>(boost::any_cast<string>(m["Ipv6TranslatorId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~CreateIPv6TranslatorResponseBody() = default;
};
class CreateIPv6TranslatorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIPv6TranslatorResponseBody> body{};

  CreateIPv6TranslatorResponse() {}

  explicit CreateIPv6TranslatorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIPv6TranslatorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIPv6TranslatorResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIPv6TranslatorResponse() = default;
};
class CreateIPv6TranslatorAclListRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclName{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateIPv6TranslatorAclListRequest() {}

  explicit CreateIPv6TranslatorAclListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclName) {
      res["AclName"] = boost::any(*aclName);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclName") != m.end() && !m["AclName"].empty()) {
      aclName = make_shared<string>(boost::any_cast<string>(m["AclName"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateIPv6TranslatorAclListRequest() = default;
};
class CreateIPv6TranslatorAclListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> requestId{};

  CreateIPv6TranslatorAclListResponseBody() {}

  explicit CreateIPv6TranslatorAclListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateIPv6TranslatorAclListResponseBody() = default;
};
class CreateIPv6TranslatorAclListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIPv6TranslatorAclListResponseBody> body{};

  CreateIPv6TranslatorAclListResponse() {}

  explicit CreateIPv6TranslatorAclListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIPv6TranslatorAclListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIPv6TranslatorAclListResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIPv6TranslatorAclListResponse() = default;
};
class CreateIPv6TranslatorEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> aclStatus{};
  shared_ptr<string> aclType{};
  shared_ptr<long> allocateIpv6Port{};
  shared_ptr<string> backendIpv4Addr{};
  shared_ptr<long> backendIpv4Port{};
  shared_ptr<long> entryBandwidth{};
  shared_ptr<string> entryDescription{};
  shared_ptr<string> entryName{};
  shared_ptr<string> ipv6TranslatorId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> transProtocol{};

  CreateIPv6TranslatorEntryRequest() {}

  explicit CreateIPv6TranslatorEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (aclStatus) {
      res["AclStatus"] = boost::any(*aclStatus);
    }
    if (aclType) {
      res["AclType"] = boost::any(*aclType);
    }
    if (allocateIpv6Port) {
      res["AllocateIpv6Port"] = boost::any(*allocateIpv6Port);
    }
    if (backendIpv4Addr) {
      res["BackendIpv4Addr"] = boost::any(*backendIpv4Addr);
    }
    if (backendIpv4Port) {
      res["BackendIpv4Port"] = boost::any(*backendIpv4Port);
    }
    if (entryBandwidth) {
      res["EntryBandwidth"] = boost::any(*entryBandwidth);
    }
    if (entryDescription) {
      res["EntryDescription"] = boost::any(*entryDescription);
    }
    if (entryName) {
      res["EntryName"] = boost::any(*entryName);
    }
    if (ipv6TranslatorId) {
      res["Ipv6TranslatorId"] = boost::any(*ipv6TranslatorId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (transProtocol) {
      res["TransProtocol"] = boost::any(*transProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AclStatus") != m.end() && !m["AclStatus"].empty()) {
      aclStatus = make_shared<string>(boost::any_cast<string>(m["AclStatus"]));
    }
    if (m.find("AclType") != m.end() && !m["AclType"].empty()) {
      aclType = make_shared<string>(boost::any_cast<string>(m["AclType"]));
    }
    if (m.find("AllocateIpv6Port") != m.end() && !m["AllocateIpv6Port"].empty()) {
      allocateIpv6Port = make_shared<long>(boost::any_cast<long>(m["AllocateIpv6Port"]));
    }
    if (m.find("BackendIpv4Addr") != m.end() && !m["BackendIpv4Addr"].empty()) {
      backendIpv4Addr = make_shared<string>(boost::any_cast<string>(m["BackendIpv4Addr"]));
    }
    if (m.find("BackendIpv4Port") != m.end() && !m["BackendIpv4Port"].empty()) {
      backendIpv4Port = make_shared<long>(boost::any_cast<long>(m["BackendIpv4Port"]));
    }
    if (m.find("EntryBandwidth") != m.end() && !m["EntryBandwidth"].empty()) {
      entryBandwidth = make_shared<long>(boost::any_cast<long>(m["EntryBandwidth"]));
    }
    if (m.find("EntryDescription") != m.end() && !m["EntryDescription"].empty()) {
      entryDescription = make_shared<string>(boost::any_cast<string>(m["EntryDescription"]));
    }
    if (m.find("EntryName") != m.end() && !m["EntryName"].empty()) {
      entryName = make_shared<string>(boost::any_cast<string>(m["EntryName"]));
    }
    if (m.find("Ipv6TranslatorId") != m.end() && !m["Ipv6TranslatorId"].empty()) {
      ipv6TranslatorId = make_shared<string>(boost::any_cast<string>(m["Ipv6TranslatorId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TransProtocol") != m.end() && !m["TransProtocol"].empty()) {
      transProtocol = make_shared<string>(boost::any_cast<string>(m["TransProtocol"]));
    }
  }


  virtual ~CreateIPv6TranslatorEntryRequest() = default;
};
class CreateIPv6TranslatorEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ipv6TranslatorEntryId{};
  shared_ptr<string> requestId{};

  CreateIPv6TranslatorEntryResponseBody() {}

  explicit CreateIPv6TranslatorEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6TranslatorEntryId) {
      res["Ipv6TranslatorEntryId"] = boost::any(*ipv6TranslatorEntryId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6TranslatorEntryId") != m.end() && !m["Ipv6TranslatorEntryId"].empty()) {
      ipv6TranslatorEntryId = make_shared<string>(boost::any_cast<string>(m["Ipv6TranslatorEntryId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateIPv6TranslatorEntryResponseBody() = default;
};
class CreateIPv6TranslatorEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIPv6TranslatorEntryResponseBody> body{};

  CreateIPv6TranslatorEntryResponse() {}

  explicit CreateIPv6TranslatorEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIPv6TranslatorEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIPv6TranslatorEntryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIPv6TranslatorEntryResponse() = default;
};
class CreateIpsecServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientIpPool{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> dryRun{};
  shared_ptr<bool> effectImmediately{};
  shared_ptr<string> ikeConfig{};
  shared_ptr<string> ipSecServerName{};
  shared_ptr<string> ipsecConfig{};
  shared_ptr<string> localSubnet{};
  shared_ptr<string> psk{};
  shared_ptr<bool> pskEnabled{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vpnGatewayId{};

  CreateIpsecServerRequest() {}

  explicit CreateIpsecServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientIpPool) {
      res["ClientIpPool"] = boost::any(*clientIpPool);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (effectImmediately) {
      res["EffectImmediately"] = boost::any(*effectImmediately);
    }
    if (ikeConfig) {
      res["IkeConfig"] = boost::any(*ikeConfig);
    }
    if (ipSecServerName) {
      res["IpSecServerName"] = boost::any(*ipSecServerName);
    }
    if (ipsecConfig) {
      res["IpsecConfig"] = boost::any(*ipsecConfig);
    }
    if (localSubnet) {
      res["LocalSubnet"] = boost::any(*localSubnet);
    }
    if (psk) {
      res["Psk"] = boost::any(*psk);
    }
    if (pskEnabled) {
      res["PskEnabled"] = boost::any(*pskEnabled);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientIpPool") != m.end() && !m["ClientIpPool"].empty()) {
      clientIpPool = make_shared<string>(boost::any_cast<string>(m["ClientIpPool"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<string>(boost::any_cast<string>(m["DryRun"]));
    }
    if (m.find("EffectImmediately") != m.end() && !m["EffectImmediately"].empty()) {
      effectImmediately = make_shared<bool>(boost::any_cast<bool>(m["EffectImmediately"]));
    }
    if (m.find("IkeConfig") != m.end() && !m["IkeConfig"].empty()) {
      ikeConfig = make_shared<string>(boost::any_cast<string>(m["IkeConfig"]));
    }
    if (m.find("IpSecServerName") != m.end() && !m["IpSecServerName"].empty()) {
      ipSecServerName = make_shared<string>(boost::any_cast<string>(m["IpSecServerName"]));
    }
    if (m.find("IpsecConfig") != m.end() && !m["IpsecConfig"].empty()) {
      ipsecConfig = make_shared<string>(boost::any_cast<string>(m["IpsecConfig"]));
    }
    if (m.find("LocalSubnet") != m.end() && !m["LocalSubnet"].empty()) {
      localSubnet = make_shared<string>(boost::any_cast<string>(m["LocalSubnet"]));
    }
    if (m.find("Psk") != m.end() && !m["Psk"].empty()) {
      psk = make_shared<string>(boost::any_cast<string>(m["Psk"]));
    }
    if (m.find("PskEnabled") != m.end() && !m["PskEnabled"].empty()) {
      pskEnabled = make_shared<bool>(boost::any_cast<bool>(m["PskEnabled"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~CreateIpsecServerRequest() = default;
};
class CreateIpsecServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> ipsecServerId{};
  shared_ptr<string> ipsecServerName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vpnGatewayId{};

  CreateIpsecServerResponseBody() {}

  explicit CreateIpsecServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (ipsecServerId) {
      res["IpsecServerId"] = boost::any(*ipsecServerId);
    }
    if (ipsecServerName) {
      res["IpsecServerName"] = boost::any(*ipsecServerName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("IpsecServerId") != m.end() && !m["IpsecServerId"].empty()) {
      ipsecServerId = make_shared<string>(boost::any_cast<string>(m["IpsecServerId"]));
    }
    if (m.find("IpsecServerName") != m.end() && !m["IpsecServerName"].empty()) {
      ipsecServerName = make_shared<string>(boost::any_cast<string>(m["IpsecServerName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~CreateIpsecServerResponseBody() = default;
};
class CreateIpsecServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIpsecServerResponseBody> body{};

  CreateIpsecServerResponse() {}

  explicit CreateIpsecServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIpsecServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIpsecServerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIpsecServerResponse() = default;
};
class CreateIpv4GatewayRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateIpv4GatewayRequestTag() {}

  explicit CreateIpv4GatewayRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateIpv4GatewayRequestTag() = default;
};
class CreateIpv4GatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ipv4GatewayDescription{};
  shared_ptr<string> ipv4GatewayName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateIpv4GatewayRequestTag>> tag{};
  shared_ptr<string> vpcId{};

  CreateIpv4GatewayRequest() {}

  explicit CreateIpv4GatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ipv4GatewayDescription) {
      res["Ipv4GatewayDescription"] = boost::any(*ipv4GatewayDescription);
    }
    if (ipv4GatewayName) {
      res["Ipv4GatewayName"] = boost::any(*ipv4GatewayName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("Ipv4GatewayDescription") != m.end() && !m["Ipv4GatewayDescription"].empty()) {
      ipv4GatewayDescription = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayDescription"]));
    }
    if (m.find("Ipv4GatewayName") != m.end() && !m["Ipv4GatewayName"].empty()) {
      ipv4GatewayName = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateIpv4GatewayRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateIpv4GatewayRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateIpv4GatewayRequestTag>>(expect1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreateIpv4GatewayRequest() = default;
};
class CreateIpv4GatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ipv4GatewayId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};

  CreateIpv4GatewayResponseBody() {}

  explicit CreateIpv4GatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv4GatewayId) {
      res["Ipv4GatewayId"] = boost::any(*ipv4GatewayId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv4GatewayId") != m.end() && !m["Ipv4GatewayId"].empty()) {
      ipv4GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateIpv4GatewayResponseBody() = default;
};
class CreateIpv4GatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIpv4GatewayResponseBody> body{};

  CreateIpv4GatewayResponse() {}

  explicit CreateIpv4GatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIpv4GatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIpv4GatewayResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIpv4GatewayResponse() = default;
};
class CreateIpv6EgressOnlyRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ipv6GatewayId{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateIpv6EgressOnlyRuleRequest() {}

  explicit CreateIpv6EgressOnlyRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ipv6GatewayId) {
      res["Ipv6GatewayId"] = boost::any(*ipv6GatewayId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ipv6GatewayId") != m.end() && !m["Ipv6GatewayId"].empty()) {
      ipv6GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv6GatewayId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateIpv6EgressOnlyRuleRequest() = default;
};
class CreateIpv6EgressOnlyRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ipv6EgressRuleId{};
  shared_ptr<string> requestId{};

  CreateIpv6EgressOnlyRuleResponseBody() {}

  explicit CreateIpv6EgressOnlyRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6EgressRuleId) {
      res["Ipv6EgressRuleId"] = boost::any(*ipv6EgressRuleId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6EgressRuleId") != m.end() && !m["Ipv6EgressRuleId"].empty()) {
      ipv6EgressRuleId = make_shared<string>(boost::any_cast<string>(m["Ipv6EgressRuleId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateIpv6EgressOnlyRuleResponseBody() = default;
};
class CreateIpv6EgressOnlyRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIpv6EgressOnlyRuleResponseBody> body{};

  CreateIpv6EgressOnlyRuleResponse() {}

  explicit CreateIpv6EgressOnlyRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIpv6EgressOnlyRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIpv6EgressOnlyRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIpv6EgressOnlyRuleResponse() = default;
};
class CreateIpv6GatewayRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateIpv6GatewayRequestTag() {}

  explicit CreateIpv6GatewayRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateIpv6GatewayRequestTag() = default;
};
class CreateIpv6GatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateIpv6GatewayRequestTag>> tag{};
  shared_ptr<string> vpcId{};

  CreateIpv6GatewayRequest() {}

  explicit CreateIpv6GatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateIpv6GatewayRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateIpv6GatewayRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateIpv6GatewayRequestTag>>(expect1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreateIpv6GatewayRequest() = default;
};
class CreateIpv6GatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ipv6GatewayId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};

  CreateIpv6GatewayResponseBody() {}

  explicit CreateIpv6GatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6GatewayId) {
      res["Ipv6GatewayId"] = boost::any(*ipv6GatewayId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6GatewayId") != m.end() && !m["Ipv6GatewayId"].empty()) {
      ipv6GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv6GatewayId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateIpv6GatewayResponseBody() = default;
};
class CreateIpv6GatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIpv6GatewayResponseBody> body{};

  CreateIpv6GatewayResponse() {}

  explicit CreateIpv6GatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIpv6GatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIpv6GatewayResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIpv6GatewayResponse() = default;
};
class CreateNatGatewayRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateNatGatewayRequestTag() {}

  explicit CreateNatGatewayRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateNatGatewayRequestTag() = default;
};
class CreateNatGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> duration{};
  shared_ptr<string> eipBindMode{};
  shared_ptr<bool> icmpReplyEnabled{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> name{};
  shared_ptr<string> natType{};
  shared_ptr<string> networkType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pricingCycle{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<bool> securityProtectionEnabled{};
  shared_ptr<string> spec{};
  shared_ptr<vector<CreateNatGatewayRequestTag>> tag{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  CreateNatGatewayRequest() {}

  explicit CreateNatGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (eipBindMode) {
      res["EipBindMode"] = boost::any(*eipBindMode);
    }
    if (icmpReplyEnabled) {
      res["IcmpReplyEnabled"] = boost::any(*icmpReplyEnabled);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (natType) {
      res["NatType"] = boost::any(*natType);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pricingCycle) {
      res["PricingCycle"] = boost::any(*pricingCycle);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityProtectionEnabled) {
      res["SecurityProtectionEnabled"] = boost::any(*securityProtectionEnabled);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("EipBindMode") != m.end() && !m["EipBindMode"].empty()) {
      eipBindMode = make_shared<string>(boost::any_cast<string>(m["EipBindMode"]));
    }
    if (m.find("IcmpReplyEnabled") != m.end() && !m["IcmpReplyEnabled"].empty()) {
      icmpReplyEnabled = make_shared<bool>(boost::any_cast<bool>(m["IcmpReplyEnabled"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NatType") != m.end() && !m["NatType"].empty()) {
      natType = make_shared<string>(boost::any_cast<string>(m["NatType"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PricingCycle") != m.end() && !m["PricingCycle"].empty()) {
      pricingCycle = make_shared<string>(boost::any_cast<string>(m["PricingCycle"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityProtectionEnabled") != m.end() && !m["SecurityProtectionEnabled"].empty()) {
      securityProtectionEnabled = make_shared<bool>(boost::any_cast<bool>(m["SecurityProtectionEnabled"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateNatGatewayRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateNatGatewayRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateNatGatewayRequestTag>>(expect1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreateNatGatewayRequest() = default;
};
class CreateNatGatewayResponseBodyForwardTableIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> forwardTableId{};

  CreateNatGatewayResponseBodyForwardTableIds() {}

  explicit CreateNatGatewayResponseBodyForwardTableIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardTableId) {
      res["ForwardTableId"] = boost::any(*forwardTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardTableId") != m.end() && !m["ForwardTableId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ForwardTableId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ForwardTableId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      forwardTableId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateNatGatewayResponseBodyForwardTableIds() = default;
};
class CreateNatGatewayResponseBodyFullNatTableIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fullNatTableId{};

  CreateNatGatewayResponseBodyFullNatTableIds() {}

  explicit CreateNatGatewayResponseBodyFullNatTableIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fullNatTableId) {
      res["FullNatTableId"] = boost::any(*fullNatTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FullNatTableId") != m.end() && !m["FullNatTableId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FullNatTableId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FullNatTableId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fullNatTableId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateNatGatewayResponseBodyFullNatTableIds() = default;
};
class CreateNatGatewayResponseBodySnatTableIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> snatTableId{};

  CreateNatGatewayResponseBodySnatTableIds() {}

  explicit CreateNatGatewayResponseBodySnatTableIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snatTableId) {
      res["SnatTableId"] = boost::any(*snatTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnatTableId") != m.end() && !m["SnatTableId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SnatTableId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SnatTableId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      snatTableId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateNatGatewayResponseBodySnatTableIds() = default;
};
class CreateNatGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateNatGatewayResponseBodyForwardTableIds> forwardTableIds{};
  shared_ptr<CreateNatGatewayResponseBodyFullNatTableIds> fullNatTableIds{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateNatGatewayResponseBodySnatTableIds> snatTableIds{};

  CreateNatGatewayResponseBody() {}

  explicit CreateNatGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardTableIds) {
      res["ForwardTableIds"] = forwardTableIds ? boost::any(forwardTableIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fullNatTableIds) {
      res["FullNatTableIds"] = fullNatTableIds ? boost::any(fullNatTableIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snatTableIds) {
      res["SnatTableIds"] = snatTableIds ? boost::any(snatTableIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardTableIds") != m.end() && !m["ForwardTableIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ForwardTableIds"].type()) {
        CreateNatGatewayResponseBodyForwardTableIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ForwardTableIds"]));
        forwardTableIds = make_shared<CreateNatGatewayResponseBodyForwardTableIds>(model1);
      }
    }
    if (m.find("FullNatTableIds") != m.end() && !m["FullNatTableIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["FullNatTableIds"].type()) {
        CreateNatGatewayResponseBodyFullNatTableIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FullNatTableIds"]));
        fullNatTableIds = make_shared<CreateNatGatewayResponseBodyFullNatTableIds>(model1);
      }
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnatTableIds") != m.end() && !m["SnatTableIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnatTableIds"].type()) {
        CreateNatGatewayResponseBodySnatTableIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnatTableIds"]));
        snatTableIds = make_shared<CreateNatGatewayResponseBodySnatTableIds>(model1);
      }
    }
  }


  virtual ~CreateNatGatewayResponseBody() = default;
};
class CreateNatGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNatGatewayResponseBody> body{};

  CreateNatGatewayResponse() {}

  explicit CreateNatGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNatGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNatGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNatGatewayResponse() = default;
};
class CreateNatIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> natIp{};
  shared_ptr<string> natIpCidr{};
  shared_ptr<string> natIpDescription{};
  shared_ptr<string> natIpName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateNatIpRequest() {}

  explicit CreateNatIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (natIp) {
      res["NatIp"] = boost::any(*natIp);
    }
    if (natIpCidr) {
      res["NatIpCidr"] = boost::any(*natIpCidr);
    }
    if (natIpDescription) {
      res["NatIpDescription"] = boost::any(*natIpDescription);
    }
    if (natIpName) {
      res["NatIpName"] = boost::any(*natIpName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("NatIp") != m.end() && !m["NatIp"].empty()) {
      natIp = make_shared<string>(boost::any_cast<string>(m["NatIp"]));
    }
    if (m.find("NatIpCidr") != m.end() && !m["NatIpCidr"].empty()) {
      natIpCidr = make_shared<string>(boost::any_cast<string>(m["NatIpCidr"]));
    }
    if (m.find("NatIpDescription") != m.end() && !m["NatIpDescription"].empty()) {
      natIpDescription = make_shared<string>(boost::any_cast<string>(m["NatIpDescription"]));
    }
    if (m.find("NatIpName") != m.end() && !m["NatIpName"].empty()) {
      natIpName = make_shared<string>(boost::any_cast<string>(m["NatIpName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateNatIpRequest() = default;
};
class CreateNatIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> natIp{};
  shared_ptr<string> natIpId{};
  shared_ptr<string> requestId{};

  CreateNatIpResponseBody() {}

  explicit CreateNatIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (natIp) {
      res["NatIp"] = boost::any(*natIp);
    }
    if (natIpId) {
      res["NatIpId"] = boost::any(*natIpId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NatIp") != m.end() && !m["NatIp"].empty()) {
      natIp = make_shared<string>(boost::any_cast<string>(m["NatIp"]));
    }
    if (m.find("NatIpId") != m.end() && !m["NatIpId"].empty()) {
      natIpId = make_shared<string>(boost::any_cast<string>(m["NatIpId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateNatIpResponseBody() = default;
};
class CreateNatIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNatIpResponseBody> body{};

  CreateNatIpResponse() {}

  explicit CreateNatIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNatIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNatIpResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNatIpResponse() = default;
};
class CreateNatIpCidrRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> natIpCidr{};
  shared_ptr<string> natIpCidrDescription{};
  shared_ptr<string> natIpCidrName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateNatIpCidrRequest() {}

  explicit CreateNatIpCidrRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (natIpCidr) {
      res["NatIpCidr"] = boost::any(*natIpCidr);
    }
    if (natIpCidrDescription) {
      res["NatIpCidrDescription"] = boost::any(*natIpCidrDescription);
    }
    if (natIpCidrName) {
      res["NatIpCidrName"] = boost::any(*natIpCidrName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("NatIpCidr") != m.end() && !m["NatIpCidr"].empty()) {
      natIpCidr = make_shared<string>(boost::any_cast<string>(m["NatIpCidr"]));
    }
    if (m.find("NatIpCidrDescription") != m.end() && !m["NatIpCidrDescription"].empty()) {
      natIpCidrDescription = make_shared<string>(boost::any_cast<string>(m["NatIpCidrDescription"]));
    }
    if (m.find("NatIpCidrName") != m.end() && !m["NatIpCidrName"].empty()) {
      natIpCidrName = make_shared<string>(boost::any_cast<string>(m["NatIpCidrName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateNatIpCidrRequest() = default;
};
class CreateNatIpCidrResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> natIpCidrId{};
  shared_ptr<string> requestId{};

  CreateNatIpCidrResponseBody() {}

  explicit CreateNatIpCidrResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (natIpCidrId) {
      res["NatIpCidrId"] = boost::any(*natIpCidrId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NatIpCidrId") != m.end() && !m["NatIpCidrId"].empty()) {
      natIpCidrId = make_shared<string>(boost::any_cast<string>(m["NatIpCidrId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateNatIpCidrResponseBody() = default;
};
class CreateNatIpCidrResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNatIpCidrResponseBody> body{};

  CreateNatIpCidrResponse() {}

  explicit CreateNatIpCidrResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNatIpCidrResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNatIpCidrResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNatIpCidrResponse() = default;
};
class CreateNetworkAclRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateNetworkAclRequestTag() {}

  explicit CreateNetworkAclRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateNetworkAclRequestTag() = default;
};
class CreateNetworkAclRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> networkAclName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateNetworkAclRequestTag>> tag{};
  shared_ptr<string> vpcId{};

  CreateNetworkAclRequest() {}

  explicit CreateNetworkAclRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (networkAclName) {
      res["NetworkAclName"] = boost::any(*networkAclName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NetworkAclName") != m.end() && !m["NetworkAclName"].empty()) {
      networkAclName = make_shared<string>(boost::any_cast<string>(m["NetworkAclName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateNetworkAclRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateNetworkAclRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateNetworkAclRequestTag>>(expect1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreateNetworkAclRequest() = default;
};
class CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> destinationCidrIp{};
  shared_ptr<string> networkAclEntryId{};
  shared_ptr<string> networkAclEntryName{};
  shared_ptr<string> policy{};
  shared_ptr<string> port{};
  shared_ptr<string> protocol{};

  CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry() {}

  explicit CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationCidrIp) {
      res["DestinationCidrIp"] = boost::any(*destinationCidrIp);
    }
    if (networkAclEntryId) {
      res["NetworkAclEntryId"] = boost::any(*networkAclEntryId);
    }
    if (networkAclEntryName) {
      res["NetworkAclEntryName"] = boost::any(*networkAclEntryName);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationCidrIp") != m.end() && !m["DestinationCidrIp"].empty()) {
      destinationCidrIp = make_shared<string>(boost::any_cast<string>(m["DestinationCidrIp"]));
    }
    if (m.find("NetworkAclEntryId") != m.end() && !m["NetworkAclEntryId"].empty()) {
      networkAclEntryId = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryId"]));
    }
    if (m.find("NetworkAclEntryName") != m.end() && !m["NetworkAclEntryName"].empty()) {
      networkAclEntryName = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryName"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry() = default;
};
class CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntries : public Darabonba::Model {
public:
  shared_ptr<vector<CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry>> egressAclEntry{};

  CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntries() {}

  explicit CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (egressAclEntry) {
      vector<boost::any> temp1;
      for(auto item1:*egressAclEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EgressAclEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EgressAclEntry") != m.end() && !m["EgressAclEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["EgressAclEntry"].type()) {
        vector<CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EgressAclEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        egressAclEntry = make_shared<vector<CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry>>(expect1);
      }
    }
  }


  virtual ~CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntries() = default;
};
class CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> networkAclEntryId{};
  shared_ptr<string> networkAclEntryName{};
  shared_ptr<string> policy{};
  shared_ptr<string> port{};
  shared_ptr<string> protocol{};
  shared_ptr<string> sourceCidrIp{};

  CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry() {}

  explicit CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (networkAclEntryId) {
      res["NetworkAclEntryId"] = boost::any(*networkAclEntryId);
    }
    if (networkAclEntryName) {
      res["NetworkAclEntryName"] = boost::any(*networkAclEntryName);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NetworkAclEntryId") != m.end() && !m["NetworkAclEntryId"].empty()) {
      networkAclEntryId = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryId"]));
    }
    if (m.find("NetworkAclEntryName") != m.end() && !m["NetworkAclEntryName"].empty()) {
      networkAclEntryName = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryName"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
  }


  virtual ~CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry() = default;
};
class CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntries : public Darabonba::Model {
public:
  shared_ptr<vector<CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry>> ingressAclEntry{};

  CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntries() {}

  explicit CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ingressAclEntry) {
      vector<boost::any> temp1;
      for(auto item1:*ingressAclEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IngressAclEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IngressAclEntry") != m.end() && !m["IngressAclEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["IngressAclEntry"].type()) {
        vector<CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IngressAclEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ingressAclEntry = make_shared<vector<CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry>>(expect1);
      }
    }
  }


  virtual ~CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntries() = default;
};
class CreateNetworkAclResponseBodyNetworkAclAttributeResourcesResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> status{};

  CreateNetworkAclResponseBodyNetworkAclAttributeResourcesResource() {}

  explicit CreateNetworkAclResponseBodyNetworkAclAttributeResourcesResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~CreateNetworkAclResponseBodyNetworkAclAttributeResourcesResource() = default;
};
class CreateNetworkAclResponseBodyNetworkAclAttributeResources : public Darabonba::Model {
public:
  shared_ptr<vector<CreateNetworkAclResponseBodyNetworkAclAttributeResourcesResource>> resource{};

  CreateNetworkAclResponseBodyNetworkAclAttributeResources() {}

  explicit CreateNetworkAclResponseBodyNetworkAclAttributeResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<CreateNetworkAclResponseBodyNetworkAclAttributeResourcesResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateNetworkAclResponseBodyNetworkAclAttributeResourcesResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<CreateNetworkAclResponseBodyNetworkAclAttributeResourcesResource>>(expect1);
      }
    }
  }


  virtual ~CreateNetworkAclResponseBodyNetworkAclAttributeResources() = default;
};
class CreateNetworkAclResponseBodyNetworkAclAttribute : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntries> egressAclEntries{};
  shared_ptr<CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntries> ingressAclEntries{};
  shared_ptr<string> networkAclId{};
  shared_ptr<string> networkAclName{};
  shared_ptr<string> regionId{};
  shared_ptr<CreateNetworkAclResponseBodyNetworkAclAttributeResources> resources{};
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};

  CreateNetworkAclResponseBodyNetworkAclAttribute() {}

  explicit CreateNetworkAclResponseBodyNetworkAclAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (egressAclEntries) {
      res["EgressAclEntries"] = egressAclEntries ? boost::any(egressAclEntries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ingressAclEntries) {
      res["IngressAclEntries"] = ingressAclEntries ? boost::any(ingressAclEntries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (networkAclName) {
      res["NetworkAclName"] = boost::any(*networkAclName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resources) {
      res["Resources"] = resources ? boost::any(resources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EgressAclEntries") != m.end() && !m["EgressAclEntries"].empty()) {
      if (typeid(map<string, boost::any>) == m["EgressAclEntries"].type()) {
        CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EgressAclEntries"]));
        egressAclEntries = make_shared<CreateNetworkAclResponseBodyNetworkAclAttributeEgressAclEntries>(model1);
      }
    }
    if (m.find("IngressAclEntries") != m.end() && !m["IngressAclEntries"].empty()) {
      if (typeid(map<string, boost::any>) == m["IngressAclEntries"].type()) {
        CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IngressAclEntries"]));
        ingressAclEntries = make_shared<CreateNetworkAclResponseBodyNetworkAclAttributeIngressAclEntries>(model1);
      }
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("NetworkAclName") != m.end() && !m["NetworkAclName"].empty()) {
      networkAclName = make_shared<string>(boost::any_cast<string>(m["NetworkAclName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resources"].type()) {
        CreateNetworkAclResponseBodyNetworkAclAttributeResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resources"]));
        resources = make_shared<CreateNetworkAclResponseBodyNetworkAclAttributeResources>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreateNetworkAclResponseBodyNetworkAclAttribute() = default;
};
class CreateNetworkAclResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateNetworkAclResponseBodyNetworkAclAttribute> networkAclAttribute{};
  shared_ptr<string> networkAclId{};
  shared_ptr<string> requestId{};

  CreateNetworkAclResponseBody() {}

  explicit CreateNetworkAclResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAclAttribute) {
      res["NetworkAclAttribute"] = networkAclAttribute ? boost::any(networkAclAttribute->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAclAttribute") != m.end() && !m["NetworkAclAttribute"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkAclAttribute"].type()) {
        CreateNetworkAclResponseBodyNetworkAclAttribute model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkAclAttribute"]));
        networkAclAttribute = make_shared<CreateNetworkAclResponseBodyNetworkAclAttribute>(model1);
      }
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateNetworkAclResponseBody() = default;
};
class CreateNetworkAclResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNetworkAclResponseBody> body{};

  CreateNetworkAclResponse() {}

  explicit CreateNetworkAclResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNetworkAclResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNetworkAclResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNetworkAclResponse() = default;
};
class CreatePhysicalConnectionRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreatePhysicalConnectionRequestTag() {}

  explicit CreatePhysicalConnectionRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreatePhysicalConnectionRequestTag() = default;
};
class CreatePhysicalConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessPointId{};
  shared_ptr<string> circuitCode{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<vector<string>> deviceAdvancedCapacity{};
  shared_ptr<string> lineOperator{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> peerLocation{};
  shared_ptr<string> portType{};
  shared_ptr<string> redundantPhysicalConnectionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreatePhysicalConnectionRequestTag>> tag{};
  shared_ptr<string> type{};
  shared_ptr<long> bandwidth{};

  CreatePhysicalConnectionRequest() {}

  explicit CreatePhysicalConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (circuitCode) {
      res["CircuitCode"] = boost::any(*circuitCode);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceAdvancedCapacity) {
      res["DeviceAdvancedCapacity"] = boost::any(*deviceAdvancedCapacity);
    }
    if (lineOperator) {
      res["LineOperator"] = boost::any(*lineOperator);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (peerLocation) {
      res["PeerLocation"] = boost::any(*peerLocation);
    }
    if (portType) {
      res["PortType"] = boost::any(*portType);
    }
    if (redundantPhysicalConnectionId) {
      res["RedundantPhysicalConnectionId"] = boost::any(*redundantPhysicalConnectionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (bandwidth) {
      res["bandwidth"] = boost::any(*bandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<string>(boost::any_cast<string>(m["AccessPointId"]));
    }
    if (m.find("CircuitCode") != m.end() && !m["CircuitCode"].empty()) {
      circuitCode = make_shared<string>(boost::any_cast<string>(m["CircuitCode"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceAdvancedCapacity") != m.end() && !m["DeviceAdvancedCapacity"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceAdvancedCapacity"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceAdvancedCapacity"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceAdvancedCapacity = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LineOperator") != m.end() && !m["LineOperator"].empty()) {
      lineOperator = make_shared<string>(boost::any_cast<string>(m["LineOperator"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PeerLocation") != m.end() && !m["PeerLocation"].empty()) {
      peerLocation = make_shared<string>(boost::any_cast<string>(m["PeerLocation"]));
    }
    if (m.find("PortType") != m.end() && !m["PortType"].empty()) {
      portType = make_shared<string>(boost::any_cast<string>(m["PortType"]));
    }
    if (m.find("RedundantPhysicalConnectionId") != m.end() && !m["RedundantPhysicalConnectionId"].empty()) {
      redundantPhysicalConnectionId = make_shared<string>(boost::any_cast<string>(m["RedundantPhysicalConnectionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreatePhysicalConnectionRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePhysicalConnectionRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreatePhysicalConnectionRequestTag>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("bandwidth") != m.end() && !m["bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["bandwidth"]));
    }
  }


  virtual ~CreatePhysicalConnectionRequest() = default;
};
class CreatePhysicalConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> requestId{};

  CreatePhysicalConnectionResponseBody() {}

  explicit CreatePhysicalConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreatePhysicalConnectionResponseBody() = default;
};
class CreatePhysicalConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePhysicalConnectionResponseBody> body{};

  CreatePhysicalConnectionResponse() {}

  explicit CreatePhysicalConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePhysicalConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePhysicalConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePhysicalConnectionResponse() = default;
};
class CreatePhysicalConnectionOccupancyOrderRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> period{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> pricingCycle{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreatePhysicalConnectionOccupancyOrderRequest() {}

  explicit CreatePhysicalConnectionOccupancyOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (pricingCycle) {
      res["PricingCycle"] = boost::any(*pricingCycle);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("PricingCycle") != m.end() && !m["PricingCycle"].empty()) {
      pricingCycle = make_shared<string>(boost::any_cast<string>(m["PricingCycle"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreatePhysicalConnectionOccupancyOrderRequest() = default;
};
class CreatePhysicalConnectionOccupancyOrderResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};

  CreatePhysicalConnectionOccupancyOrderResponseBodyData() {}

  explicit CreatePhysicalConnectionOccupancyOrderResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~CreatePhysicalConnectionOccupancyOrderResponseBodyData() = default;
};
class CreatePhysicalConnectionOccupancyOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreatePhysicalConnectionOccupancyOrderResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreatePhysicalConnectionOccupancyOrderResponseBody() {}

  explicit CreatePhysicalConnectionOccupancyOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreatePhysicalConnectionOccupancyOrderResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreatePhysicalConnectionOccupancyOrderResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreatePhysicalConnectionOccupancyOrderResponseBody() = default;
};
class CreatePhysicalConnectionOccupancyOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePhysicalConnectionOccupancyOrderResponseBody> body{};

  CreatePhysicalConnectionOccupancyOrderResponse() {}

  explicit CreatePhysicalConnectionOccupancyOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePhysicalConnectionOccupancyOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePhysicalConnectionOccupancyOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePhysicalConnectionOccupancyOrderResponse() = default;
};
class CreatePhysicalConnectionSetupOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessPointId{};
  shared_ptr<bool> autoPay{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> lineOperator{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> portType{};
  shared_ptr<string> redundantPhysicalConnectionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreatePhysicalConnectionSetupOrderRequest() {}

  explicit CreatePhysicalConnectionSetupOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (lineOperator) {
      res["LineOperator"] = boost::any(*lineOperator);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (portType) {
      res["PortType"] = boost::any(*portType);
    }
    if (redundantPhysicalConnectionId) {
      res["RedundantPhysicalConnectionId"] = boost::any(*redundantPhysicalConnectionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<string>(boost::any_cast<string>(m["AccessPointId"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("LineOperator") != m.end() && !m["LineOperator"].empty()) {
      lineOperator = make_shared<string>(boost::any_cast<string>(m["LineOperator"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PortType") != m.end() && !m["PortType"].empty()) {
      portType = make_shared<string>(boost::any_cast<string>(m["PortType"]));
    }
    if (m.find("RedundantPhysicalConnectionId") != m.end() && !m["RedundantPhysicalConnectionId"].empty()) {
      redundantPhysicalConnectionId = make_shared<string>(boost::any_cast<string>(m["RedundantPhysicalConnectionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreatePhysicalConnectionSetupOrderRequest() = default;
};
class CreatePhysicalConnectionSetupOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> requestId{};

  CreatePhysicalConnectionSetupOrderResponseBody() {}

  explicit CreatePhysicalConnectionSetupOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreatePhysicalConnectionSetupOrderResponseBody() = default;
};
class CreatePhysicalConnectionSetupOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePhysicalConnectionSetupOrderResponseBody> body{};

  CreatePhysicalConnectionSetupOrderResponse() {}

  explicit CreatePhysicalConnectionSetupOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePhysicalConnectionSetupOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePhysicalConnectionSetupOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePhysicalConnectionSetupOrderResponse() = default;
};
class CreatePublicIpAddressPoolRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreatePublicIpAddressPoolRequestTag() {}

  explicit CreatePublicIpAddressPoolRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreatePublicIpAddressPoolRequestTag() = default;
};
class CreatePublicIpAddressPoolRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> isp{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> securityProtectionTypes{};
  shared_ptr<vector<CreatePublicIpAddressPoolRequestTag>> tag{};
  shared_ptr<vector<string>> zones{};

  CreatePublicIpAddressPoolRequest() {}

  explicit CreatePublicIpAddressPoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityProtectionTypes) {
      res["SecurityProtectionTypes"] = boost::any(*securityProtectionTypes);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (zones) {
      res["Zones"] = boost::any(*zones);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityProtectionTypes") != m.end() && !m["SecurityProtectionTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityProtectionTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityProtectionTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityProtectionTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreatePublicIpAddressPoolRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePublicIpAddressPoolRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreatePublicIpAddressPoolRequestTag>>(expect1);
      }
    }
    if (m.find("Zones") != m.end() && !m["Zones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Zones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Zones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      zones = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreatePublicIpAddressPoolRequest() = default;
};
class CreatePublicIpAddressPoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> publicIpAddressPoolId{};
  shared_ptr<string> pulbicIpAddressPoolId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};

  CreatePublicIpAddressPoolResponseBody() {}

  explicit CreatePublicIpAddressPoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (publicIpAddressPoolId) {
      res["PublicIpAddressPoolId"] = boost::any(*publicIpAddressPoolId);
    }
    if (pulbicIpAddressPoolId) {
      res["PulbicIpAddressPoolId"] = boost::any(*pulbicIpAddressPoolId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PublicIpAddressPoolId") != m.end() && !m["PublicIpAddressPoolId"].empty()) {
      publicIpAddressPoolId = make_shared<string>(boost::any_cast<string>(m["PublicIpAddressPoolId"]));
    }
    if (m.find("PulbicIpAddressPoolId") != m.end() && !m["PulbicIpAddressPoolId"].empty()) {
      pulbicIpAddressPoolId = make_shared<string>(boost::any_cast<string>(m["PulbicIpAddressPoolId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreatePublicIpAddressPoolResponseBody() = default;
};
class CreatePublicIpAddressPoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePublicIpAddressPoolResponseBody> body{};

  CreatePublicIpAddressPoolResponse() {}

  explicit CreatePublicIpAddressPoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePublicIpAddressPoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePublicIpAddressPoolResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePublicIpAddressPoolResponse() = default;
};
class CreateRouteEntriesRequestRouteEntries : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> dstCidrBlock{};
  shared_ptr<long> ipVersion{};
  shared_ptr<string> name{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> nextHopType{};
  shared_ptr<string> routeTableId{};

  CreateRouteEntriesRequestRouteEntries() {}

  explicit CreateRouteEntriesRequestRouteEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dstCidrBlock) {
      res["DstCidrBlock"] = boost::any(*dstCidrBlock);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (nextHopType) {
      res["NextHopType"] = boost::any(*nextHopType);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DstCidrBlock") != m.end() && !m["DstCidrBlock"].empty()) {
      dstCidrBlock = make_shared<string>(boost::any_cast<string>(m["DstCidrBlock"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<long>(boost::any_cast<long>(m["IpVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("NextHopType") != m.end() && !m["NextHopType"].empty()) {
      nextHopType = make_shared<string>(boost::any_cast<string>(m["NextHopType"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
  }


  virtual ~CreateRouteEntriesRequestRouteEntries() = default;
};
class CreateRouteEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateRouteEntriesRequestRouteEntries>> routeEntries{};

  CreateRouteEntriesRequest() {}

  explicit CreateRouteEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeEntries) {
      vector<boost::any> temp1;
      for(auto item1:*routeEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouteEntries"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteEntries") != m.end() && !m["RouteEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["RouteEntries"].type()) {
        vector<CreateRouteEntriesRequestRouteEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouteEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRouteEntriesRequestRouteEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeEntries = make_shared<vector<CreateRouteEntriesRequestRouteEntries>>(expect1);
      }
    }
  }


  virtual ~CreateRouteEntriesRequest() = default;
};
class CreateRouteEntriesResponseBodyFailedRouteEntries : public Darabonba::Model {
public:
  shared_ptr<string> dstCidrBlock{};
  shared_ptr<string> failedCode{};
  shared_ptr<string> failedMessage{};
  shared_ptr<string> nextHop{};

  CreateRouteEntriesResponseBodyFailedRouteEntries() {}

  explicit CreateRouteEntriesResponseBodyFailedRouteEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstCidrBlock) {
      res["DstCidrBlock"] = boost::any(*dstCidrBlock);
    }
    if (failedCode) {
      res["FailedCode"] = boost::any(*failedCode);
    }
    if (failedMessage) {
      res["FailedMessage"] = boost::any(*failedMessage);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstCidrBlock") != m.end() && !m["DstCidrBlock"].empty()) {
      dstCidrBlock = make_shared<string>(boost::any_cast<string>(m["DstCidrBlock"]));
    }
    if (m.find("FailedCode") != m.end() && !m["FailedCode"].empty()) {
      failedCode = make_shared<string>(boost::any_cast<string>(m["FailedCode"]));
    }
    if (m.find("FailedMessage") != m.end() && !m["FailedMessage"].empty()) {
      failedMessage = make_shared<string>(boost::any_cast<string>(m["FailedMessage"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
  }


  virtual ~CreateRouteEntriesResponseBodyFailedRouteEntries() = default;
};
class CreateRouteEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> failedCount{};
  shared_ptr<vector<CreateRouteEntriesResponseBodyFailedRouteEntries>> failedRouteEntries{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> routeEntryIds{};
  shared_ptr<long> successCount{};

  CreateRouteEntriesResponseBody() {}

  explicit CreateRouteEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedCount) {
      res["FailedCount"] = boost::any(*failedCount);
    }
    if (failedRouteEntries) {
      vector<boost::any> temp1;
      for(auto item1:*failedRouteEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedRouteEntries"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routeEntryIds) {
      res["RouteEntryIds"] = boost::any(*routeEntryIds);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedCount") != m.end() && !m["FailedCount"].empty()) {
      failedCount = make_shared<long>(boost::any_cast<long>(m["FailedCount"]));
    }
    if (m.find("FailedRouteEntries") != m.end() && !m["FailedRouteEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedRouteEntries"].type()) {
        vector<CreateRouteEntriesResponseBodyFailedRouteEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedRouteEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRouteEntriesResponseBodyFailedRouteEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedRouteEntries = make_shared<vector<CreateRouteEntriesResponseBodyFailedRouteEntries>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouteEntryIds") != m.end() && !m["RouteEntryIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RouteEntryIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RouteEntryIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      routeEntryIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
  }


  virtual ~CreateRouteEntriesResponseBody() = default;
};
class CreateRouteEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRouteEntriesResponseBody> body{};

  CreateRouteEntriesResponse() {}

  explicit CreateRouteEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRouteEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRouteEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRouteEntriesResponse() = default;
};
class CreateRouteEntryRequestNextHopList : public Darabonba::Model {
public:
  shared_ptr<string> nextHopId{};
  shared_ptr<string> nextHopType{};
  shared_ptr<long> weight{};

  CreateRouteEntryRequestNextHopList() {}

  explicit CreateRouteEntryRequestNextHopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextHopId) {
      res["NextHopId"] = boost::any(*nextHopId);
    }
    if (nextHopType) {
      res["NextHopType"] = boost::any(*nextHopType);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextHopId") != m.end() && !m["NextHopId"].empty()) {
      nextHopId = make_shared<string>(boost::any_cast<string>(m["NextHopId"]));
    }
    if (m.find("NextHopType") != m.end() && !m["NextHopType"].empty()) {
      nextHopType = make_shared<string>(boost::any_cast<string>(m["NextHopType"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~CreateRouteEntryRequestNextHopList() = default;
};
class CreateRouteEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> nextHopId{};
  shared_ptr<vector<CreateRouteEntryRequestNextHopList>> nextHopList{};
  shared_ptr<string> nextHopType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeEntryName{};
  shared_ptr<string> routeTableId{};

  CreateRouteEntryRequest() {}

  explicit CreateRouteEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (nextHopId) {
      res["NextHopId"] = boost::any(*nextHopId);
    }
    if (nextHopList) {
      vector<boost::any> temp1;
      for(auto item1:*nextHopList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NextHopList"] = boost::any(temp1);
    }
    if (nextHopType) {
      res["NextHopType"] = boost::any(*nextHopType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeEntryName) {
      res["RouteEntryName"] = boost::any(*routeEntryName);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("NextHopId") != m.end() && !m["NextHopId"].empty()) {
      nextHopId = make_shared<string>(boost::any_cast<string>(m["NextHopId"]));
    }
    if (m.find("NextHopList") != m.end() && !m["NextHopList"].empty()) {
      if (typeid(vector<boost::any>) == m["NextHopList"].type()) {
        vector<CreateRouteEntryRequestNextHopList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NextHopList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRouteEntryRequestNextHopList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nextHopList = make_shared<vector<CreateRouteEntryRequestNextHopList>>(expect1);
      }
    }
    if (m.find("NextHopType") != m.end() && !m["NextHopType"].empty()) {
      nextHopType = make_shared<string>(boost::any_cast<string>(m["NextHopType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteEntryName") != m.end() && !m["RouteEntryName"].empty()) {
      routeEntryName = make_shared<string>(boost::any_cast<string>(m["RouteEntryName"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
  }


  virtual ~CreateRouteEntryRequest() = default;
};
class CreateRouteEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> routeEntryId{};

  CreateRouteEntryResponseBody() {}

  explicit CreateRouteEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routeEntryId) {
      res["RouteEntryId"] = boost::any(*routeEntryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouteEntryId") != m.end() && !m["RouteEntryId"].empty()) {
      routeEntryId = make_shared<string>(boost::any_cast<string>(m["RouteEntryId"]));
    }
  }


  virtual ~CreateRouteEntryResponseBody() = default;
};
class CreateRouteEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRouteEntryResponseBody> body{};

  CreateRouteEntryResponse() {}

  explicit CreateRouteEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRouteEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRouteEntryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRouteEntryResponse() = default;
};
class CreateRouteTableRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateRouteTableRequestTag() {}

  explicit CreateRouteTableRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateRouteTableRequestTag() = default;
};
class CreateRouteTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> associateType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeTableName{};
  shared_ptr<vector<CreateRouteTableRequestTag>> tag{};
  shared_ptr<string> vpcId{};

  CreateRouteTableRequest() {}

  explicit CreateRouteTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associateType) {
      res["AssociateType"] = boost::any(*associateType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeTableName) {
      res["RouteTableName"] = boost::any(*routeTableName);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociateType") != m.end() && !m["AssociateType"].empty()) {
      associateType = make_shared<string>(boost::any_cast<string>(m["AssociateType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteTableName") != m.end() && !m["RouteTableName"].empty()) {
      routeTableName = make_shared<string>(boost::any_cast<string>(m["RouteTableName"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateRouteTableRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRouteTableRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateRouteTableRequestTag>>(expect1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreateRouteTableRequest() = default;
};
class CreateRouteTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> routeTableId{};

  CreateRouteTableResponseBody() {}

  explicit CreateRouteTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
  }


  virtual ~CreateRouteTableResponseBody() = default;
};
class CreateRouteTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRouteTableResponseBody> body{};

  CreateRouteTableResponse() {}

  explicit CreateRouteTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRouteTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRouteTableResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRouteTableResponse() = default;
};
class CreateRouterInterfaceRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateRouterInterfaceRequestTags() {}

  explicit CreateRouterInterfaceRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateRouterInterfaceRequestTags() = default;
};
class CreateRouterInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessPointId{};
  shared_ptr<bool> autoPay{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<bool> fastLinkMode{};
  shared_ptr<string> healthCheckSourceIp{};
  shared_ptr<string> healthCheckTargetIp{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> name{};
  shared_ptr<string> oppositeAccessPointId{};
  shared_ptr<string> oppositeInterfaceId{};
  shared_ptr<string> oppositeInterfaceOwnerId{};
  shared_ptr<string> oppositeRegionId{};
  shared_ptr<string> oppositeRouterId{};
  shared_ptr<string> oppositeRouterType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> period{};
  shared_ptr<string> pricingCycle{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> role{};
  shared_ptr<string> routerId{};
  shared_ptr<string> routerType{};
  shared_ptr<string> spec{};
  shared_ptr<vector<CreateRouterInterfaceRequestTags>> tags{};

  CreateRouterInterfaceRequest() {}

  explicit CreateRouterInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fastLinkMode) {
      res["FastLinkMode"] = boost::any(*fastLinkMode);
    }
    if (healthCheckSourceIp) {
      res["HealthCheckSourceIp"] = boost::any(*healthCheckSourceIp);
    }
    if (healthCheckTargetIp) {
      res["HealthCheckTargetIp"] = boost::any(*healthCheckTargetIp);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (oppositeAccessPointId) {
      res["OppositeAccessPointId"] = boost::any(*oppositeAccessPointId);
    }
    if (oppositeInterfaceId) {
      res["OppositeInterfaceId"] = boost::any(*oppositeInterfaceId);
    }
    if (oppositeInterfaceOwnerId) {
      res["OppositeInterfaceOwnerId"] = boost::any(*oppositeInterfaceOwnerId);
    }
    if (oppositeRegionId) {
      res["OppositeRegionId"] = boost::any(*oppositeRegionId);
    }
    if (oppositeRouterId) {
      res["OppositeRouterId"] = boost::any(*oppositeRouterId);
    }
    if (oppositeRouterType) {
      res["OppositeRouterType"] = boost::any(*oppositeRouterType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (pricingCycle) {
      res["PricingCycle"] = boost::any(*pricingCycle);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    if (routerType) {
      res["RouterType"] = boost::any(*routerType);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<string>(boost::any_cast<string>(m["AccessPointId"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FastLinkMode") != m.end() && !m["FastLinkMode"].empty()) {
      fastLinkMode = make_shared<bool>(boost::any_cast<bool>(m["FastLinkMode"]));
    }
    if (m.find("HealthCheckSourceIp") != m.end() && !m["HealthCheckSourceIp"].empty()) {
      healthCheckSourceIp = make_shared<string>(boost::any_cast<string>(m["HealthCheckSourceIp"]));
    }
    if (m.find("HealthCheckTargetIp") != m.end() && !m["HealthCheckTargetIp"].empty()) {
      healthCheckTargetIp = make_shared<string>(boost::any_cast<string>(m["HealthCheckTargetIp"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OppositeAccessPointId") != m.end() && !m["OppositeAccessPointId"].empty()) {
      oppositeAccessPointId = make_shared<string>(boost::any_cast<string>(m["OppositeAccessPointId"]));
    }
    if (m.find("OppositeInterfaceId") != m.end() && !m["OppositeInterfaceId"].empty()) {
      oppositeInterfaceId = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceId"]));
    }
    if (m.find("OppositeInterfaceOwnerId") != m.end() && !m["OppositeInterfaceOwnerId"].empty()) {
      oppositeInterfaceOwnerId = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceOwnerId"]));
    }
    if (m.find("OppositeRegionId") != m.end() && !m["OppositeRegionId"].empty()) {
      oppositeRegionId = make_shared<string>(boost::any_cast<string>(m["OppositeRegionId"]));
    }
    if (m.find("OppositeRouterId") != m.end() && !m["OppositeRouterId"].empty()) {
      oppositeRouterId = make_shared<string>(boost::any_cast<string>(m["OppositeRouterId"]));
    }
    if (m.find("OppositeRouterType") != m.end() && !m["OppositeRouterType"].empty()) {
      oppositeRouterType = make_shared<string>(boost::any_cast<string>(m["OppositeRouterType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PricingCycle") != m.end() && !m["PricingCycle"].empty()) {
      pricingCycle = make_shared<string>(boost::any_cast<string>(m["PricingCycle"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
    if (m.find("RouterType") != m.end() && !m["RouterType"].empty()) {
      routerType = make_shared<string>(boost::any_cast<string>(m["RouterType"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreateRouterInterfaceRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRouterInterfaceRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateRouterInterfaceRequestTags>>(expect1);
      }
    }
  }


  virtual ~CreateRouterInterfaceRequest() = default;
};
class CreateRouterInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> routerInterfaceId{};

  CreateRouterInterfaceResponseBody() {}

  explicit CreateRouterInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routerInterfaceId) {
      res["RouterInterfaceId"] = boost::any(*routerInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouterInterfaceId") != m.end() && !m["RouterInterfaceId"].empty()) {
      routerInterfaceId = make_shared<string>(boost::any_cast<string>(m["RouterInterfaceId"]));
    }
  }


  virtual ~CreateRouterInterfaceResponseBody() = default;
};
class CreateRouterInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRouterInterfaceResponseBody> body{};

  CreateRouterInterfaceResponse() {}

  explicit CreateRouterInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRouterInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRouterInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRouterInterfaceResponse() = default;
};
class CreateSnatEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> eipAffinity{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> snatEntryName{};
  shared_ptr<string> snatIp{};
  shared_ptr<string> snatTableId{};
  shared_ptr<string> sourceCIDR{};
  shared_ptr<string> sourceVSwitchId{};

  CreateSnatEntryRequest() {}

  explicit CreateSnatEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (eipAffinity) {
      res["EipAffinity"] = boost::any(*eipAffinity);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (snatEntryName) {
      res["SnatEntryName"] = boost::any(*snatEntryName);
    }
    if (snatIp) {
      res["SnatIp"] = boost::any(*snatIp);
    }
    if (snatTableId) {
      res["SnatTableId"] = boost::any(*snatTableId);
    }
    if (sourceCIDR) {
      res["SourceCIDR"] = boost::any(*sourceCIDR);
    }
    if (sourceVSwitchId) {
      res["SourceVSwitchId"] = boost::any(*sourceVSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EipAffinity") != m.end() && !m["EipAffinity"].empty()) {
      eipAffinity = make_shared<long>(boost::any_cast<long>(m["EipAffinity"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SnatEntryName") != m.end() && !m["SnatEntryName"].empty()) {
      snatEntryName = make_shared<string>(boost::any_cast<string>(m["SnatEntryName"]));
    }
    if (m.find("SnatIp") != m.end() && !m["SnatIp"].empty()) {
      snatIp = make_shared<string>(boost::any_cast<string>(m["SnatIp"]));
    }
    if (m.find("SnatTableId") != m.end() && !m["SnatTableId"].empty()) {
      snatTableId = make_shared<string>(boost::any_cast<string>(m["SnatTableId"]));
    }
    if (m.find("SourceCIDR") != m.end() && !m["SourceCIDR"].empty()) {
      sourceCIDR = make_shared<string>(boost::any_cast<string>(m["SourceCIDR"]));
    }
    if (m.find("SourceVSwitchId") != m.end() && !m["SourceVSwitchId"].empty()) {
      sourceVSwitchId = make_shared<string>(boost::any_cast<string>(m["SourceVSwitchId"]));
    }
  }


  virtual ~CreateSnatEntryRequest() = default;
};
class CreateSnatEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> snatEntryId{};

  CreateSnatEntryResponseBody() {}

  explicit CreateSnatEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snatEntryId) {
      res["SnatEntryId"] = boost::any(*snatEntryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnatEntryId") != m.end() && !m["SnatEntryId"].empty()) {
      snatEntryId = make_shared<string>(boost::any_cast<string>(m["SnatEntryId"]));
    }
  }


  virtual ~CreateSnatEntryResponseBody() = default;
};
class CreateSnatEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSnatEntryResponseBody> body{};

  CreateSnatEntryResponse() {}

  explicit CreateSnatEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSnatEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSnatEntryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSnatEntryResponse() = default;
};
class CreateSslVpnClientCertRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sslVpnServerId{};

  CreateSslVpnClientCertRequest() {}

  explicit CreateSslVpnClientCertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sslVpnServerId) {
      res["SslVpnServerId"] = boost::any(*sslVpnServerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SslVpnServerId") != m.end() && !m["SslVpnServerId"].empty()) {
      sslVpnServerId = make_shared<string>(boost::any_cast<string>(m["SslVpnServerId"]));
    }
  }


  virtual ~CreateSslVpnClientCertRequest() = default;
};
class CreateSslVpnClientCertResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sslVpnClientCertId{};

  CreateSslVpnClientCertResponseBody() {}

  explicit CreateSslVpnClientCertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sslVpnClientCertId) {
      res["SslVpnClientCertId"] = boost::any(*sslVpnClientCertId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SslVpnClientCertId") != m.end() && !m["SslVpnClientCertId"].empty()) {
      sslVpnClientCertId = make_shared<string>(boost::any_cast<string>(m["SslVpnClientCertId"]));
    }
  }


  virtual ~CreateSslVpnClientCertResponseBody() = default;
};
class CreateSslVpnClientCertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSslVpnClientCertResponseBody> body{};

  CreateSslVpnClientCertResponse() {}

  explicit CreateSslVpnClientCertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSslVpnClientCertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSslVpnClientCertResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSslVpnClientCertResponse() = default;
};
class CreateSslVpnServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> cipher{};
  shared_ptr<string> clientIpPool{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> compress{};
  shared_ptr<bool> enableMultiFactorAuth{};
  shared_ptr<string> IDaaSApplicationId{};
  shared_ptr<string> IDaaSInstanceId{};
  shared_ptr<string> IDaaSRegionId{};
  shared_ptr<string> localSubnet{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> port{};
  shared_ptr<string> proto{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpnGatewayId{};

  CreateSslVpnServerRequest() {}

  explicit CreateSslVpnServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cipher) {
      res["Cipher"] = boost::any(*cipher);
    }
    if (clientIpPool) {
      res["ClientIpPool"] = boost::any(*clientIpPool);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (compress) {
      res["Compress"] = boost::any(*compress);
    }
    if (enableMultiFactorAuth) {
      res["EnableMultiFactorAuth"] = boost::any(*enableMultiFactorAuth);
    }
    if (IDaaSApplicationId) {
      res["IDaaSApplicationId"] = boost::any(*IDaaSApplicationId);
    }
    if (IDaaSInstanceId) {
      res["IDaaSInstanceId"] = boost::any(*IDaaSInstanceId);
    }
    if (IDaaSRegionId) {
      res["IDaaSRegionId"] = boost::any(*IDaaSRegionId);
    }
    if (localSubnet) {
      res["LocalSubnet"] = boost::any(*localSubnet);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (proto) {
      res["Proto"] = boost::any(*proto);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cipher") != m.end() && !m["Cipher"].empty()) {
      cipher = make_shared<string>(boost::any_cast<string>(m["Cipher"]));
    }
    if (m.find("ClientIpPool") != m.end() && !m["ClientIpPool"].empty()) {
      clientIpPool = make_shared<string>(boost::any_cast<string>(m["ClientIpPool"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Compress") != m.end() && !m["Compress"].empty()) {
      compress = make_shared<bool>(boost::any_cast<bool>(m["Compress"]));
    }
    if (m.find("EnableMultiFactorAuth") != m.end() && !m["EnableMultiFactorAuth"].empty()) {
      enableMultiFactorAuth = make_shared<bool>(boost::any_cast<bool>(m["EnableMultiFactorAuth"]));
    }
    if (m.find("IDaaSApplicationId") != m.end() && !m["IDaaSApplicationId"].empty()) {
      IDaaSApplicationId = make_shared<string>(boost::any_cast<string>(m["IDaaSApplicationId"]));
    }
    if (m.find("IDaaSInstanceId") != m.end() && !m["IDaaSInstanceId"].empty()) {
      IDaaSInstanceId = make_shared<string>(boost::any_cast<string>(m["IDaaSInstanceId"]));
    }
    if (m.find("IDaaSRegionId") != m.end() && !m["IDaaSRegionId"].empty()) {
      IDaaSRegionId = make_shared<string>(boost::any_cast<string>(m["IDaaSRegionId"]));
    }
    if (m.find("LocalSubnet") != m.end() && !m["LocalSubnet"].empty()) {
      localSubnet = make_shared<string>(boost::any_cast<string>(m["LocalSubnet"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Proto") != m.end() && !m["Proto"].empty()) {
      proto = make_shared<string>(boost::any_cast<string>(m["Proto"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~CreateSslVpnServerRequest() = default;
};
class CreateSslVpnServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sslVpnServerId{};

  CreateSslVpnServerResponseBody() {}

  explicit CreateSslVpnServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sslVpnServerId) {
      res["SslVpnServerId"] = boost::any(*sslVpnServerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SslVpnServerId") != m.end() && !m["SslVpnServerId"].empty()) {
      sslVpnServerId = make_shared<string>(boost::any_cast<string>(m["SslVpnServerId"]));
    }
  }


  virtual ~CreateSslVpnServerResponseBody() = default;
};
class CreateSslVpnServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSslVpnServerResponseBody> body{};

  CreateSslVpnServerResponse() {}

  explicit CreateSslVpnServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSslVpnServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSslVpnServerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSslVpnServerResponse() = default;
};
class CreateTrafficMirrorFilterRequestEgressRules : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> destinationPortRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> protocol{};
  shared_ptr<string> sourceCidrBlock{};
  shared_ptr<string> sourcePortRange{};

  CreateTrafficMirrorFilterRequestEgressRules() {}

  explicit CreateTrafficMirrorFilterRequestEgressRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (destinationPortRange) {
      res["DestinationPortRange"] = boost::any(*destinationPortRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (sourceCidrBlock) {
      res["SourceCidrBlock"] = boost::any(*sourceCidrBlock);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("DestinationPortRange") != m.end() && !m["DestinationPortRange"].empty()) {
      destinationPortRange = make_shared<string>(boost::any_cast<string>(m["DestinationPortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SourceCidrBlock") != m.end() && !m["SourceCidrBlock"].empty()) {
      sourceCidrBlock = make_shared<string>(boost::any_cast<string>(m["SourceCidrBlock"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
  }


  virtual ~CreateTrafficMirrorFilterRequestEgressRules() = default;
};
class CreateTrafficMirrorFilterRequestIngressRules : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> destinationPortRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> protocol{};
  shared_ptr<string> sourceCidrBlock{};
  shared_ptr<string> sourcePortRange{};

  CreateTrafficMirrorFilterRequestIngressRules() {}

  explicit CreateTrafficMirrorFilterRequestIngressRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (destinationPortRange) {
      res["DestinationPortRange"] = boost::any(*destinationPortRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (sourceCidrBlock) {
      res["SourceCidrBlock"] = boost::any(*sourceCidrBlock);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("DestinationPortRange") != m.end() && !m["DestinationPortRange"].empty()) {
      destinationPortRange = make_shared<string>(boost::any_cast<string>(m["DestinationPortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SourceCidrBlock") != m.end() && !m["SourceCidrBlock"].empty()) {
      sourceCidrBlock = make_shared<string>(boost::any_cast<string>(m["SourceCidrBlock"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
  }


  virtual ~CreateTrafficMirrorFilterRequestIngressRules() = default;
};
class CreateTrafficMirrorFilterRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateTrafficMirrorFilterRequestTag() {}

  explicit CreateTrafficMirrorFilterRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateTrafficMirrorFilterRequestTag() = default;
};
class CreateTrafficMirrorFilterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<CreateTrafficMirrorFilterRequestEgressRules>> egressRules{};
  shared_ptr<vector<CreateTrafficMirrorFilterRequestIngressRules>> ingressRules{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateTrafficMirrorFilterRequestTag>> tag{};
  shared_ptr<string> trafficMirrorFilterDescription{};
  shared_ptr<string> trafficMirrorFilterName{};

  CreateTrafficMirrorFilterRequest() {}

  explicit CreateTrafficMirrorFilterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (egressRules) {
      vector<boost::any> temp1;
      for(auto item1:*egressRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EgressRules"] = boost::any(temp1);
    }
    if (ingressRules) {
      vector<boost::any> temp1;
      for(auto item1:*ingressRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IngressRules"] = boost::any(temp1);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (trafficMirrorFilterDescription) {
      res["TrafficMirrorFilterDescription"] = boost::any(*trafficMirrorFilterDescription);
    }
    if (trafficMirrorFilterName) {
      res["TrafficMirrorFilterName"] = boost::any(*trafficMirrorFilterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EgressRules") != m.end() && !m["EgressRules"].empty()) {
      if (typeid(vector<boost::any>) == m["EgressRules"].type()) {
        vector<CreateTrafficMirrorFilterRequestEgressRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EgressRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTrafficMirrorFilterRequestEgressRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        egressRules = make_shared<vector<CreateTrafficMirrorFilterRequestEgressRules>>(expect1);
      }
    }
    if (m.find("IngressRules") != m.end() && !m["IngressRules"].empty()) {
      if (typeid(vector<boost::any>) == m["IngressRules"].type()) {
        vector<CreateTrafficMirrorFilterRequestIngressRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IngressRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTrafficMirrorFilterRequestIngressRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ingressRules = make_shared<vector<CreateTrafficMirrorFilterRequestIngressRules>>(expect1);
      }
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateTrafficMirrorFilterRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTrafficMirrorFilterRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateTrafficMirrorFilterRequestTag>>(expect1);
      }
    }
    if (m.find("TrafficMirrorFilterDescription") != m.end() && !m["TrafficMirrorFilterDescription"].empty()) {
      trafficMirrorFilterDescription = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterDescription"]));
    }
    if (m.find("TrafficMirrorFilterName") != m.end() && !m["TrafficMirrorFilterName"].empty()) {
      trafficMirrorFilterName = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterName"]));
    }
  }


  virtual ~CreateTrafficMirrorFilterRequest() = default;
};
class CreateTrafficMirrorFilterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> trafficMirrorFilterId{};

  CreateTrafficMirrorFilterResponseBody() {}

  explicit CreateTrafficMirrorFilterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (trafficMirrorFilterId) {
      res["TrafficMirrorFilterId"] = boost::any(*trafficMirrorFilterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("TrafficMirrorFilterId") != m.end() && !m["TrafficMirrorFilterId"].empty()) {
      trafficMirrorFilterId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterId"]));
    }
  }


  virtual ~CreateTrafficMirrorFilterResponseBody() = default;
};
class CreateTrafficMirrorFilterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTrafficMirrorFilterResponseBody> body{};

  CreateTrafficMirrorFilterResponse() {}

  explicit CreateTrafficMirrorFilterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTrafficMirrorFilterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTrafficMirrorFilterResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTrafficMirrorFilterResponse() = default;
};
class CreateTrafficMirrorFilterRulesRequestEgressRules : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> destinationPortRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> protocol{};
  shared_ptr<string> sourceCidrBlock{};
  shared_ptr<string> sourcePortRange{};

  CreateTrafficMirrorFilterRulesRequestEgressRules() {}

  explicit CreateTrafficMirrorFilterRulesRequestEgressRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (destinationPortRange) {
      res["DestinationPortRange"] = boost::any(*destinationPortRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (sourceCidrBlock) {
      res["SourceCidrBlock"] = boost::any(*sourceCidrBlock);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("DestinationPortRange") != m.end() && !m["DestinationPortRange"].empty()) {
      destinationPortRange = make_shared<string>(boost::any_cast<string>(m["DestinationPortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SourceCidrBlock") != m.end() && !m["SourceCidrBlock"].empty()) {
      sourceCidrBlock = make_shared<string>(boost::any_cast<string>(m["SourceCidrBlock"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
  }


  virtual ~CreateTrafficMirrorFilterRulesRequestEgressRules() = default;
};
class CreateTrafficMirrorFilterRulesRequestIngressRules : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> destinationPortRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> protocol{};
  shared_ptr<string> sourceCidrBlock{};
  shared_ptr<string> sourcePortRange{};

  CreateTrafficMirrorFilterRulesRequestIngressRules() {}

  explicit CreateTrafficMirrorFilterRulesRequestIngressRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (destinationPortRange) {
      res["DestinationPortRange"] = boost::any(*destinationPortRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (sourceCidrBlock) {
      res["SourceCidrBlock"] = boost::any(*sourceCidrBlock);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("DestinationPortRange") != m.end() && !m["DestinationPortRange"].empty()) {
      destinationPortRange = make_shared<string>(boost::any_cast<string>(m["DestinationPortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SourceCidrBlock") != m.end() && !m["SourceCidrBlock"].empty()) {
      sourceCidrBlock = make_shared<string>(boost::any_cast<string>(m["SourceCidrBlock"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
  }


  virtual ~CreateTrafficMirrorFilterRulesRequestIngressRules() = default;
};
class CreateTrafficMirrorFilterRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<CreateTrafficMirrorFilterRulesRequestEgressRules>> egressRules{};
  shared_ptr<vector<CreateTrafficMirrorFilterRulesRequestIngressRules>> ingressRules{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> trafficMirrorFilterId{};

  CreateTrafficMirrorFilterRulesRequest() {}

  explicit CreateTrafficMirrorFilterRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (egressRules) {
      vector<boost::any> temp1;
      for(auto item1:*egressRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EgressRules"] = boost::any(temp1);
    }
    if (ingressRules) {
      vector<boost::any> temp1;
      for(auto item1:*ingressRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IngressRules"] = boost::any(temp1);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (trafficMirrorFilterId) {
      res["TrafficMirrorFilterId"] = boost::any(*trafficMirrorFilterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EgressRules") != m.end() && !m["EgressRules"].empty()) {
      if (typeid(vector<boost::any>) == m["EgressRules"].type()) {
        vector<CreateTrafficMirrorFilterRulesRequestEgressRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EgressRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTrafficMirrorFilterRulesRequestEgressRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        egressRules = make_shared<vector<CreateTrafficMirrorFilterRulesRequestEgressRules>>(expect1);
      }
    }
    if (m.find("IngressRules") != m.end() && !m["IngressRules"].empty()) {
      if (typeid(vector<boost::any>) == m["IngressRules"].type()) {
        vector<CreateTrafficMirrorFilterRulesRequestIngressRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IngressRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTrafficMirrorFilterRulesRequestIngressRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ingressRules = make_shared<vector<CreateTrafficMirrorFilterRulesRequestIngressRules>>(expect1);
      }
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TrafficMirrorFilterId") != m.end() && !m["TrafficMirrorFilterId"].empty()) {
      trafficMirrorFilterId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterId"]));
    }
  }


  virtual ~CreateTrafficMirrorFilterRulesRequest() = default;
};
class CreateTrafficMirrorFilterRulesResponseBodyEgressRules : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  CreateTrafficMirrorFilterRulesResponseBodyEgressRules() {}

  explicit CreateTrafficMirrorFilterRulesResponseBodyEgressRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateTrafficMirrorFilterRulesResponseBodyEgressRules() = default;
};
class CreateTrafficMirrorFilterRulesResponseBodyIngressRules : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  CreateTrafficMirrorFilterRulesResponseBodyIngressRules() {}

  explicit CreateTrafficMirrorFilterRulesResponseBodyIngressRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateTrafficMirrorFilterRulesResponseBodyIngressRules() = default;
};
class CreateTrafficMirrorFilterRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<CreateTrafficMirrorFilterRulesResponseBodyEgressRules>> egressRules{};
  shared_ptr<vector<CreateTrafficMirrorFilterRulesResponseBodyIngressRules>> ingressRules{};
  shared_ptr<string> requestId{};

  CreateTrafficMirrorFilterRulesResponseBody() {}

  explicit CreateTrafficMirrorFilterRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (egressRules) {
      vector<boost::any> temp1;
      for(auto item1:*egressRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EgressRules"] = boost::any(temp1);
    }
    if (ingressRules) {
      vector<boost::any> temp1;
      for(auto item1:*ingressRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IngressRules"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EgressRules") != m.end() && !m["EgressRules"].empty()) {
      if (typeid(vector<boost::any>) == m["EgressRules"].type()) {
        vector<CreateTrafficMirrorFilterRulesResponseBodyEgressRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EgressRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTrafficMirrorFilterRulesResponseBodyEgressRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        egressRules = make_shared<vector<CreateTrafficMirrorFilterRulesResponseBodyEgressRules>>(expect1);
      }
    }
    if (m.find("IngressRules") != m.end() && !m["IngressRules"].empty()) {
      if (typeid(vector<boost::any>) == m["IngressRules"].type()) {
        vector<CreateTrafficMirrorFilterRulesResponseBodyIngressRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IngressRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTrafficMirrorFilterRulesResponseBodyIngressRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ingressRules = make_shared<vector<CreateTrafficMirrorFilterRulesResponseBodyIngressRules>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateTrafficMirrorFilterRulesResponseBody() = default;
};
class CreateTrafficMirrorFilterRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTrafficMirrorFilterRulesResponseBody> body{};

  CreateTrafficMirrorFilterRulesResponse() {}

  explicit CreateTrafficMirrorFilterRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTrafficMirrorFilterRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTrafficMirrorFilterRulesResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTrafficMirrorFilterRulesResponse() = default;
};
class CreateTrafficMirrorSessionRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateTrafficMirrorSessionRequestTag() {}

  explicit CreateTrafficMirrorSessionRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateTrafficMirrorSessionRequestTag() = default;
};
class CreateTrafficMirrorSessionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> packetLength{};
  shared_ptr<long> priority{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateTrafficMirrorSessionRequestTag>> tag{};
  shared_ptr<string> trafficMirrorFilterId{};
  shared_ptr<string> trafficMirrorSessionDescription{};
  shared_ptr<string> trafficMirrorSessionName{};
  shared_ptr<vector<string>> trafficMirrorSourceIds{};
  shared_ptr<string> trafficMirrorTargetId{};
  shared_ptr<string> trafficMirrorTargetType{};
  shared_ptr<long> virtualNetworkId{};

  CreateTrafficMirrorSessionRequest() {}

  explicit CreateTrafficMirrorSessionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (packetLength) {
      res["PacketLength"] = boost::any(*packetLength);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (trafficMirrorFilterId) {
      res["TrafficMirrorFilterId"] = boost::any(*trafficMirrorFilterId);
    }
    if (trafficMirrorSessionDescription) {
      res["TrafficMirrorSessionDescription"] = boost::any(*trafficMirrorSessionDescription);
    }
    if (trafficMirrorSessionName) {
      res["TrafficMirrorSessionName"] = boost::any(*trafficMirrorSessionName);
    }
    if (trafficMirrorSourceIds) {
      res["TrafficMirrorSourceIds"] = boost::any(*trafficMirrorSourceIds);
    }
    if (trafficMirrorTargetId) {
      res["TrafficMirrorTargetId"] = boost::any(*trafficMirrorTargetId);
    }
    if (trafficMirrorTargetType) {
      res["TrafficMirrorTargetType"] = boost::any(*trafficMirrorTargetType);
    }
    if (virtualNetworkId) {
      res["VirtualNetworkId"] = boost::any(*virtualNetworkId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PacketLength") != m.end() && !m["PacketLength"].empty()) {
      packetLength = make_shared<long>(boost::any_cast<long>(m["PacketLength"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateTrafficMirrorSessionRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTrafficMirrorSessionRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateTrafficMirrorSessionRequestTag>>(expect1);
      }
    }
    if (m.find("TrafficMirrorFilterId") != m.end() && !m["TrafficMirrorFilterId"].empty()) {
      trafficMirrorFilterId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterId"]));
    }
    if (m.find("TrafficMirrorSessionDescription") != m.end() && !m["TrafficMirrorSessionDescription"].empty()) {
      trafficMirrorSessionDescription = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorSessionDescription"]));
    }
    if (m.find("TrafficMirrorSessionName") != m.end() && !m["TrafficMirrorSessionName"].empty()) {
      trafficMirrorSessionName = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorSessionName"]));
    }
    if (m.find("TrafficMirrorSourceIds") != m.end() && !m["TrafficMirrorSourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TrafficMirrorSourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TrafficMirrorSourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      trafficMirrorSourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TrafficMirrorTargetId") != m.end() && !m["TrafficMirrorTargetId"].empty()) {
      trafficMirrorTargetId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorTargetId"]));
    }
    if (m.find("TrafficMirrorTargetType") != m.end() && !m["TrafficMirrorTargetType"].empty()) {
      trafficMirrorTargetType = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorTargetType"]));
    }
    if (m.find("VirtualNetworkId") != m.end() && !m["VirtualNetworkId"].empty()) {
      virtualNetworkId = make_shared<long>(boost::any_cast<long>(m["VirtualNetworkId"]));
    }
  }


  virtual ~CreateTrafficMirrorSessionRequest() = default;
};
class CreateTrafficMirrorSessionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> trafficMirrorSessionId{};

  CreateTrafficMirrorSessionResponseBody() {}

  explicit CreateTrafficMirrorSessionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (trafficMirrorSessionId) {
      res["TrafficMirrorSessionId"] = boost::any(*trafficMirrorSessionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("TrafficMirrorSessionId") != m.end() && !m["TrafficMirrorSessionId"].empty()) {
      trafficMirrorSessionId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorSessionId"]));
    }
  }


  virtual ~CreateTrafficMirrorSessionResponseBody() = default;
};
class CreateTrafficMirrorSessionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTrafficMirrorSessionResponseBody> body{};

  CreateTrafficMirrorSessionResponse() {}

  explicit CreateTrafficMirrorSessionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTrafficMirrorSessionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTrafficMirrorSessionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTrafficMirrorSessionResponse() = default;
};
class CreateVSwitchRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateVSwitchRequestTag() {}

  explicit CreateVSwitchRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateVSwitchRequestTag() = default;
};
class CreateVSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<long> ipv6CidrBlock{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateVSwitchRequestTag>> tag{};
  shared_ptr<string> vSwitchName{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcIpv6CidrBlock{};
  shared_ptr<string> zoneId{};

  CreateVSwitchRequest() {}

  explicit CreateVSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipv6CidrBlock) {
      res["Ipv6CidrBlock"] = boost::any(*ipv6CidrBlock);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcIpv6CidrBlock) {
      res["VpcIpv6CidrBlock"] = boost::any(*vpcIpv6CidrBlock);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Ipv6CidrBlock") != m.end() && !m["Ipv6CidrBlock"].empty()) {
      ipv6CidrBlock = make_shared<long>(boost::any_cast<long>(m["Ipv6CidrBlock"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateVSwitchRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateVSwitchRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateVSwitchRequestTag>>(expect1);
      }
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcIpv6CidrBlock") != m.end() && !m["VpcIpv6CidrBlock"].empty()) {
      vpcIpv6CidrBlock = make_shared<string>(boost::any_cast<string>(m["VpcIpv6CidrBlock"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateVSwitchRequest() = default;
};
class CreateVSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vSwitchId{};

  CreateVSwitchResponseBody() {}

  explicit CreateVSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateVSwitchResponseBody() = default;
};
class CreateVSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVSwitchResponseBody> body{};

  CreateVSwitchResponse() {}

  explicit CreateVSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVSwitchResponse() = default;
};
class CreateVSwitchCidrReservationRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateVSwitchCidrReservationRequestTag() {}

  explicit CreateVSwitchCidrReservationRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateVSwitchCidrReservationRequestTag() = default;
};
class CreateVSwitchCidrReservationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateVSwitchCidrReservationRequestTag>> tag{};
  shared_ptr<string> vSwitchCidrReservationCidr{};
  shared_ptr<string> vSwitchCidrReservationDescription{};
  shared_ptr<string> vSwitchCidrReservationMask{};
  shared_ptr<string> vSwitchCidrReservationName{};
  shared_ptr<string> vSwitchCidrReservationType{};
  shared_ptr<string> vSwitchId{};

  CreateVSwitchCidrReservationRequest() {}

  explicit CreateVSwitchCidrReservationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vSwitchCidrReservationCidr) {
      res["VSwitchCidrReservationCidr"] = boost::any(*vSwitchCidrReservationCidr);
    }
    if (vSwitchCidrReservationDescription) {
      res["VSwitchCidrReservationDescription"] = boost::any(*vSwitchCidrReservationDescription);
    }
    if (vSwitchCidrReservationMask) {
      res["VSwitchCidrReservationMask"] = boost::any(*vSwitchCidrReservationMask);
    }
    if (vSwitchCidrReservationName) {
      res["VSwitchCidrReservationName"] = boost::any(*vSwitchCidrReservationName);
    }
    if (vSwitchCidrReservationType) {
      res["VSwitchCidrReservationType"] = boost::any(*vSwitchCidrReservationType);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateVSwitchCidrReservationRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateVSwitchCidrReservationRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateVSwitchCidrReservationRequestTag>>(expect1);
      }
    }
    if (m.find("VSwitchCidrReservationCidr") != m.end() && !m["VSwitchCidrReservationCidr"].empty()) {
      vSwitchCidrReservationCidr = make_shared<string>(boost::any_cast<string>(m["VSwitchCidrReservationCidr"]));
    }
    if (m.find("VSwitchCidrReservationDescription") != m.end() && !m["VSwitchCidrReservationDescription"].empty()) {
      vSwitchCidrReservationDescription = make_shared<string>(boost::any_cast<string>(m["VSwitchCidrReservationDescription"]));
    }
    if (m.find("VSwitchCidrReservationMask") != m.end() && !m["VSwitchCidrReservationMask"].empty()) {
      vSwitchCidrReservationMask = make_shared<string>(boost::any_cast<string>(m["VSwitchCidrReservationMask"]));
    }
    if (m.find("VSwitchCidrReservationName") != m.end() && !m["VSwitchCidrReservationName"].empty()) {
      vSwitchCidrReservationName = make_shared<string>(boost::any_cast<string>(m["VSwitchCidrReservationName"]));
    }
    if (m.find("VSwitchCidrReservationType") != m.end() && !m["VSwitchCidrReservationType"].empty()) {
      vSwitchCidrReservationType = make_shared<string>(boost::any_cast<string>(m["VSwitchCidrReservationType"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateVSwitchCidrReservationRequest() = default;
};
class CreateVSwitchCidrReservationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vSwitchCidrReservationId{};

  CreateVSwitchCidrReservationResponseBody() {}

  explicit CreateVSwitchCidrReservationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vSwitchCidrReservationId) {
      res["VSwitchCidrReservationId"] = boost::any(*vSwitchCidrReservationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VSwitchCidrReservationId") != m.end() && !m["VSwitchCidrReservationId"].empty()) {
      vSwitchCidrReservationId = make_shared<string>(boost::any_cast<string>(m["VSwitchCidrReservationId"]));
    }
  }


  virtual ~CreateVSwitchCidrReservationResponseBody() = default;
};
class CreateVSwitchCidrReservationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVSwitchCidrReservationResponseBody> body{};

  CreateVSwitchCidrReservationResponse() {}

  explicit CreateVSwitchCidrReservationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVSwitchCidrReservationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVSwitchCidrReservationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVSwitchCidrReservationResponse() = default;
};
class CreateVbrHaRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> peerVbrId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vbrId{};

  CreateVbrHaRequest() {}

  explicit CreateVbrHaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (peerVbrId) {
      res["PeerVbrId"] = boost::any(*peerVbrId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PeerVbrId") != m.end() && !m["PeerVbrId"].empty()) {
      peerVbrId = make_shared<string>(boost::any_cast<string>(m["PeerVbrId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
  }


  virtual ~CreateVbrHaRequest() = default;
};
class CreateVbrHaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vbrHaId{};

  CreateVbrHaResponseBody() {}

  explicit CreateVbrHaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vbrHaId) {
      res["VbrHaId"] = boost::any(*vbrHaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VbrHaId") != m.end() && !m["VbrHaId"].empty()) {
      vbrHaId = make_shared<string>(boost::any_cast<string>(m["VbrHaId"]));
    }
  }


  virtual ~CreateVbrHaResponseBody() = default;
};
class CreateVbrHaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVbrHaResponseBody> body{};

  CreateVbrHaResponse() {}

  explicit CreateVbrHaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVbrHaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVbrHaResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVbrHaResponse() = default;
};
class CreateVcoRouteEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> overlayMode{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeDest{};
  shared_ptr<string> vpnConnectionId{};
  shared_ptr<long> weight{};

  CreateVcoRouteEntryRequest() {}

  explicit CreateVcoRouteEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (overlayMode) {
      res["OverlayMode"] = boost::any(*overlayMode);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeDest) {
      res["RouteDest"] = boost::any(*routeDest);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("OverlayMode") != m.end() && !m["OverlayMode"].empty()) {
      overlayMode = make_shared<string>(boost::any_cast<string>(m["OverlayMode"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteDest") != m.end() && !m["RouteDest"].empty()) {
      routeDest = make_shared<string>(boost::any_cast<string>(m["RouteDest"]));
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~CreateVcoRouteEntryRequest() = default;
};
class CreateVcoRouteEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> overlayMode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> routeDest{};
  shared_ptr<string> state{};
  shared_ptr<string> vpnConnectionId{};
  shared_ptr<long> weight{};

  CreateVcoRouteEntryResponseBody() {}

  explicit CreateVcoRouteEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (overlayMode) {
      res["OverlayMode"] = boost::any(*overlayMode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routeDest) {
      res["RouteDest"] = boost::any(*routeDest);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("OverlayMode") != m.end() && !m["OverlayMode"].empty()) {
      overlayMode = make_shared<string>(boost::any_cast<string>(m["OverlayMode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouteDest") != m.end() && !m["RouteDest"].empty()) {
      routeDest = make_shared<string>(boost::any_cast<string>(m["RouteDest"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~CreateVcoRouteEntryResponseBody() = default;
};
class CreateVcoRouteEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVcoRouteEntryResponseBody> body{};

  CreateVcoRouteEntryResponse() {}

  explicit CreateVcoRouteEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVcoRouteEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVcoRouteEntryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVcoRouteEntryResponse() = default;
};
class CreateVirtualBorderRouterRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateVirtualBorderRouterRequestTags() {}

  explicit CreateVirtualBorderRouterRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateVirtualBorderRouterRequestTags() = default;
};
class CreateVirtualBorderRouterRequest : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> circuitCode{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<bool> enableIpv6{};
  shared_ptr<string> localGatewayIp{};
  shared_ptr<string> localIpv6GatewayIp{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> peerGatewayIp{};
  shared_ptr<string> peerIpv6GatewayIp{};
  shared_ptr<string> peeringIpv6SubnetMask{};
  shared_ptr<string> peeringSubnetMask{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateVirtualBorderRouterRequestTags>> tags{};
  shared_ptr<long> vbrOwnerId{};
  shared_ptr<long> vlanId{};

  CreateVirtualBorderRouterRequest() {}

  explicit CreateVirtualBorderRouterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (circuitCode) {
      res["CircuitCode"] = boost::any(*circuitCode);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enableIpv6) {
      res["EnableIpv6"] = boost::any(*enableIpv6);
    }
    if (localGatewayIp) {
      res["LocalGatewayIp"] = boost::any(*localGatewayIp);
    }
    if (localIpv6GatewayIp) {
      res["LocalIpv6GatewayIp"] = boost::any(*localIpv6GatewayIp);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (peerGatewayIp) {
      res["PeerGatewayIp"] = boost::any(*peerGatewayIp);
    }
    if (peerIpv6GatewayIp) {
      res["PeerIpv6GatewayIp"] = boost::any(*peerIpv6GatewayIp);
    }
    if (peeringIpv6SubnetMask) {
      res["PeeringIpv6SubnetMask"] = boost::any(*peeringIpv6SubnetMask);
    }
    if (peeringSubnetMask) {
      res["PeeringSubnetMask"] = boost::any(*peeringSubnetMask);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (vbrOwnerId) {
      res["VbrOwnerId"] = boost::any(*vbrOwnerId);
    }
    if (vlanId) {
      res["VlanId"] = boost::any(*vlanId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("CircuitCode") != m.end() && !m["CircuitCode"].empty()) {
      circuitCode = make_shared<string>(boost::any_cast<string>(m["CircuitCode"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnableIpv6") != m.end() && !m["EnableIpv6"].empty()) {
      enableIpv6 = make_shared<bool>(boost::any_cast<bool>(m["EnableIpv6"]));
    }
    if (m.find("LocalGatewayIp") != m.end() && !m["LocalGatewayIp"].empty()) {
      localGatewayIp = make_shared<string>(boost::any_cast<string>(m["LocalGatewayIp"]));
    }
    if (m.find("LocalIpv6GatewayIp") != m.end() && !m["LocalIpv6GatewayIp"].empty()) {
      localIpv6GatewayIp = make_shared<string>(boost::any_cast<string>(m["LocalIpv6GatewayIp"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PeerGatewayIp") != m.end() && !m["PeerGatewayIp"].empty()) {
      peerGatewayIp = make_shared<string>(boost::any_cast<string>(m["PeerGatewayIp"]));
    }
    if (m.find("PeerIpv6GatewayIp") != m.end() && !m["PeerIpv6GatewayIp"].empty()) {
      peerIpv6GatewayIp = make_shared<string>(boost::any_cast<string>(m["PeerIpv6GatewayIp"]));
    }
    if (m.find("PeeringIpv6SubnetMask") != m.end() && !m["PeeringIpv6SubnetMask"].empty()) {
      peeringIpv6SubnetMask = make_shared<string>(boost::any_cast<string>(m["PeeringIpv6SubnetMask"]));
    }
    if (m.find("PeeringSubnetMask") != m.end() && !m["PeeringSubnetMask"].empty()) {
      peeringSubnetMask = make_shared<string>(boost::any_cast<string>(m["PeeringSubnetMask"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreateVirtualBorderRouterRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateVirtualBorderRouterRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateVirtualBorderRouterRequestTags>>(expect1);
      }
    }
    if (m.find("VbrOwnerId") != m.end() && !m["VbrOwnerId"].empty()) {
      vbrOwnerId = make_shared<long>(boost::any_cast<long>(m["VbrOwnerId"]));
    }
    if (m.find("VlanId") != m.end() && !m["VlanId"].empty()) {
      vlanId = make_shared<long>(boost::any_cast<long>(m["VlanId"]));
    }
  }


  virtual ~CreateVirtualBorderRouterRequest() = default;
};
class CreateVirtualBorderRouterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vbrId{};

  CreateVirtualBorderRouterResponseBody() {}

  explicit CreateVirtualBorderRouterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
  }


  virtual ~CreateVirtualBorderRouterResponseBody() = default;
};
class CreateVirtualBorderRouterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVirtualBorderRouterResponseBody> body{};

  CreateVirtualBorderRouterResponse() {}

  explicit CreateVirtualBorderRouterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVirtualBorderRouterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVirtualBorderRouterResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVirtualBorderRouterResponse() = default;
};
class CreateVirtualPhysicalConnectionRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateVirtualPhysicalConnectionRequestTag() {}

  explicit CreateVirtualPhysicalConnectionRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateVirtualPhysicalConnectionRequestTag() = default;
};
class CreateVirtualPhysicalConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> name{};
  shared_ptr<string> orderMode{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> spec{};
  shared_ptr<vector<CreateVirtualPhysicalConnectionRequestTag>> tag{};
  shared_ptr<string> token{};
  shared_ptr<long> vlanId{};
  shared_ptr<long> vpconnAliUid{};

  CreateVirtualPhysicalConnectionRequest() {}

  explicit CreateVirtualPhysicalConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (orderMode) {
      res["OrderMode"] = boost::any(*orderMode);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (vlanId) {
      res["VlanId"] = boost::any(*vlanId);
    }
    if (vpconnAliUid) {
      res["VpconnAliUid"] = boost::any(*vpconnAliUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrderMode") != m.end() && !m["OrderMode"].empty()) {
      orderMode = make_shared<string>(boost::any_cast<string>(m["OrderMode"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateVirtualPhysicalConnectionRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateVirtualPhysicalConnectionRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateVirtualPhysicalConnectionRequestTag>>(expect1);
      }
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("VlanId") != m.end() && !m["VlanId"].empty()) {
      vlanId = make_shared<long>(boost::any_cast<long>(m["VlanId"]));
    }
    if (m.find("VpconnAliUid") != m.end() && !m["VpconnAliUid"].empty()) {
      vpconnAliUid = make_shared<long>(boost::any_cast<long>(m["VpconnAliUid"]));
    }
  }


  virtual ~CreateVirtualPhysicalConnectionRequest() = default;
};
class CreateVirtualPhysicalConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> virtualPhysicalConnection{};

  CreateVirtualPhysicalConnectionResponseBody() {}

  explicit CreateVirtualPhysicalConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (virtualPhysicalConnection) {
      res["VirtualPhysicalConnection"] = boost::any(*virtualPhysicalConnection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VirtualPhysicalConnection") != m.end() && !m["VirtualPhysicalConnection"].empty()) {
      virtualPhysicalConnection = make_shared<string>(boost::any_cast<string>(m["VirtualPhysicalConnection"]));
    }
  }


  virtual ~CreateVirtualPhysicalConnectionResponseBody() = default;
};
class CreateVirtualPhysicalConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVirtualPhysicalConnectionResponseBody> body{};

  CreateVirtualPhysicalConnectionResponse() {}

  explicit CreateVirtualPhysicalConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVirtualPhysicalConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVirtualPhysicalConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVirtualPhysicalConnectionResponse() = default;
};
class CreateVpcRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateVpcRequestTag() {}

  explicit CreateVpcRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateVpcRequestTag() = default;
};
class CreateVpcRequest : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<bool> dryRun{};
  shared_ptr<bool> enableIpv6{};
  shared_ptr<long> ipv4CidrMask{};
  shared_ptr<string> ipv4IpamPoolId{};
  shared_ptr<string> ipv6CidrBlock{};
  shared_ptr<string> ipv6Isp{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateVpcRequestTag>> tag{};
  shared_ptr<string> userCidr{};
  shared_ptr<string> vpcName{};

  CreateVpcRequest() {}

  explicit CreateVpcRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (enableIpv6) {
      res["EnableIpv6"] = boost::any(*enableIpv6);
    }
    if (ipv4CidrMask) {
      res["Ipv4CidrMask"] = boost::any(*ipv4CidrMask);
    }
    if (ipv4IpamPoolId) {
      res["Ipv4IpamPoolId"] = boost::any(*ipv4IpamPoolId);
    }
    if (ipv6CidrBlock) {
      res["Ipv6CidrBlock"] = boost::any(*ipv6CidrBlock);
    }
    if (ipv6Isp) {
      res["Ipv6Isp"] = boost::any(*ipv6Isp);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EnableIpv6") != m.end() && !m["EnableIpv6"].empty()) {
      enableIpv6 = make_shared<bool>(boost::any_cast<bool>(m["EnableIpv6"]));
    }
    if (m.find("Ipv4CidrMask") != m.end() && !m["Ipv4CidrMask"].empty()) {
      ipv4CidrMask = make_shared<long>(boost::any_cast<long>(m["Ipv4CidrMask"]));
    }
    if (m.find("Ipv4IpamPoolId") != m.end() && !m["Ipv4IpamPoolId"].empty()) {
      ipv4IpamPoolId = make_shared<string>(boost::any_cast<string>(m["Ipv4IpamPoolId"]));
    }
    if (m.find("Ipv6CidrBlock") != m.end() && !m["Ipv6CidrBlock"].empty()) {
      ipv6CidrBlock = make_shared<string>(boost::any_cast<string>(m["Ipv6CidrBlock"]));
    }
    if (m.find("Ipv6Isp") != m.end() && !m["Ipv6Isp"].empty()) {
      ipv6Isp = make_shared<string>(boost::any_cast<string>(m["Ipv6Isp"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateVpcRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateVpcRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateVpcRequestTag>>(expect1);
      }
    }
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      userCidr = make_shared<string>(boost::any_cast<string>(m["UserCidr"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
  }


  virtual ~CreateVpcRequest() = default;
};
class CreateVpcResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> VRouterId{};
  shared_ptr<string> vpcId{};

  CreateVpcResponseBody() {}

  explicit CreateVpcResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (VRouterId) {
      res["VRouterId"] = boost::any(*VRouterId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("VRouterId") != m.end() && !m["VRouterId"].empty()) {
      VRouterId = make_shared<string>(boost::any_cast<string>(m["VRouterId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreateVpcResponseBody() = default;
};
class CreateVpcResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVpcResponseBody> body{};

  CreateVpcResponse() {}

  explicit CreateVpcResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVpcResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVpcResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVpcResponse() = default;
};
class CreateVpcGatewayEndpointRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateVpcGatewayEndpointRequestTag() {}

  explicit CreateVpcGatewayEndpointRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateVpcGatewayEndpointRequestTag() = default;
};
class CreateVpcGatewayEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> endpointDescription{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> policyDocument{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serviceName{};
  shared_ptr<vector<CreateVpcGatewayEndpointRequestTag>> tag{};
  shared_ptr<string> vpcId{};

  CreateVpcGatewayEndpointRequest() {}

  explicit CreateVpcGatewayEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (endpointDescription) {
      res["EndpointDescription"] = boost::any(*endpointDescription);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (policyDocument) {
      res["PolicyDocument"] = boost::any(*policyDocument);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EndpointDescription") != m.end() && !m["EndpointDescription"].empty()) {
      endpointDescription = make_shared<string>(boost::any_cast<string>(m["EndpointDescription"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PolicyDocument") != m.end() && !m["PolicyDocument"].empty()) {
      policyDocument = make_shared<string>(boost::any_cast<string>(m["PolicyDocument"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateVpcGatewayEndpointRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateVpcGatewayEndpointRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateVpcGatewayEndpointRequestTag>>(expect1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreateVpcGatewayEndpointRequest() = default;
};
class CreateVpcGatewayEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> serviceName{};

  CreateVpcGatewayEndpointResponseBody() {}

  explicit CreateVpcGatewayEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~CreateVpcGatewayEndpointResponseBody() = default;
};
class CreateVpcGatewayEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVpcGatewayEndpointResponseBody> body{};

  CreateVpcGatewayEndpointResponse() {}

  explicit CreateVpcGatewayEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVpcGatewayEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVpcGatewayEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVpcGatewayEndpointResponse() = default;
};
class CreateVpcPrefixListRequestPrefixListEntries : public Darabonba::Model {
public:
  shared_ptr<string> cidr{};
  shared_ptr<string> description{};

  CreateVpcPrefixListRequestPrefixListEntries() {}

  explicit CreateVpcPrefixListRequestPrefixListEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidr) {
      res["Cidr"] = boost::any(*cidr);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cidr") != m.end() && !m["Cidr"].empty()) {
      cidr = make_shared<string>(boost::any_cast<string>(m["Cidr"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~CreateVpcPrefixListRequestPrefixListEntries() = default;
};
class CreateVpcPrefixListRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateVpcPrefixListRequestTag() {}

  explicit CreateVpcPrefixListRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateVpcPrefixListRequestTag() = default;
};
class CreateVpcPrefixListRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ipVersion{};
  shared_ptr<long> maxEntries{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prefixListDescription{};
  shared_ptr<vector<CreateVpcPrefixListRequestPrefixListEntries>> prefixListEntries{};
  shared_ptr<string> prefixListName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateVpcPrefixListRequestTag>> tag{};

  CreateVpcPrefixListRequest() {}

  explicit CreateVpcPrefixListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (maxEntries) {
      res["MaxEntries"] = boost::any(*maxEntries);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prefixListDescription) {
      res["PrefixListDescription"] = boost::any(*prefixListDescription);
    }
    if (prefixListEntries) {
      vector<boost::any> temp1;
      for(auto item1:*prefixListEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrefixListEntries"] = boost::any(temp1);
    }
    if (prefixListName) {
      res["PrefixListName"] = boost::any(*prefixListName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("MaxEntries") != m.end() && !m["MaxEntries"].empty()) {
      maxEntries = make_shared<long>(boost::any_cast<long>(m["MaxEntries"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PrefixListDescription") != m.end() && !m["PrefixListDescription"].empty()) {
      prefixListDescription = make_shared<string>(boost::any_cast<string>(m["PrefixListDescription"]));
    }
    if (m.find("PrefixListEntries") != m.end() && !m["PrefixListEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["PrefixListEntries"].type()) {
        vector<CreateVpcPrefixListRequestPrefixListEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrefixListEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateVpcPrefixListRequestPrefixListEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        prefixListEntries = make_shared<vector<CreateVpcPrefixListRequestPrefixListEntries>>(expect1);
      }
    }
    if (m.find("PrefixListName") != m.end() && !m["PrefixListName"].empty()) {
      prefixListName = make_shared<string>(boost::any_cast<string>(m["PrefixListName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateVpcPrefixListRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateVpcPrefixListRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateVpcPrefixListRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateVpcPrefixListRequest() = default;
};
class CreateVpcPrefixListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> prefixListId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};

  CreateVpcPrefixListResponseBody() {}

  explicit CreateVpcPrefixListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prefixListId) {
      res["PrefixListId"] = boost::any(*prefixListId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrefixListId") != m.end() && !m["PrefixListId"].empty()) {
      prefixListId = make_shared<string>(boost::any_cast<string>(m["PrefixListId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateVpcPrefixListResponseBody() = default;
};
class CreateVpcPrefixListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVpcPrefixListResponseBody> body{};

  CreateVpcPrefixListResponse() {}

  explicit CreateVpcPrefixListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVpcPrefixListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVpcPrefixListResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVpcPrefixListResponse() = default;
};
class CreateVpconnFromVbrRequest : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<string> orderMode{};
  shared_ptr<string> regionId{};
  shared_ptr<string> token{};
  shared_ptr<string> vbrId{};

  CreateVpconnFromVbrRequest() {}

  explicit CreateVpconnFromVbrRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (orderMode) {
      res["OrderMode"] = boost::any(*orderMode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OrderMode") != m.end() && !m["OrderMode"].empty()) {
      orderMode = make_shared<string>(boost::any_cast<string>(m["OrderMode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
  }


  virtual ~CreateVpconnFromVbrRequest() = default;
};
class CreateVpconnFromVbrResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> virtualPhysicalConnection{};

  CreateVpconnFromVbrResponseBody() {}

  explicit CreateVpconnFromVbrResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (virtualPhysicalConnection) {
      res["VirtualPhysicalConnection"] = boost::any(*virtualPhysicalConnection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VirtualPhysicalConnection") != m.end() && !m["VirtualPhysicalConnection"].empty()) {
      virtualPhysicalConnection = make_shared<string>(boost::any_cast<string>(m["VirtualPhysicalConnection"]));
    }
  }


  virtual ~CreateVpconnFromVbrResponseBody() = default;
};
class CreateVpconnFromVbrResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVpconnFromVbrResponseBody> body{};

  CreateVpconnFromVbrResponse() {}

  explicit CreateVpconnFromVbrResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVpconnFromVbrResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVpconnFromVbrResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVpconnFromVbrResponse() = default;
};
class CreateVpnAttachmentRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateVpnAttachmentRequestTags() {}

  explicit CreateVpnAttachmentRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateVpnAttachmentRequestTags() = default;
};
class CreateVpnAttachmentRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoConfigRoute{};
  shared_ptr<string> bgpConfig{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> customerGatewayId{};
  shared_ptr<bool> effectImmediately{};
  shared_ptr<bool> enableDpd{};
  shared_ptr<bool> enableNatTraversal{};
  shared_ptr<string> healthCheckConfig{};
  shared_ptr<string> ikeConfig{};
  shared_ptr<string> ipsecConfig{};
  shared_ptr<string> localSubnet{};
  shared_ptr<string> name{};
  shared_ptr<string> networkType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> remoteCaCert{};
  shared_ptr<string> remoteSubnet{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateVpnAttachmentRequestTags>> tags{};

  CreateVpnAttachmentRequest() {}

  explicit CreateVpnAttachmentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoConfigRoute) {
      res["AutoConfigRoute"] = boost::any(*autoConfigRoute);
    }
    if (bgpConfig) {
      res["BgpConfig"] = boost::any(*bgpConfig);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (effectImmediately) {
      res["EffectImmediately"] = boost::any(*effectImmediately);
    }
    if (enableDpd) {
      res["EnableDpd"] = boost::any(*enableDpd);
    }
    if (enableNatTraversal) {
      res["EnableNatTraversal"] = boost::any(*enableNatTraversal);
    }
    if (healthCheckConfig) {
      res["HealthCheckConfig"] = boost::any(*healthCheckConfig);
    }
    if (ikeConfig) {
      res["IkeConfig"] = boost::any(*ikeConfig);
    }
    if (ipsecConfig) {
      res["IpsecConfig"] = boost::any(*ipsecConfig);
    }
    if (localSubnet) {
      res["LocalSubnet"] = boost::any(*localSubnet);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (remoteCaCert) {
      res["RemoteCaCert"] = boost::any(*remoteCaCert);
    }
    if (remoteSubnet) {
      res["RemoteSubnet"] = boost::any(*remoteSubnet);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoConfigRoute") != m.end() && !m["AutoConfigRoute"].empty()) {
      autoConfigRoute = make_shared<bool>(boost::any_cast<bool>(m["AutoConfigRoute"]));
    }
    if (m.find("BgpConfig") != m.end() && !m["BgpConfig"].empty()) {
      bgpConfig = make_shared<string>(boost::any_cast<string>(m["BgpConfig"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("EffectImmediately") != m.end() && !m["EffectImmediately"].empty()) {
      effectImmediately = make_shared<bool>(boost::any_cast<bool>(m["EffectImmediately"]));
    }
    if (m.find("EnableDpd") != m.end() && !m["EnableDpd"].empty()) {
      enableDpd = make_shared<bool>(boost::any_cast<bool>(m["EnableDpd"]));
    }
    if (m.find("EnableNatTraversal") != m.end() && !m["EnableNatTraversal"].empty()) {
      enableNatTraversal = make_shared<bool>(boost::any_cast<bool>(m["EnableNatTraversal"]));
    }
    if (m.find("HealthCheckConfig") != m.end() && !m["HealthCheckConfig"].empty()) {
      healthCheckConfig = make_shared<string>(boost::any_cast<string>(m["HealthCheckConfig"]));
    }
    if (m.find("IkeConfig") != m.end() && !m["IkeConfig"].empty()) {
      ikeConfig = make_shared<string>(boost::any_cast<string>(m["IkeConfig"]));
    }
    if (m.find("IpsecConfig") != m.end() && !m["IpsecConfig"].empty()) {
      ipsecConfig = make_shared<string>(boost::any_cast<string>(m["IpsecConfig"]));
    }
    if (m.find("LocalSubnet") != m.end() && !m["LocalSubnet"].empty()) {
      localSubnet = make_shared<string>(boost::any_cast<string>(m["LocalSubnet"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemoteCaCert") != m.end() && !m["RemoteCaCert"].empty()) {
      remoteCaCert = make_shared<string>(boost::any_cast<string>(m["RemoteCaCert"]));
    }
    if (m.find("RemoteSubnet") != m.end() && !m["RemoteSubnet"].empty()) {
      remoteSubnet = make_shared<string>(boost::any_cast<string>(m["RemoteSubnet"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreateVpnAttachmentRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateVpnAttachmentRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateVpnAttachmentRequestTags>>(expect1);
      }
    }
  }


  virtual ~CreateVpnAttachmentRequest() = default;
};
class CreateVpnAttachmentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> createTime{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> vpnConnectionId{};

  CreateVpnAttachmentResponseBody() {}

  explicit CreateVpnAttachmentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
  }


  virtual ~CreateVpnAttachmentResponseBody() = default;
};
class CreateVpnAttachmentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVpnAttachmentResponseBody> body{};

  CreateVpnAttachmentResponse() {}

  explicit CreateVpnAttachmentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVpnAttachmentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVpnAttachmentResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVpnAttachmentResponse() = default;
};
class CreateVpnConnectionRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateVpnConnectionRequestTags() {}

  explicit CreateVpnConnectionRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateVpnConnectionRequestTags() = default;
};
class CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelBgpConfig : public Darabonba::Model {
public:
  shared_ptr<long> localAsn{};
  shared_ptr<string> localBgpIp{};
  shared_ptr<string> tunnelCidr{};

  CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelBgpConfig() {}

  explicit CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelBgpConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localAsn) {
      res["LocalAsn"] = boost::any(*localAsn);
    }
    if (localBgpIp) {
      res["LocalBgpIp"] = boost::any(*localBgpIp);
    }
    if (tunnelCidr) {
      res["TunnelCidr"] = boost::any(*tunnelCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalAsn") != m.end() && !m["LocalAsn"].empty()) {
      localAsn = make_shared<long>(boost::any_cast<long>(m["LocalAsn"]));
    }
    if (m.find("LocalBgpIp") != m.end() && !m["LocalBgpIp"].empty()) {
      localBgpIp = make_shared<string>(boost::any_cast<string>(m["LocalBgpIp"]));
    }
    if (m.find("TunnelCidr") != m.end() && !m["TunnelCidr"].empty()) {
      tunnelCidr = make_shared<string>(boost::any_cast<string>(m["TunnelCidr"]));
    }
  }


  virtual ~CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelBgpConfig() = default;
};
class CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig : public Darabonba::Model {
public:
  shared_ptr<string> ikeAuthAlg{};
  shared_ptr<string> ikeEncAlg{};
  shared_ptr<long> ikeLifetime{};
  shared_ptr<string> ikeMode{};
  shared_ptr<string> ikePfs{};
  shared_ptr<string> ikeVersion{};
  shared_ptr<string> localId{};
  shared_ptr<string> psk{};
  shared_ptr<string> remoteId{};

  CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig() {}

  explicit CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ikeAuthAlg) {
      res["IkeAuthAlg"] = boost::any(*ikeAuthAlg);
    }
    if (ikeEncAlg) {
      res["IkeEncAlg"] = boost::any(*ikeEncAlg);
    }
    if (ikeLifetime) {
      res["IkeLifetime"] = boost::any(*ikeLifetime);
    }
    if (ikeMode) {
      res["IkeMode"] = boost::any(*ikeMode);
    }
    if (ikePfs) {
      res["IkePfs"] = boost::any(*ikePfs);
    }
    if (ikeVersion) {
      res["IkeVersion"] = boost::any(*ikeVersion);
    }
    if (localId) {
      res["LocalId"] = boost::any(*localId);
    }
    if (psk) {
      res["Psk"] = boost::any(*psk);
    }
    if (remoteId) {
      res["RemoteId"] = boost::any(*remoteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IkeAuthAlg") != m.end() && !m["IkeAuthAlg"].empty()) {
      ikeAuthAlg = make_shared<string>(boost::any_cast<string>(m["IkeAuthAlg"]));
    }
    if (m.find("IkeEncAlg") != m.end() && !m["IkeEncAlg"].empty()) {
      ikeEncAlg = make_shared<string>(boost::any_cast<string>(m["IkeEncAlg"]));
    }
    if (m.find("IkeLifetime") != m.end() && !m["IkeLifetime"].empty()) {
      ikeLifetime = make_shared<long>(boost::any_cast<long>(m["IkeLifetime"]));
    }
    if (m.find("IkeMode") != m.end() && !m["IkeMode"].empty()) {
      ikeMode = make_shared<string>(boost::any_cast<string>(m["IkeMode"]));
    }
    if (m.find("IkePfs") != m.end() && !m["IkePfs"].empty()) {
      ikePfs = make_shared<string>(boost::any_cast<string>(m["IkePfs"]));
    }
    if (m.find("IkeVersion") != m.end() && !m["IkeVersion"].empty()) {
      ikeVersion = make_shared<string>(boost::any_cast<string>(m["IkeVersion"]));
    }
    if (m.find("LocalId") != m.end() && !m["LocalId"].empty()) {
      localId = make_shared<string>(boost::any_cast<string>(m["LocalId"]));
    }
    if (m.find("Psk") != m.end() && !m["Psk"].empty()) {
      psk = make_shared<string>(boost::any_cast<string>(m["Psk"]));
    }
    if (m.find("RemoteId") != m.end() && !m["RemoteId"].empty()) {
      remoteId = make_shared<string>(boost::any_cast<string>(m["RemoteId"]));
    }
  }


  virtual ~CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig() = default;
};
class CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig : public Darabonba::Model {
public:
  shared_ptr<string> ipsecAuthAlg{};
  shared_ptr<string> ipsecEncAlg{};
  shared_ptr<long> ipsecLifetime{};
  shared_ptr<string> ipsecPfs{};

  CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig() {}

  explicit CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipsecAuthAlg) {
      res["IpsecAuthAlg"] = boost::any(*ipsecAuthAlg);
    }
    if (ipsecEncAlg) {
      res["IpsecEncAlg"] = boost::any(*ipsecEncAlg);
    }
    if (ipsecLifetime) {
      res["IpsecLifetime"] = boost::any(*ipsecLifetime);
    }
    if (ipsecPfs) {
      res["IpsecPfs"] = boost::any(*ipsecPfs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpsecAuthAlg") != m.end() && !m["IpsecAuthAlg"].empty()) {
      ipsecAuthAlg = make_shared<string>(boost::any_cast<string>(m["IpsecAuthAlg"]));
    }
    if (m.find("IpsecEncAlg") != m.end() && !m["IpsecEncAlg"].empty()) {
      ipsecEncAlg = make_shared<string>(boost::any_cast<string>(m["IpsecEncAlg"]));
    }
    if (m.find("IpsecLifetime") != m.end() && !m["IpsecLifetime"].empty()) {
      ipsecLifetime = make_shared<long>(boost::any_cast<long>(m["IpsecLifetime"]));
    }
    if (m.find("IpsecPfs") != m.end() && !m["IpsecPfs"].empty()) {
      ipsecPfs = make_shared<string>(boost::any_cast<string>(m["IpsecPfs"]));
    }
  }


  virtual ~CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig() = default;
};
class CreateVpnConnectionRequestTunnelOptionsSpecification : public Darabonba::Model {
public:
  shared_ptr<string> customerGatewayId{};
  shared_ptr<bool> enableDpd{};
  shared_ptr<bool> enableNatTraversal{};
  shared_ptr<string> remoteCaCertificate{};
  shared_ptr<string> role{};
  shared_ptr<CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelBgpConfig> tunnelBgpConfig{};
  shared_ptr<CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig> tunnelIkeConfig{};
  shared_ptr<CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig> tunnelIpsecConfig{};

  CreateVpnConnectionRequestTunnelOptionsSpecification() {}

  explicit CreateVpnConnectionRequestTunnelOptionsSpecification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (enableDpd) {
      res["EnableDpd"] = boost::any(*enableDpd);
    }
    if (enableNatTraversal) {
      res["EnableNatTraversal"] = boost::any(*enableNatTraversal);
    }
    if (remoteCaCertificate) {
      res["RemoteCaCertificate"] = boost::any(*remoteCaCertificate);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (tunnelBgpConfig) {
      res["TunnelBgpConfig"] = tunnelBgpConfig ? boost::any(tunnelBgpConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tunnelIkeConfig) {
      res["TunnelIkeConfig"] = tunnelIkeConfig ? boost::any(tunnelIkeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tunnelIpsecConfig) {
      res["TunnelIpsecConfig"] = tunnelIpsecConfig ? boost::any(tunnelIpsecConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("EnableDpd") != m.end() && !m["EnableDpd"].empty()) {
      enableDpd = make_shared<bool>(boost::any_cast<bool>(m["EnableDpd"]));
    }
    if (m.find("EnableNatTraversal") != m.end() && !m["EnableNatTraversal"].empty()) {
      enableNatTraversal = make_shared<bool>(boost::any_cast<bool>(m["EnableNatTraversal"]));
    }
    if (m.find("RemoteCaCertificate") != m.end() && !m["RemoteCaCertificate"].empty()) {
      remoteCaCertificate = make_shared<string>(boost::any_cast<string>(m["RemoteCaCertificate"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("TunnelBgpConfig") != m.end() && !m["TunnelBgpConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelBgpConfig"].type()) {
        CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelBgpConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelBgpConfig"]));
        tunnelBgpConfig = make_shared<CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelBgpConfig>(model1);
      }
    }
    if (m.find("TunnelIkeConfig") != m.end() && !m["TunnelIkeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelIkeConfig"].type()) {
        CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelIkeConfig"]));
        tunnelIkeConfig = make_shared<CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIkeConfig>(model1);
      }
    }
    if (m.find("TunnelIpsecConfig") != m.end() && !m["TunnelIpsecConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelIpsecConfig"].type()) {
        CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelIpsecConfig"]));
        tunnelIpsecConfig = make_shared<CreateVpnConnectionRequestTunnelOptionsSpecificationTunnelIpsecConfig>(model1);
      }
    }
  }


  virtual ~CreateVpnConnectionRequestTunnelOptionsSpecification() = default;
};
class CreateVpnConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoConfigRoute{};
  shared_ptr<string> bgpConfig{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> customerGatewayId{};
  shared_ptr<bool> effectImmediately{};
  shared_ptr<bool> enableDpd{};
  shared_ptr<bool> enableNatTraversal{};
  shared_ptr<bool> enableTunnelsBgp{};
  shared_ptr<string> healthCheckConfig{};
  shared_ptr<string> ikeConfig{};
  shared_ptr<string> ipsecConfig{};
  shared_ptr<string> localSubnet{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> remoteCaCertificate{};
  shared_ptr<string> remoteSubnet{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<CreateVpnConnectionRequestTags>> tags{};
  shared_ptr<vector<CreateVpnConnectionRequestTunnelOptionsSpecification>> tunnelOptionsSpecification{};
  shared_ptr<string> vpnGatewayId{};

  CreateVpnConnectionRequest() {}

  explicit CreateVpnConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoConfigRoute) {
      res["AutoConfigRoute"] = boost::any(*autoConfigRoute);
    }
    if (bgpConfig) {
      res["BgpConfig"] = boost::any(*bgpConfig);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (effectImmediately) {
      res["EffectImmediately"] = boost::any(*effectImmediately);
    }
    if (enableDpd) {
      res["EnableDpd"] = boost::any(*enableDpd);
    }
    if (enableNatTraversal) {
      res["EnableNatTraversal"] = boost::any(*enableNatTraversal);
    }
    if (enableTunnelsBgp) {
      res["EnableTunnelsBgp"] = boost::any(*enableTunnelsBgp);
    }
    if (healthCheckConfig) {
      res["HealthCheckConfig"] = boost::any(*healthCheckConfig);
    }
    if (ikeConfig) {
      res["IkeConfig"] = boost::any(*ikeConfig);
    }
    if (ipsecConfig) {
      res["IpsecConfig"] = boost::any(*ipsecConfig);
    }
    if (localSubnet) {
      res["LocalSubnet"] = boost::any(*localSubnet);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (remoteCaCertificate) {
      res["RemoteCaCertificate"] = boost::any(*remoteCaCertificate);
    }
    if (remoteSubnet) {
      res["RemoteSubnet"] = boost::any(*remoteSubnet);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (tunnelOptionsSpecification) {
      vector<boost::any> temp1;
      for(auto item1:*tunnelOptionsSpecification){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TunnelOptionsSpecification"] = boost::any(temp1);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoConfigRoute") != m.end() && !m["AutoConfigRoute"].empty()) {
      autoConfigRoute = make_shared<bool>(boost::any_cast<bool>(m["AutoConfigRoute"]));
    }
    if (m.find("BgpConfig") != m.end() && !m["BgpConfig"].empty()) {
      bgpConfig = make_shared<string>(boost::any_cast<string>(m["BgpConfig"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("EffectImmediately") != m.end() && !m["EffectImmediately"].empty()) {
      effectImmediately = make_shared<bool>(boost::any_cast<bool>(m["EffectImmediately"]));
    }
    if (m.find("EnableDpd") != m.end() && !m["EnableDpd"].empty()) {
      enableDpd = make_shared<bool>(boost::any_cast<bool>(m["EnableDpd"]));
    }
    if (m.find("EnableNatTraversal") != m.end() && !m["EnableNatTraversal"].empty()) {
      enableNatTraversal = make_shared<bool>(boost::any_cast<bool>(m["EnableNatTraversal"]));
    }
    if (m.find("EnableTunnelsBgp") != m.end() && !m["EnableTunnelsBgp"].empty()) {
      enableTunnelsBgp = make_shared<bool>(boost::any_cast<bool>(m["EnableTunnelsBgp"]));
    }
    if (m.find("HealthCheckConfig") != m.end() && !m["HealthCheckConfig"].empty()) {
      healthCheckConfig = make_shared<string>(boost::any_cast<string>(m["HealthCheckConfig"]));
    }
    if (m.find("IkeConfig") != m.end() && !m["IkeConfig"].empty()) {
      ikeConfig = make_shared<string>(boost::any_cast<string>(m["IkeConfig"]));
    }
    if (m.find("IpsecConfig") != m.end() && !m["IpsecConfig"].empty()) {
      ipsecConfig = make_shared<string>(boost::any_cast<string>(m["IpsecConfig"]));
    }
    if (m.find("LocalSubnet") != m.end() && !m["LocalSubnet"].empty()) {
      localSubnet = make_shared<string>(boost::any_cast<string>(m["LocalSubnet"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemoteCaCertificate") != m.end() && !m["RemoteCaCertificate"].empty()) {
      remoteCaCertificate = make_shared<string>(boost::any_cast<string>(m["RemoteCaCertificate"]));
    }
    if (m.find("RemoteSubnet") != m.end() && !m["RemoteSubnet"].empty()) {
      remoteSubnet = make_shared<string>(boost::any_cast<string>(m["RemoteSubnet"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<CreateVpnConnectionRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateVpnConnectionRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<CreateVpnConnectionRequestTags>>(expect1);
      }
    }
    if (m.find("TunnelOptionsSpecification") != m.end() && !m["TunnelOptionsSpecification"].empty()) {
      if (typeid(vector<boost::any>) == m["TunnelOptionsSpecification"].type()) {
        vector<CreateVpnConnectionRequestTunnelOptionsSpecification> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TunnelOptionsSpecification"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateVpnConnectionRequestTunnelOptionsSpecification model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tunnelOptionsSpecification = make_shared<vector<CreateVpnConnectionRequestTunnelOptionsSpecification>>(expect1);
      }
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~CreateVpnConnectionRequest() = default;
};
class CreateVpnConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vpnConnectionId{};

  CreateVpnConnectionResponseBody() {}

  explicit CreateVpnConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
  }


  virtual ~CreateVpnConnectionResponseBody() = default;
};
class CreateVpnConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVpnConnectionResponseBody> body{};

  CreateVpnConnectionResponse() {}

  explicit CreateVpnConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVpnConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVpnConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVpnConnectionResponse() = default;
};
class CreateVpnGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> disasterRecoveryVSwitchId{};
  shared_ptr<bool> enableIpsec{};
  shared_ptr<bool> enableSsl{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> name{};
  shared_ptr<string> networkType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> period{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> sslConnections{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpnType{};

  CreateVpnGatewayRequest() {}

  explicit CreateVpnGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (disasterRecoveryVSwitchId) {
      res["DisasterRecoveryVSwitchId"] = boost::any(*disasterRecoveryVSwitchId);
    }
    if (enableIpsec) {
      res["EnableIpsec"] = boost::any(*enableIpsec);
    }
    if (enableSsl) {
      res["EnableSsl"] = boost::any(*enableSsl);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sslConnections) {
      res["SslConnections"] = boost::any(*sslConnections);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpnType) {
      res["VpnType"] = boost::any(*vpnType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DisasterRecoveryVSwitchId") != m.end() && !m["DisasterRecoveryVSwitchId"].empty()) {
      disasterRecoveryVSwitchId = make_shared<string>(boost::any_cast<string>(m["DisasterRecoveryVSwitchId"]));
    }
    if (m.find("EnableIpsec") != m.end() && !m["EnableIpsec"].empty()) {
      enableIpsec = make_shared<bool>(boost::any_cast<bool>(m["EnableIpsec"]));
    }
    if (m.find("EnableSsl") != m.end() && !m["EnableSsl"].empty()) {
      enableSsl = make_shared<bool>(boost::any_cast<bool>(m["EnableSsl"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SslConnections") != m.end() && !m["SslConnections"].empty()) {
      sslConnections = make_shared<long>(boost::any_cast<long>(m["SslConnections"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpnType") != m.end() && !m["VpnType"].empty()) {
      vpnType = make_shared<string>(boost::any_cast<string>(m["VpnType"]));
    }
  }


  virtual ~CreateVpnGatewayRequest() = default;
};
class CreateVpnGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> orderId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vpnGatewayId{};

  CreateVpnGatewayResponseBody() {}

  explicit CreateVpnGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~CreateVpnGatewayResponseBody() = default;
};
class CreateVpnGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVpnGatewayResponseBody> body{};

  CreateVpnGatewayResponse() {}

  explicit CreateVpnGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVpnGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVpnGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVpnGatewayResponse() = default;
};
class CreateVpnPbrRouteEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> overlayMode{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> priority{};
  shared_ptr<bool> publishVpc{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeDest{};
  shared_ptr<string> routeSource{};
  shared_ptr<string> vpnGatewayId{};
  shared_ptr<long> weight{};

  CreateVpnPbrRouteEntryRequest() {}

  explicit CreateVpnPbrRouteEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (overlayMode) {
      res["OverlayMode"] = boost::any(*overlayMode);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (publishVpc) {
      res["PublishVpc"] = boost::any(*publishVpc);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeDest) {
      res["RouteDest"] = boost::any(*routeDest);
    }
    if (routeSource) {
      res["RouteSource"] = boost::any(*routeSource);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("OverlayMode") != m.end() && !m["OverlayMode"].empty()) {
      overlayMode = make_shared<string>(boost::any_cast<string>(m["OverlayMode"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("PublishVpc") != m.end() && !m["PublishVpc"].empty()) {
      publishVpc = make_shared<bool>(boost::any_cast<bool>(m["PublishVpc"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteDest") != m.end() && !m["RouteDest"].empty()) {
      routeDest = make_shared<string>(boost::any_cast<string>(m["RouteDest"]));
    }
    if (m.find("RouteSource") != m.end() && !m["RouteSource"].empty()) {
      routeSource = make_shared<string>(boost::any_cast<string>(m["RouteSource"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~CreateVpnPbrRouteEntryRequest() = default;
};
class CreateVpnPbrRouteEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> overlayMode{};
  shared_ptr<long> priority{};
  shared_ptr<string> requestId{};
  shared_ptr<string> routeDest{};
  shared_ptr<string> routeSource{};
  shared_ptr<string> state{};
  shared_ptr<string> vpnInstanceId{};
  shared_ptr<long> weight{};

  CreateVpnPbrRouteEntryResponseBody() {}

  explicit CreateVpnPbrRouteEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (overlayMode) {
      res["OverlayMode"] = boost::any(*overlayMode);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routeDest) {
      res["RouteDest"] = boost::any(*routeDest);
    }
    if (routeSource) {
      res["RouteSource"] = boost::any(*routeSource);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (vpnInstanceId) {
      res["VpnInstanceId"] = boost::any(*vpnInstanceId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("OverlayMode") != m.end() && !m["OverlayMode"].empty()) {
      overlayMode = make_shared<string>(boost::any_cast<string>(m["OverlayMode"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouteDest") != m.end() && !m["RouteDest"].empty()) {
      routeDest = make_shared<string>(boost::any_cast<string>(m["RouteDest"]));
    }
    if (m.find("RouteSource") != m.end() && !m["RouteSource"].empty()) {
      routeSource = make_shared<string>(boost::any_cast<string>(m["RouteSource"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("VpnInstanceId") != m.end() && !m["VpnInstanceId"].empty()) {
      vpnInstanceId = make_shared<string>(boost::any_cast<string>(m["VpnInstanceId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~CreateVpnPbrRouteEntryResponseBody() = default;
};
class CreateVpnPbrRouteEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVpnPbrRouteEntryResponseBody> body{};

  CreateVpnPbrRouteEntryResponse() {}

  explicit CreateVpnPbrRouteEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVpnPbrRouteEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVpnPbrRouteEntryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVpnPbrRouteEntryResponse() = default;
};
class CreateVpnRouteEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> overlayMode{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<bool> publishVpc{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeDest{};
  shared_ptr<string> vpnGatewayId{};
  shared_ptr<long> weight{};

  CreateVpnRouteEntryRequest() {}

  explicit CreateVpnRouteEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (overlayMode) {
      res["OverlayMode"] = boost::any(*overlayMode);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (publishVpc) {
      res["PublishVpc"] = boost::any(*publishVpc);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeDest) {
      res["RouteDest"] = boost::any(*routeDest);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("OverlayMode") != m.end() && !m["OverlayMode"].empty()) {
      overlayMode = make_shared<string>(boost::any_cast<string>(m["OverlayMode"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PublishVpc") != m.end() && !m["PublishVpc"].empty()) {
      publishVpc = make_shared<bool>(boost::any_cast<bool>(m["PublishVpc"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteDest") != m.end() && !m["RouteDest"].empty()) {
      routeDest = make_shared<string>(boost::any_cast<string>(m["RouteDest"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~CreateVpnRouteEntryRequest() = default;
};
class CreateVpnRouteEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> overlayMode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> routeDest{};
  shared_ptr<string> state{};
  shared_ptr<string> vpnInstanceId{};
  shared_ptr<long> weight{};

  CreateVpnRouteEntryResponseBody() {}

  explicit CreateVpnRouteEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (overlayMode) {
      res["OverlayMode"] = boost::any(*overlayMode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routeDest) {
      res["RouteDest"] = boost::any(*routeDest);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (vpnInstanceId) {
      res["VpnInstanceId"] = boost::any(*vpnInstanceId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("OverlayMode") != m.end() && !m["OverlayMode"].empty()) {
      overlayMode = make_shared<string>(boost::any_cast<string>(m["OverlayMode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouteDest") != m.end() && !m["RouteDest"].empty()) {
      routeDest = make_shared<string>(boost::any_cast<string>(m["RouteDest"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("VpnInstanceId") != m.end() && !m["VpnInstanceId"].empty()) {
      vpnInstanceId = make_shared<string>(boost::any_cast<string>(m["VpnInstanceId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~CreateVpnRouteEntryResponseBody() = default;
};
class CreateVpnRouteEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVpnRouteEntryResponseBody> body{};

  CreateVpnRouteEntryResponse() {}

  explicit CreateVpnRouteEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVpnRouteEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVpnRouteEntryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVpnRouteEntryResponse() = default;
};
class DeactivateRouterInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routerInterfaceId{};

  DeactivateRouterInterfaceRequest() {}

  explicit DeactivateRouterInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routerInterfaceId) {
      res["RouterInterfaceId"] = boost::any(*routerInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouterInterfaceId") != m.end() && !m["RouterInterfaceId"].empty()) {
      routerInterfaceId = make_shared<string>(boost::any_cast<string>(m["RouterInterfaceId"]));
    }
  }


  virtual ~DeactivateRouterInterfaceRequest() = default;
};
class DeactivateRouterInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeactivateRouterInterfaceResponseBody() {}

  explicit DeactivateRouterInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeactivateRouterInterfaceResponseBody() = default;
};
class DeactivateRouterInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeactivateRouterInterfaceResponseBody> body{};

  DeactivateRouterInterfaceResponse() {}

  explicit DeactivateRouterInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeactivateRouterInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeactivateRouterInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~DeactivateRouterInterfaceResponse() = default;
};
class DeactiveFlowLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowLogId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeactiveFlowLogRequest() {}

  explicit DeactiveFlowLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowLogId) {
      res["FlowLogId"] = boost::any(*flowLogId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowLogId") != m.end() && !m["FlowLogId"].empty()) {
      flowLogId = make_shared<string>(boost::any_cast<string>(m["FlowLogId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeactiveFlowLogRequest() = default;
};
class DeactiveFlowLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DeactiveFlowLogResponseBody() {}

  explicit DeactiveFlowLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DeactiveFlowLogResponseBody() = default;
};
class DeactiveFlowLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeactiveFlowLogResponseBody> body{};

  DeactiveFlowLogResponse() {}

  explicit DeactiveFlowLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeactiveFlowLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeactiveFlowLogResponseBody>(model1);
      }
    }
  }


  virtual ~DeactiveFlowLogResponse() = default;
};
class DeleteBgpGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> bgpGroupId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteBgpGroupRequest() {}

  explicit DeleteBgpGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgpGroupId) {
      res["BgpGroupId"] = boost::any(*bgpGroupId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgpGroupId") != m.end() && !m["BgpGroupId"].empty()) {
      bgpGroupId = make_shared<string>(boost::any_cast<string>(m["BgpGroupId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteBgpGroupRequest() = default;
};
class DeleteBgpGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteBgpGroupResponseBody() {}

  explicit DeleteBgpGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBgpGroupResponseBody() = default;
};
class DeleteBgpGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBgpGroupResponseBody> body{};

  DeleteBgpGroupResponse() {}

  explicit DeleteBgpGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBgpGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBgpGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBgpGroupResponse() = default;
};
class DeleteBgpNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> dstCidrBlock{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routerId{};

  DeleteBgpNetworkRequest() {}

  explicit DeleteBgpNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dstCidrBlock) {
      res["DstCidrBlock"] = boost::any(*dstCidrBlock);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DstCidrBlock") != m.end() && !m["DstCidrBlock"].empty()) {
      dstCidrBlock = make_shared<string>(boost::any_cast<string>(m["DstCidrBlock"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
  }


  virtual ~DeleteBgpNetworkRequest() = default;
};
class DeleteBgpNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteBgpNetworkResponseBody() {}

  explicit DeleteBgpNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBgpNetworkResponseBody() = default;
};
class DeleteBgpNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBgpNetworkResponseBody> body{};

  DeleteBgpNetworkResponse() {}

  explicit DeleteBgpNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBgpNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBgpNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBgpNetworkResponse() = default;
};
class DeleteBgpPeerRequest : public Darabonba::Model {
public:
  shared_ptr<string> bgpPeerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteBgpPeerRequest() {}

  explicit DeleteBgpPeerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgpPeerId) {
      res["BgpPeerId"] = boost::any(*bgpPeerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgpPeerId") != m.end() && !m["BgpPeerId"].empty()) {
      bgpPeerId = make_shared<string>(boost::any_cast<string>(m["BgpPeerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteBgpPeerRequest() = default;
};
class DeleteBgpPeerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteBgpPeerResponseBody() {}

  explicit DeleteBgpPeerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBgpPeerResponseBody() = default;
};
class DeleteBgpPeerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBgpPeerResponseBody> body{};

  DeleteBgpPeerResponse() {}

  explicit DeleteBgpPeerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBgpPeerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBgpPeerResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBgpPeerResponse() = default;
};
class DeleteCommonBandwidthPackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> force{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteCommonBandwidthPackageRequest() {}

  explicit DeleteCommonBandwidthPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<string>(boost::any_cast<string>(m["Force"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteCommonBandwidthPackageRequest() = default;
};
class DeleteCommonBandwidthPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCommonBandwidthPackageResponseBody() {}

  explicit DeleteCommonBandwidthPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCommonBandwidthPackageResponseBody() = default;
};
class DeleteCommonBandwidthPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCommonBandwidthPackageResponseBody> body{};

  DeleteCommonBandwidthPackageResponse() {}

  explicit DeleteCommonBandwidthPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCommonBandwidthPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCommonBandwidthPackageResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCommonBandwidthPackageResponse() = default;
};
class DeleteCustomerGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> customerGatewayId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteCustomerGatewayRequest() {}

  explicit DeleteCustomerGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteCustomerGatewayRequest() = default;
};
class DeleteCustomerGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCustomerGatewayResponseBody() {}

  explicit DeleteCustomerGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCustomerGatewayResponseBody() = default;
};
class DeleteCustomerGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomerGatewayResponseBody> body{};

  DeleteCustomerGatewayResponse() {}

  explicit DeleteCustomerGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomerGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomerGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomerGatewayResponse() = default;
};
class DeleteDhcpOptionsSetRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> dhcpOptionsSetId{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteDhcpOptionsSetRequest() {}

  explicit DeleteDhcpOptionsSetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dhcpOptionsSetId) {
      res["DhcpOptionsSetId"] = boost::any(*dhcpOptionsSetId);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DhcpOptionsSetId") != m.end() && !m["DhcpOptionsSetId"].empty()) {
      dhcpOptionsSetId = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetId"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteDhcpOptionsSetRequest() = default;
};
class DeleteDhcpOptionsSetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDhcpOptionsSetResponseBody() {}

  explicit DeleteDhcpOptionsSetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDhcpOptionsSetResponseBody() = default;
};
class DeleteDhcpOptionsSetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDhcpOptionsSetResponseBody> body{};

  DeleteDhcpOptionsSetResponse() {}

  explicit DeleteDhcpOptionsSetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDhcpOptionsSetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDhcpOptionsSetResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDhcpOptionsSetResponse() = default;
};
class DeleteExpressConnectTrafficQosRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> qosId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};

  DeleteExpressConnectTrafficQosRequest() {}

  explicit DeleteExpressConnectTrafficQosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~DeleteExpressConnectTrafficQosRequest() = default;
};
class DeleteExpressConnectTrafficQosResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteExpressConnectTrafficQosResponseBody() {}

  explicit DeleteExpressConnectTrafficQosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteExpressConnectTrafficQosResponseBody() = default;
};
class DeleteExpressConnectTrafficQosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteExpressConnectTrafficQosResponseBody> body{};

  DeleteExpressConnectTrafficQosResponse() {}

  explicit DeleteExpressConnectTrafficQosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteExpressConnectTrafficQosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteExpressConnectTrafficQosResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteExpressConnectTrafficQosResponse() = default;
};
class DeleteExpressConnectTrafficQosQueueRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> qosId{};
  shared_ptr<string> queueId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};

  DeleteExpressConnectTrafficQosQueueRequest() {}

  explicit DeleteExpressConnectTrafficQosQueueRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~DeleteExpressConnectTrafficQosQueueRequest() = default;
};
class DeleteExpressConnectTrafficQosQueueResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteExpressConnectTrafficQosQueueResponseBody() {}

  explicit DeleteExpressConnectTrafficQosQueueResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteExpressConnectTrafficQosQueueResponseBody() = default;
};
class DeleteExpressConnectTrafficQosQueueResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteExpressConnectTrafficQosQueueResponseBody> body{};

  DeleteExpressConnectTrafficQosQueueResponse() {}

  explicit DeleteExpressConnectTrafficQosQueueResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteExpressConnectTrafficQosQueueResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteExpressConnectTrafficQosQueueResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteExpressConnectTrafficQosQueueResponse() = default;
};
class DeleteExpressConnectTrafficQosRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> qosId{};
  shared_ptr<string> queueId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> ruleId{};

  DeleteExpressConnectTrafficQosRuleRequest() {}

  explicit DeleteExpressConnectTrafficQosRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DeleteExpressConnectTrafficQosRuleRequest() = default;
};
class DeleteExpressConnectTrafficQosRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteExpressConnectTrafficQosRuleResponseBody() {}

  explicit DeleteExpressConnectTrafficQosRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteExpressConnectTrafficQosRuleResponseBody() = default;
};
class DeleteExpressConnectTrafficQosRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteExpressConnectTrafficQosRuleResponseBody> body{};

  DeleteExpressConnectTrafficQosRuleResponse() {}

  explicit DeleteExpressConnectTrafficQosRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteExpressConnectTrafficQosRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteExpressConnectTrafficQosRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteExpressConnectTrafficQosRuleResponse() = default;
};
class DeleteFailoverTestJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> jobId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};

  DeleteFailoverTestJobRequest() {}

  explicit DeleteFailoverTestJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~DeleteFailoverTestJobRequest() = default;
};
class DeleteFailoverTestJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteFailoverTestJobResponseBody() {}

  explicit DeleteFailoverTestJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFailoverTestJobResponseBody() = default;
};
class DeleteFailoverTestJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFailoverTestJobResponseBody> body{};

  DeleteFailoverTestJobResponse() {}

  explicit DeleteFailoverTestJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFailoverTestJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFailoverTestJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFailoverTestJobResponse() = default;
};
class DeleteFlowLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowLogId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteFlowLogRequest() {}

  explicit DeleteFlowLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowLogId) {
      res["FlowLogId"] = boost::any(*flowLogId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowLogId") != m.end() && !m["FlowLogId"].empty()) {
      flowLogId = make_shared<string>(boost::any_cast<string>(m["FlowLogId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteFlowLogRequest() = default;
};
class DeleteFlowLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DeleteFlowLogResponseBody() {}

  explicit DeleteFlowLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DeleteFlowLogResponseBody() = default;
};
class DeleteFlowLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFlowLogResponseBody> body{};

  DeleteFlowLogResponse() {}

  explicit DeleteFlowLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFlowLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFlowLogResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFlowLogResponse() = default;
};
class DeleteForwardEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> forwardEntryId{};
  shared_ptr<string> forwardTableId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteForwardEntryRequest() {}

  explicit DeleteForwardEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (forwardEntryId) {
      res["ForwardEntryId"] = boost::any(*forwardEntryId);
    }
    if (forwardTableId) {
      res["ForwardTableId"] = boost::any(*forwardTableId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ForwardEntryId") != m.end() && !m["ForwardEntryId"].empty()) {
      forwardEntryId = make_shared<string>(boost::any_cast<string>(m["ForwardEntryId"]));
    }
    if (m.find("ForwardTableId") != m.end() && !m["ForwardTableId"].empty()) {
      forwardTableId = make_shared<string>(boost::any_cast<string>(m["ForwardTableId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteForwardEntryRequest() = default;
};
class DeleteForwardEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteForwardEntryResponseBody() {}

  explicit DeleteForwardEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteForwardEntryResponseBody() = default;
};
class DeleteForwardEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteForwardEntryResponseBody> body{};

  DeleteForwardEntryResponse() {}

  explicit DeleteForwardEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteForwardEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteForwardEntryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteForwardEntryResponse() = default;
};
class DeleteFullNatEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> fullNatEntryId{};
  shared_ptr<string> fullNatTableId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteFullNatEntryRequest() {}

  explicit DeleteFullNatEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (fullNatEntryId) {
      res["FullNatEntryId"] = boost::any(*fullNatEntryId);
    }
    if (fullNatTableId) {
      res["FullNatTableId"] = boost::any(*fullNatTableId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("FullNatEntryId") != m.end() && !m["FullNatEntryId"].empty()) {
      fullNatEntryId = make_shared<string>(boost::any_cast<string>(m["FullNatEntryId"]));
    }
    if (m.find("FullNatTableId") != m.end() && !m["FullNatTableId"].empty()) {
      fullNatTableId = make_shared<string>(boost::any_cast<string>(m["FullNatTableId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteFullNatEntryRequest() = default;
};
class DeleteFullNatEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteFullNatEntryResponseBody() {}

  explicit DeleteFullNatEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFullNatEntryResponseBody() = default;
};
class DeleteFullNatEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFullNatEntryResponseBody> body{};

  DeleteFullNatEntryResponse() {}

  explicit DeleteFullNatEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFullNatEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFullNatEntryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFullNatEntryResponse() = default;
};
class DeleteGlobalAccelerationInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> globalAccelerationInstanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteGlobalAccelerationInstanceRequest() {}

  explicit DeleteGlobalAccelerationInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalAccelerationInstanceId) {
      res["GlobalAccelerationInstanceId"] = boost::any(*globalAccelerationInstanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalAccelerationInstanceId") != m.end() && !m["GlobalAccelerationInstanceId"].empty()) {
      globalAccelerationInstanceId = make_shared<string>(boost::any_cast<string>(m["GlobalAccelerationInstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteGlobalAccelerationInstanceRequest() = default;
};
class DeleteGlobalAccelerationInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteGlobalAccelerationInstanceResponseBody() {}

  explicit DeleteGlobalAccelerationInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteGlobalAccelerationInstanceResponseBody() = default;
};
class DeleteGlobalAccelerationInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGlobalAccelerationInstanceResponseBody> body{};

  DeleteGlobalAccelerationInstanceResponse() {}

  explicit DeleteGlobalAccelerationInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGlobalAccelerationInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGlobalAccelerationInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGlobalAccelerationInstanceResponse() = default;
};
class DeleteHaVipRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> haVipId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteHaVipRequest() {}

  explicit DeleteHaVipRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (haVipId) {
      res["HaVipId"] = boost::any(*haVipId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("HaVipId") != m.end() && !m["HaVipId"].empty()) {
      haVipId = make_shared<string>(boost::any_cast<string>(m["HaVipId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteHaVipRequest() = default;
};
class DeleteHaVipResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteHaVipResponseBody() {}

  explicit DeleteHaVipResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteHaVipResponseBody() = default;
};
class DeleteHaVipResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteHaVipResponseBody> body{};

  DeleteHaVipResponse() {}

  explicit DeleteHaVipResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHaVipResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHaVipResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHaVipResponse() = default;
};
class DeleteIPv6TranslatorRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ipv6TranslatorId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteIPv6TranslatorRequest() {}

  explicit DeleteIPv6TranslatorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ipv6TranslatorId) {
      res["Ipv6TranslatorId"] = boost::any(*ipv6TranslatorId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Ipv6TranslatorId") != m.end() && !m["Ipv6TranslatorId"].empty()) {
      ipv6TranslatorId = make_shared<string>(boost::any_cast<string>(m["Ipv6TranslatorId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteIPv6TranslatorRequest() = default;
};
class DeleteIPv6TranslatorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteIPv6TranslatorResponseBody() {}

  explicit DeleteIPv6TranslatorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIPv6TranslatorResponseBody() = default;
};
class DeleteIPv6TranslatorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIPv6TranslatorResponseBody> body{};

  DeleteIPv6TranslatorResponse() {}

  explicit DeleteIPv6TranslatorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIPv6TranslatorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIPv6TranslatorResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIPv6TranslatorResponse() = default;
};
class DeleteIPv6TranslatorAclListRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteIPv6TranslatorAclListRequest() {}

  explicit DeleteIPv6TranslatorAclListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteIPv6TranslatorAclListRequest() = default;
};
class DeleteIPv6TranslatorAclListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteIPv6TranslatorAclListResponseBody() {}

  explicit DeleteIPv6TranslatorAclListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIPv6TranslatorAclListResponseBody() = default;
};
class DeleteIPv6TranslatorAclListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIPv6TranslatorAclListResponseBody> body{};

  DeleteIPv6TranslatorAclListResponse() {}

  explicit DeleteIPv6TranslatorAclListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIPv6TranslatorAclListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIPv6TranslatorAclListResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIPv6TranslatorAclListResponse() = default;
};
class DeleteIPv6TranslatorEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ipv6TranslatorEntryId{};
  shared_ptr<string> ipv6TranslatorId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteIPv6TranslatorEntryRequest() {}

  explicit DeleteIPv6TranslatorEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ipv6TranslatorEntryId) {
      res["Ipv6TranslatorEntryId"] = boost::any(*ipv6TranslatorEntryId);
    }
    if (ipv6TranslatorId) {
      res["Ipv6TranslatorId"] = boost::any(*ipv6TranslatorId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Ipv6TranslatorEntryId") != m.end() && !m["Ipv6TranslatorEntryId"].empty()) {
      ipv6TranslatorEntryId = make_shared<string>(boost::any_cast<string>(m["Ipv6TranslatorEntryId"]));
    }
    if (m.find("Ipv6TranslatorId") != m.end() && !m["Ipv6TranslatorId"].empty()) {
      ipv6TranslatorId = make_shared<string>(boost::any_cast<string>(m["Ipv6TranslatorId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteIPv6TranslatorEntryRequest() = default;
};
class DeleteIPv6TranslatorEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteIPv6TranslatorEntryResponseBody() {}

  explicit DeleteIPv6TranslatorEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIPv6TranslatorEntryResponseBody() = default;
};
class DeleteIPv6TranslatorEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIPv6TranslatorEntryResponseBody> body{};

  DeleteIPv6TranslatorEntryResponse() {}

  explicit DeleteIPv6TranslatorEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIPv6TranslatorEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIPv6TranslatorEntryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIPv6TranslatorEntryResponse() = default;
};
class DeleteIpsecServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> dryRun{};
  shared_ptr<string> ipsecServerId{};
  shared_ptr<string> regionId{};

  DeleteIpsecServerRequest() {}

  explicit DeleteIpsecServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ipsecServerId) {
      res["IpsecServerId"] = boost::any(*ipsecServerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<string>(boost::any_cast<string>(m["DryRun"]));
    }
    if (m.find("IpsecServerId") != m.end() && !m["IpsecServerId"].empty()) {
      ipsecServerId = make_shared<string>(boost::any_cast<string>(m["IpsecServerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteIpsecServerRequest() = default;
};
class DeleteIpsecServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteIpsecServerResponseBody() {}

  explicit DeleteIpsecServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIpsecServerResponseBody() = default;
};
class DeleteIpsecServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIpsecServerResponseBody> body{};

  DeleteIpsecServerResponse() {}

  explicit DeleteIpsecServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIpsecServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIpsecServerResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIpsecServerResponse() = default;
};
class DeleteIpv4GatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ipv4GatewayId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteIpv4GatewayRequest() {}

  explicit DeleteIpv4GatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ipv4GatewayId) {
      res["Ipv4GatewayId"] = boost::any(*ipv4GatewayId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("Ipv4GatewayId") != m.end() && !m["Ipv4GatewayId"].empty()) {
      ipv4GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteIpv4GatewayRequest() = default;
};
class DeleteIpv4GatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteIpv4GatewayResponseBody() {}

  explicit DeleteIpv4GatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIpv4GatewayResponseBody() = default;
};
class DeleteIpv4GatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIpv4GatewayResponseBody> body{};

  DeleteIpv4GatewayResponse() {}

  explicit DeleteIpv4GatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIpv4GatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIpv4GatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIpv4GatewayResponse() = default;
};
class DeleteIpv6EgressOnlyRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ipv6EgressOnlyRuleId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteIpv6EgressOnlyRuleRequest() {}

  explicit DeleteIpv6EgressOnlyRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ipv6EgressOnlyRuleId) {
      res["Ipv6EgressOnlyRuleId"] = boost::any(*ipv6EgressOnlyRuleId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Ipv6EgressOnlyRuleId") != m.end() && !m["Ipv6EgressOnlyRuleId"].empty()) {
      ipv6EgressOnlyRuleId = make_shared<string>(boost::any_cast<string>(m["Ipv6EgressOnlyRuleId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteIpv6EgressOnlyRuleRequest() = default;
};
class DeleteIpv6EgressOnlyRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteIpv6EgressOnlyRuleResponseBody() {}

  explicit DeleteIpv6EgressOnlyRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIpv6EgressOnlyRuleResponseBody() = default;
};
class DeleteIpv6EgressOnlyRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIpv6EgressOnlyRuleResponseBody> body{};

  DeleteIpv6EgressOnlyRuleResponse() {}

  explicit DeleteIpv6EgressOnlyRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIpv6EgressOnlyRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIpv6EgressOnlyRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIpv6EgressOnlyRuleResponse() = default;
};
class DeleteIpv6GatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipv6GatewayId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteIpv6GatewayRequest() {}

  explicit DeleteIpv6GatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6GatewayId) {
      res["Ipv6GatewayId"] = boost::any(*ipv6GatewayId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6GatewayId") != m.end() && !m["Ipv6GatewayId"].empty()) {
      ipv6GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv6GatewayId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteIpv6GatewayRequest() = default;
};
class DeleteIpv6GatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteIpv6GatewayResponseBody() {}

  explicit DeleteIpv6GatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIpv6GatewayResponseBody() = default;
};
class DeleteIpv6GatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIpv6GatewayResponseBody> body{};

  DeleteIpv6GatewayResponse() {}

  explicit DeleteIpv6GatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIpv6GatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIpv6GatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIpv6GatewayResponse() = default;
};
class DeleteIpv6InternetBandwidthRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipv6AddressId{};
  shared_ptr<string> ipv6InternetBandwidthId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteIpv6InternetBandwidthRequest() {}

  explicit DeleteIpv6InternetBandwidthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6AddressId) {
      res["Ipv6AddressId"] = boost::any(*ipv6AddressId);
    }
    if (ipv6InternetBandwidthId) {
      res["Ipv6InternetBandwidthId"] = boost::any(*ipv6InternetBandwidthId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6AddressId") != m.end() && !m["Ipv6AddressId"].empty()) {
      ipv6AddressId = make_shared<string>(boost::any_cast<string>(m["Ipv6AddressId"]));
    }
    if (m.find("Ipv6InternetBandwidthId") != m.end() && !m["Ipv6InternetBandwidthId"].empty()) {
      ipv6InternetBandwidthId = make_shared<string>(boost::any_cast<string>(m["Ipv6InternetBandwidthId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteIpv6InternetBandwidthRequest() = default;
};
class DeleteIpv6InternetBandwidthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteIpv6InternetBandwidthResponseBody() {}

  explicit DeleteIpv6InternetBandwidthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIpv6InternetBandwidthResponseBody() = default;
};
class DeleteIpv6InternetBandwidthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIpv6InternetBandwidthResponseBody> body{};

  DeleteIpv6InternetBandwidthResponse() {}

  explicit DeleteIpv6InternetBandwidthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIpv6InternetBandwidthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIpv6InternetBandwidthResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIpv6InternetBandwidthResponse() = default;
};
class DeleteNatGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<bool> force{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteNatGatewayRequest() {}

  explicit DeleteNatGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteNatGatewayRequest() = default;
};
class DeleteNatGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNatGatewayResponseBody() {}

  explicit DeleteNatGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNatGatewayResponseBody() = default;
};
class DeleteNatGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNatGatewayResponseBody> body{};

  DeleteNatGatewayResponse() {}

  explicit DeleteNatGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNatGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNatGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNatGatewayResponse() = default;
};
class DeleteNatIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> natIpId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteNatIpRequest() {}

  explicit DeleteNatIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (natIpId) {
      res["NatIpId"] = boost::any(*natIpId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NatIpId") != m.end() && !m["NatIpId"].empty()) {
      natIpId = make_shared<string>(boost::any_cast<string>(m["NatIpId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteNatIpRequest() = default;
};
class DeleteNatIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNatIpResponseBody() {}

  explicit DeleteNatIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNatIpResponseBody() = default;
};
class DeleteNatIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNatIpResponseBody> body{};

  DeleteNatIpResponse() {}

  explicit DeleteNatIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNatIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNatIpResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNatIpResponse() = default;
};
class DeleteNatIpCidrRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> natIpCidr{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteNatIpCidrRequest() {}

  explicit DeleteNatIpCidrRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (natIpCidr) {
      res["NatIpCidr"] = boost::any(*natIpCidr);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("NatIpCidr") != m.end() && !m["NatIpCidr"].empty()) {
      natIpCidr = make_shared<string>(boost::any_cast<string>(m["NatIpCidr"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteNatIpCidrRequest() = default;
};
class DeleteNatIpCidrResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNatIpCidrResponseBody() {}

  explicit DeleteNatIpCidrResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNatIpCidrResponseBody() = default;
};
class DeleteNatIpCidrResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNatIpCidrResponseBody> body{};

  DeleteNatIpCidrResponse() {}

  explicit DeleteNatIpCidrResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNatIpCidrResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNatIpCidrResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNatIpCidrResponse() = default;
};
class DeleteNetworkAclRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> networkAclId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteNetworkAclRequest() {}

  explicit DeleteNetworkAclRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteNetworkAclRequest() = default;
};
class DeleteNetworkAclResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNetworkAclResponseBody() {}

  explicit DeleteNetworkAclResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNetworkAclResponseBody() = default;
};
class DeleteNetworkAclResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNetworkAclResponseBody> body{};

  DeleteNetworkAclResponse() {}

  explicit DeleteNetworkAclResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNetworkAclResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNetworkAclResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNetworkAclResponse() = default;
};
class DeletePhysicalConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeletePhysicalConnectionRequest() {}

  explicit DeletePhysicalConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeletePhysicalConnectionRequest() = default;
};
class DeletePhysicalConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeletePhysicalConnectionResponseBody() {}

  explicit DeletePhysicalConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePhysicalConnectionResponseBody() = default;
};
class DeletePhysicalConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePhysicalConnectionResponseBody> body{};

  DeletePhysicalConnectionResponse() {}

  explicit DeletePhysicalConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePhysicalConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePhysicalConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePhysicalConnectionResponse() = default;
};
class DeletePublicIpAddressPoolRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> publicIpAddressPoolId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeletePublicIpAddressPoolRequest() {}

  explicit DeletePublicIpAddressPoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (publicIpAddressPoolId) {
      res["PublicIpAddressPoolId"] = boost::any(*publicIpAddressPoolId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PublicIpAddressPoolId") != m.end() && !m["PublicIpAddressPoolId"].empty()) {
      publicIpAddressPoolId = make_shared<string>(boost::any_cast<string>(m["PublicIpAddressPoolId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeletePublicIpAddressPoolRequest() = default;
};
class DeletePublicIpAddressPoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeletePublicIpAddressPoolResponseBody() {}

  explicit DeletePublicIpAddressPoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePublicIpAddressPoolResponseBody() = default;
};
class DeletePublicIpAddressPoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePublicIpAddressPoolResponseBody> body{};

  DeletePublicIpAddressPoolResponse() {}

  explicit DeletePublicIpAddressPoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePublicIpAddressPoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePublicIpAddressPoolResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePublicIpAddressPoolResponse() = default;
};
class DeletePublicIpAddressPoolCidrBlockRequest : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> publicIpAddressPoolId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeletePublicIpAddressPoolCidrBlockRequest() {}

  explicit DeletePublicIpAddressPoolCidrBlockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (publicIpAddressPoolId) {
      res["PublicIpAddressPoolId"] = boost::any(*publicIpAddressPoolId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PublicIpAddressPoolId") != m.end() && !m["PublicIpAddressPoolId"].empty()) {
      publicIpAddressPoolId = make_shared<string>(boost::any_cast<string>(m["PublicIpAddressPoolId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeletePublicIpAddressPoolCidrBlockRequest() = default;
};
class DeletePublicIpAddressPoolCidrBlockResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeletePublicIpAddressPoolCidrBlockResponseBody() {}

  explicit DeletePublicIpAddressPoolCidrBlockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePublicIpAddressPoolCidrBlockResponseBody() = default;
};
class DeletePublicIpAddressPoolCidrBlockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePublicIpAddressPoolCidrBlockResponseBody> body{};

  DeletePublicIpAddressPoolCidrBlockResponse() {}

  explicit DeletePublicIpAddressPoolCidrBlockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePublicIpAddressPoolCidrBlockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePublicIpAddressPoolCidrBlockResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePublicIpAddressPoolCidrBlockResponse() = default;
};
class DeleteRouteEntriesRequestRouteEntries : public Darabonba::Model {
public:
  shared_ptr<string> dstCidrBlock{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> routeEntryId{};
  shared_ptr<string> routeTableId{};

  DeleteRouteEntriesRequestRouteEntries() {}

  explicit DeleteRouteEntriesRequestRouteEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstCidrBlock) {
      res["DstCidrBlock"] = boost::any(*dstCidrBlock);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (routeEntryId) {
      res["RouteEntryId"] = boost::any(*routeEntryId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstCidrBlock") != m.end() && !m["DstCidrBlock"].empty()) {
      dstCidrBlock = make_shared<string>(boost::any_cast<string>(m["DstCidrBlock"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("RouteEntryId") != m.end() && !m["RouteEntryId"].empty()) {
      routeEntryId = make_shared<string>(boost::any_cast<string>(m["RouteEntryId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
  }


  virtual ~DeleteRouteEntriesRequestRouteEntries() = default;
};
class DeleteRouteEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<DeleteRouteEntriesRequestRouteEntries>> routeEntries{};

  DeleteRouteEntriesRequest() {}

  explicit DeleteRouteEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeEntries) {
      vector<boost::any> temp1;
      for(auto item1:*routeEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouteEntries"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteEntries") != m.end() && !m["RouteEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["RouteEntries"].type()) {
        vector<DeleteRouteEntriesRequestRouteEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouteEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteRouteEntriesRequestRouteEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeEntries = make_shared<vector<DeleteRouteEntriesRequestRouteEntries>>(expect1);
      }
    }
  }


  virtual ~DeleteRouteEntriesRequest() = default;
};
class DeleteRouteEntriesResponseBodyFailedRouteEntries : public Darabonba::Model {
public:
  shared_ptr<string> dstCidrBlock{};
  shared_ptr<string> failedCode{};
  shared_ptr<string> failedMessage{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> routeEntryId{};

  DeleteRouteEntriesResponseBodyFailedRouteEntries() {}

  explicit DeleteRouteEntriesResponseBodyFailedRouteEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstCidrBlock) {
      res["DstCidrBlock"] = boost::any(*dstCidrBlock);
    }
    if (failedCode) {
      res["FailedCode"] = boost::any(*failedCode);
    }
    if (failedMessage) {
      res["FailedMessage"] = boost::any(*failedMessage);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (routeEntryId) {
      res["RouteEntryId"] = boost::any(*routeEntryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstCidrBlock") != m.end() && !m["DstCidrBlock"].empty()) {
      dstCidrBlock = make_shared<string>(boost::any_cast<string>(m["DstCidrBlock"]));
    }
    if (m.find("FailedCode") != m.end() && !m["FailedCode"].empty()) {
      failedCode = make_shared<string>(boost::any_cast<string>(m["FailedCode"]));
    }
    if (m.find("FailedMessage") != m.end() && !m["FailedMessage"].empty()) {
      failedMessage = make_shared<string>(boost::any_cast<string>(m["FailedMessage"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("RouteEntryId") != m.end() && !m["RouteEntryId"].empty()) {
      routeEntryId = make_shared<string>(boost::any_cast<string>(m["RouteEntryId"]));
    }
  }


  virtual ~DeleteRouteEntriesResponseBodyFailedRouteEntries() = default;
};
class DeleteRouteEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> failedCount{};
  shared_ptr<vector<DeleteRouteEntriesResponseBodyFailedRouteEntries>> failedRouteEntries{};
  shared_ptr<string> requestId{};
  shared_ptr<long> successCount{};

  DeleteRouteEntriesResponseBody() {}

  explicit DeleteRouteEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedCount) {
      res["FailedCount"] = boost::any(*failedCount);
    }
    if (failedRouteEntries) {
      vector<boost::any> temp1;
      for(auto item1:*failedRouteEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedRouteEntries"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedCount") != m.end() && !m["FailedCount"].empty()) {
      failedCount = make_shared<long>(boost::any_cast<long>(m["FailedCount"]));
    }
    if (m.find("FailedRouteEntries") != m.end() && !m["FailedRouteEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedRouteEntries"].type()) {
        vector<DeleteRouteEntriesResponseBodyFailedRouteEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedRouteEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteRouteEntriesResponseBodyFailedRouteEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedRouteEntries = make_shared<vector<DeleteRouteEntriesResponseBodyFailedRouteEntries>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
  }


  virtual ~DeleteRouteEntriesResponseBody() = default;
};
class DeleteRouteEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRouteEntriesResponseBody> body{};

  DeleteRouteEntriesResponse() {}

  explicit DeleteRouteEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRouteEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRouteEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRouteEntriesResponse() = default;
};
class DeleteRouteEntryRequestNextHopList : public Darabonba::Model {
public:
  shared_ptr<string> nextHopId{};
  shared_ptr<string> nextHopType{};

  DeleteRouteEntryRequestNextHopList() {}

  explicit DeleteRouteEntryRequestNextHopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextHopId) {
      res["NextHopId"] = boost::any(*nextHopId);
    }
    if (nextHopType) {
      res["NextHopType"] = boost::any(*nextHopType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextHopId") != m.end() && !m["NextHopId"].empty()) {
      nextHopId = make_shared<string>(boost::any_cast<string>(m["NextHopId"]));
    }
    if (m.find("NextHopType") != m.end() && !m["NextHopType"].empty()) {
      nextHopType = make_shared<string>(boost::any_cast<string>(m["NextHopType"]));
    }
  }


  virtual ~DeleteRouteEntryRequestNextHopList() = default;
};
class DeleteRouteEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> nextHopId{};
  shared_ptr<vector<DeleteRouteEntryRequestNextHopList>> nextHopList{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeEntryId{};
  shared_ptr<string> routeTableId{};

  DeleteRouteEntryRequest() {}

  explicit DeleteRouteEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (nextHopId) {
      res["NextHopId"] = boost::any(*nextHopId);
    }
    if (nextHopList) {
      vector<boost::any> temp1;
      for(auto item1:*nextHopList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NextHopList"] = boost::any(temp1);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeEntryId) {
      res["RouteEntryId"] = boost::any(*routeEntryId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("NextHopId") != m.end() && !m["NextHopId"].empty()) {
      nextHopId = make_shared<string>(boost::any_cast<string>(m["NextHopId"]));
    }
    if (m.find("NextHopList") != m.end() && !m["NextHopList"].empty()) {
      if (typeid(vector<boost::any>) == m["NextHopList"].type()) {
        vector<DeleteRouteEntryRequestNextHopList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NextHopList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteRouteEntryRequestNextHopList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nextHopList = make_shared<vector<DeleteRouteEntryRequestNextHopList>>(expect1);
      }
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteEntryId") != m.end() && !m["RouteEntryId"].empty()) {
      routeEntryId = make_shared<string>(boost::any_cast<string>(m["RouteEntryId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
  }


  virtual ~DeleteRouteEntryRequest() = default;
};
class DeleteRouteEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteRouteEntryResponseBody() {}

  explicit DeleteRouteEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRouteEntryResponseBody() = default;
};
class DeleteRouteEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRouteEntryResponseBody> body{};

  DeleteRouteEntryResponse() {}

  explicit DeleteRouteEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRouteEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRouteEntryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRouteEntryResponse() = default;
};
class DeleteRouteTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeTableId{};

  DeleteRouteTableRequest() {}

  explicit DeleteRouteTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
  }


  virtual ~DeleteRouteTableRequest() = default;
};
class DeleteRouteTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteRouteTableResponseBody() {}

  explicit DeleteRouteTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRouteTableResponseBody() = default;
};
class DeleteRouteTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRouteTableResponseBody> body{};

  DeleteRouteTableResponse() {}

  explicit DeleteRouteTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRouteTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRouteTableResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRouteTableResponse() = default;
};
class DeleteRouterInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routerInterfaceId{};

  DeleteRouterInterfaceRequest() {}

  explicit DeleteRouterInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routerInterfaceId) {
      res["RouterInterfaceId"] = boost::any(*routerInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouterInterfaceId") != m.end() && !m["RouterInterfaceId"].empty()) {
      routerInterfaceId = make_shared<string>(boost::any_cast<string>(m["RouterInterfaceId"]));
    }
  }


  virtual ~DeleteRouterInterfaceRequest() = default;
};
class DeleteRouterInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteRouterInterfaceResponseBody() {}

  explicit DeleteRouterInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRouterInterfaceResponseBody() = default;
};
class DeleteRouterInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRouterInterfaceResponseBody> body{};

  DeleteRouterInterfaceResponse() {}

  explicit DeleteRouterInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRouterInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRouterInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRouterInterfaceResponse() = default;
};
class DeleteSnatEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> snatEntryId{};
  shared_ptr<string> snatTableId{};

  DeleteSnatEntryRequest() {}

  explicit DeleteSnatEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (snatEntryId) {
      res["SnatEntryId"] = boost::any(*snatEntryId);
    }
    if (snatTableId) {
      res["SnatTableId"] = boost::any(*snatTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SnatEntryId") != m.end() && !m["SnatEntryId"].empty()) {
      snatEntryId = make_shared<string>(boost::any_cast<string>(m["SnatEntryId"]));
    }
    if (m.find("SnatTableId") != m.end() && !m["SnatTableId"].empty()) {
      snatTableId = make_shared<string>(boost::any_cast<string>(m["SnatTableId"]));
    }
  }


  virtual ~DeleteSnatEntryRequest() = default;
};
class DeleteSnatEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSnatEntryResponseBody() {}

  explicit DeleteSnatEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSnatEntryResponseBody() = default;
};
class DeleteSnatEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSnatEntryResponseBody> body{};

  DeleteSnatEntryResponse() {}

  explicit DeleteSnatEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSnatEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSnatEntryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSnatEntryResponse() = default;
};
class DeleteSslVpnClientCertRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sslVpnClientCertId{};

  DeleteSslVpnClientCertRequest() {}

  explicit DeleteSslVpnClientCertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sslVpnClientCertId) {
      res["SslVpnClientCertId"] = boost::any(*sslVpnClientCertId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SslVpnClientCertId") != m.end() && !m["SslVpnClientCertId"].empty()) {
      sslVpnClientCertId = make_shared<string>(boost::any_cast<string>(m["SslVpnClientCertId"]));
    }
  }


  virtual ~DeleteSslVpnClientCertRequest() = default;
};
class DeleteSslVpnClientCertResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSslVpnClientCertResponseBody() {}

  explicit DeleteSslVpnClientCertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSslVpnClientCertResponseBody() = default;
};
class DeleteSslVpnClientCertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSslVpnClientCertResponseBody> body{};

  DeleteSslVpnClientCertResponse() {}

  explicit DeleteSslVpnClientCertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSslVpnClientCertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSslVpnClientCertResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSslVpnClientCertResponse() = default;
};
class DeleteSslVpnServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sslVpnServerId{};

  DeleteSslVpnServerRequest() {}

  explicit DeleteSslVpnServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sslVpnServerId) {
      res["SslVpnServerId"] = boost::any(*sslVpnServerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SslVpnServerId") != m.end() && !m["SslVpnServerId"].empty()) {
      sslVpnServerId = make_shared<string>(boost::any_cast<string>(m["SslVpnServerId"]));
    }
  }


  virtual ~DeleteSslVpnServerRequest() = default;
};
class DeleteSslVpnServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSslVpnServerResponseBody() {}

  explicit DeleteSslVpnServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSslVpnServerResponseBody() = default;
};
class DeleteSslVpnServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSslVpnServerResponseBody> body{};

  DeleteSslVpnServerResponse() {}

  explicit DeleteSslVpnServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSslVpnServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSslVpnServerResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSslVpnServerResponse() = default;
};
class DeleteTrafficMirrorFilterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> trafficMirrorFilterId{};

  DeleteTrafficMirrorFilterRequest() {}

  explicit DeleteTrafficMirrorFilterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (trafficMirrorFilterId) {
      res["TrafficMirrorFilterId"] = boost::any(*trafficMirrorFilterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TrafficMirrorFilterId") != m.end() && !m["TrafficMirrorFilterId"].empty()) {
      trafficMirrorFilterId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterId"]));
    }
  }


  virtual ~DeleteTrafficMirrorFilterRequest() = default;
};
class DeleteTrafficMirrorFilterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteTrafficMirrorFilterResponseBody() {}

  explicit DeleteTrafficMirrorFilterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTrafficMirrorFilterResponseBody() = default;
};
class DeleteTrafficMirrorFilterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTrafficMirrorFilterResponseBody> body{};

  DeleteTrafficMirrorFilterResponse() {}

  explicit DeleteTrafficMirrorFilterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTrafficMirrorFilterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTrafficMirrorFilterResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTrafficMirrorFilterResponse() = default;
};
class DeleteTrafficMirrorFilterRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> trafficMirrorFilterId{};
  shared_ptr<vector<string>> trafficMirrorFilterRuleIds{};

  DeleteTrafficMirrorFilterRulesRequest() {}

  explicit DeleteTrafficMirrorFilterRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (trafficMirrorFilterId) {
      res["TrafficMirrorFilterId"] = boost::any(*trafficMirrorFilterId);
    }
    if (trafficMirrorFilterRuleIds) {
      res["TrafficMirrorFilterRuleIds"] = boost::any(*trafficMirrorFilterRuleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TrafficMirrorFilterId") != m.end() && !m["TrafficMirrorFilterId"].empty()) {
      trafficMirrorFilterId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterId"]));
    }
    if (m.find("TrafficMirrorFilterRuleIds") != m.end() && !m["TrafficMirrorFilterRuleIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TrafficMirrorFilterRuleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TrafficMirrorFilterRuleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      trafficMirrorFilterRuleIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteTrafficMirrorFilterRulesRequest() = default;
};
class DeleteTrafficMirrorFilterRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteTrafficMirrorFilterRulesResponseBody() {}

  explicit DeleteTrafficMirrorFilterRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTrafficMirrorFilterRulesResponseBody() = default;
};
class DeleteTrafficMirrorFilterRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTrafficMirrorFilterRulesResponseBody> body{};

  DeleteTrafficMirrorFilterRulesResponse() {}

  explicit DeleteTrafficMirrorFilterRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTrafficMirrorFilterRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTrafficMirrorFilterRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTrafficMirrorFilterRulesResponse() = default;
};
class DeleteTrafficMirrorSessionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> trafficMirrorSessionId{};

  DeleteTrafficMirrorSessionRequest() {}

  explicit DeleteTrafficMirrorSessionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (trafficMirrorSessionId) {
      res["TrafficMirrorSessionId"] = boost::any(*trafficMirrorSessionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TrafficMirrorSessionId") != m.end() && !m["TrafficMirrorSessionId"].empty()) {
      trafficMirrorSessionId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorSessionId"]));
    }
  }


  virtual ~DeleteTrafficMirrorSessionRequest() = default;
};
class DeleteTrafficMirrorSessionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteTrafficMirrorSessionResponseBody() {}

  explicit DeleteTrafficMirrorSessionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTrafficMirrorSessionResponseBody() = default;
};
class DeleteTrafficMirrorSessionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTrafficMirrorSessionResponseBody> body{};

  DeleteTrafficMirrorSessionResponse() {}

  explicit DeleteTrafficMirrorSessionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTrafficMirrorSessionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTrafficMirrorSessionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTrafficMirrorSessionResponse() = default;
};
class DeleteVSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vSwitchId{};

  DeleteVSwitchRequest() {}

  explicit DeleteVSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DeleteVSwitchRequest() = default;
};
class DeleteVSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVSwitchResponseBody() {}

  explicit DeleteVSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVSwitchResponseBody() = default;
};
class DeleteVSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVSwitchResponseBody> body{};

  DeleteVSwitchResponse() {}

  explicit DeleteVSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVSwitchResponse() = default;
};
class DeleteVSwitchCidrReservationRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vSwitchCidrReservationId{};

  DeleteVSwitchCidrReservationRequest() {}

  explicit DeleteVSwitchCidrReservationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vSwitchCidrReservationId) {
      res["VSwitchCidrReservationId"] = boost::any(*vSwitchCidrReservationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VSwitchCidrReservationId") != m.end() && !m["VSwitchCidrReservationId"].empty()) {
      vSwitchCidrReservationId = make_shared<string>(boost::any_cast<string>(m["VSwitchCidrReservationId"]));
    }
  }


  virtual ~DeleteVSwitchCidrReservationRequest() = default;
};
class DeleteVSwitchCidrReservationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVSwitchCidrReservationResponseBody() {}

  explicit DeleteVSwitchCidrReservationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVSwitchCidrReservationResponseBody() = default;
};
class DeleteVSwitchCidrReservationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVSwitchCidrReservationResponseBody> body{};

  DeleteVSwitchCidrReservationResponse() {}

  explicit DeleteVSwitchCidrReservationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVSwitchCidrReservationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVSwitchCidrReservationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVSwitchCidrReservationResponse() = default;
};
class DeleteVbrHaRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteVbrHaRequest() {}

  explicit DeleteVbrHaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteVbrHaRequest() = default;
};
class DeleteVbrHaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVbrHaResponseBody() {}

  explicit DeleteVbrHaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVbrHaResponseBody() = default;
};
class DeleteVbrHaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVbrHaResponseBody> body{};

  DeleteVbrHaResponse() {}

  explicit DeleteVbrHaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVbrHaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVbrHaResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVbrHaResponse() = default;
};
class DeleteVcoRouteEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> overlayMode{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeDest{};
  shared_ptr<string> vpnConnectionId{};
  shared_ptr<long> weight{};

  DeleteVcoRouteEntryRequest() {}

  explicit DeleteVcoRouteEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (overlayMode) {
      res["OverlayMode"] = boost::any(*overlayMode);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeDest) {
      res["RouteDest"] = boost::any(*routeDest);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("OverlayMode") != m.end() && !m["OverlayMode"].empty()) {
      overlayMode = make_shared<string>(boost::any_cast<string>(m["OverlayMode"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteDest") != m.end() && !m["RouteDest"].empty()) {
      routeDest = make_shared<string>(boost::any_cast<string>(m["RouteDest"]));
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DeleteVcoRouteEntryRequest() = default;
};
class DeleteVcoRouteEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVcoRouteEntryResponseBody() {}

  explicit DeleteVcoRouteEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVcoRouteEntryResponseBody() = default;
};
class DeleteVcoRouteEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVcoRouteEntryResponseBody> body{};

  DeleteVcoRouteEntryResponse() {}

  explicit DeleteVcoRouteEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVcoRouteEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVcoRouteEntryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVcoRouteEntryResponse() = default;
};
class DeleteVirtualBorderRouterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vbrId{};

  DeleteVirtualBorderRouterRequest() {}

  explicit DeleteVirtualBorderRouterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
  }


  virtual ~DeleteVirtualBorderRouterRequest() = default;
};
class DeleteVirtualBorderRouterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVirtualBorderRouterResponseBody() {}

  explicit DeleteVirtualBorderRouterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVirtualBorderRouterResponseBody() = default;
};
class DeleteVirtualBorderRouterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVirtualBorderRouterResponseBody> body{};

  DeleteVirtualBorderRouterResponse() {}

  explicit DeleteVirtualBorderRouterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVirtualBorderRouterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVirtualBorderRouterResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVirtualBorderRouterResponse() = default;
};
class DeleteVpcRequest : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<bool> forceDelete{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpcId{};

  DeleteVpcRequest() {}

  explicit DeleteVpcRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (forceDelete) {
      res["ForceDelete"] = boost::any(*forceDelete);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("ForceDelete") != m.end() && !m["ForceDelete"].empty()) {
      forceDelete = make_shared<bool>(boost::any_cast<bool>(m["ForceDelete"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DeleteVpcRequest() = default;
};
class DeleteVpcResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVpcResponseBody() {}

  explicit DeleteVpcResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVpcResponseBody() = default;
};
class DeleteVpcResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVpcResponseBody> body{};

  DeleteVpcResponse() {}

  explicit DeleteVpcResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVpcResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVpcResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVpcResponse() = default;
};
class DeleteVpcGatewayEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteVpcGatewayEndpointRequest() {}

  explicit DeleteVpcGatewayEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteVpcGatewayEndpointRequest() = default;
};
class DeleteVpcGatewayEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVpcGatewayEndpointResponseBody() {}

  explicit DeleteVpcGatewayEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVpcGatewayEndpointResponseBody() = default;
};
class DeleteVpcGatewayEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVpcGatewayEndpointResponseBody> body{};

  DeleteVpcGatewayEndpointResponse() {}

  explicit DeleteVpcGatewayEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVpcGatewayEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVpcGatewayEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVpcGatewayEndpointResponse() = default;
};
class DeleteVpcPrefixListRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prefixListId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteVpcPrefixListRequest() {}

  explicit DeleteVpcPrefixListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prefixListId) {
      res["PrefixListId"] = boost::any(*prefixListId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PrefixListId") != m.end() && !m["PrefixListId"].empty()) {
      prefixListId = make_shared<string>(boost::any_cast<string>(m["PrefixListId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteVpcPrefixListRequest() = default;
};
class DeleteVpcPrefixListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVpcPrefixListResponseBody() {}

  explicit DeleteVpcPrefixListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVpcPrefixListResponseBody() = default;
};
class DeleteVpcPrefixListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVpcPrefixListResponseBody> body{};

  DeleteVpcPrefixListResponse() {}

  explicit DeleteVpcPrefixListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVpcPrefixListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVpcPrefixListResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVpcPrefixListResponse() = default;
};
class DeleteVpnAttachmentRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpnConnectionId{};

  DeleteVpnAttachmentRequest() {}

  explicit DeleteVpnAttachmentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
  }


  virtual ~DeleteVpnAttachmentRequest() = default;
};
class DeleteVpnAttachmentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteVpnAttachmentResponseBody() {}

  explicit DeleteVpnAttachmentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteVpnAttachmentResponseBody() = default;
};
class DeleteVpnAttachmentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVpnAttachmentResponseBody> body{};

  DeleteVpnAttachmentResponse() {}

  explicit DeleteVpnAttachmentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVpnAttachmentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVpnAttachmentResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVpnAttachmentResponse() = default;
};
class DeleteVpnConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpnConnectionId{};

  DeleteVpnConnectionRequest() {}

  explicit DeleteVpnConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
  }


  virtual ~DeleteVpnConnectionRequest() = default;
};
class DeleteVpnConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVpnConnectionResponseBody() {}

  explicit DeleteVpnConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVpnConnectionResponseBody() = default;
};
class DeleteVpnConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVpnConnectionResponseBody> body{};

  DeleteVpnConnectionResponse() {}

  explicit DeleteVpnConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVpnConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVpnConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVpnConnectionResponse() = default;
};
class DeleteVpnGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpnGatewayId{};

  DeleteVpnGatewayRequest() {}

  explicit DeleteVpnGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~DeleteVpnGatewayRequest() = default;
};
class DeleteVpnGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVpnGatewayResponseBody() {}

  explicit DeleteVpnGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVpnGatewayResponseBody() = default;
};
class DeleteVpnGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVpnGatewayResponseBody> body{};

  DeleteVpnGatewayResponse() {}

  explicit DeleteVpnGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVpnGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVpnGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVpnGatewayResponse() = default;
};
class DeleteVpnPbrRouteEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> overlayMode{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> priority{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeDest{};
  shared_ptr<string> routeSource{};
  shared_ptr<string> vpnGatewayId{};
  shared_ptr<long> weight{};

  DeleteVpnPbrRouteEntryRequest() {}

  explicit DeleteVpnPbrRouteEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (overlayMode) {
      res["OverlayMode"] = boost::any(*overlayMode);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeDest) {
      res["RouteDest"] = boost::any(*routeDest);
    }
    if (routeSource) {
      res["RouteSource"] = boost::any(*routeSource);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("OverlayMode") != m.end() && !m["OverlayMode"].empty()) {
      overlayMode = make_shared<string>(boost::any_cast<string>(m["OverlayMode"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteDest") != m.end() && !m["RouteDest"].empty()) {
      routeDest = make_shared<string>(boost::any_cast<string>(m["RouteDest"]));
    }
    if (m.find("RouteSource") != m.end() && !m["RouteSource"].empty()) {
      routeSource = make_shared<string>(boost::any_cast<string>(m["RouteSource"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DeleteVpnPbrRouteEntryRequest() = default;
};
class DeleteVpnPbrRouteEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVpnPbrRouteEntryResponseBody() {}

  explicit DeleteVpnPbrRouteEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVpnPbrRouteEntryResponseBody() = default;
};
class DeleteVpnPbrRouteEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVpnPbrRouteEntryResponseBody> body{};

  DeleteVpnPbrRouteEntryResponse() {}

  explicit DeleteVpnPbrRouteEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVpnPbrRouteEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVpnPbrRouteEntryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVpnPbrRouteEntryResponse() = default;
};
class DeleteVpnRouteEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> overlayMode{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeDest{};
  shared_ptr<string> vpnGatewayId{};
  shared_ptr<long> weight{};

  DeleteVpnRouteEntryRequest() {}

  explicit DeleteVpnRouteEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (overlayMode) {
      res["OverlayMode"] = boost::any(*overlayMode);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeDest) {
      res["RouteDest"] = boost::any(*routeDest);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("OverlayMode") != m.end() && !m["OverlayMode"].empty()) {
      overlayMode = make_shared<string>(boost::any_cast<string>(m["OverlayMode"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteDest") != m.end() && !m["RouteDest"].empty()) {
      routeDest = make_shared<string>(boost::any_cast<string>(m["RouteDest"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DeleteVpnRouteEntryRequest() = default;
};
class DeleteVpnRouteEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVpnRouteEntryResponseBody() {}

  explicit DeleteVpnRouteEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVpnRouteEntryResponseBody() = default;
};
class DeleteVpnRouteEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVpnRouteEntryResponseBody> body{};

  DeleteVpnRouteEntryResponse() {}

  explicit DeleteVpnRouteEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVpnRouteEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVpnRouteEntryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVpnRouteEntryResponse() = default;
};
class DeletionProtectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> ownerId{};
  shared_ptr<bool> protectionEnable{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> type{};

  DeletionProtectionRequest() {}

  explicit DeletionProtectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (protectionEnable) {
      res["ProtectionEnable"] = boost::any(*protectionEnable);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProtectionEnable") != m.end() && !m["ProtectionEnable"].empty()) {
      protectionEnable = make_shared<bool>(boost::any_cast<bool>(m["ProtectionEnable"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeletionProtectionRequest() = default;
};
class DeletionProtectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeletionProtectionResponseBody() {}

  explicit DeletionProtectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletionProtectionResponseBody() = default;
};
class DeletionProtectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletionProtectionResponseBody> body{};

  DeletionProtectionResponse() {}

  explicit DeletionProtectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletionProtectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletionProtectionResponseBody>(model1);
      }
    }
  }


  virtual ~DeletionProtectionResponse() = default;
};
class Describe95TrafficRequest : public Darabonba::Model {
public:
  shared_ptr<string> day{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};

  Describe95TrafficRequest() {}

  explicit Describe95TrafficRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (day) {
      res["Day"] = boost::any(*day);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Day") != m.end() && !m["Day"].empty()) {
      day = make_shared<string>(boost::any_cast<string>(m["Day"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~Describe95TrafficRequest() = default;
};
class Describe95TrafficResponseBodyTraffic95SummaryTraffic95DetailListTraffic95Detail : public Darabonba::Model {
public:
  shared_ptr<string> billBandwidth{};
  shared_ptr<string> inBandwidth{};
  shared_ptr<string> outBandwidth{};
  shared_ptr<string> time{};

  Describe95TrafficResponseBodyTraffic95SummaryTraffic95DetailListTraffic95Detail() {}

  explicit Describe95TrafficResponseBodyTraffic95SummaryTraffic95DetailListTraffic95Detail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billBandwidth) {
      res["BillBandwidth"] = boost::any(*billBandwidth);
    }
    if (inBandwidth) {
      res["InBandwidth"] = boost::any(*inBandwidth);
    }
    if (outBandwidth) {
      res["OutBandwidth"] = boost::any(*outBandwidth);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillBandwidth") != m.end() && !m["BillBandwidth"].empty()) {
      billBandwidth = make_shared<string>(boost::any_cast<string>(m["BillBandwidth"]));
    }
    if (m.find("InBandwidth") != m.end() && !m["InBandwidth"].empty()) {
      inBandwidth = make_shared<string>(boost::any_cast<string>(m["InBandwidth"]));
    }
    if (m.find("OutBandwidth") != m.end() && !m["OutBandwidth"].empty()) {
      outBandwidth = make_shared<string>(boost::any_cast<string>(m["OutBandwidth"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~Describe95TrafficResponseBodyTraffic95SummaryTraffic95DetailListTraffic95Detail() = default;
};
class Describe95TrafficResponseBodyTraffic95SummaryTraffic95DetailList : public Darabonba::Model {
public:
  shared_ptr<vector<Describe95TrafficResponseBodyTraffic95SummaryTraffic95DetailListTraffic95Detail>> traffic95Detail{};

  Describe95TrafficResponseBodyTraffic95SummaryTraffic95DetailList() {}

  explicit Describe95TrafficResponseBodyTraffic95SummaryTraffic95DetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (traffic95Detail) {
      vector<boost::any> temp1;
      for(auto item1:*traffic95Detail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Traffic95Detail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Traffic95Detail") != m.end() && !m["Traffic95Detail"].empty()) {
      if (typeid(vector<boost::any>) == m["Traffic95Detail"].type()) {
        vector<Describe95TrafficResponseBodyTraffic95SummaryTraffic95DetailListTraffic95Detail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Traffic95Detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Describe95TrafficResponseBodyTraffic95SummaryTraffic95DetailListTraffic95Detail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        traffic95Detail = make_shared<vector<Describe95TrafficResponseBodyTraffic95SummaryTraffic95DetailListTraffic95Detail>>(expect1);
      }
    }
  }


  virtual ~Describe95TrafficResponseBodyTraffic95SummaryTraffic95DetailList() = default;
};
class Describe95TrafficResponseBodyTraffic95Summary : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> fifthPeakBandwidth{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> minimumConsumeBandwidth{};
  shared_ptr<Describe95TrafficResponseBodyTraffic95SummaryTraffic95DetailList> traffic95DetailList{};

  Describe95TrafficResponseBodyTraffic95Summary() {}

  explicit Describe95TrafficResponseBodyTraffic95Summary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (fifthPeakBandwidth) {
      res["FifthPeakBandwidth"] = boost::any(*fifthPeakBandwidth);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (minimumConsumeBandwidth) {
      res["MinimumConsumeBandwidth"] = boost::any(*minimumConsumeBandwidth);
    }
    if (traffic95DetailList) {
      res["Traffic95DetailList"] = traffic95DetailList ? boost::any(traffic95DetailList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("FifthPeakBandwidth") != m.end() && !m["FifthPeakBandwidth"].empty()) {
      fifthPeakBandwidth = make_shared<string>(boost::any_cast<string>(m["FifthPeakBandwidth"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("MinimumConsumeBandwidth") != m.end() && !m["MinimumConsumeBandwidth"].empty()) {
      minimumConsumeBandwidth = make_shared<string>(boost::any_cast<string>(m["MinimumConsumeBandwidth"]));
    }
    if (m.find("Traffic95DetailList") != m.end() && !m["Traffic95DetailList"].empty()) {
      if (typeid(map<string, boost::any>) == m["Traffic95DetailList"].type()) {
        Describe95TrafficResponseBodyTraffic95SummaryTraffic95DetailList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Traffic95DetailList"]));
        traffic95DetailList = make_shared<Describe95TrafficResponseBodyTraffic95SummaryTraffic95DetailList>(model1);
      }
    }
  }


  virtual ~Describe95TrafficResponseBodyTraffic95Summary() = default;
};
class Describe95TrafficResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<Describe95TrafficResponseBodyTraffic95Summary> traffic95Summary{};

  Describe95TrafficResponseBody() {}

  explicit Describe95TrafficResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (traffic95Summary) {
      res["Traffic95Summary"] = traffic95Summary ? boost::any(traffic95Summary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Traffic95Summary") != m.end() && !m["Traffic95Summary"].empty()) {
      if (typeid(map<string, boost::any>) == m["Traffic95Summary"].type()) {
        Describe95TrafficResponseBodyTraffic95Summary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Traffic95Summary"]));
        traffic95Summary = make_shared<Describe95TrafficResponseBodyTraffic95Summary>(model1);
      }
    }
  }


  virtual ~Describe95TrafficResponseBody() = default;
};
class Describe95TrafficResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<Describe95TrafficResponseBody> body{};

  Describe95TrafficResponse() {}

  explicit Describe95TrafficResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        Describe95TrafficResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<Describe95TrafficResponseBody>(model1);
      }
    }
  }


  virtual ~Describe95TrafficResponse() = default;
};
class DescribeAccessPointsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeAccessPointsRequest() {}

  explicit DescribeAccessPointsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeAccessPointsRequest() = default;
};
class DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModelsAccessPointFeatureModel : public Darabonba::Model {
public:
  shared_ptr<string> featureKey{};
  shared_ptr<string> featureValue{};

  DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModelsAccessPointFeatureModel() {}

  explicit DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModelsAccessPointFeatureModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (featureKey) {
      res["FeatureKey"] = boost::any(*featureKey);
    }
    if (featureValue) {
      res["FeatureValue"] = boost::any(*featureValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FeatureKey") != m.end() && !m["FeatureKey"].empty()) {
      featureKey = make_shared<string>(boost::any_cast<string>(m["FeatureKey"]));
    }
    if (m.find("FeatureValue") != m.end() && !m["FeatureValue"].empty()) {
      featureValue = make_shared<string>(boost::any_cast<string>(m["FeatureValue"]));
    }
  }


  virtual ~DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModelsAccessPointFeatureModel() = default;
};
class DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModels : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModelsAccessPointFeatureModel>> accessPointFeatureModel{};

  DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModels() {}

  explicit DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPointFeatureModel) {
      vector<boost::any> temp1;
      for(auto item1:*accessPointFeatureModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccessPointFeatureModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPointFeatureModel") != m.end() && !m["AccessPointFeatureModel"].empty()) {
      if (typeid(vector<boost::any>) == m["AccessPointFeatureModel"].type()) {
        vector<DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModelsAccessPointFeatureModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccessPointFeatureModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModelsAccessPointFeatureModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accessPointFeatureModel = make_shared<vector<DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModelsAccessPointFeatureModel>>(expect1);
      }
    }
  }


  virtual ~DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModels() = default;
};
class DescribeAccessPointsResponseBodyAccessPointSetAccessPointType : public Darabonba::Model {
public:
  shared_ptr<DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModels> accessPointFeatureModels{};
  shared_ptr<string> accessPointId{};
  shared_ptr<string> attachedRegionNo{};
  shared_ptr<string> description{};
  shared_ptr<string> hostOperator{};
  shared_ptr<string> location{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeAccessPointsResponseBodyAccessPointSetAccessPointType() {}

  explicit DescribeAccessPointsResponseBodyAccessPointSetAccessPointType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPointFeatureModels) {
      res["AccessPointFeatureModels"] = accessPointFeatureModels ? boost::any(accessPointFeatureModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (attachedRegionNo) {
      res["AttachedRegionNo"] = boost::any(*attachedRegionNo);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hostOperator) {
      res["HostOperator"] = boost::any(*hostOperator);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPointFeatureModels") != m.end() && !m["AccessPointFeatureModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccessPointFeatureModels"].type()) {
        DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccessPointFeatureModels"]));
        accessPointFeatureModels = make_shared<DescribeAccessPointsResponseBodyAccessPointSetAccessPointTypeAccessPointFeatureModels>(model1);
      }
    }
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<string>(boost::any_cast<string>(m["AccessPointId"]));
    }
    if (m.find("AttachedRegionNo") != m.end() && !m["AttachedRegionNo"].empty()) {
      attachedRegionNo = make_shared<string>(boost::any_cast<string>(m["AttachedRegionNo"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HostOperator") != m.end() && !m["HostOperator"].empty()) {
      hostOperator = make_shared<string>(boost::any_cast<string>(m["HostOperator"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeAccessPointsResponseBodyAccessPointSetAccessPointType() = default;
};
class DescribeAccessPointsResponseBodyAccessPointSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAccessPointsResponseBodyAccessPointSetAccessPointType>> accessPointType{};

  DescribeAccessPointsResponseBodyAccessPointSet() {}

  explicit DescribeAccessPointsResponseBodyAccessPointSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPointType) {
      vector<boost::any> temp1;
      for(auto item1:*accessPointType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccessPointType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPointType") != m.end() && !m["AccessPointType"].empty()) {
      if (typeid(vector<boost::any>) == m["AccessPointType"].type()) {
        vector<DescribeAccessPointsResponseBodyAccessPointSetAccessPointType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccessPointType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAccessPointsResponseBodyAccessPointSetAccessPointType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accessPointType = make_shared<vector<DescribeAccessPointsResponseBodyAccessPointSetAccessPointType>>(expect1);
      }
    }
  }


  virtual ~DescribeAccessPointsResponseBodyAccessPointSet() = default;
};
class DescribeAccessPointsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAccessPointsResponseBodyAccessPointSet> accessPointSet{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAccessPointsResponseBody() {}

  explicit DescribeAccessPointsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPointSet) {
      res["AccessPointSet"] = accessPointSet ? boost::any(accessPointSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPointSet") != m.end() && !m["AccessPointSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccessPointSet"].type()) {
        DescribeAccessPointsResponseBodyAccessPointSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccessPointSet"]));
        accessPointSet = make_shared<DescribeAccessPointsResponseBodyAccessPointSet>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAccessPointsResponseBody() = default;
};
class DescribeAccessPointsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAccessPointsResponseBody> body{};

  DescribeAccessPointsResponse() {}

  explicit DescribeAccessPointsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAccessPointsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAccessPointsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAccessPointsResponse() = default;
};
class DescribeBgpGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bgpGroupId{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routerId{};

  DescribeBgpGroupsRequest() {}

  explicit DescribeBgpGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgpGroupId) {
      res["BgpGroupId"] = boost::any(*bgpGroupId);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgpGroupId") != m.end() && !m["BgpGroupId"].empty()) {
      bgpGroupId = make_shared<string>(boost::any_cast<string>(m["BgpGroupId"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
  }


  virtual ~DescribeBgpGroupsRequest() = default;
};
class DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup : public Darabonba::Model {
public:
  shared_ptr<string> authKey{};
  shared_ptr<string> bgpGroupId{};
  shared_ptr<string> description{};
  shared_ptr<string> hold{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> isFake{};
  shared_ptr<string> keepalive{};
  shared_ptr<string> localAsn{};
  shared_ptr<string> name{};
  shared_ptr<string> peerAsn{};
  shared_ptr<string> regionId{};
  shared_ptr<string> routeLimit{};
  shared_ptr<string> routerId{};
  shared_ptr<string> status{};

  DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup() {}

  explicit DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (bgpGroupId) {
      res["BgpGroupId"] = boost::any(*bgpGroupId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hold) {
      res["Hold"] = boost::any(*hold);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (isFake) {
      res["IsFake"] = boost::any(*isFake);
    }
    if (keepalive) {
      res["Keepalive"] = boost::any(*keepalive);
    }
    if (localAsn) {
      res["LocalAsn"] = boost::any(*localAsn);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (peerAsn) {
      res["PeerAsn"] = boost::any(*peerAsn);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (routeLimit) {
      res["RouteLimit"] = boost::any(*routeLimit);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("BgpGroupId") != m.end() && !m["BgpGroupId"].empty()) {
      bgpGroupId = make_shared<string>(boost::any_cast<string>(m["BgpGroupId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hold") != m.end() && !m["Hold"].empty()) {
      hold = make_shared<string>(boost::any_cast<string>(m["Hold"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("IsFake") != m.end() && !m["IsFake"].empty()) {
      isFake = make_shared<string>(boost::any_cast<string>(m["IsFake"]));
    }
    if (m.find("Keepalive") != m.end() && !m["Keepalive"].empty()) {
      keepalive = make_shared<string>(boost::any_cast<string>(m["Keepalive"]));
    }
    if (m.find("LocalAsn") != m.end() && !m["LocalAsn"].empty()) {
      localAsn = make_shared<string>(boost::any_cast<string>(m["LocalAsn"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PeerAsn") != m.end() && !m["PeerAsn"].empty()) {
      peerAsn = make_shared<string>(boost::any_cast<string>(m["PeerAsn"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RouteLimit") != m.end() && !m["RouteLimit"].empty()) {
      routeLimit = make_shared<string>(boost::any_cast<string>(m["RouteLimit"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup() = default;
};
class DescribeBgpGroupsResponseBodyBgpGroups : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup>> bgpGroup{};

  DescribeBgpGroupsResponseBodyBgpGroups() {}

  explicit DescribeBgpGroupsResponseBodyBgpGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgpGroup) {
      vector<boost::any> temp1;
      for(auto item1:*bgpGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BgpGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgpGroup") != m.end() && !m["BgpGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["BgpGroup"].type()) {
        vector<DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BgpGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bgpGroup = make_shared<vector<DescribeBgpGroupsResponseBodyBgpGroupsBgpGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeBgpGroupsResponseBodyBgpGroups() = default;
};
class DescribeBgpGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeBgpGroupsResponseBodyBgpGroups> bgpGroups{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeBgpGroupsResponseBody() {}

  explicit DescribeBgpGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgpGroups) {
      res["BgpGroups"] = bgpGroups ? boost::any(bgpGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgpGroups") != m.end() && !m["BgpGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["BgpGroups"].type()) {
        DescribeBgpGroupsResponseBodyBgpGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BgpGroups"]));
        bgpGroups = make_shared<DescribeBgpGroupsResponseBodyBgpGroups>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeBgpGroupsResponseBody() = default;
};
class DescribeBgpGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBgpGroupsResponseBody> body{};

  DescribeBgpGroupsResponse() {}

  explicit DescribeBgpGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBgpGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBgpGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBgpGroupsResponse() = default;
};
class DescribeBgpNetworksRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routerId{};

  DescribeBgpNetworksRequest() {}

  explicit DescribeBgpNetworksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
  }


  virtual ~DescribeBgpNetworksRequest() = default;
};
class DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork : public Darabonba::Model {
public:
  shared_ptr<string> dstCidrBlock{};
  shared_ptr<string> routerId{};
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};

  DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork() {}

  explicit DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstCidrBlock) {
      res["DstCidrBlock"] = boost::any(*dstCidrBlock);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstCidrBlock") != m.end() && !m["DstCidrBlock"].empty()) {
      dstCidrBlock = make_shared<string>(boost::any_cast<string>(m["DstCidrBlock"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork() = default;
};
class DescribeBgpNetworksResponseBodyBgpNetworks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork>> bgpNetwork{};

  DescribeBgpNetworksResponseBodyBgpNetworks() {}

  explicit DescribeBgpNetworksResponseBodyBgpNetworks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgpNetwork) {
      vector<boost::any> temp1;
      for(auto item1:*bgpNetwork){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BgpNetwork"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgpNetwork") != m.end() && !m["BgpNetwork"].empty()) {
      if (typeid(vector<boost::any>) == m["BgpNetwork"].type()) {
        vector<DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BgpNetwork"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bgpNetwork = make_shared<vector<DescribeBgpNetworksResponseBodyBgpNetworksBgpNetwork>>(expect1);
      }
    }
  }


  virtual ~DescribeBgpNetworksResponseBodyBgpNetworks() = default;
};
class DescribeBgpNetworksResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeBgpNetworksResponseBodyBgpNetworks> bgpNetworks{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeBgpNetworksResponseBody() {}

  explicit DescribeBgpNetworksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgpNetworks) {
      res["BgpNetworks"] = bgpNetworks ? boost::any(bgpNetworks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgpNetworks") != m.end() && !m["BgpNetworks"].empty()) {
      if (typeid(map<string, boost::any>) == m["BgpNetworks"].type()) {
        DescribeBgpNetworksResponseBodyBgpNetworks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BgpNetworks"]));
        bgpNetworks = make_shared<DescribeBgpNetworksResponseBodyBgpNetworks>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeBgpNetworksResponseBody() = default;
};
class DescribeBgpNetworksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBgpNetworksResponseBody> body{};

  DescribeBgpNetworksResponse() {}

  explicit DescribeBgpNetworksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBgpNetworksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBgpNetworksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBgpNetworksResponse() = default;
};
class DescribeBgpPeersRequest : public Darabonba::Model {
public:
  shared_ptr<string> bgpGroupId{};
  shared_ptr<string> bgpPeerId{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routerId{};

  DescribeBgpPeersRequest() {}

  explicit DescribeBgpPeersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgpGroupId) {
      res["BgpGroupId"] = boost::any(*bgpGroupId);
    }
    if (bgpPeerId) {
      res["BgpPeerId"] = boost::any(*bgpPeerId);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgpGroupId") != m.end() && !m["BgpGroupId"].empty()) {
      bgpGroupId = make_shared<string>(boost::any_cast<string>(m["BgpGroupId"]));
    }
    if (m.find("BgpPeerId") != m.end() && !m["BgpPeerId"].empty()) {
      bgpPeerId = make_shared<string>(boost::any_cast<string>(m["BgpPeerId"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
  }


  virtual ~DescribeBgpPeersRequest() = default;
};
class DescribeBgpPeersResponseBodyBgpPeersBgpPeer : public Darabonba::Model {
public:
  shared_ptr<long> advertisedRouteCount{};
  shared_ptr<string> authKey{};
  shared_ptr<long> bfdMultiHop{};
  shared_ptr<string> bgpGroupId{};
  shared_ptr<string> bgpPeerId{};
  shared_ptr<string> bgpStatus{};
  shared_ptr<string> description{};
  shared_ptr<bool> enableBfd{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> hold{};
  shared_ptr<string> ipVersion{};
  shared_ptr<bool> isFake{};
  shared_ptr<string> keepalive{};
  shared_ptr<string> localAsn{};
  shared_ptr<string> name{};
  shared_ptr<string> peerAsn{};
  shared_ptr<string> peerIpAddress{};
  shared_ptr<long> receivedRouteCount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> routeLimit{};
  shared_ptr<string> routerId{};
  shared_ptr<string> status{};

  DescribeBgpPeersResponseBodyBgpPeersBgpPeer() {}

  explicit DescribeBgpPeersResponseBodyBgpPeersBgpPeer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advertisedRouteCount) {
      res["AdvertisedRouteCount"] = boost::any(*advertisedRouteCount);
    }
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (bfdMultiHop) {
      res["BfdMultiHop"] = boost::any(*bfdMultiHop);
    }
    if (bgpGroupId) {
      res["BgpGroupId"] = boost::any(*bgpGroupId);
    }
    if (bgpPeerId) {
      res["BgpPeerId"] = boost::any(*bgpPeerId);
    }
    if (bgpStatus) {
      res["BgpStatus"] = boost::any(*bgpStatus);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enableBfd) {
      res["EnableBfd"] = boost::any(*enableBfd);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (hold) {
      res["Hold"] = boost::any(*hold);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (isFake) {
      res["IsFake"] = boost::any(*isFake);
    }
    if (keepalive) {
      res["Keepalive"] = boost::any(*keepalive);
    }
    if (localAsn) {
      res["LocalAsn"] = boost::any(*localAsn);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (peerAsn) {
      res["PeerAsn"] = boost::any(*peerAsn);
    }
    if (peerIpAddress) {
      res["PeerIpAddress"] = boost::any(*peerIpAddress);
    }
    if (receivedRouteCount) {
      res["ReceivedRouteCount"] = boost::any(*receivedRouteCount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (routeLimit) {
      res["RouteLimit"] = boost::any(*routeLimit);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdvertisedRouteCount") != m.end() && !m["AdvertisedRouteCount"].empty()) {
      advertisedRouteCount = make_shared<long>(boost::any_cast<long>(m["AdvertisedRouteCount"]));
    }
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("BfdMultiHop") != m.end() && !m["BfdMultiHop"].empty()) {
      bfdMultiHop = make_shared<long>(boost::any_cast<long>(m["BfdMultiHop"]));
    }
    if (m.find("BgpGroupId") != m.end() && !m["BgpGroupId"].empty()) {
      bgpGroupId = make_shared<string>(boost::any_cast<string>(m["BgpGroupId"]));
    }
    if (m.find("BgpPeerId") != m.end() && !m["BgpPeerId"].empty()) {
      bgpPeerId = make_shared<string>(boost::any_cast<string>(m["BgpPeerId"]));
    }
    if (m.find("BgpStatus") != m.end() && !m["BgpStatus"].empty()) {
      bgpStatus = make_shared<string>(boost::any_cast<string>(m["BgpStatus"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnableBfd") != m.end() && !m["EnableBfd"].empty()) {
      enableBfd = make_shared<bool>(boost::any_cast<bool>(m["EnableBfd"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Hold") != m.end() && !m["Hold"].empty()) {
      hold = make_shared<string>(boost::any_cast<string>(m["Hold"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("IsFake") != m.end() && !m["IsFake"].empty()) {
      isFake = make_shared<bool>(boost::any_cast<bool>(m["IsFake"]));
    }
    if (m.find("Keepalive") != m.end() && !m["Keepalive"].empty()) {
      keepalive = make_shared<string>(boost::any_cast<string>(m["Keepalive"]));
    }
    if (m.find("LocalAsn") != m.end() && !m["LocalAsn"].empty()) {
      localAsn = make_shared<string>(boost::any_cast<string>(m["LocalAsn"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PeerAsn") != m.end() && !m["PeerAsn"].empty()) {
      peerAsn = make_shared<string>(boost::any_cast<string>(m["PeerAsn"]));
    }
    if (m.find("PeerIpAddress") != m.end() && !m["PeerIpAddress"].empty()) {
      peerIpAddress = make_shared<string>(boost::any_cast<string>(m["PeerIpAddress"]));
    }
    if (m.find("ReceivedRouteCount") != m.end() && !m["ReceivedRouteCount"].empty()) {
      receivedRouteCount = make_shared<long>(boost::any_cast<long>(m["ReceivedRouteCount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RouteLimit") != m.end() && !m["RouteLimit"].empty()) {
      routeLimit = make_shared<string>(boost::any_cast<string>(m["RouteLimit"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeBgpPeersResponseBodyBgpPeersBgpPeer() = default;
};
class DescribeBgpPeersResponseBodyBgpPeers : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBgpPeersResponseBodyBgpPeersBgpPeer>> bgpPeer{};

  DescribeBgpPeersResponseBodyBgpPeers() {}

  explicit DescribeBgpPeersResponseBodyBgpPeers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgpPeer) {
      vector<boost::any> temp1;
      for(auto item1:*bgpPeer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BgpPeer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgpPeer") != m.end() && !m["BgpPeer"].empty()) {
      if (typeid(vector<boost::any>) == m["BgpPeer"].type()) {
        vector<DescribeBgpPeersResponseBodyBgpPeersBgpPeer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BgpPeer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBgpPeersResponseBodyBgpPeersBgpPeer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bgpPeer = make_shared<vector<DescribeBgpPeersResponseBodyBgpPeersBgpPeer>>(expect1);
      }
    }
  }


  virtual ~DescribeBgpPeersResponseBodyBgpPeers() = default;
};
class DescribeBgpPeersResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeBgpPeersResponseBodyBgpPeers> bgpPeers{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeBgpPeersResponseBody() {}

  explicit DescribeBgpPeersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgpPeers) {
      res["BgpPeers"] = bgpPeers ? boost::any(bgpPeers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgpPeers") != m.end() && !m["BgpPeers"].empty()) {
      if (typeid(map<string, boost::any>) == m["BgpPeers"].type()) {
        DescribeBgpPeersResponseBodyBgpPeers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BgpPeers"]));
        bgpPeers = make_shared<DescribeBgpPeersResponseBodyBgpPeers>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeBgpPeersResponseBody() = default;
};
class DescribeBgpPeersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBgpPeersResponseBody> body{};

  DescribeBgpPeersResponse() {}

  explicit DescribeBgpPeersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBgpPeersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBgpPeersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBgpPeersResponse() = default;
};
class DescribeCommonBandwidthPackagesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeCommonBandwidthPackagesRequestTag() {}

  explicit DescribeCommonBandwidthPackagesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeCommonBandwidthPackagesRequestTag() = default;
};
class DescribeCommonBandwidthPackagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<bool> dryRun{};
  shared_ptr<bool> includeReservationData{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<bool> securityProtectionEnabled{};
  shared_ptr<vector<DescribeCommonBandwidthPackagesRequestTag>> tag{};

  DescribeCommonBandwidthPackagesRequest() {}

  explicit DescribeCommonBandwidthPackagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (includeReservationData) {
      res["IncludeReservationData"] = boost::any(*includeReservationData);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityProtectionEnabled) {
      res["SecurityProtectionEnabled"] = boost::any(*securityProtectionEnabled);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("IncludeReservationData") != m.end() && !m["IncludeReservationData"].empty()) {
      includeReservationData = make_shared<bool>(boost::any_cast<bool>(m["IncludeReservationData"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityProtectionEnabled") != m.end() && !m["SecurityProtectionEnabled"].empty()) {
      securityProtectionEnabled = make_shared<bool>(boost::any_cast<bool>(m["SecurityProtectionEnabled"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeCommonBandwidthPackagesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCommonBandwidthPackagesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeCommonBandwidthPackagesRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeCommonBandwidthPackagesRequest() = default;
};
class DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddressesPublicIpAddresse : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> bandwidthPackageIpRelationStatus{};
  shared_ptr<string> ipAddress{};

  DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddressesPublicIpAddresse() {}

  explicit DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddressesPublicIpAddresse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (bandwidthPackageIpRelationStatus) {
      res["BandwidthPackageIpRelationStatus"] = boost::any(*bandwidthPackageIpRelationStatus);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("BandwidthPackageIpRelationStatus") != m.end() && !m["BandwidthPackageIpRelationStatus"].empty()) {
      bandwidthPackageIpRelationStatus = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageIpRelationStatus"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
  }


  virtual ~DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddressesPublicIpAddresse() = default;
};
class DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddressesPublicIpAddresse>> publicIpAddresse{};

  DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddresses() {}

  explicit DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (publicIpAddresse) {
      vector<boost::any> temp1;
      for(auto item1:*publicIpAddresse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PublicIpAddresse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PublicIpAddresse") != m.end() && !m["PublicIpAddresse"].empty()) {
      if (typeid(vector<boost::any>) == m["PublicIpAddresse"].type()) {
        vector<DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddressesPublicIpAddresse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PublicIpAddresse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddressesPublicIpAddresse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        publicIpAddresse = make_shared<vector<DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddressesPublicIpAddresse>>(expect1);
      }
    }
  }


  virtual ~DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddresses() = default;
};
class DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageSecurityProtectionTypes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> securityProtectionType{};

  DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageSecurityProtectionTypes() {}

  explicit DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageSecurityProtectionTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityProtectionType) {
      res["SecurityProtectionType"] = boost::any(*securityProtectionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityProtectionType") != m.end() && !m["SecurityProtectionType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityProtectionType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityProtectionType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityProtectionType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageSecurityProtectionTypes() = default;
};
class DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTagsTag() {}

  explicit DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTagsTag() = default;
};
class DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTagsTag>> tag{};

  DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTags() {}

  explicit DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTags() = default;
};
class DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage : public Darabonba::Model {
public:
  shared_ptr<string> bandwidth{};
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> bizType{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> creationTime{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<string> description{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> hasReservationData{};
  shared_ptr<string> ISP{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> name{};
  shared_ptr<DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddresses> publicIpAddresses{};
  shared_ptr<long> ratio{};
  shared_ptr<string> regionId{};
  shared_ptr<string> reservationActiveTime{};
  shared_ptr<string> reservationBandwidth{};
  shared_ptr<string> reservationInternetChargeType{};
  shared_ptr<string> reservationOrderType{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageSecurityProtectionTypes> securityProtectionTypes{};
  shared_ptr<long> serviceManaged{};
  shared_ptr<string> status{};
  shared_ptr<DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTags> tags{};
  shared_ptr<string> zone{};

  DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage() {}

  explicit DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (deletionProtection) {
      res["DeletionProtection"] = boost::any(*deletionProtection);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (hasReservationData) {
      res["HasReservationData"] = boost::any(*hasReservationData);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (publicIpAddresses) {
      res["PublicIpAddresses"] = publicIpAddresses ? boost::any(publicIpAddresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ratio) {
      res["Ratio"] = boost::any(*ratio);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reservationActiveTime) {
      res["ReservationActiveTime"] = boost::any(*reservationActiveTime);
    }
    if (reservationBandwidth) {
      res["ReservationBandwidth"] = boost::any(*reservationBandwidth);
    }
    if (reservationInternetChargeType) {
      res["ReservationInternetChargeType"] = boost::any(*reservationInternetChargeType);
    }
    if (reservationOrderType) {
      res["ReservationOrderType"] = boost::any(*reservationOrderType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityProtectionTypes) {
      res["SecurityProtectionTypes"] = securityProtectionTypes ? boost::any(securityProtectionTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceManaged) {
      res["ServiceManaged"] = boost::any(*serviceManaged);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (zone) {
      res["Zone"] = boost::any(*zone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DeletionProtection") != m.end() && !m["DeletionProtection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["DeletionProtection"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("HasReservationData") != m.end() && !m["HasReservationData"].empty()) {
      hasReservationData = make_shared<string>(boost::any_cast<string>(m["HasReservationData"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PublicIpAddresses") != m.end() && !m["PublicIpAddresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["PublicIpAddresses"].type()) {
        DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PublicIpAddresses"]));
        publicIpAddresses = make_shared<DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackagePublicIpAddresses>(model1);
      }
    }
    if (m.find("Ratio") != m.end() && !m["Ratio"].empty()) {
      ratio = make_shared<long>(boost::any_cast<long>(m["Ratio"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReservationActiveTime") != m.end() && !m["ReservationActiveTime"].empty()) {
      reservationActiveTime = make_shared<string>(boost::any_cast<string>(m["ReservationActiveTime"]));
    }
    if (m.find("ReservationBandwidth") != m.end() && !m["ReservationBandwidth"].empty()) {
      reservationBandwidth = make_shared<string>(boost::any_cast<string>(m["ReservationBandwidth"]));
    }
    if (m.find("ReservationInternetChargeType") != m.end() && !m["ReservationInternetChargeType"].empty()) {
      reservationInternetChargeType = make_shared<string>(boost::any_cast<string>(m["ReservationInternetChargeType"]));
    }
    if (m.find("ReservationOrderType") != m.end() && !m["ReservationOrderType"].empty()) {
      reservationOrderType = make_shared<string>(boost::any_cast<string>(m["ReservationOrderType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityProtectionTypes") != m.end() && !m["SecurityProtectionTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityProtectionTypes"].type()) {
        DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageSecurityProtectionTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityProtectionTypes"]));
        securityProtectionTypes = make_shared<DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageSecurityProtectionTypes>(model1);
      }
    }
    if (m.find("ServiceManaged") != m.end() && !m["ServiceManaged"].empty()) {
      serviceManaged = make_shared<long>(boost::any_cast<long>(m["ServiceManaged"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackageTags>(model1);
      }
    }
    if (m.find("Zone") != m.end() && !m["Zone"].empty()) {
      zone = make_shared<string>(boost::any_cast<string>(m["Zone"]));
    }
  }


  virtual ~DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage() = default;
};
class DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackages : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage>> commonBandwidthPackage{};

  DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackages() {}

  explicit DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonBandwidthPackage) {
      vector<boost::any> temp1;
      for(auto item1:*commonBandwidthPackage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CommonBandwidthPackage"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommonBandwidthPackage") != m.end() && !m["CommonBandwidthPackage"].empty()) {
      if (typeid(vector<boost::any>) == m["CommonBandwidthPackage"].type()) {
        vector<DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CommonBandwidthPackage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        commonBandwidthPackage = make_shared<vector<DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackagesCommonBandwidthPackage>>(expect1);
      }
    }
  }


  virtual ~DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackages() = default;
};
class DescribeCommonBandwidthPackagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackages> commonBandwidthPackages{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeCommonBandwidthPackagesResponseBody() {}

  explicit DescribeCommonBandwidthPackagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonBandwidthPackages) {
      res["CommonBandwidthPackages"] = commonBandwidthPackages ? boost::any(commonBandwidthPackages->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommonBandwidthPackages") != m.end() && !m["CommonBandwidthPackages"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommonBandwidthPackages"].type()) {
        DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommonBandwidthPackages"]));
        commonBandwidthPackages = make_shared<DescribeCommonBandwidthPackagesResponseBodyCommonBandwidthPackages>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeCommonBandwidthPackagesResponseBody() = default;
};
class DescribeCommonBandwidthPackagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCommonBandwidthPackagesResponseBody> body{};

  DescribeCommonBandwidthPackagesResponse() {}

  explicit DescribeCommonBandwidthPackagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCommonBandwidthPackagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCommonBandwidthPackagesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCommonBandwidthPackagesResponse() = default;
};
class DescribeCustomerGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> customerGatewayId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeCustomerGatewayRequest() {}

  explicit DescribeCustomerGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeCustomerGatewayRequest() = default;
};
class DescribeCustomerGatewayResponseBodyTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeCustomerGatewayResponseBodyTagsTag() {}

  explicit DescribeCustomerGatewayResponseBodyTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeCustomerGatewayResponseBodyTagsTag() = default;
};
class DescribeCustomerGatewayResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCustomerGatewayResponseBodyTagsTag>> tag{};

  DescribeCustomerGatewayResponseBodyTags() {}

  explicit DescribeCustomerGatewayResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeCustomerGatewayResponseBodyTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCustomerGatewayResponseBodyTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeCustomerGatewayResponseBodyTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeCustomerGatewayResponseBodyTags() = default;
};
class DescribeCustomerGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> asn{};
  shared_ptr<string> authKey{};
  shared_ptr<long> createTime{};
  shared_ptr<string> customerGatewayId{};
  shared_ptr<string> description{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<DescribeCustomerGatewayResponseBodyTags> tags{};

  DescribeCustomerGatewayResponseBody() {}

  explicit DescribeCustomerGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asn) {
      res["Asn"] = boost::any(*asn);
    }
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asn") != m.end() && !m["Asn"].empty()) {
      asn = make_shared<long>(boost::any_cast<long>(m["Asn"]));
    }
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeCustomerGatewayResponseBodyTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeCustomerGatewayResponseBodyTags>(model1);
      }
    }
  }


  virtual ~DescribeCustomerGatewayResponseBody() = default;
};
class DescribeCustomerGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustomerGatewayResponseBody> body{};

  DescribeCustomerGatewayResponse() {}

  explicit DescribeCustomerGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustomerGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustomerGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustomerGatewayResponse() = default;
};
class DescribeCustomerGatewaysRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeCustomerGatewaysRequestTag() {}

  explicit DescribeCustomerGatewaysRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeCustomerGatewaysRequestTag() = default;
};
class DescribeCustomerGatewaysRequest : public Darabonba::Model {
public:
  shared_ptr<string> customerGatewayId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<DescribeCustomerGatewaysRequestTag>> tag{};

  DescribeCustomerGatewaysRequest() {}

  explicit DescribeCustomerGatewaysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeCustomerGatewaysRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCustomerGatewaysRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeCustomerGatewaysRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeCustomerGatewaysRequest() = default;
};
class DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTagsTag() {}

  explicit DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTagsTag() = default;
};
class DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTagsTag>> tag{};

  DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTags() {}

  explicit DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTags() = default;
};
class DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway : public Darabonba::Model {
public:
  shared_ptr<long> asn{};
  shared_ptr<string> authKey{};
  shared_ptr<long> createTime{};
  shared_ptr<string> customerGatewayId{};
  shared_ptr<string> description{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> name{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTags> tags{};

  DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway() {}

  explicit DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asn) {
      res["Asn"] = boost::any(*asn);
    }
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asn") != m.end() && !m["Asn"].empty()) {
      asn = make_shared<long>(boost::any_cast<long>(m["Asn"]));
    }
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGatewayTags>(model1);
      }
    }
  }


  virtual ~DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway() = default;
};
class DescribeCustomerGatewaysResponseBodyCustomerGateways : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway>> customerGateway{};

  DescribeCustomerGatewaysResponseBodyCustomerGateways() {}

  explicit DescribeCustomerGatewaysResponseBodyCustomerGateways(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customerGateway) {
      vector<boost::any> temp1;
      for(auto item1:*customerGateway){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomerGateway"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomerGateway") != m.end() && !m["CustomerGateway"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomerGateway"].type()) {
        vector<DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomerGateway"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customerGateway = make_shared<vector<DescribeCustomerGatewaysResponseBodyCustomerGatewaysCustomerGateway>>(expect1);
      }
    }
  }


  virtual ~DescribeCustomerGatewaysResponseBodyCustomerGateways() = default;
};
class DescribeCustomerGatewaysResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCustomerGatewaysResponseBodyCustomerGateways> customerGateways{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeCustomerGatewaysResponseBody() {}

  explicit DescribeCustomerGatewaysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customerGateways) {
      res["CustomerGateways"] = customerGateways ? boost::any(customerGateways->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomerGateways") != m.end() && !m["CustomerGateways"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomerGateways"].type()) {
        DescribeCustomerGatewaysResponseBodyCustomerGateways model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomerGateways"]));
        customerGateways = make_shared<DescribeCustomerGatewaysResponseBodyCustomerGateways>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeCustomerGatewaysResponseBody() = default;
};
class DescribeCustomerGatewaysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustomerGatewaysResponseBody> body{};

  DescribeCustomerGatewaysResponse() {}

  explicit DescribeCustomerGatewaysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustomerGatewaysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustomerGatewaysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustomerGatewaysResponse() = default;
};
class DescribeEcGrantRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> vbrRegionNo{};

  DescribeEcGrantRelationRequest() {}

  explicit DescribeEcGrantRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (vbrRegionNo) {
      res["VbrRegionNo"] = boost::any(*vbrRegionNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("VbrRegionNo") != m.end() && !m["VbrRegionNo"].empty()) {
      vbrRegionNo = make_shared<string>(boost::any_cast<string>(m["VbrRegionNo"]));
    }
  }


  virtual ~DescribeEcGrantRelationRequest() = default;
};
class DescribeEcGrantRelationResponseBodyEcGrantRelations : public Darabonba::Model {
public:
  shared_ptr<long> aliUid{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> grantType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceRouterId{};
  shared_ptr<string> regionNo{};
  shared_ptr<string> status{};
  shared_ptr<string> vbrInstanceId{};
  shared_ptr<long> vbrOwnerUid{};
  shared_ptr<string> vbrRegionNo{};

  DescribeEcGrantRelationResponseBodyEcGrantRelations() {}

  explicit DescribeEcGrantRelationResponseBodyEcGrantRelations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (grantType) {
      res["GrantType"] = boost::any(*grantType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceRouterId) {
      res["InstanceRouterId"] = boost::any(*instanceRouterId);
    }
    if (regionNo) {
      res["RegionNo"] = boost::any(*regionNo);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vbrInstanceId) {
      res["VbrInstanceId"] = boost::any(*vbrInstanceId);
    }
    if (vbrOwnerUid) {
      res["VbrOwnerUid"] = boost::any(*vbrOwnerUid);
    }
    if (vbrRegionNo) {
      res["VbrRegionNo"] = boost::any(*vbrRegionNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GrantType") != m.end() && !m["GrantType"].empty()) {
      grantType = make_shared<string>(boost::any_cast<string>(m["GrantType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceRouterId") != m.end() && !m["InstanceRouterId"].empty()) {
      instanceRouterId = make_shared<string>(boost::any_cast<string>(m["InstanceRouterId"]));
    }
    if (m.find("RegionNo") != m.end() && !m["RegionNo"].empty()) {
      regionNo = make_shared<string>(boost::any_cast<string>(m["RegionNo"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VbrInstanceId") != m.end() && !m["VbrInstanceId"].empty()) {
      vbrInstanceId = make_shared<string>(boost::any_cast<string>(m["VbrInstanceId"]));
    }
    if (m.find("VbrOwnerUid") != m.end() && !m["VbrOwnerUid"].empty()) {
      vbrOwnerUid = make_shared<long>(boost::any_cast<long>(m["VbrOwnerUid"]));
    }
    if (m.find("VbrRegionNo") != m.end() && !m["VbrRegionNo"].empty()) {
      vbrRegionNo = make_shared<string>(boost::any_cast<string>(m["VbrRegionNo"]));
    }
  }


  virtual ~DescribeEcGrantRelationResponseBodyEcGrantRelations() = default;
};
class DescribeEcGrantRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeEcGrantRelationResponseBodyEcGrantRelations>> ecGrantRelations{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeEcGrantRelationResponseBody() {}

  explicit DescribeEcGrantRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (ecGrantRelations) {
      vector<boost::any> temp1;
      for(auto item1:*ecGrantRelations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EcGrantRelations"] = boost::any(temp1);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("EcGrantRelations") != m.end() && !m["EcGrantRelations"].empty()) {
      if (typeid(vector<boost::any>) == m["EcGrantRelations"].type()) {
        vector<DescribeEcGrantRelationResponseBodyEcGrantRelations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EcGrantRelations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEcGrantRelationResponseBodyEcGrantRelations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecGrantRelations = make_shared<vector<DescribeEcGrantRelationResponseBodyEcGrantRelations>>(expect1);
      }
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeEcGrantRelationResponseBody() = default;
};
class DescribeEcGrantRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEcGrantRelationResponseBody> body{};

  DescribeEcGrantRelationResponse() {}

  explicit DescribeEcGrantRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEcGrantRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEcGrantRelationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEcGrantRelationResponse() = default;
};
class DescribeEipAddressesRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeEipAddressesRequestFilter() {}

  explicit DescribeEipAddressesRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeEipAddressesRequestFilter() = default;
};
class DescribeEipAddressesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeEipAddressesRequestTag() {}

  explicit DescribeEipAddressesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeEipAddressesRequestTag() = default;
};
class DescribeEipAddressesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEipAddressesRequestFilter>> filter{};
  shared_ptr<string> allocationId{};
  shared_ptr<string> associatedInstanceId{};
  shared_ptr<string> associatedInstanceType{};
  shared_ptr<string> chargeType{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> eipAddress{};
  shared_ptr<string> eipName{};
  shared_ptr<string> ISP{};
  shared_ptr<bool> includeReservationData{};
  shared_ptr<string> lockReason{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> publicIpAddressPoolId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<bool> securityProtectionEnabled{};
  shared_ptr<string> segmentInstanceId{};
  shared_ptr<bool> serviceManaged{};
  shared_ptr<string> status{};
  shared_ptr<vector<DescribeEipAddressesRequestTag>> tag{};

  DescribeEipAddressesRequest() {}

  explicit DescribeEipAddressesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (associatedInstanceId) {
      res["AssociatedInstanceId"] = boost::any(*associatedInstanceId);
    }
    if (associatedInstanceType) {
      res["AssociatedInstanceType"] = boost::any(*associatedInstanceType);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (eipAddress) {
      res["EipAddress"] = boost::any(*eipAddress);
    }
    if (eipName) {
      res["EipName"] = boost::any(*eipName);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (includeReservationData) {
      res["IncludeReservationData"] = boost::any(*includeReservationData);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (publicIpAddressPoolId) {
      res["PublicIpAddressPoolId"] = boost::any(*publicIpAddressPoolId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityProtectionEnabled) {
      res["SecurityProtectionEnabled"] = boost::any(*securityProtectionEnabled);
    }
    if (segmentInstanceId) {
      res["SegmentInstanceId"] = boost::any(*segmentInstanceId);
    }
    if (serviceManaged) {
      res["ServiceManaged"] = boost::any(*serviceManaged);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeEipAddressesRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEipAddressesRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeEipAddressesRequestFilter>>(expect1);
      }
    }
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("AssociatedInstanceId") != m.end() && !m["AssociatedInstanceId"].empty()) {
      associatedInstanceId = make_shared<string>(boost::any_cast<string>(m["AssociatedInstanceId"]));
    }
    if (m.find("AssociatedInstanceType") != m.end() && !m["AssociatedInstanceType"].empty()) {
      associatedInstanceType = make_shared<string>(boost::any_cast<string>(m["AssociatedInstanceType"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EipAddress") != m.end() && !m["EipAddress"].empty()) {
      eipAddress = make_shared<string>(boost::any_cast<string>(m["EipAddress"]));
    }
    if (m.find("EipName") != m.end() && !m["EipName"].empty()) {
      eipName = make_shared<string>(boost::any_cast<string>(m["EipName"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("IncludeReservationData") != m.end() && !m["IncludeReservationData"].empty()) {
      includeReservationData = make_shared<bool>(boost::any_cast<bool>(m["IncludeReservationData"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PublicIpAddressPoolId") != m.end() && !m["PublicIpAddressPoolId"].empty()) {
      publicIpAddressPoolId = make_shared<string>(boost::any_cast<string>(m["PublicIpAddressPoolId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityProtectionEnabled") != m.end() && !m["SecurityProtectionEnabled"].empty()) {
      securityProtectionEnabled = make_shared<bool>(boost::any_cast<bool>(m["SecurityProtectionEnabled"]));
    }
    if (m.find("SegmentInstanceId") != m.end() && !m["SegmentInstanceId"].empty()) {
      segmentInstanceId = make_shared<string>(boost::any_cast<string>(m["SegmentInstanceId"]));
    }
    if (m.find("ServiceManaged") != m.end() && !m["ServiceManaged"].empty()) {
      serviceManaged = make_shared<bool>(boost::any_cast<bool>(m["ServiceManaged"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeEipAddressesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEipAddressesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeEipAddressesRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeEipAddressesRequest() = default;
};
class DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason : public Darabonba::Model {
public:
  shared_ptr<string> lockReason{};

  DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason() {}

  explicit DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
  }


  virtual ~DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason() = default;
};
class DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason>> lockReason{};

  DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks() {}

  explicit DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      vector<boost::any> temp1;
      for(auto item1:*lockReason){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LockReason"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      if (typeid(vector<boost::any>) == m["LockReason"].type()) {
        vector<DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LockReason"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lockReason = make_shared<vector<DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason>>(expect1);
      }
    }
  }


  virtual ~DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks() = default;
};
class DescribeEipAddressesResponseBodyEipAddressesEipAddressSecurityProtectionTypes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> securityProtectionType{};

  DescribeEipAddressesResponseBodyEipAddressesEipAddressSecurityProtectionTypes() {}

  explicit DescribeEipAddressesResponseBodyEipAddressesEipAddressSecurityProtectionTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityProtectionType) {
      res["SecurityProtectionType"] = boost::any(*securityProtectionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityProtectionType") != m.end() && !m["SecurityProtectionType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityProtectionType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityProtectionType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityProtectionType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeEipAddressesResponseBodyEipAddressesEipAddressSecurityProtectionTypes() = default;
};
class DescribeEipAddressesResponseBodyEipAddressesEipAddressTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeEipAddressesResponseBodyEipAddressesEipAddressTagsTag() {}

  explicit DescribeEipAddressesResponseBodyEipAddressesEipAddressTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeEipAddressesResponseBodyEipAddressesEipAddressTagsTag() = default;
};
class DescribeEipAddressesResponseBodyEipAddressesEipAddressTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEipAddressesResponseBodyEipAddressesEipAddressTagsTag>> tag{};

  DescribeEipAddressesResponseBodyEipAddressesEipAddressTags() {}

  explicit DescribeEipAddressesResponseBodyEipAddressesEipAddressTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeEipAddressesResponseBodyEipAddressesEipAddressTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEipAddressesResponseBodyEipAddressesEipAddressTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeEipAddressesResponseBodyEipAddressesEipAddressTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeEipAddressesResponseBodyEipAddressesEipAddressTags() = default;
};
class DescribeEipAddressesResponseBodyEipAddressesEipAddress : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> allocationTime{};
  shared_ptr<string> bandwidth{};
  shared_ptr<string> bandwidthPackageBandwidth{};
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> bandwidthPackageType{};
  shared_ptr<string> bizType{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> chargeType{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<string> description{};
  shared_ptr<string> eipBandwidth{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> HDMonitorStatus{};
  shared_ptr<string> hasReservationData{};
  shared_ptr<string> ISP{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceRegionId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> mode{};
  shared_ptr<string> name{};
  shared_ptr<string> netmode{};
  shared_ptr<DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks> operationLocks{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> publicIpAddressPoolId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> reservationActiveTime{};
  shared_ptr<string> reservationBandwidth{};
  shared_ptr<string> reservationInternetChargeType{};
  shared_ptr<string> reservationOrderType{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> secondLimited{};
  shared_ptr<DescribeEipAddressesResponseBodyEipAddressesEipAddressSecurityProtectionTypes> securityProtectionTypes{};
  shared_ptr<string> segmentInstanceId{};
  shared_ptr<long> serviceManaged{};
  shared_ptr<string> status{};
  shared_ptr<DescribeEipAddressesResponseBodyEipAddressesEipAddressTags> tags{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zone{};

  DescribeEipAddressesResponseBodyEipAddressesEipAddress() {}

  explicit DescribeEipAddressesResponseBodyEipAddressesEipAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (allocationTime) {
      res["AllocationTime"] = boost::any(*allocationTime);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (bandwidthPackageBandwidth) {
      res["BandwidthPackageBandwidth"] = boost::any(*bandwidthPackageBandwidth);
    }
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (bandwidthPackageType) {
      res["BandwidthPackageType"] = boost::any(*bandwidthPackageType);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (deletionProtection) {
      res["DeletionProtection"] = boost::any(*deletionProtection);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eipBandwidth) {
      res["EipBandwidth"] = boost::any(*eipBandwidth);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (HDMonitorStatus) {
      res["HDMonitorStatus"] = boost::any(*HDMonitorStatus);
    }
    if (hasReservationData) {
      res["HasReservationData"] = boost::any(*hasReservationData);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceRegionId) {
      res["InstanceRegionId"] = boost::any(*instanceRegionId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (netmode) {
      res["Netmode"] = boost::any(*netmode);
    }
    if (operationLocks) {
      res["OperationLocks"] = operationLocks ? boost::any(operationLocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (publicIpAddressPoolId) {
      res["PublicIpAddressPoolId"] = boost::any(*publicIpAddressPoolId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reservationActiveTime) {
      res["ReservationActiveTime"] = boost::any(*reservationActiveTime);
    }
    if (reservationBandwidth) {
      res["ReservationBandwidth"] = boost::any(*reservationBandwidth);
    }
    if (reservationInternetChargeType) {
      res["ReservationInternetChargeType"] = boost::any(*reservationInternetChargeType);
    }
    if (reservationOrderType) {
      res["ReservationOrderType"] = boost::any(*reservationOrderType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (secondLimited) {
      res["SecondLimited"] = boost::any(*secondLimited);
    }
    if (securityProtectionTypes) {
      res["SecurityProtectionTypes"] = securityProtectionTypes ? boost::any(securityProtectionTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segmentInstanceId) {
      res["SegmentInstanceId"] = boost::any(*segmentInstanceId);
    }
    if (serviceManaged) {
      res["ServiceManaged"] = boost::any(*serviceManaged);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zone) {
      res["Zone"] = boost::any(*zone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("AllocationTime") != m.end() && !m["AllocationTime"].empty()) {
      allocationTime = make_shared<string>(boost::any_cast<string>(m["AllocationTime"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("BandwidthPackageBandwidth") != m.end() && !m["BandwidthPackageBandwidth"].empty()) {
      bandwidthPackageBandwidth = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageBandwidth"]));
    }
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("BandwidthPackageType") != m.end() && !m["BandwidthPackageType"].empty()) {
      bandwidthPackageType = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageType"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DeletionProtection") != m.end() && !m["DeletionProtection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["DeletionProtection"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EipBandwidth") != m.end() && !m["EipBandwidth"].empty()) {
      eipBandwidth = make_shared<string>(boost::any_cast<string>(m["EipBandwidth"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("HDMonitorStatus") != m.end() && !m["HDMonitorStatus"].empty()) {
      HDMonitorStatus = make_shared<string>(boost::any_cast<string>(m["HDMonitorStatus"]));
    }
    if (m.find("HasReservationData") != m.end() && !m["HasReservationData"].empty()) {
      hasReservationData = make_shared<string>(boost::any_cast<string>(m["HasReservationData"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceRegionId") != m.end() && !m["InstanceRegionId"].empty()) {
      instanceRegionId = make_shared<string>(boost::any_cast<string>(m["InstanceRegionId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Netmode") != m.end() && !m["Netmode"].empty()) {
      netmode = make_shared<string>(boost::any_cast<string>(m["Netmode"]));
    }
    if (m.find("OperationLocks") != m.end() && !m["OperationLocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperationLocks"].type()) {
        DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperationLocks"]));
        operationLocks = make_shared<DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks>(model1);
      }
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("PublicIpAddressPoolId") != m.end() && !m["PublicIpAddressPoolId"].empty()) {
      publicIpAddressPoolId = make_shared<string>(boost::any_cast<string>(m["PublicIpAddressPoolId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReservationActiveTime") != m.end() && !m["ReservationActiveTime"].empty()) {
      reservationActiveTime = make_shared<string>(boost::any_cast<string>(m["ReservationActiveTime"]));
    }
    if (m.find("ReservationBandwidth") != m.end() && !m["ReservationBandwidth"].empty()) {
      reservationBandwidth = make_shared<string>(boost::any_cast<string>(m["ReservationBandwidth"]));
    }
    if (m.find("ReservationInternetChargeType") != m.end() && !m["ReservationInternetChargeType"].empty()) {
      reservationInternetChargeType = make_shared<string>(boost::any_cast<string>(m["ReservationInternetChargeType"]));
    }
    if (m.find("ReservationOrderType") != m.end() && !m["ReservationOrderType"].empty()) {
      reservationOrderType = make_shared<string>(boost::any_cast<string>(m["ReservationOrderType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecondLimited") != m.end() && !m["SecondLimited"].empty()) {
      secondLimited = make_shared<bool>(boost::any_cast<bool>(m["SecondLimited"]));
    }
    if (m.find("SecurityProtectionTypes") != m.end() && !m["SecurityProtectionTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityProtectionTypes"].type()) {
        DescribeEipAddressesResponseBodyEipAddressesEipAddressSecurityProtectionTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityProtectionTypes"]));
        securityProtectionTypes = make_shared<DescribeEipAddressesResponseBodyEipAddressesEipAddressSecurityProtectionTypes>(model1);
      }
    }
    if (m.find("SegmentInstanceId") != m.end() && !m["SegmentInstanceId"].empty()) {
      segmentInstanceId = make_shared<string>(boost::any_cast<string>(m["SegmentInstanceId"]));
    }
    if (m.find("ServiceManaged") != m.end() && !m["ServiceManaged"].empty()) {
      serviceManaged = make_shared<long>(boost::any_cast<long>(m["ServiceManaged"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeEipAddressesResponseBodyEipAddressesEipAddressTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeEipAddressesResponseBodyEipAddressesEipAddressTags>(model1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("Zone") != m.end() && !m["Zone"].empty()) {
      zone = make_shared<string>(boost::any_cast<string>(m["Zone"]));
    }
  }


  virtual ~DescribeEipAddressesResponseBodyEipAddressesEipAddress() = default;
};
class DescribeEipAddressesResponseBodyEipAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEipAddressesResponseBodyEipAddressesEipAddress>> eipAddress{};

  DescribeEipAddressesResponseBodyEipAddresses() {}

  explicit DescribeEipAddressesResponseBodyEipAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipAddress) {
      vector<boost::any> temp1;
      for(auto item1:*eipAddress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EipAddress"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipAddress") != m.end() && !m["EipAddress"].empty()) {
      if (typeid(vector<boost::any>) == m["EipAddress"].type()) {
        vector<DescribeEipAddressesResponseBodyEipAddressesEipAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EipAddress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEipAddressesResponseBodyEipAddressesEipAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eipAddress = make_shared<vector<DescribeEipAddressesResponseBodyEipAddressesEipAddress>>(expect1);
      }
    }
  }


  virtual ~DescribeEipAddressesResponseBodyEipAddresses() = default;
};
class DescribeEipAddressesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeEipAddressesResponseBodyEipAddresses> eipAddresses{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeEipAddressesResponseBody() {}

  explicit DescribeEipAddressesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipAddresses) {
      res["EipAddresses"] = eipAddresses ? boost::any(eipAddresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipAddresses") != m.end() && !m["EipAddresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["EipAddresses"].type()) {
        DescribeEipAddressesResponseBodyEipAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EipAddresses"]));
        eipAddresses = make_shared<DescribeEipAddressesResponseBodyEipAddresses>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeEipAddressesResponseBody() = default;
};
class DescribeEipAddressesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEipAddressesResponseBody> body{};

  DescribeEipAddressesResponse() {}

  explicit DescribeEipAddressesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEipAddressesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEipAddressesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEipAddressesResponse() = default;
};
class DescribeEipGatewayInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeEipGatewayInfoRequest() {}

  explicit DescribeEipGatewayInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeEipGatewayInfoRequest() = default;
};
class DescribeEipGatewayInfoResponseBodyEipInfosEipInfo : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<string> ipGw{};
  shared_ptr<string> ipMask{};

  DescribeEipGatewayInfoResponseBodyEipInfosEipInfo() {}

  explicit DescribeEipGatewayInfoResponseBodyEipInfosEipInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (ipGw) {
      res["IpGw"] = boost::any(*ipGw);
    }
    if (ipMask) {
      res["IpMask"] = boost::any(*ipMask);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("IpGw") != m.end() && !m["IpGw"].empty()) {
      ipGw = make_shared<string>(boost::any_cast<string>(m["IpGw"]));
    }
    if (m.find("IpMask") != m.end() && !m["IpMask"].empty()) {
      ipMask = make_shared<string>(boost::any_cast<string>(m["IpMask"]));
    }
  }


  virtual ~DescribeEipGatewayInfoResponseBodyEipInfosEipInfo() = default;
};
class DescribeEipGatewayInfoResponseBodyEipInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEipGatewayInfoResponseBodyEipInfosEipInfo>> eipInfo{};

  DescribeEipGatewayInfoResponseBodyEipInfos() {}

  explicit DescribeEipGatewayInfoResponseBodyEipInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipInfo) {
      vector<boost::any> temp1;
      for(auto item1:*eipInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EipInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipInfo") != m.end() && !m["EipInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["EipInfo"].type()) {
        vector<DescribeEipGatewayInfoResponseBodyEipInfosEipInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EipInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEipGatewayInfoResponseBodyEipInfosEipInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eipInfo = make_shared<vector<DescribeEipGatewayInfoResponseBodyEipInfosEipInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeEipGatewayInfoResponseBodyEipInfos() = default;
};
class DescribeEipGatewayInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeEipGatewayInfoResponseBodyEipInfos> eipInfos{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DescribeEipGatewayInfoResponseBody() {}

  explicit DescribeEipGatewayInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (eipInfos) {
      res["EipInfos"] = eipInfos ? boost::any(eipInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("EipInfos") != m.end() && !m["EipInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["EipInfos"].type()) {
        DescribeEipGatewayInfoResponseBodyEipInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EipInfos"]));
        eipInfos = make_shared<DescribeEipGatewayInfoResponseBodyEipInfos>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEipGatewayInfoResponseBody() = default;
};
class DescribeEipGatewayInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEipGatewayInfoResponseBody> body{};

  DescribeEipGatewayInfoResponse() {}

  explicit DescribeEipGatewayInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEipGatewayInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEipGatewayInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEipGatewayInfoResponse() = default;
};
class DescribeEipMonitorDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> period{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> startTime{};

  DescribeEipMonitorDataRequest() {}

  explicit DescribeEipMonitorDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeEipMonitorDataRequest() = default;
};
class DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData : public Darabonba::Model {
public:
  shared_ptr<long> eipBandwidth{};
  shared_ptr<long> eipFlow{};
  shared_ptr<long> eipPackets{};
  shared_ptr<long> eipRX{};
  shared_ptr<long> eipTX{};
  shared_ptr<string> timeStamp{};

  DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData() {}

  explicit DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipBandwidth) {
      res["EipBandwidth"] = boost::any(*eipBandwidth);
    }
    if (eipFlow) {
      res["EipFlow"] = boost::any(*eipFlow);
    }
    if (eipPackets) {
      res["EipPackets"] = boost::any(*eipPackets);
    }
    if (eipRX) {
      res["EipRX"] = boost::any(*eipRX);
    }
    if (eipTX) {
      res["EipTX"] = boost::any(*eipTX);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipBandwidth") != m.end() && !m["EipBandwidth"].empty()) {
      eipBandwidth = make_shared<long>(boost::any_cast<long>(m["EipBandwidth"]));
    }
    if (m.find("EipFlow") != m.end() && !m["EipFlow"].empty()) {
      eipFlow = make_shared<long>(boost::any_cast<long>(m["EipFlow"]));
    }
    if (m.find("EipPackets") != m.end() && !m["EipPackets"].empty()) {
      eipPackets = make_shared<long>(boost::any_cast<long>(m["EipPackets"]));
    }
    if (m.find("EipRX") != m.end() && !m["EipRX"].empty()) {
      eipRX = make_shared<long>(boost::any_cast<long>(m["EipRX"]));
    }
    if (m.find("EipTX") != m.end() && !m["EipTX"].empty()) {
      eipTX = make_shared<long>(boost::any_cast<long>(m["EipTX"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData() = default;
};
class DescribeEipMonitorDataResponseBodyEipMonitorDatas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData>> eipMonitorData{};

  DescribeEipMonitorDataResponseBodyEipMonitorDatas() {}

  explicit DescribeEipMonitorDataResponseBodyEipMonitorDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipMonitorData) {
      vector<boost::any> temp1;
      for(auto item1:*eipMonitorData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EipMonitorData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipMonitorData") != m.end() && !m["EipMonitorData"].empty()) {
      if (typeid(vector<boost::any>) == m["EipMonitorData"].type()) {
        vector<DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EipMonitorData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eipMonitorData = make_shared<vector<DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData>>(expect1);
      }
    }
  }


  virtual ~DescribeEipMonitorDataResponseBodyEipMonitorDatas() = default;
};
class DescribeEipMonitorDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeEipMonitorDataResponseBodyEipMonitorDatas> eipMonitorDatas{};
  shared_ptr<string> requestId{};

  DescribeEipMonitorDataResponseBody() {}

  explicit DescribeEipMonitorDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipMonitorDatas) {
      res["EipMonitorDatas"] = eipMonitorDatas ? boost::any(eipMonitorDatas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipMonitorDatas") != m.end() && !m["EipMonitorDatas"].empty()) {
      if (typeid(map<string, boost::any>) == m["EipMonitorDatas"].type()) {
        DescribeEipMonitorDataResponseBodyEipMonitorDatas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EipMonitorDatas"]));
        eipMonitorDatas = make_shared<DescribeEipMonitorDataResponseBodyEipMonitorDatas>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEipMonitorDataResponseBody() = default;
};
class DescribeEipMonitorDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEipMonitorDataResponseBody> body{};

  DescribeEipMonitorDataResponse() {}

  explicit DescribeEipMonitorDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEipMonitorDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEipMonitorDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEipMonitorDataResponse() = default;
};
class DescribeEipSegmentRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> segmentInstanceId{};

  DescribeEipSegmentRequest() {}

  explicit DescribeEipSegmentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (segmentInstanceId) {
      res["SegmentInstanceId"] = boost::any(*segmentInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SegmentInstanceId") != m.end() && !m["SegmentInstanceId"].empty()) {
      segmentInstanceId = make_shared<string>(boost::any_cast<string>(m["SegmentInstanceId"]));
    }
  }


  virtual ~DescribeEipSegmentRequest() = default;
};
class DescribeEipSegmentResponseBodyEipSegmentsEipSegment : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> descritpion{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipCount{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> segment{};
  shared_ptr<string> status{};
  shared_ptr<string> zone{};

  DescribeEipSegmentResponseBodyEipSegmentsEipSegment() {}

  explicit DescribeEipSegmentResponseBodyEipSegmentsEipSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (descritpion) {
      res["Descritpion"] = boost::any(*descritpion);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipCount) {
      res["IpCount"] = boost::any(*ipCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (segment) {
      res["Segment"] = boost::any(*segment);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (zone) {
      res["Zone"] = boost::any(*zone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Descritpion") != m.end() && !m["Descritpion"].empty()) {
      descritpion = make_shared<string>(boost::any_cast<string>(m["Descritpion"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IpCount") != m.end() && !m["IpCount"].empty()) {
      ipCount = make_shared<string>(boost::any_cast<string>(m["IpCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      segment = make_shared<string>(boost::any_cast<string>(m["Segment"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Zone") != m.end() && !m["Zone"].empty()) {
      zone = make_shared<string>(boost::any_cast<string>(m["Zone"]));
    }
  }


  virtual ~DescribeEipSegmentResponseBodyEipSegmentsEipSegment() = default;
};
class DescribeEipSegmentResponseBodyEipSegments : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEipSegmentResponseBodyEipSegmentsEipSegment>> eipSegment{};

  DescribeEipSegmentResponseBodyEipSegments() {}

  explicit DescribeEipSegmentResponseBodyEipSegments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipSegment) {
      vector<boost::any> temp1;
      for(auto item1:*eipSegment){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EipSegment"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipSegment") != m.end() && !m["EipSegment"].empty()) {
      if (typeid(vector<boost::any>) == m["EipSegment"].type()) {
        vector<DescribeEipSegmentResponseBodyEipSegmentsEipSegment> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EipSegment"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEipSegmentResponseBodyEipSegmentsEipSegment model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eipSegment = make_shared<vector<DescribeEipSegmentResponseBodyEipSegmentsEipSegment>>(expect1);
      }
    }
  }


  virtual ~DescribeEipSegmentResponseBodyEipSegments() = default;
};
class DescribeEipSegmentResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeEipSegmentResponseBodyEipSegments> eipSegments{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeEipSegmentResponseBody() {}

  explicit DescribeEipSegmentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipSegments) {
      res["EipSegments"] = eipSegments ? boost::any(eipSegments->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipSegments") != m.end() && !m["EipSegments"].empty()) {
      if (typeid(map<string, boost::any>) == m["EipSegments"].type()) {
        DescribeEipSegmentResponseBodyEipSegments model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EipSegments"]));
        eipSegments = make_shared<DescribeEipSegmentResponseBodyEipSegments>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeEipSegmentResponseBody() = default;
};
class DescribeEipSegmentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEipSegmentResponseBody> body{};

  DescribeEipSegmentResponse() {}

  explicit DescribeEipSegmentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEipSegmentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEipSegmentResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEipSegmentResponse() = default;
};
class DescribeExpressConnectTrafficQosRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<string>> qosIdList{};
  shared_ptr<vector<string>> qosNameList{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};

  DescribeExpressConnectTrafficQosRequest() {}

  explicit DescribeExpressConnectTrafficQosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (qosIdList) {
      res["QosIdList"] = boost::any(*qosIdList);
    }
    if (qosNameList) {
      res["QosNameList"] = boost::any(*qosNameList);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QosIdList") != m.end() && !m["QosIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["QosIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["QosIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      qosIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("QosNameList") != m.end() && !m["QosNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["QosNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["QosNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      qosNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~DescribeExpressConnectTrafficQosRequest() = default;
};
class DescribeExpressConnectTrafficQosResponseBodyQosListAssociatedInstanceList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> instanceProgressing{};
  shared_ptr<string> instanceStatus{};
  shared_ptr<string> instanceType{};

  DescribeExpressConnectTrafficQosResponseBodyQosListAssociatedInstanceList() {}

  explicit DescribeExpressConnectTrafficQosResponseBodyQosListAssociatedInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceProgressing) {
      res["InstanceProgressing"] = boost::any(*instanceProgressing);
    }
    if (instanceStatus) {
      res["InstanceStatus"] = boost::any(*instanceStatus);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceProgressing") != m.end() && !m["InstanceProgressing"].empty()) {
      instanceProgressing = make_shared<long>(boost::any_cast<long>(m["InstanceProgressing"]));
    }
    if (m.find("InstanceStatus") != m.end() && !m["InstanceStatus"].empty()) {
      instanceStatus = make_shared<string>(boost::any_cast<string>(m["InstanceStatus"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~DescribeExpressConnectTrafficQosResponseBodyQosListAssociatedInstanceList() = default;
};
class DescribeExpressConnectTrafficQosResponseBodyQosListQueueList : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthPercent{};
  shared_ptr<string> qosId{};
  shared_ptr<string> queueDescription{};
  shared_ptr<string> queueId{};
  shared_ptr<string> queueName{};
  shared_ptr<string> queueType{};
  shared_ptr<string> status{};

  DescribeExpressConnectTrafficQosResponseBodyQosListQueueList() {}

  explicit DescribeExpressConnectTrafficQosResponseBodyQosListQueueList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPercent) {
      res["BandwidthPercent"] = boost::any(*bandwidthPercent);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (queueDescription) {
      res["QueueDescription"] = boost::any(*queueDescription);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (queueType) {
      res["QueueType"] = boost::any(*queueType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPercent") != m.end() && !m["BandwidthPercent"].empty()) {
      bandwidthPercent = make_shared<string>(boost::any_cast<string>(m["BandwidthPercent"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QueueDescription") != m.end() && !m["QueueDescription"].empty()) {
      queueDescription = make_shared<string>(boost::any_cast<string>(m["QueueDescription"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("QueueType") != m.end() && !m["QueueType"].empty()) {
      queueType = make_shared<string>(boost::any_cast<string>(m["QueueType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeExpressConnectTrafficQosResponseBodyQosListQueueList() = default;
};
class DescribeExpressConnectTrafficQosResponseBodyQosList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeExpressConnectTrafficQosResponseBodyQosListAssociatedInstanceList>> associatedInstanceList{};
  shared_ptr<long> progressing{};
  shared_ptr<string> qosDescription{};
  shared_ptr<string> qosId{};
  shared_ptr<string> qosName{};
  shared_ptr<vector<DescribeExpressConnectTrafficQosResponseBodyQosListQueueList>> queueList{};
  shared_ptr<string> status{};

  DescribeExpressConnectTrafficQosResponseBodyQosList() {}

  explicit DescribeExpressConnectTrafficQosResponseBodyQosList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associatedInstanceList) {
      vector<boost::any> temp1;
      for(auto item1:*associatedInstanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AssociatedInstanceList"] = boost::any(temp1);
    }
    if (progressing) {
      res["Progressing"] = boost::any(*progressing);
    }
    if (qosDescription) {
      res["QosDescription"] = boost::any(*qosDescription);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (qosName) {
      res["QosName"] = boost::any(*qosName);
    }
    if (queueList) {
      vector<boost::any> temp1;
      for(auto item1:*queueList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QueueList"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociatedInstanceList") != m.end() && !m["AssociatedInstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["AssociatedInstanceList"].type()) {
        vector<DescribeExpressConnectTrafficQosResponseBodyQosListAssociatedInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AssociatedInstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExpressConnectTrafficQosResponseBodyQosListAssociatedInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        associatedInstanceList = make_shared<vector<DescribeExpressConnectTrafficQosResponseBodyQosListAssociatedInstanceList>>(expect1);
      }
    }
    if (m.find("Progressing") != m.end() && !m["Progressing"].empty()) {
      progressing = make_shared<long>(boost::any_cast<long>(m["Progressing"]));
    }
    if (m.find("QosDescription") != m.end() && !m["QosDescription"].empty()) {
      qosDescription = make_shared<string>(boost::any_cast<string>(m["QosDescription"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QosName") != m.end() && !m["QosName"].empty()) {
      qosName = make_shared<string>(boost::any_cast<string>(m["QosName"]));
    }
    if (m.find("QueueList") != m.end() && !m["QueueList"].empty()) {
      if (typeid(vector<boost::any>) == m["QueueList"].type()) {
        vector<DescribeExpressConnectTrafficQosResponseBodyQosListQueueList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QueueList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExpressConnectTrafficQosResponseBodyQosListQueueList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        queueList = make_shared<vector<DescribeExpressConnectTrafficQosResponseBodyQosListQueueList>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeExpressConnectTrafficQosResponseBodyQosList() = default;
};
class DescribeExpressConnectTrafficQosResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> count{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<DescribeExpressConnectTrafficQosResponseBodyQosList>> qosList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeExpressConnectTrafficQosResponseBody() {}

  explicit DescribeExpressConnectTrafficQosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (qosList) {
      vector<boost::any> temp1;
      for(auto item1:*qosList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QosList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("QosList") != m.end() && !m["QosList"].empty()) {
      if (typeid(vector<boost::any>) == m["QosList"].type()) {
        vector<DescribeExpressConnectTrafficQosResponseBodyQosList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QosList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExpressConnectTrafficQosResponseBodyQosList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        qosList = make_shared<vector<DescribeExpressConnectTrafficQosResponseBodyQosList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeExpressConnectTrafficQosResponseBody() = default;
};
class DescribeExpressConnectTrafficQosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExpressConnectTrafficQosResponseBody> body{};

  DescribeExpressConnectTrafficQosResponse() {}

  explicit DescribeExpressConnectTrafficQosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExpressConnectTrafficQosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExpressConnectTrafficQosResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExpressConnectTrafficQosResponse() = default;
};
class DescribeExpressConnectTrafficQosQueueRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> qosId{};
  shared_ptr<vector<string>> queueIdList{};
  shared_ptr<vector<string>> queueNameList{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};

  DescribeExpressConnectTrafficQosQueueRequest() {}

  explicit DescribeExpressConnectTrafficQosQueueRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (queueIdList) {
      res["QueueIdList"] = boost::any(*queueIdList);
    }
    if (queueNameList) {
      res["QueueNameList"] = boost::any(*queueNameList);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QueueIdList") != m.end() && !m["QueueIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["QueueIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["QueueIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      queueIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("QueueNameList") != m.end() && !m["QueueNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["QueueNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["QueueNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      queueNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~DescribeExpressConnectTrafficQosQueueRequest() = default;
};
class DescribeExpressConnectTrafficQosQueueResponseBodyQueueListRuleList : public Darabonba::Model {
public:
  shared_ptr<string> dstCidr{};
  shared_ptr<string> dstIPv6Cidr{};
  shared_ptr<string> dstPortRange{};
  shared_ptr<long> matchDscp{};
  shared_ptr<long> priority{};
  shared_ptr<string> protocol{};
  shared_ptr<string> qosId{};
  shared_ptr<string> queueId{};
  shared_ptr<long> remarkingDscp{};
  shared_ptr<string> ruleDescription{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> srcCidr{};
  shared_ptr<string> srcIPv6Cidr{};
  shared_ptr<string> srcPortRange{};
  shared_ptr<string> status{};

  DescribeExpressConnectTrafficQosQueueResponseBodyQueueListRuleList() {}

  explicit DescribeExpressConnectTrafficQosQueueResponseBodyQueueListRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstCidr) {
      res["DstCidr"] = boost::any(*dstCidr);
    }
    if (dstIPv6Cidr) {
      res["DstIPv6Cidr"] = boost::any(*dstIPv6Cidr);
    }
    if (dstPortRange) {
      res["DstPortRange"] = boost::any(*dstPortRange);
    }
    if (matchDscp) {
      res["MatchDscp"] = boost::any(*matchDscp);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (remarkingDscp) {
      res["RemarkingDscp"] = boost::any(*remarkingDscp);
    }
    if (ruleDescription) {
      res["RuleDescription"] = boost::any(*ruleDescription);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (srcCidr) {
      res["SrcCidr"] = boost::any(*srcCidr);
    }
    if (srcIPv6Cidr) {
      res["SrcIPv6Cidr"] = boost::any(*srcIPv6Cidr);
    }
    if (srcPortRange) {
      res["SrcPortRange"] = boost::any(*srcPortRange);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstCidr") != m.end() && !m["DstCidr"].empty()) {
      dstCidr = make_shared<string>(boost::any_cast<string>(m["DstCidr"]));
    }
    if (m.find("DstIPv6Cidr") != m.end() && !m["DstIPv6Cidr"].empty()) {
      dstIPv6Cidr = make_shared<string>(boost::any_cast<string>(m["DstIPv6Cidr"]));
    }
    if (m.find("DstPortRange") != m.end() && !m["DstPortRange"].empty()) {
      dstPortRange = make_shared<string>(boost::any_cast<string>(m["DstPortRange"]));
    }
    if (m.find("MatchDscp") != m.end() && !m["MatchDscp"].empty()) {
      matchDscp = make_shared<long>(boost::any_cast<long>(m["MatchDscp"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("RemarkingDscp") != m.end() && !m["RemarkingDscp"].empty()) {
      remarkingDscp = make_shared<long>(boost::any_cast<long>(m["RemarkingDscp"]));
    }
    if (m.find("RuleDescription") != m.end() && !m["RuleDescription"].empty()) {
      ruleDescription = make_shared<string>(boost::any_cast<string>(m["RuleDescription"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SrcCidr") != m.end() && !m["SrcCidr"].empty()) {
      srcCidr = make_shared<string>(boost::any_cast<string>(m["SrcCidr"]));
    }
    if (m.find("SrcIPv6Cidr") != m.end() && !m["SrcIPv6Cidr"].empty()) {
      srcIPv6Cidr = make_shared<string>(boost::any_cast<string>(m["SrcIPv6Cidr"]));
    }
    if (m.find("SrcPortRange") != m.end() && !m["SrcPortRange"].empty()) {
      srcPortRange = make_shared<string>(boost::any_cast<string>(m["SrcPortRange"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeExpressConnectTrafficQosQueueResponseBodyQueueListRuleList() = default;
};
class DescribeExpressConnectTrafficQosQueueResponseBodyQueueList : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthPercent{};
  shared_ptr<string> qosId{};
  shared_ptr<string> queueDescription{};
  shared_ptr<string> queueId{};
  shared_ptr<string> queueName{};
  shared_ptr<string> queueType{};
  shared_ptr<vector<DescribeExpressConnectTrafficQosQueueResponseBodyQueueListRuleList>> ruleList{};
  shared_ptr<string> status{};

  DescribeExpressConnectTrafficQosQueueResponseBodyQueueList() {}

  explicit DescribeExpressConnectTrafficQosQueueResponseBodyQueueList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPercent) {
      res["BandwidthPercent"] = boost::any(*bandwidthPercent);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (queueDescription) {
      res["QueueDescription"] = boost::any(*queueDescription);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (queueType) {
      res["QueueType"] = boost::any(*queueType);
    }
    if (ruleList) {
      vector<boost::any> temp1;
      for(auto item1:*ruleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleList"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPercent") != m.end() && !m["BandwidthPercent"].empty()) {
      bandwidthPercent = make_shared<string>(boost::any_cast<string>(m["BandwidthPercent"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QueueDescription") != m.end() && !m["QueueDescription"].empty()) {
      queueDescription = make_shared<string>(boost::any_cast<string>(m["QueueDescription"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("QueueType") != m.end() && !m["QueueType"].empty()) {
      queueType = make_shared<string>(boost::any_cast<string>(m["QueueType"]));
    }
    if (m.find("RuleList") != m.end() && !m["RuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleList"].type()) {
        vector<DescribeExpressConnectTrafficQosQueueResponseBodyQueueListRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExpressConnectTrafficQosQueueResponseBodyQueueListRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleList = make_shared<vector<DescribeExpressConnectTrafficQosQueueResponseBodyQueueListRuleList>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeExpressConnectTrafficQosQueueResponseBodyQueueList() = default;
};
class DescribeExpressConnectTrafficQosQueueResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeExpressConnectTrafficQosQueueResponseBodyQueueList>> queueList{};
  shared_ptr<string> requestId{};

  DescribeExpressConnectTrafficQosQueueResponseBody() {}

  explicit DescribeExpressConnectTrafficQosQueueResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queueList) {
      vector<boost::any> temp1;
      for(auto item1:*queueList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QueueList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QueueList") != m.end() && !m["QueueList"].empty()) {
      if (typeid(vector<boost::any>) == m["QueueList"].type()) {
        vector<DescribeExpressConnectTrafficQosQueueResponseBodyQueueList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QueueList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExpressConnectTrafficQosQueueResponseBodyQueueList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        queueList = make_shared<vector<DescribeExpressConnectTrafficQosQueueResponseBodyQueueList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeExpressConnectTrafficQosQueueResponseBody() = default;
};
class DescribeExpressConnectTrafficQosQueueResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExpressConnectTrafficQosQueueResponseBody> body{};

  DescribeExpressConnectTrafficQosQueueResponse() {}

  explicit DescribeExpressConnectTrafficQosQueueResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExpressConnectTrafficQosQueueResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExpressConnectTrafficQosQueueResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExpressConnectTrafficQosQueueResponse() = default;
};
class DescribeExpressConnectTrafficQosRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> qosId{};
  shared_ptr<string> queueId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<vector<string>> ruleIdList{};
  shared_ptr<vector<string>> ruleNameList{};

  DescribeExpressConnectTrafficQosRuleRequest() {}

  explicit DescribeExpressConnectTrafficQosRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (ruleIdList) {
      res["RuleIdList"] = boost::any(*ruleIdList);
    }
    if (ruleNameList) {
      res["RuleNameList"] = boost::any(*ruleNameList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("RuleIdList") != m.end() && !m["RuleIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RuleNameList") != m.end() && !m["RuleNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleNameList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeExpressConnectTrafficQosRuleRequest() = default;
};
class DescribeExpressConnectTrafficQosRuleResponseBodyRuleList : public Darabonba::Model {
public:
  shared_ptr<string> dstCidr{};
  shared_ptr<string> dstIPv6Cidr{};
  shared_ptr<string> dstPortRange{};
  shared_ptr<long> matchDscp{};
  shared_ptr<long> priority{};
  shared_ptr<string> protocol{};
  shared_ptr<string> qosId{};
  shared_ptr<string> queueId{};
  shared_ptr<long> remarkingDscp{};
  shared_ptr<string> ruleDescription{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> srcCidr{};
  shared_ptr<string> srcIPv6Cidr{};
  shared_ptr<string> srcPortRange{};
  shared_ptr<string> status{};

  DescribeExpressConnectTrafficQosRuleResponseBodyRuleList() {}

  explicit DescribeExpressConnectTrafficQosRuleResponseBodyRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstCidr) {
      res["DstCidr"] = boost::any(*dstCidr);
    }
    if (dstIPv6Cidr) {
      res["DstIPv6Cidr"] = boost::any(*dstIPv6Cidr);
    }
    if (dstPortRange) {
      res["DstPortRange"] = boost::any(*dstPortRange);
    }
    if (matchDscp) {
      res["MatchDscp"] = boost::any(*matchDscp);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (remarkingDscp) {
      res["RemarkingDscp"] = boost::any(*remarkingDscp);
    }
    if (ruleDescription) {
      res["RuleDescription"] = boost::any(*ruleDescription);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (srcCidr) {
      res["SrcCidr"] = boost::any(*srcCidr);
    }
    if (srcIPv6Cidr) {
      res["SrcIPv6Cidr"] = boost::any(*srcIPv6Cidr);
    }
    if (srcPortRange) {
      res["SrcPortRange"] = boost::any(*srcPortRange);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstCidr") != m.end() && !m["DstCidr"].empty()) {
      dstCidr = make_shared<string>(boost::any_cast<string>(m["DstCidr"]));
    }
    if (m.find("DstIPv6Cidr") != m.end() && !m["DstIPv6Cidr"].empty()) {
      dstIPv6Cidr = make_shared<string>(boost::any_cast<string>(m["DstIPv6Cidr"]));
    }
    if (m.find("DstPortRange") != m.end() && !m["DstPortRange"].empty()) {
      dstPortRange = make_shared<string>(boost::any_cast<string>(m["DstPortRange"]));
    }
    if (m.find("MatchDscp") != m.end() && !m["MatchDscp"].empty()) {
      matchDscp = make_shared<long>(boost::any_cast<long>(m["MatchDscp"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("RemarkingDscp") != m.end() && !m["RemarkingDscp"].empty()) {
      remarkingDscp = make_shared<long>(boost::any_cast<long>(m["RemarkingDscp"]));
    }
    if (m.find("RuleDescription") != m.end() && !m["RuleDescription"].empty()) {
      ruleDescription = make_shared<string>(boost::any_cast<string>(m["RuleDescription"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SrcCidr") != m.end() && !m["SrcCidr"].empty()) {
      srcCidr = make_shared<string>(boost::any_cast<string>(m["SrcCidr"]));
    }
    if (m.find("SrcIPv6Cidr") != m.end() && !m["SrcIPv6Cidr"].empty()) {
      srcIPv6Cidr = make_shared<string>(boost::any_cast<string>(m["SrcIPv6Cidr"]));
    }
    if (m.find("SrcPortRange") != m.end() && !m["SrcPortRange"].empty()) {
      srcPortRange = make_shared<string>(boost::any_cast<string>(m["SrcPortRange"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeExpressConnectTrafficQosRuleResponseBodyRuleList() = default;
};
class DescribeExpressConnectTrafficQosRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeExpressConnectTrafficQosRuleResponseBodyRuleList>> ruleList{};

  DescribeExpressConnectTrafficQosRuleResponseBody() {}

  explicit DescribeExpressConnectTrafficQosRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleList) {
      vector<boost::any> temp1;
      for(auto item1:*ruleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleList") != m.end() && !m["RuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleList"].type()) {
        vector<DescribeExpressConnectTrafficQosRuleResponseBodyRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExpressConnectTrafficQosRuleResponseBodyRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleList = make_shared<vector<DescribeExpressConnectTrafficQosRuleResponseBodyRuleList>>(expect1);
      }
    }
  }


  virtual ~DescribeExpressConnectTrafficQosRuleResponseBody() = default;
};
class DescribeExpressConnectTrafficQosRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExpressConnectTrafficQosRuleResponseBody> body{};

  DescribeExpressConnectTrafficQosRuleResponse() {}

  explicit DescribeExpressConnectTrafficQosRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExpressConnectTrafficQosRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExpressConnectTrafficQosRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExpressConnectTrafficQosRuleResponse() = default;
};
class DescribeFailoverTestJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> jobId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};

  DescribeFailoverTestJobRequest() {}

  explicit DescribeFailoverTestJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~DescribeFailoverTestJobRequest() = default;
};
class DescribeFailoverTestJobResponseBodyFailoverTestJobModel : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> jobDuration{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobType{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> stopTime{};

  DescribeFailoverTestJobResponseBodyFailoverTestJobModel() {}

  explicit DescribeFailoverTestJobResponseBodyFailoverTestJobModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (jobDuration) {
      res["JobDuration"] = boost::any(*jobDuration);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("JobDuration") != m.end() && !m["JobDuration"].empty()) {
      jobDuration = make_shared<string>(boost::any_cast<string>(m["JobDuration"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<string>(boost::any_cast<string>(m["StopTime"]));
    }
  }


  virtual ~DescribeFailoverTestJobResponseBodyFailoverTestJobModel() = default;
};
class DescribeFailoverTestJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeFailoverTestJobResponseBodyFailoverTestJobModel> failoverTestJobModel{};
  shared_ptr<string> requestId{};

  DescribeFailoverTestJobResponseBody() {}

  explicit DescribeFailoverTestJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failoverTestJobModel) {
      res["FailoverTestJobModel"] = failoverTestJobModel ? boost::any(failoverTestJobModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailoverTestJobModel") != m.end() && !m["FailoverTestJobModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailoverTestJobModel"].type()) {
        DescribeFailoverTestJobResponseBodyFailoverTestJobModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailoverTestJobModel"]));
        failoverTestJobModel = make_shared<DescribeFailoverTestJobResponseBodyFailoverTestJobModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeFailoverTestJobResponseBody() = default;
};
class DescribeFailoverTestJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFailoverTestJobResponseBody> body{};

  DescribeFailoverTestJobResponse() {}

  explicit DescribeFailoverTestJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFailoverTestJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFailoverTestJobResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFailoverTestJobResponse() = default;
};
class DescribeFailoverTestJobsRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> value{};

  DescribeFailoverTestJobsRequestFilter() {}

  explicit DescribeFailoverTestJobsRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeFailoverTestJobsRequestFilter() = default;
};
class DescribeFailoverTestJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<vector<DescribeFailoverTestJobsRequestFilter>> filter{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};

  DescribeFailoverTestJobsRequest() {}

  explicit DescribeFailoverTestJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeFailoverTestJobsRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFailoverTestJobsRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeFailoverTestJobsRequestFilter>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~DescribeFailoverTestJobsRequest() = default;
};
class DescribeFailoverTestJobsResponseBodyFailoverTestJobList : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> jobDuration{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobType{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> stopTime{};

  DescribeFailoverTestJobsResponseBodyFailoverTestJobList() {}

  explicit DescribeFailoverTestJobsResponseBodyFailoverTestJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (jobDuration) {
      res["JobDuration"] = boost::any(*jobDuration);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("JobDuration") != m.end() && !m["JobDuration"].empty()) {
      jobDuration = make_shared<string>(boost::any_cast<string>(m["JobDuration"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<string>(boost::any_cast<string>(m["StopTime"]));
    }
  }


  virtual ~DescribeFailoverTestJobsResponseBodyFailoverTestJobList() = default;
};
class DescribeFailoverTestJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeFailoverTestJobsResponseBodyFailoverTestJobList>> failoverTestJobList{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeFailoverTestJobsResponseBody() {}

  explicit DescribeFailoverTestJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (failoverTestJobList) {
      vector<boost::any> temp1;
      for(auto item1:*failoverTestJobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailoverTestJobList"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("FailoverTestJobList") != m.end() && !m["FailoverTestJobList"].empty()) {
      if (typeid(vector<boost::any>) == m["FailoverTestJobList"].type()) {
        vector<DescribeFailoverTestJobsResponseBodyFailoverTestJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailoverTestJobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFailoverTestJobsResponseBodyFailoverTestJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failoverTestJobList = make_shared<vector<DescribeFailoverTestJobsResponseBodyFailoverTestJobList>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeFailoverTestJobsResponseBody() = default;
};
class DescribeFailoverTestJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFailoverTestJobsResponseBody> body{};

  DescribeFailoverTestJobsResponse() {}

  explicit DescribeFailoverTestJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFailoverTestJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFailoverTestJobsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFailoverTestJobsResponse() = default;
};
class DescribeFlowLogsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeFlowLogsRequestTags() {}

  explicit DescribeFlowLogsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeFlowLogsRequestTags() = default;
};
class DescribeFlowLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> flowLogId{};
  shared_ptr<string> flowLogName{};
  shared_ptr<string> logStoreName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> status{};
  shared_ptr<vector<DescribeFlowLogsRequestTags>> tags{};
  shared_ptr<string> trafficType{};
  shared_ptr<string> vpcId{};

  DescribeFlowLogsRequest() {}

  explicit DescribeFlowLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (flowLogId) {
      res["FlowLogId"] = boost::any(*flowLogId);
    }
    if (flowLogName) {
      res["FlowLogName"] = boost::any(*flowLogName);
    }
    if (logStoreName) {
      res["LogStoreName"] = boost::any(*logStoreName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (trafficType) {
      res["TrafficType"] = boost::any(*trafficType);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FlowLogId") != m.end() && !m["FlowLogId"].empty()) {
      flowLogId = make_shared<string>(boost::any_cast<string>(m["FlowLogId"]));
    }
    if (m.find("FlowLogName") != m.end() && !m["FlowLogName"].empty()) {
      flowLogName = make_shared<string>(boost::any_cast<string>(m["FlowLogName"]));
    }
    if (m.find("LogStoreName") != m.end() && !m["LogStoreName"].empty()) {
      logStoreName = make_shared<string>(boost::any_cast<string>(m["LogStoreName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeFlowLogsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowLogsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeFlowLogsRequestTags>>(expect1);
      }
    }
    if (m.find("TrafficType") != m.end() && !m["TrafficType"].empty()) {
      trafficType = make_shared<string>(boost::any_cast<string>(m["TrafficType"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeFlowLogsRequest() = default;
};
class DescribeFlowLogsResponseBodyFlowLogsFlowLogTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeFlowLogsResponseBodyFlowLogsFlowLogTagsTag() {}

  explicit DescribeFlowLogsResponseBodyFlowLogsFlowLogTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeFlowLogsResponseBodyFlowLogsFlowLogTagsTag() = default;
};
class DescribeFlowLogsResponseBodyFlowLogsFlowLogTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFlowLogsResponseBodyFlowLogsFlowLogTagsTag>> tag{};

  DescribeFlowLogsResponseBodyFlowLogsFlowLogTags() {}

  explicit DescribeFlowLogsResponseBodyFlowLogsFlowLogTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeFlowLogsResponseBodyFlowLogsFlowLogTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowLogsResponseBodyFlowLogsFlowLogTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeFlowLogsResponseBodyFlowLogsFlowLogTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeFlowLogsResponseBodyFlowLogsFlowLogTags() = default;
};
class DescribeFlowLogsResponseBodyFlowLogsFlowLogTrafficPath : public Darabonba::Model {
public:
  shared_ptr<vector<string>> trafficPathList{};

  DescribeFlowLogsResponseBodyFlowLogsFlowLogTrafficPath() {}

  explicit DescribeFlowLogsResponseBodyFlowLogsFlowLogTrafficPath(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trafficPathList) {
      res["TrafficPathList"] = boost::any(*trafficPathList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrafficPathList") != m.end() && !m["TrafficPathList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TrafficPathList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TrafficPathList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      trafficPathList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeFlowLogsResponseBodyFlowLogsFlowLogTrafficPath() = default;
};
class DescribeFlowLogsResponseBodyFlowLogsFlowLog : public Darabonba::Model {
public:
  shared_ptr<long> aggregationInterval{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> flowLogDeliverErrorMessage{};
  shared_ptr<string> flowLogDeliverStatus{};
  shared_ptr<string> flowLogId{};
  shared_ptr<string> flowLogName{};
  shared_ptr<string> logStoreName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> status{};
  shared_ptr<DescribeFlowLogsResponseBodyFlowLogsFlowLogTags> tags{};
  shared_ptr<DescribeFlowLogsResponseBodyFlowLogsFlowLogTrafficPath> trafficPath{};
  shared_ptr<string> trafficType{};

  DescribeFlowLogsResponseBodyFlowLogsFlowLog() {}

  explicit DescribeFlowLogsResponseBodyFlowLogsFlowLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregationInterval) {
      res["AggregationInterval"] = boost::any(*aggregationInterval);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (flowLogDeliverErrorMessage) {
      res["FlowLogDeliverErrorMessage"] = boost::any(*flowLogDeliverErrorMessage);
    }
    if (flowLogDeliverStatus) {
      res["FlowLogDeliverStatus"] = boost::any(*flowLogDeliverStatus);
    }
    if (flowLogId) {
      res["FlowLogId"] = boost::any(*flowLogId);
    }
    if (flowLogName) {
      res["FlowLogName"] = boost::any(*flowLogName);
    }
    if (logStoreName) {
      res["LogStoreName"] = boost::any(*logStoreName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trafficPath) {
      res["TrafficPath"] = trafficPath ? boost::any(trafficPath->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trafficType) {
      res["TrafficType"] = boost::any(*trafficType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregationInterval") != m.end() && !m["AggregationInterval"].empty()) {
      aggregationInterval = make_shared<long>(boost::any_cast<long>(m["AggregationInterval"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FlowLogDeliverErrorMessage") != m.end() && !m["FlowLogDeliverErrorMessage"].empty()) {
      flowLogDeliverErrorMessage = make_shared<string>(boost::any_cast<string>(m["FlowLogDeliverErrorMessage"]));
    }
    if (m.find("FlowLogDeliverStatus") != m.end() && !m["FlowLogDeliverStatus"].empty()) {
      flowLogDeliverStatus = make_shared<string>(boost::any_cast<string>(m["FlowLogDeliverStatus"]));
    }
    if (m.find("FlowLogId") != m.end() && !m["FlowLogId"].empty()) {
      flowLogId = make_shared<string>(boost::any_cast<string>(m["FlowLogId"]));
    }
    if (m.find("FlowLogName") != m.end() && !m["FlowLogName"].empty()) {
      flowLogName = make_shared<string>(boost::any_cast<string>(m["FlowLogName"]));
    }
    if (m.find("LogStoreName") != m.end() && !m["LogStoreName"].empty()) {
      logStoreName = make_shared<string>(boost::any_cast<string>(m["LogStoreName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeFlowLogsResponseBodyFlowLogsFlowLogTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeFlowLogsResponseBodyFlowLogsFlowLogTags>(model1);
      }
    }
    if (m.find("TrafficPath") != m.end() && !m["TrafficPath"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficPath"].type()) {
        DescribeFlowLogsResponseBodyFlowLogsFlowLogTrafficPath model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficPath"]));
        trafficPath = make_shared<DescribeFlowLogsResponseBodyFlowLogsFlowLogTrafficPath>(model1);
      }
    }
    if (m.find("TrafficType") != m.end() && !m["TrafficType"].empty()) {
      trafficType = make_shared<string>(boost::any_cast<string>(m["TrafficType"]));
    }
  }


  virtual ~DescribeFlowLogsResponseBodyFlowLogsFlowLog() = default;
};
class DescribeFlowLogsResponseBodyFlowLogs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFlowLogsResponseBodyFlowLogsFlowLog>> flowLog{};

  DescribeFlowLogsResponseBodyFlowLogs() {}

  explicit DescribeFlowLogsResponseBodyFlowLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowLog) {
      vector<boost::any> temp1;
      for(auto item1:*flowLog){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FlowLog"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowLog") != m.end() && !m["FlowLog"].empty()) {
      if (typeid(vector<boost::any>) == m["FlowLog"].type()) {
        vector<DescribeFlowLogsResponseBodyFlowLogsFlowLog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FlowLog"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowLogsResponseBodyFlowLogsFlowLog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flowLog = make_shared<vector<DescribeFlowLogsResponseBodyFlowLogsFlowLog>>(expect1);
      }
    }
  }


  virtual ~DescribeFlowLogsResponseBodyFlowLogs() = default;
};
class DescribeFlowLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeFlowLogsResponseBodyFlowLogs> flowLogs{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<string> totalCount{};

  DescribeFlowLogsResponseBody() {}

  explicit DescribeFlowLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowLogs) {
      res["FlowLogs"] = flowLogs ? boost::any(flowLogs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowLogs") != m.end() && !m["FlowLogs"].empty()) {
      if (typeid(map<string, boost::any>) == m["FlowLogs"].type()) {
        DescribeFlowLogsResponseBodyFlowLogs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FlowLogs"]));
        flowLogs = make_shared<DescribeFlowLogsResponseBodyFlowLogs>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~DescribeFlowLogsResponseBody() = default;
};
class DescribeFlowLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFlowLogsResponseBody> body{};

  DescribeFlowLogsResponse() {}

  explicit DescribeFlowLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowLogsResponse() = default;
};
class DescribeForwardTableEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> externalIp{};
  shared_ptr<string> externalPort{};
  shared_ptr<string> forwardEntryId{};
  shared_ptr<string> forwardEntryName{};
  shared_ptr<string> forwardTableId{};
  shared_ptr<string> internalIp{};
  shared_ptr<string> internalPort{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeForwardTableEntriesRequest() {}

  explicit DescribeForwardTableEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (externalIp) {
      res["ExternalIp"] = boost::any(*externalIp);
    }
    if (externalPort) {
      res["ExternalPort"] = boost::any(*externalPort);
    }
    if (forwardEntryId) {
      res["ForwardEntryId"] = boost::any(*forwardEntryId);
    }
    if (forwardEntryName) {
      res["ForwardEntryName"] = boost::any(*forwardEntryName);
    }
    if (forwardTableId) {
      res["ForwardTableId"] = boost::any(*forwardTableId);
    }
    if (internalIp) {
      res["InternalIp"] = boost::any(*internalIp);
    }
    if (internalPort) {
      res["InternalPort"] = boost::any(*internalPort);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExternalIp") != m.end() && !m["ExternalIp"].empty()) {
      externalIp = make_shared<string>(boost::any_cast<string>(m["ExternalIp"]));
    }
    if (m.find("ExternalPort") != m.end() && !m["ExternalPort"].empty()) {
      externalPort = make_shared<string>(boost::any_cast<string>(m["ExternalPort"]));
    }
    if (m.find("ForwardEntryId") != m.end() && !m["ForwardEntryId"].empty()) {
      forwardEntryId = make_shared<string>(boost::any_cast<string>(m["ForwardEntryId"]));
    }
    if (m.find("ForwardEntryName") != m.end() && !m["ForwardEntryName"].empty()) {
      forwardEntryName = make_shared<string>(boost::any_cast<string>(m["ForwardEntryName"]));
    }
    if (m.find("ForwardTableId") != m.end() && !m["ForwardTableId"].empty()) {
      forwardTableId = make_shared<string>(boost::any_cast<string>(m["ForwardTableId"]));
    }
    if (m.find("InternalIp") != m.end() && !m["InternalIp"].empty()) {
      internalIp = make_shared<string>(boost::any_cast<string>(m["InternalIp"]));
    }
    if (m.find("InternalPort") != m.end() && !m["InternalPort"].empty()) {
      internalPort = make_shared<string>(boost::any_cast<string>(m["InternalPort"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeForwardTableEntriesRequest() = default;
};
class DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry : public Darabonba::Model {
public:
  shared_ptr<string> externalIp{};
  shared_ptr<string> externalPort{};
  shared_ptr<string> forwardEntryId{};
  shared_ptr<string> forwardEntryName{};
  shared_ptr<string> forwardTableId{};
  shared_ptr<string> internalIp{};
  shared_ptr<string> internalPort{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> status{};

  DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry() {}

  explicit DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (externalIp) {
      res["ExternalIp"] = boost::any(*externalIp);
    }
    if (externalPort) {
      res["ExternalPort"] = boost::any(*externalPort);
    }
    if (forwardEntryId) {
      res["ForwardEntryId"] = boost::any(*forwardEntryId);
    }
    if (forwardEntryName) {
      res["ForwardEntryName"] = boost::any(*forwardEntryName);
    }
    if (forwardTableId) {
      res["ForwardTableId"] = boost::any(*forwardTableId);
    }
    if (internalIp) {
      res["InternalIp"] = boost::any(*internalIp);
    }
    if (internalPort) {
      res["InternalPort"] = boost::any(*internalPort);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExternalIp") != m.end() && !m["ExternalIp"].empty()) {
      externalIp = make_shared<string>(boost::any_cast<string>(m["ExternalIp"]));
    }
    if (m.find("ExternalPort") != m.end() && !m["ExternalPort"].empty()) {
      externalPort = make_shared<string>(boost::any_cast<string>(m["ExternalPort"]));
    }
    if (m.find("ForwardEntryId") != m.end() && !m["ForwardEntryId"].empty()) {
      forwardEntryId = make_shared<string>(boost::any_cast<string>(m["ForwardEntryId"]));
    }
    if (m.find("ForwardEntryName") != m.end() && !m["ForwardEntryName"].empty()) {
      forwardEntryName = make_shared<string>(boost::any_cast<string>(m["ForwardEntryName"]));
    }
    if (m.find("ForwardTableId") != m.end() && !m["ForwardTableId"].empty()) {
      forwardTableId = make_shared<string>(boost::any_cast<string>(m["ForwardTableId"]));
    }
    if (m.find("InternalIp") != m.end() && !m["InternalIp"].empty()) {
      internalIp = make_shared<string>(boost::any_cast<string>(m["InternalIp"]));
    }
    if (m.find("InternalPort") != m.end() && !m["InternalPort"].empty()) {
      internalPort = make_shared<string>(boost::any_cast<string>(m["InternalPort"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry() = default;
};
class DescribeForwardTableEntriesResponseBodyForwardTableEntries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry>> forwardTableEntry{};

  DescribeForwardTableEntriesResponseBodyForwardTableEntries() {}

  explicit DescribeForwardTableEntriesResponseBodyForwardTableEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardTableEntry) {
      vector<boost::any> temp1;
      for(auto item1:*forwardTableEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ForwardTableEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardTableEntry") != m.end() && !m["ForwardTableEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["ForwardTableEntry"].type()) {
        vector<DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ForwardTableEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        forwardTableEntry = make_shared<vector<DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeForwardTableEntriesResponseBodyForwardTableEntries() = default;
};
class DescribeForwardTableEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeForwardTableEntriesResponseBodyForwardTableEntries> forwardTableEntries{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeForwardTableEntriesResponseBody() {}

  explicit DescribeForwardTableEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardTableEntries) {
      res["ForwardTableEntries"] = forwardTableEntries ? boost::any(forwardTableEntries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardTableEntries") != m.end() && !m["ForwardTableEntries"].empty()) {
      if (typeid(map<string, boost::any>) == m["ForwardTableEntries"].type()) {
        DescribeForwardTableEntriesResponseBodyForwardTableEntries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ForwardTableEntries"]));
        forwardTableEntries = make_shared<DescribeForwardTableEntriesResponseBodyForwardTableEntries>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeForwardTableEntriesResponseBody() = default;
};
class DescribeForwardTableEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeForwardTableEntriesResponseBody> body{};

  DescribeForwardTableEntriesResponse() {}

  explicit DescribeForwardTableEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeForwardTableEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeForwardTableEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeForwardTableEntriesResponse() = default;
};
class DescribeGlobalAccelerationInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthType{};
  shared_ptr<string> globalAccelerationInstanceId{};
  shared_ptr<bool> includeReservationData{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serverId{};
  shared_ptr<string> serviceLocation{};
  shared_ptr<string> status{};

  DescribeGlobalAccelerationInstancesRequest() {}

  explicit DescribeGlobalAccelerationInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthType) {
      res["BandwidthType"] = boost::any(*bandwidthType);
    }
    if (globalAccelerationInstanceId) {
      res["GlobalAccelerationInstanceId"] = boost::any(*globalAccelerationInstanceId);
    }
    if (includeReservationData) {
      res["IncludeReservationData"] = boost::any(*includeReservationData);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (serviceLocation) {
      res["ServiceLocation"] = boost::any(*serviceLocation);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthType") != m.end() && !m["BandwidthType"].empty()) {
      bandwidthType = make_shared<string>(boost::any_cast<string>(m["BandwidthType"]));
    }
    if (m.find("GlobalAccelerationInstanceId") != m.end() && !m["GlobalAccelerationInstanceId"].empty()) {
      globalAccelerationInstanceId = make_shared<string>(boost::any_cast<string>(m["GlobalAccelerationInstanceId"]));
    }
    if (m.find("IncludeReservationData") != m.end() && !m["IncludeReservationData"].empty()) {
      includeReservationData = make_shared<bool>(boost::any_cast<bool>(m["IncludeReservationData"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("ServiceLocation") != m.end() && !m["ServiceLocation"].empty()) {
      serviceLocation = make_shared<string>(boost::any_cast<string>(m["ServiceLocation"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeGlobalAccelerationInstancesRequest() = default;
};
class DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> serverId{};
  shared_ptr<string> serverIpAddress{};
  shared_ptr<string> serverType{};

  DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer() {}

  explicit DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (serverIpAddress) {
      res["ServerIpAddress"] = boost::any(*serverIpAddress);
    }
    if (serverType) {
      res["ServerType"] = boost::any(*serverType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("ServerIpAddress") != m.end() && !m["ServerIpAddress"].empty()) {
      serverIpAddress = make_shared<string>(boost::any_cast<string>(m["ServerIpAddress"]));
    }
    if (m.find("ServerType") != m.end() && !m["ServerType"].empty()) {
      serverType = make_shared<string>(boost::any_cast<string>(m["ServerType"]));
    }
  }


  virtual ~DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer() = default;
};
class DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServers : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer>> backendServer{};

  DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServers() {}

  explicit DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendServer) {
      vector<boost::any> temp1;
      for(auto item1:*backendServer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendServer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendServer") != m.end() && !m["BackendServer"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendServer"].type()) {
        vector<DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendServer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendServer = make_shared<vector<DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServersBackendServer>>(expect1);
      }
    }
  }


  virtual ~DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServers() = default;
};
class DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddressesPublicIpAddress : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> ipAddress{};

  DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddressesPublicIpAddress() {}

  explicit DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddressesPublicIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
  }


  virtual ~DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddressesPublicIpAddress() = default;
};
class DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddressesPublicIpAddress>> publicIpAddress{};

  DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddresses() {}

  explicit DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (publicIpAddress) {
      vector<boost::any> temp1;
      for(auto item1:*publicIpAddress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PublicIpAddress"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PublicIpAddress") != m.end() && !m["PublicIpAddress"].empty()) {
      if (typeid(vector<boost::any>) == m["PublicIpAddress"].type()) {
        vector<DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddressesPublicIpAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PublicIpAddress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddressesPublicIpAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        publicIpAddress = make_shared<vector<DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddressesPublicIpAddress>>(expect1);
      }
    }
  }


  virtual ~DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddresses() = default;
};
class DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance : public Darabonba::Model {
public:
  shared_ptr<string> accelerationLocation{};
  shared_ptr<DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServers> backendServers{};
  shared_ptr<string> bandwidth{};
  shared_ptr<string> bandwidthType{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> globalAccelerationInstanceId{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> name{};
  shared_ptr<DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddresses> publicIpAddresses{};
  shared_ptr<string> regionId{};
  shared_ptr<string> serviceLocation{};
  shared_ptr<string> status{};

  DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance() {}

  explicit DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerationLocation) {
      res["AccelerationLocation"] = boost::any(*accelerationLocation);
    }
    if (backendServers) {
      res["BackendServers"] = backendServers ? boost::any(backendServers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (bandwidthType) {
      res["BandwidthType"] = boost::any(*bandwidthType);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (globalAccelerationInstanceId) {
      res["GlobalAccelerationInstanceId"] = boost::any(*globalAccelerationInstanceId);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (publicIpAddresses) {
      res["PublicIpAddresses"] = publicIpAddresses ? boost::any(publicIpAddresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serviceLocation) {
      res["ServiceLocation"] = boost::any(*serviceLocation);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerationLocation") != m.end() && !m["AccelerationLocation"].empty()) {
      accelerationLocation = make_shared<string>(boost::any_cast<string>(m["AccelerationLocation"]));
    }
    if (m.find("BackendServers") != m.end() && !m["BackendServers"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackendServers"].type()) {
        DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackendServers"]));
        backendServers = make_shared<DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstanceBackendServers>(model1);
      }
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("BandwidthType") != m.end() && !m["BandwidthType"].empty()) {
      bandwidthType = make_shared<string>(boost::any_cast<string>(m["BandwidthType"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("GlobalAccelerationInstanceId") != m.end() && !m["GlobalAccelerationInstanceId"].empty()) {
      globalAccelerationInstanceId = make_shared<string>(boost::any_cast<string>(m["GlobalAccelerationInstanceId"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PublicIpAddresses") != m.end() && !m["PublicIpAddresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["PublicIpAddresses"].type()) {
        DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PublicIpAddresses"]));
        publicIpAddresses = make_shared<DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstancePublicIpAddresses>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ServiceLocation") != m.end() && !m["ServiceLocation"].empty()) {
      serviceLocation = make_shared<string>(boost::any_cast<string>(m["ServiceLocation"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance() = default;
};
class DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance>> globalAccelerationInstance{};

  DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances() {}

  explicit DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalAccelerationInstance) {
      vector<boost::any> temp1;
      for(auto item1:*globalAccelerationInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GlobalAccelerationInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalAccelerationInstance") != m.end() && !m["GlobalAccelerationInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["GlobalAccelerationInstance"].type()) {
        vector<DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GlobalAccelerationInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        globalAccelerationInstance = make_shared<vector<DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances() = default;
};
class DescribeGlobalAccelerationInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances> globalAccelerationInstances{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeGlobalAccelerationInstancesResponseBody() {}

  explicit DescribeGlobalAccelerationInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalAccelerationInstances) {
      res["GlobalAccelerationInstances"] = globalAccelerationInstances ? boost::any(globalAccelerationInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalAccelerationInstances") != m.end() && !m["GlobalAccelerationInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["GlobalAccelerationInstances"].type()) {
        DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GlobalAccelerationInstances"]));
        globalAccelerationInstances = make_shared<DescribeGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeGlobalAccelerationInstancesResponseBody() = default;
};
class DescribeGlobalAccelerationInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGlobalAccelerationInstancesResponseBody> body{};

  DescribeGlobalAccelerationInstancesResponse() {}

  explicit DescribeGlobalAccelerationInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGlobalAccelerationInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGlobalAccelerationInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGlobalAccelerationInstancesResponse() = default;
};
class DescribeGrantRulesToCenRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeGrantRulesToCenRequest() {}

  explicit DescribeGrantRulesToCenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeGrantRulesToCenRequest() = default;
};
class DescribeGrantRulesToCenResponseBodyCenGrantRulesCbnGrantRule : public Darabonba::Model {
public:
  shared_ptr<string> cenInstanceId{};
  shared_ptr<long> cenOwnerId{};
  shared_ptr<string> creationTime{};

  DescribeGrantRulesToCenResponseBodyCenGrantRulesCbnGrantRule() {}

  explicit DescribeGrantRulesToCenResponseBodyCenGrantRulesCbnGrantRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cenInstanceId) {
      res["CenInstanceId"] = boost::any(*cenInstanceId);
    }
    if (cenOwnerId) {
      res["CenOwnerId"] = boost::any(*cenOwnerId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CenInstanceId") != m.end() && !m["CenInstanceId"].empty()) {
      cenInstanceId = make_shared<string>(boost::any_cast<string>(m["CenInstanceId"]));
    }
    if (m.find("CenOwnerId") != m.end() && !m["CenOwnerId"].empty()) {
      cenOwnerId = make_shared<long>(boost::any_cast<long>(m["CenOwnerId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
  }


  virtual ~DescribeGrantRulesToCenResponseBodyCenGrantRulesCbnGrantRule() = default;
};
class DescribeGrantRulesToCenResponseBodyCenGrantRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGrantRulesToCenResponseBodyCenGrantRulesCbnGrantRule>> cbnGrantRule{};

  DescribeGrantRulesToCenResponseBodyCenGrantRules() {}

  explicit DescribeGrantRulesToCenResponseBodyCenGrantRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cbnGrantRule) {
      vector<boost::any> temp1;
      for(auto item1:*cbnGrantRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CbnGrantRule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CbnGrantRule") != m.end() && !m["CbnGrantRule"].empty()) {
      if (typeid(vector<boost::any>) == m["CbnGrantRule"].type()) {
        vector<DescribeGrantRulesToCenResponseBodyCenGrantRulesCbnGrantRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CbnGrantRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGrantRulesToCenResponseBodyCenGrantRulesCbnGrantRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cbnGrantRule = make_shared<vector<DescribeGrantRulesToCenResponseBodyCenGrantRulesCbnGrantRule>>(expect1);
      }
    }
  }


  virtual ~DescribeGrantRulesToCenResponseBodyCenGrantRules() = default;
};
class DescribeGrantRulesToCenResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeGrantRulesToCenResponseBodyCenGrantRules> cenGrantRules{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeGrantRulesToCenResponseBody() {}

  explicit DescribeGrantRulesToCenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cenGrantRules) {
      res["CenGrantRules"] = cenGrantRules ? boost::any(cenGrantRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CenGrantRules") != m.end() && !m["CenGrantRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["CenGrantRules"].type()) {
        DescribeGrantRulesToCenResponseBodyCenGrantRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CenGrantRules"]));
        cenGrantRules = make_shared<DescribeGrantRulesToCenResponseBodyCenGrantRules>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeGrantRulesToCenResponseBody() = default;
};
class DescribeGrantRulesToCenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGrantRulesToCenResponseBody> body{};

  DescribeGrantRulesToCenResponse() {}

  explicit DescribeGrantRulesToCenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGrantRulesToCenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGrantRulesToCenResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGrantRulesToCenResponse() = default;
};
class DescribeHaVipsRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> value{};

  DescribeHaVipsRequestFilter() {}

  explicit DescribeHaVipsRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeHaVipsRequestFilter() = default;
};
class DescribeHaVipsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeHaVipsRequestTags() {}

  explicit DescribeHaVipsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeHaVipsRequestTags() = default;
};
class DescribeHaVipsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHaVipsRequestFilter>> filter{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<DescribeHaVipsRequestTags>> tags{};

  DescribeHaVipsRequest() {}

  explicit DescribeHaVipsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeHaVipsRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHaVipsRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeHaVipsRequestFilter>>(expect1);
      }
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeHaVipsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHaVipsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeHaVipsRequestTags>>(expect1);
      }
    }
  }


  virtual ~DescribeHaVipsRequest() = default;
};
class DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses : public Darabonba::Model {
public:
  shared_ptr<vector<string>> associatedEipAddresse{};

  DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses() {}

  explicit DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associatedEipAddresse) {
      res["associatedEipAddresse"] = boost::any(*associatedEipAddresse);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("associatedEipAddresse") != m.end() && !m["associatedEipAddresse"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["associatedEipAddresse"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["associatedEipAddresse"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      associatedEipAddresse = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses() = default;
};
class DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances : public Darabonba::Model {
public:
  shared_ptr<vector<string>> associatedInstance{};

  DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances() {}

  explicit DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associatedInstance) {
      res["associatedInstance"] = boost::any(*associatedInstance);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("associatedInstance") != m.end() && !m["associatedInstance"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["associatedInstance"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["associatedInstance"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      associatedInstance = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances() = default;
};
class DescribeHaVipsResponseBodyHaVipsHaVipTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeHaVipsResponseBodyHaVipsHaVipTagsTag() {}

  explicit DescribeHaVipsResponseBodyHaVipsHaVipTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeHaVipsResponseBodyHaVipsHaVipTagsTag() = default;
};
class DescribeHaVipsResponseBodyHaVipsHaVipTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHaVipsResponseBodyHaVipsHaVipTagsTag>> tag{};

  DescribeHaVipsResponseBodyHaVipsHaVipTags() {}

  explicit DescribeHaVipsResponseBodyHaVipsHaVipTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeHaVipsResponseBodyHaVipsHaVipTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHaVipsResponseBodyHaVipsHaVipTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeHaVipsResponseBodyHaVipsHaVipTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeHaVipsResponseBodyHaVipsHaVipTags() = default;
};
class DescribeHaVipsResponseBodyHaVipsHaVip : public Darabonba::Model {
public:
  shared_ptr<DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses> associatedEipAddresses{};
  shared_ptr<string> associatedInstanceType{};
  shared_ptr<DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances> associatedInstances{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> haVipId{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> masterInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> status{};
  shared_ptr<DescribeHaVipsResponseBodyHaVipsHaVipTags> tags{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  DescribeHaVipsResponseBodyHaVipsHaVip() {}

  explicit DescribeHaVipsResponseBodyHaVipsHaVip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associatedEipAddresses) {
      res["AssociatedEipAddresses"] = associatedEipAddresses ? boost::any(associatedEipAddresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (associatedInstanceType) {
      res["AssociatedInstanceType"] = boost::any(*associatedInstanceType);
    }
    if (associatedInstances) {
      res["AssociatedInstances"] = associatedInstances ? boost::any(associatedInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (haVipId) {
      res["HaVipId"] = boost::any(*haVipId);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (masterInstanceId) {
      res["MasterInstanceId"] = boost::any(*masterInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociatedEipAddresses") != m.end() && !m["AssociatedEipAddresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssociatedEipAddresses"].type()) {
        DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssociatedEipAddresses"]));
        associatedEipAddresses = make_shared<DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses>(model1);
      }
    }
    if (m.find("AssociatedInstanceType") != m.end() && !m["AssociatedInstanceType"].empty()) {
      associatedInstanceType = make_shared<string>(boost::any_cast<string>(m["AssociatedInstanceType"]));
    }
    if (m.find("AssociatedInstances") != m.end() && !m["AssociatedInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssociatedInstances"].type()) {
        DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssociatedInstances"]));
        associatedInstances = make_shared<DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances>(model1);
      }
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HaVipId") != m.end() && !m["HaVipId"].empty()) {
      haVipId = make_shared<string>(boost::any_cast<string>(m["HaVipId"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("MasterInstanceId") != m.end() && !m["MasterInstanceId"].empty()) {
      masterInstanceId = make_shared<string>(boost::any_cast<string>(m["MasterInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeHaVipsResponseBodyHaVipsHaVipTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeHaVipsResponseBodyHaVipsHaVipTags>(model1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeHaVipsResponseBodyHaVipsHaVip() = default;
};
class DescribeHaVipsResponseBodyHaVips : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHaVipsResponseBodyHaVipsHaVip>> haVip{};

  DescribeHaVipsResponseBodyHaVips() {}

  explicit DescribeHaVipsResponseBodyHaVips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (haVip) {
      vector<boost::any> temp1;
      for(auto item1:*haVip){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HaVip"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HaVip") != m.end() && !m["HaVip"].empty()) {
      if (typeid(vector<boost::any>) == m["HaVip"].type()) {
        vector<DescribeHaVipsResponseBodyHaVipsHaVip> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HaVip"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHaVipsResponseBodyHaVipsHaVip model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        haVip = make_shared<vector<DescribeHaVipsResponseBodyHaVipsHaVip>>(expect1);
      }
    }
  }


  virtual ~DescribeHaVipsResponseBodyHaVips() = default;
};
class DescribeHaVipsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeHaVipsResponseBodyHaVips> haVips{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeHaVipsResponseBody() {}

  explicit DescribeHaVipsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (haVips) {
      res["HaVips"] = haVips ? boost::any(haVips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HaVips") != m.end() && !m["HaVips"].empty()) {
      if (typeid(map<string, boost::any>) == m["HaVips"].type()) {
        DescribeHaVipsResponseBodyHaVips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HaVips"]));
        haVips = make_shared<DescribeHaVipsResponseBodyHaVips>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeHaVipsResponseBody() = default;
};
class DescribeHaVipsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHaVipsResponseBody> body{};

  DescribeHaVipsResponse() {}

  explicit DescribeHaVipsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHaVipsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHaVipsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHaVipsResponse() = default;
};
class DescribeHighDefinitionMonitorLogAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeHighDefinitionMonitorLogAttributeRequest() {}

  explicit DescribeHighDefinitionMonitorLogAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeHighDefinitionMonitorLogAttributeRequest() = default;
};
class DescribeHighDefinitionMonitorLogAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> logProject{};
  shared_ptr<string> logStore{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeHighDefinitionMonitorLogAttributeResponseBody() {}

  explicit DescribeHighDefinitionMonitorLogAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (logProject) {
      res["LogProject"] = boost::any(*logProject);
    }
    if (logStore) {
      res["LogStore"] = boost::any(*logStore);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("LogProject") != m.end() && !m["LogProject"].empty()) {
      logProject = make_shared<string>(boost::any_cast<string>(m["LogProject"]));
    }
    if (m.find("LogStore") != m.end() && !m["LogStore"].empty()) {
      logStore = make_shared<string>(boost::any_cast<string>(m["LogStore"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeHighDefinitionMonitorLogAttributeResponseBody() = default;
};
class DescribeHighDefinitionMonitorLogAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHighDefinitionMonitorLogAttributeResponseBody> body{};

  DescribeHighDefinitionMonitorLogAttributeResponse() {}

  explicit DescribeHighDefinitionMonitorLogAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHighDefinitionMonitorLogAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHighDefinitionMonitorLogAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHighDefinitionMonitorLogAttributeResponse() = default;
};
class DescribeIPv6TranslatorAclListAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeIPv6TranslatorAclListAttributesRequest() {}

  explicit DescribeIPv6TranslatorAclListAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeIPv6TranslatorAclListAttributesRequest() = default;
};
class DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntriesAclEntry : public Darabonba::Model {
public:
  shared_ptr<string> aclEntryComment{};
  shared_ptr<string> aclEntryId{};
  shared_ptr<string> aclEntryIp{};

  DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntriesAclEntry() {}

  explicit DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntriesAclEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntryComment) {
      res["AclEntryComment"] = boost::any(*aclEntryComment);
    }
    if (aclEntryId) {
      res["AclEntryId"] = boost::any(*aclEntryId);
    }
    if (aclEntryIp) {
      res["AclEntryIp"] = boost::any(*aclEntryIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclEntryComment") != m.end() && !m["AclEntryComment"].empty()) {
      aclEntryComment = make_shared<string>(boost::any_cast<string>(m["AclEntryComment"]));
    }
    if (m.find("AclEntryId") != m.end() && !m["AclEntryId"].empty()) {
      aclEntryId = make_shared<string>(boost::any_cast<string>(m["AclEntryId"]));
    }
    if (m.find("AclEntryIp") != m.end() && !m["AclEntryIp"].empty()) {
      aclEntryIp = make_shared<string>(boost::any_cast<string>(m["AclEntryIp"]));
    }
  }


  virtual ~DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntriesAclEntry() = default;
};
class DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntriesAclEntry>> aclEntry{};

  DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntries() {}

  explicit DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntry) {
      vector<boost::any> temp1;
      for(auto item1:*aclEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AclEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclEntry") != m.end() && !m["AclEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["AclEntry"].type()) {
        vector<DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntriesAclEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AclEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntriesAclEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aclEntry = make_shared<vector<DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntriesAclEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntries() = default;
};
class DescribeIPv6TranslatorAclListAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntries> aclEntries{};
  shared_ptr<string> aclId{};
  shared_ptr<string> aclName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeIPv6TranslatorAclListAttributesResponseBody() {}

  explicit DescribeIPv6TranslatorAclListAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntries) {
      res["AclEntries"] = aclEntries ? boost::any(aclEntries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (aclName) {
      res["AclName"] = boost::any(*aclName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclEntries") != m.end() && !m["AclEntries"].empty()) {
      if (typeid(map<string, boost::any>) == m["AclEntries"].type()) {
        DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AclEntries"]));
        aclEntries = make_shared<DescribeIPv6TranslatorAclListAttributesResponseBodyAclEntries>(model1);
      }
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AclName") != m.end() && !m["AclName"].empty()) {
      aclName = make_shared<string>(boost::any_cast<string>(m["AclName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeIPv6TranslatorAclListAttributesResponseBody() = default;
};
class DescribeIPv6TranslatorAclListAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIPv6TranslatorAclListAttributesResponseBody> body{};

  DescribeIPv6TranslatorAclListAttributesResponse() {}

  explicit DescribeIPv6TranslatorAclListAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIPv6TranslatorAclListAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIPv6TranslatorAclListAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIPv6TranslatorAclListAttributesResponse() = default;
};
class DescribeIPv6TranslatorAclListsRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> aclName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeIPv6TranslatorAclListsRequest() {}

  explicit DescribeIPv6TranslatorAclListsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (aclName) {
      res["AclName"] = boost::any(*aclName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AclName") != m.end() && !m["AclName"].empty()) {
      aclName = make_shared<string>(boost::any_cast<string>(m["AclName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeIPv6TranslatorAclListsRequest() = default;
};
class DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAclsIPv6TranslatorAcl : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> aclName{};

  DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAclsIPv6TranslatorAcl() {}

  explicit DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAclsIPv6TranslatorAcl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (aclName) {
      res["AclName"] = boost::any(*aclName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AclName") != m.end() && !m["AclName"].empty()) {
      aclName = make_shared<string>(boost::any_cast<string>(m["AclName"]));
    }
  }


  virtual ~DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAclsIPv6TranslatorAcl() = default;
};
class DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAcls : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAclsIPv6TranslatorAcl>> IPv6TranslatorAcl{};

  DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAcls() {}

  explicit DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAcls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IPv6TranslatorAcl) {
      vector<boost::any> temp1;
      for(auto item1:*IPv6TranslatorAcl){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IPv6TranslatorAcl"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IPv6TranslatorAcl") != m.end() && !m["IPv6TranslatorAcl"].empty()) {
      if (typeid(vector<boost::any>) == m["IPv6TranslatorAcl"].type()) {
        vector<DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAclsIPv6TranslatorAcl> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IPv6TranslatorAcl"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAclsIPv6TranslatorAcl model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        IPv6TranslatorAcl = make_shared<vector<DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAclsIPv6TranslatorAcl>>(expect1);
      }
    }
  }


  virtual ~DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAcls() = default;
};
class DescribeIPv6TranslatorAclListsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAcls> ipv6TranslatorAcls{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeIPv6TranslatorAclListsResponseBody() {}

  explicit DescribeIPv6TranslatorAclListsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6TranslatorAcls) {
      res["Ipv6TranslatorAcls"] = ipv6TranslatorAcls ? boost::any(ipv6TranslatorAcls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6TranslatorAcls") != m.end() && !m["Ipv6TranslatorAcls"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6TranslatorAcls"].type()) {
        DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAcls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6TranslatorAcls"]));
        ipv6TranslatorAcls = make_shared<DescribeIPv6TranslatorAclListsResponseBodyIpv6TranslatorAcls>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeIPv6TranslatorAclListsResponseBody() = default;
};
class DescribeIPv6TranslatorAclListsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIPv6TranslatorAclListsResponseBody> body{};

  DescribeIPv6TranslatorAclListsResponse() {}

  explicit DescribeIPv6TranslatorAclListsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIPv6TranslatorAclListsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIPv6TranslatorAclListsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIPv6TranslatorAclListsResponse() = default;
};
class DescribeIPv6TranslatorEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> aclStatus{};
  shared_ptr<string> aclType{};
  shared_ptr<string> allocateIpv6Addr{};
  shared_ptr<long> allocateIpv6Port{};
  shared_ptr<string> backendIpv4Addr{};
  shared_ptr<long> backendIpv4Port{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> entryName{};
  shared_ptr<string> ipv6TranslatorEntryId{};
  shared_ptr<string> ipv6TranslatorId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> transProtocol{};

  DescribeIPv6TranslatorEntriesRequest() {}

  explicit DescribeIPv6TranslatorEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (aclStatus) {
      res["AclStatus"] = boost::any(*aclStatus);
    }
    if (aclType) {
      res["AclType"] = boost::any(*aclType);
    }
    if (allocateIpv6Addr) {
      res["AllocateIpv6Addr"] = boost::any(*allocateIpv6Addr);
    }
    if (allocateIpv6Port) {
      res["AllocateIpv6Port"] = boost::any(*allocateIpv6Port);
    }
    if (backendIpv4Addr) {
      res["BackendIpv4Addr"] = boost::any(*backendIpv4Addr);
    }
    if (backendIpv4Port) {
      res["BackendIpv4Port"] = boost::any(*backendIpv4Port);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (entryName) {
      res["EntryName"] = boost::any(*entryName);
    }
    if (ipv6TranslatorEntryId) {
      res["Ipv6TranslatorEntryId"] = boost::any(*ipv6TranslatorEntryId);
    }
    if (ipv6TranslatorId) {
      res["Ipv6TranslatorId"] = boost::any(*ipv6TranslatorId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (transProtocol) {
      res["TransProtocol"] = boost::any(*transProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AclStatus") != m.end() && !m["AclStatus"].empty()) {
      aclStatus = make_shared<string>(boost::any_cast<string>(m["AclStatus"]));
    }
    if (m.find("AclType") != m.end() && !m["AclType"].empty()) {
      aclType = make_shared<string>(boost::any_cast<string>(m["AclType"]));
    }
    if (m.find("AllocateIpv6Addr") != m.end() && !m["AllocateIpv6Addr"].empty()) {
      allocateIpv6Addr = make_shared<string>(boost::any_cast<string>(m["AllocateIpv6Addr"]));
    }
    if (m.find("AllocateIpv6Port") != m.end() && !m["AllocateIpv6Port"].empty()) {
      allocateIpv6Port = make_shared<long>(boost::any_cast<long>(m["AllocateIpv6Port"]));
    }
    if (m.find("BackendIpv4Addr") != m.end() && !m["BackendIpv4Addr"].empty()) {
      backendIpv4Addr = make_shared<string>(boost::any_cast<string>(m["BackendIpv4Addr"]));
    }
    if (m.find("BackendIpv4Port") != m.end() && !m["BackendIpv4Port"].empty()) {
      backendIpv4Port = make_shared<long>(boost::any_cast<long>(m["BackendIpv4Port"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EntryName") != m.end() && !m["EntryName"].empty()) {
      entryName = make_shared<string>(boost::any_cast<string>(m["EntryName"]));
    }
    if (m.find("Ipv6TranslatorEntryId") != m.end() && !m["Ipv6TranslatorEntryId"].empty()) {
      ipv6TranslatorEntryId = make_shared<string>(boost::any_cast<string>(m["Ipv6TranslatorEntryId"]));
    }
    if (m.find("Ipv6TranslatorId") != m.end() && !m["Ipv6TranslatorId"].empty()) {
      ipv6TranslatorId = make_shared<string>(boost::any_cast<string>(m["Ipv6TranslatorId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TransProtocol") != m.end() && !m["TransProtocol"].empty()) {
      transProtocol = make_shared<string>(boost::any_cast<string>(m["TransProtocol"]));
    }
  }


  virtual ~DescribeIPv6TranslatorEntriesRequest() = default;
};
class DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> aclStatus{};
  shared_ptr<string> aclType{};
  shared_ptr<string> allocateIpv6Addr{};
  shared_ptr<long> allocateIpv6Port{};
  shared_ptr<string> backendIpv4Addr{};
  shared_ptr<string> backendIpv4Port{};
  shared_ptr<string> entryBandwidth{};
  shared_ptr<string> entryDescription{};
  shared_ptr<string> entryName{};
  shared_ptr<string> entryStatus{};
  shared_ptr<string> ipv6TranslatorEntryId{};
  shared_ptr<string> ipv6TranslatorId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> transProtocol{};

  DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry() {}

  explicit DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (aclStatus) {
      res["AclStatus"] = boost::any(*aclStatus);
    }
    if (aclType) {
      res["AclType"] = boost::any(*aclType);
    }
    if (allocateIpv6Addr) {
      res["AllocateIpv6Addr"] = boost::any(*allocateIpv6Addr);
    }
    if (allocateIpv6Port) {
      res["AllocateIpv6Port"] = boost::any(*allocateIpv6Port);
    }
    if (backendIpv4Addr) {
      res["BackendIpv4Addr"] = boost::any(*backendIpv4Addr);
    }
    if (backendIpv4Port) {
      res["BackendIpv4Port"] = boost::any(*backendIpv4Port);
    }
    if (entryBandwidth) {
      res["EntryBandwidth"] = boost::any(*entryBandwidth);
    }
    if (entryDescription) {
      res["EntryDescription"] = boost::any(*entryDescription);
    }
    if (entryName) {
      res["EntryName"] = boost::any(*entryName);
    }
    if (entryStatus) {
      res["EntryStatus"] = boost::any(*entryStatus);
    }
    if (ipv6TranslatorEntryId) {
      res["Ipv6TranslatorEntryId"] = boost::any(*ipv6TranslatorEntryId);
    }
    if (ipv6TranslatorId) {
      res["Ipv6TranslatorId"] = boost::any(*ipv6TranslatorId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (transProtocol) {
      res["TransProtocol"] = boost::any(*transProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AclStatus") != m.end() && !m["AclStatus"].empty()) {
      aclStatus = make_shared<string>(boost::any_cast<string>(m["AclStatus"]));
    }
    if (m.find("AclType") != m.end() && !m["AclType"].empty()) {
      aclType = make_shared<string>(boost::any_cast<string>(m["AclType"]));
    }
    if (m.find("AllocateIpv6Addr") != m.end() && !m["AllocateIpv6Addr"].empty()) {
      allocateIpv6Addr = make_shared<string>(boost::any_cast<string>(m["AllocateIpv6Addr"]));
    }
    if (m.find("AllocateIpv6Port") != m.end() && !m["AllocateIpv6Port"].empty()) {
      allocateIpv6Port = make_shared<long>(boost::any_cast<long>(m["AllocateIpv6Port"]));
    }
    if (m.find("BackendIpv4Addr") != m.end() && !m["BackendIpv4Addr"].empty()) {
      backendIpv4Addr = make_shared<string>(boost::any_cast<string>(m["BackendIpv4Addr"]));
    }
    if (m.find("BackendIpv4Port") != m.end() && !m["BackendIpv4Port"].empty()) {
      backendIpv4Port = make_shared<string>(boost::any_cast<string>(m["BackendIpv4Port"]));
    }
    if (m.find("EntryBandwidth") != m.end() && !m["EntryBandwidth"].empty()) {
      entryBandwidth = make_shared<string>(boost::any_cast<string>(m["EntryBandwidth"]));
    }
    if (m.find("EntryDescription") != m.end() && !m["EntryDescription"].empty()) {
      entryDescription = make_shared<string>(boost::any_cast<string>(m["EntryDescription"]));
    }
    if (m.find("EntryName") != m.end() && !m["EntryName"].empty()) {
      entryName = make_shared<string>(boost::any_cast<string>(m["EntryName"]));
    }
    if (m.find("EntryStatus") != m.end() && !m["EntryStatus"].empty()) {
      entryStatus = make_shared<string>(boost::any_cast<string>(m["EntryStatus"]));
    }
    if (m.find("Ipv6TranslatorEntryId") != m.end() && !m["Ipv6TranslatorEntryId"].empty()) {
      ipv6TranslatorEntryId = make_shared<string>(boost::any_cast<string>(m["Ipv6TranslatorEntryId"]));
    }
    if (m.find("Ipv6TranslatorId") != m.end() && !m["Ipv6TranslatorId"].empty()) {
      ipv6TranslatorId = make_shared<string>(boost::any_cast<string>(m["Ipv6TranslatorId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TransProtocol") != m.end() && !m["TransProtocol"].empty()) {
      transProtocol = make_shared<string>(boost::any_cast<string>(m["TransProtocol"]));
    }
  }


  virtual ~DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry() = default;
};
class DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry>> ipv6TranslatorEntry{};

  DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntries() {}

  explicit DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6TranslatorEntry) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6TranslatorEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6TranslatorEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6TranslatorEntry") != m.end() && !m["Ipv6TranslatorEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6TranslatorEntry"].type()) {
        vector<DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6TranslatorEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6TranslatorEntry = make_shared<vector<DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntriesIpv6TranslatorEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntries() = default;
};
class DescribeIPv6TranslatorEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntries> ipv6TranslatorEntries{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeIPv6TranslatorEntriesResponseBody() {}

  explicit DescribeIPv6TranslatorEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6TranslatorEntries) {
      res["Ipv6TranslatorEntries"] = ipv6TranslatorEntries ? boost::any(ipv6TranslatorEntries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6TranslatorEntries") != m.end() && !m["Ipv6TranslatorEntries"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6TranslatorEntries"].type()) {
        DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6TranslatorEntries"]));
        ipv6TranslatorEntries = make_shared<DescribeIPv6TranslatorEntriesResponseBodyIpv6TranslatorEntries>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeIPv6TranslatorEntriesResponseBody() = default;
};
class DescribeIPv6TranslatorEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIPv6TranslatorEntriesResponseBody> body{};

  DescribeIPv6TranslatorEntriesResponse() {}

  explicit DescribeIPv6TranslatorEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIPv6TranslatorEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIPv6TranslatorEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIPv6TranslatorEntriesResponse() = default;
};
class DescribeIPv6TranslatorsRequest : public Darabonba::Model {
public:
  shared_ptr<string> allocateIpv4Addr{};
  shared_ptr<string> allocateIpv6Addr{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> ipv6TranslatorId{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> payType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> spec{};
  shared_ptr<string> status{};

  DescribeIPv6TranslatorsRequest() {}

  explicit DescribeIPv6TranslatorsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocateIpv4Addr) {
      res["AllocateIpv4Addr"] = boost::any(*allocateIpv4Addr);
    }
    if (allocateIpv6Addr) {
      res["AllocateIpv6Addr"] = boost::any(*allocateIpv6Addr);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (ipv6TranslatorId) {
      res["Ipv6TranslatorId"] = boost::any(*ipv6TranslatorId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocateIpv4Addr") != m.end() && !m["AllocateIpv4Addr"].empty()) {
      allocateIpv4Addr = make_shared<string>(boost::any_cast<string>(m["AllocateIpv4Addr"]));
    }
    if (m.find("AllocateIpv6Addr") != m.end() && !m["AllocateIpv6Addr"].empty()) {
      allocateIpv6Addr = make_shared<string>(boost::any_cast<string>(m["AllocateIpv6Addr"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("Ipv6TranslatorId") != m.end() && !m["Ipv6TranslatorId"].empty()) {
      ipv6TranslatorId = make_shared<string>(boost::any_cast<string>(m["Ipv6TranslatorId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeIPv6TranslatorsRequest() = default;
};
class DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6TranslatorIpv6TranslatorEntryIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ipv6TranslatorEntryId{};

  DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6TranslatorIpv6TranslatorEntryIds() {}

  explicit DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6TranslatorIpv6TranslatorEntryIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6TranslatorEntryId) {
      res["Ipv6TranslatorEntryId"] = boost::any(*ipv6TranslatorEntryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6TranslatorEntryId") != m.end() && !m["Ipv6TranslatorEntryId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ipv6TranslatorEntryId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ipv6TranslatorEntryId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipv6TranslatorEntryId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6TranslatorIpv6TranslatorEntryIds() = default;
};
class DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator : public Darabonba::Model {
public:
  shared_ptr<string> allocateIpv4Addr{};
  shared_ptr<string> allocateIpv6Addr{};
  shared_ptr<string> availableBandwidth{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> businessStatus{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> endTime{};
  shared_ptr<DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6TranslatorIpv6TranslatorEntryIds> ipv6TranslatorEntryIds{};
  shared_ptr<string> ipv6TranslatorId{};
  shared_ptr<string> name{};
  shared_ptr<string> payType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> spec{};
  shared_ptr<string> status{};

  DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator() {}

  explicit DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocateIpv4Addr) {
      res["AllocateIpv4Addr"] = boost::any(*allocateIpv4Addr);
    }
    if (allocateIpv6Addr) {
      res["AllocateIpv6Addr"] = boost::any(*allocateIpv6Addr);
    }
    if (availableBandwidth) {
      res["AvailableBandwidth"] = boost::any(*availableBandwidth);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ipv6TranslatorEntryIds) {
      res["Ipv6TranslatorEntryIds"] = ipv6TranslatorEntryIds ? boost::any(ipv6TranslatorEntryIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipv6TranslatorId) {
      res["Ipv6TranslatorId"] = boost::any(*ipv6TranslatorId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocateIpv4Addr") != m.end() && !m["AllocateIpv4Addr"].empty()) {
      allocateIpv4Addr = make_shared<string>(boost::any_cast<string>(m["AllocateIpv4Addr"]));
    }
    if (m.find("AllocateIpv6Addr") != m.end() && !m["AllocateIpv6Addr"].empty()) {
      allocateIpv6Addr = make_shared<string>(boost::any_cast<string>(m["AllocateIpv6Addr"]));
    }
    if (m.find("AvailableBandwidth") != m.end() && !m["AvailableBandwidth"].empty()) {
      availableBandwidth = make_shared<string>(boost::any_cast<string>(m["AvailableBandwidth"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Ipv6TranslatorEntryIds") != m.end() && !m["Ipv6TranslatorEntryIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6TranslatorEntryIds"].type()) {
        DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6TranslatorIpv6TranslatorEntryIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6TranslatorEntryIds"]));
        ipv6TranslatorEntryIds = make_shared<DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6TranslatorIpv6TranslatorEntryIds>(model1);
      }
    }
    if (m.find("Ipv6TranslatorId") != m.end() && !m["Ipv6TranslatorId"].empty()) {
      ipv6TranslatorId = make_shared<string>(boost::any_cast<string>(m["Ipv6TranslatorId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator() = default;
};
class DescribeIPv6TranslatorsResponseBodyIpv6Translators : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator>> ipv6Translator{};

  DescribeIPv6TranslatorsResponseBodyIpv6Translators() {}

  explicit DescribeIPv6TranslatorsResponseBodyIpv6Translators(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Translator) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6Translator){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6Translator"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Translator") != m.end() && !m["Ipv6Translator"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6Translator"].type()) {
        vector<DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6Translator"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6Translator = make_shared<vector<DescribeIPv6TranslatorsResponseBodyIpv6TranslatorsIpv6Translator>>(expect1);
      }
    }
  }


  virtual ~DescribeIPv6TranslatorsResponseBodyIpv6Translators() = default;
};
class DescribeIPv6TranslatorsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeIPv6TranslatorsResponseBodyIpv6Translators> ipv6Translators{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeIPv6TranslatorsResponseBody() {}

  explicit DescribeIPv6TranslatorsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Translators) {
      res["Ipv6Translators"] = ipv6Translators ? boost::any(ipv6Translators->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Translators") != m.end() && !m["Ipv6Translators"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6Translators"].type()) {
        DescribeIPv6TranslatorsResponseBodyIpv6Translators model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6Translators"]));
        ipv6Translators = make_shared<DescribeIPv6TranslatorsResponseBodyIpv6Translators>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeIPv6TranslatorsResponseBody() = default;
};
class DescribeIPv6TranslatorsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIPv6TranslatorsResponseBody> body{};

  DescribeIPv6TranslatorsResponse() {}

  explicit DescribeIPv6TranslatorsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIPv6TranslatorsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIPv6TranslatorsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIPv6TranslatorsResponse() = default;
};
class DescribeIpv6AddressesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeIpv6AddressesRequestTag() {}

  explicit DescribeIpv6AddressesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeIpv6AddressesRequestTag() = default;
};
class DescribeIpv6AddressesRequest : public Darabonba::Model {
public:
  shared_ptr<string> associatedInstanceId{};
  shared_ptr<string> associatedInstanceType{};
  shared_ptr<bool> includeReservationData{};
  shared_ptr<string> ipv6Address{};
  shared_ptr<string> ipv6AddressId{};
  shared_ptr<string> ipv6InternetBandwidthId{};
  shared_ptr<string> name{};
  shared_ptr<string> networkType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<bool> serviceManaged{};
  shared_ptr<vector<DescribeIpv6AddressesRequestTag>> tag{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  DescribeIpv6AddressesRequest() {}

  explicit DescribeIpv6AddressesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associatedInstanceId) {
      res["AssociatedInstanceId"] = boost::any(*associatedInstanceId);
    }
    if (associatedInstanceType) {
      res["AssociatedInstanceType"] = boost::any(*associatedInstanceType);
    }
    if (includeReservationData) {
      res["IncludeReservationData"] = boost::any(*includeReservationData);
    }
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    if (ipv6AddressId) {
      res["Ipv6AddressId"] = boost::any(*ipv6AddressId);
    }
    if (ipv6InternetBandwidthId) {
      res["Ipv6InternetBandwidthId"] = boost::any(*ipv6InternetBandwidthId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceManaged) {
      res["ServiceManaged"] = boost::any(*serviceManaged);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociatedInstanceId") != m.end() && !m["AssociatedInstanceId"].empty()) {
      associatedInstanceId = make_shared<string>(boost::any_cast<string>(m["AssociatedInstanceId"]));
    }
    if (m.find("AssociatedInstanceType") != m.end() && !m["AssociatedInstanceType"].empty()) {
      associatedInstanceType = make_shared<string>(boost::any_cast<string>(m["AssociatedInstanceType"]));
    }
    if (m.find("IncludeReservationData") != m.end() && !m["IncludeReservationData"].empty()) {
      includeReservationData = make_shared<bool>(boost::any_cast<bool>(m["IncludeReservationData"]));
    }
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      ipv6Address = make_shared<string>(boost::any_cast<string>(m["Ipv6Address"]));
    }
    if (m.find("Ipv6AddressId") != m.end() && !m["Ipv6AddressId"].empty()) {
      ipv6AddressId = make_shared<string>(boost::any_cast<string>(m["Ipv6AddressId"]));
    }
    if (m.find("Ipv6InternetBandwidthId") != m.end() && !m["Ipv6InternetBandwidthId"].empty()) {
      ipv6InternetBandwidthId = make_shared<string>(boost::any_cast<string>(m["Ipv6InternetBandwidthId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceManaged") != m.end() && !m["ServiceManaged"].empty()) {
      serviceManaged = make_shared<bool>(boost::any_cast<bool>(m["ServiceManaged"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeIpv6AddressesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIpv6AddressesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeIpv6AddressesRequestTag>>(expect1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeIpv6AddressesRequest() = default;
};
class DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> businessStatus{};
  shared_ptr<bool> hasReservationData{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> ipv6InternetBandwidthId{};
  shared_ptr<string> reservationActiveTime{};
  shared_ptr<long> reservationBandwidth{};
  shared_ptr<string> reservationInternetChargeType{};
  shared_ptr<string> reservationOrderType{};

  DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth() {}

  explicit DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (hasReservationData) {
      res["HasReservationData"] = boost::any(*hasReservationData);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (ipv6InternetBandwidthId) {
      res["Ipv6InternetBandwidthId"] = boost::any(*ipv6InternetBandwidthId);
    }
    if (reservationActiveTime) {
      res["ReservationActiveTime"] = boost::any(*reservationActiveTime);
    }
    if (reservationBandwidth) {
      res["ReservationBandwidth"] = boost::any(*reservationBandwidth);
    }
    if (reservationInternetChargeType) {
      res["ReservationInternetChargeType"] = boost::any(*reservationInternetChargeType);
    }
    if (reservationOrderType) {
      res["ReservationOrderType"] = boost::any(*reservationOrderType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("HasReservationData") != m.end() && !m["HasReservationData"].empty()) {
      hasReservationData = make_shared<bool>(boost::any_cast<bool>(m["HasReservationData"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("Ipv6InternetBandwidthId") != m.end() && !m["Ipv6InternetBandwidthId"].empty()) {
      ipv6InternetBandwidthId = make_shared<string>(boost::any_cast<string>(m["Ipv6InternetBandwidthId"]));
    }
    if (m.find("ReservationActiveTime") != m.end() && !m["ReservationActiveTime"].empty()) {
      reservationActiveTime = make_shared<string>(boost::any_cast<string>(m["ReservationActiveTime"]));
    }
    if (m.find("ReservationBandwidth") != m.end() && !m["ReservationBandwidth"].empty()) {
      reservationBandwidth = make_shared<long>(boost::any_cast<long>(m["ReservationBandwidth"]));
    }
    if (m.find("ReservationInternetChargeType") != m.end() && !m["ReservationInternetChargeType"].empty()) {
      reservationInternetChargeType = make_shared<string>(boost::any_cast<string>(m["ReservationInternetChargeType"]));
    }
    if (m.find("ReservationOrderType") != m.end() && !m["ReservationOrderType"].empty()) {
      reservationOrderType = make_shared<string>(boost::any_cast<string>(m["ReservationOrderType"]));
    }
  }


  virtual ~DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth() = default;
};
class DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressTagsTag() {}

  explicit DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressTagsTag() = default;
};
class DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressTagsTag>> tag{};

  DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressTags() {}

  explicit DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressTags() = default;
};
class DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address : public Darabonba::Model {
public:
  shared_ptr<string> allocationTime{};
  shared_ptr<string> associatedInstanceId{};
  shared_ptr<string> associatedInstanceType{};
  shared_ptr<string> ipv6Address{};
  shared_ptr<string> ipv6AddressDescription{};
  shared_ptr<string> ipv6AddressId{};
  shared_ptr<string> ipv6AddressName{};
  shared_ptr<string> ipv6GatewayId{};
  shared_ptr<DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth> ipv6InternetBandwidth{};
  shared_ptr<string> ipv6Isp{};
  shared_ptr<string> networkType{};
  shared_ptr<long> realBandwidth{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> serviceManaged{};
  shared_ptr<string> status{};
  shared_ptr<DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressTags> tags{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address() {}

  explicit DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationTime) {
      res["AllocationTime"] = boost::any(*allocationTime);
    }
    if (associatedInstanceId) {
      res["AssociatedInstanceId"] = boost::any(*associatedInstanceId);
    }
    if (associatedInstanceType) {
      res["AssociatedInstanceType"] = boost::any(*associatedInstanceType);
    }
    if (ipv6Address) {
      res["Ipv6Address"] = boost::any(*ipv6Address);
    }
    if (ipv6AddressDescription) {
      res["Ipv6AddressDescription"] = boost::any(*ipv6AddressDescription);
    }
    if (ipv6AddressId) {
      res["Ipv6AddressId"] = boost::any(*ipv6AddressId);
    }
    if (ipv6AddressName) {
      res["Ipv6AddressName"] = boost::any(*ipv6AddressName);
    }
    if (ipv6GatewayId) {
      res["Ipv6GatewayId"] = boost::any(*ipv6GatewayId);
    }
    if (ipv6InternetBandwidth) {
      res["Ipv6InternetBandwidth"] = ipv6InternetBandwidth ? boost::any(ipv6InternetBandwidth->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipv6Isp) {
      res["Ipv6Isp"] = boost::any(*ipv6Isp);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (realBandwidth) {
      res["RealBandwidth"] = boost::any(*realBandwidth);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (serviceManaged) {
      res["ServiceManaged"] = boost::any(*serviceManaged);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationTime") != m.end() && !m["AllocationTime"].empty()) {
      allocationTime = make_shared<string>(boost::any_cast<string>(m["AllocationTime"]));
    }
    if (m.find("AssociatedInstanceId") != m.end() && !m["AssociatedInstanceId"].empty()) {
      associatedInstanceId = make_shared<string>(boost::any_cast<string>(m["AssociatedInstanceId"]));
    }
    if (m.find("AssociatedInstanceType") != m.end() && !m["AssociatedInstanceType"].empty()) {
      associatedInstanceType = make_shared<string>(boost::any_cast<string>(m["AssociatedInstanceType"]));
    }
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      ipv6Address = make_shared<string>(boost::any_cast<string>(m["Ipv6Address"]));
    }
    if (m.find("Ipv6AddressDescription") != m.end() && !m["Ipv6AddressDescription"].empty()) {
      ipv6AddressDescription = make_shared<string>(boost::any_cast<string>(m["Ipv6AddressDescription"]));
    }
    if (m.find("Ipv6AddressId") != m.end() && !m["Ipv6AddressId"].empty()) {
      ipv6AddressId = make_shared<string>(boost::any_cast<string>(m["Ipv6AddressId"]));
    }
    if (m.find("Ipv6AddressName") != m.end() && !m["Ipv6AddressName"].empty()) {
      ipv6AddressName = make_shared<string>(boost::any_cast<string>(m["Ipv6AddressName"]));
    }
    if (m.find("Ipv6GatewayId") != m.end() && !m["Ipv6GatewayId"].empty()) {
      ipv6GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv6GatewayId"]));
    }
    if (m.find("Ipv6InternetBandwidth") != m.end() && !m["Ipv6InternetBandwidth"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6InternetBandwidth"].type()) {
        DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6InternetBandwidth"]));
        ipv6InternetBandwidth = make_shared<DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressIpv6InternetBandwidth>(model1);
      }
    }
    if (m.find("Ipv6Isp") != m.end() && !m["Ipv6Isp"].empty()) {
      ipv6Isp = make_shared<string>(boost::any_cast<string>(m["Ipv6Isp"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("RealBandwidth") != m.end() && !m["RealBandwidth"].empty()) {
      realBandwidth = make_shared<long>(boost::any_cast<long>(m["RealBandwidth"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ServiceManaged") != m.end() && !m["ServiceManaged"].empty()) {
      serviceManaged = make_shared<long>(boost::any_cast<long>(m["ServiceManaged"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6AddressTags>(model1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address() = default;
};
class DescribeIpv6AddressesResponseBodyIpv6Addresses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address>> ipv6Address{};

  DescribeIpv6AddressesResponseBodyIpv6Addresses() {}

  explicit DescribeIpv6AddressesResponseBodyIpv6Addresses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Address) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6Address){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6Address"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Address") != m.end() && !m["Ipv6Address"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6Address"].type()) {
        vector<DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6Address"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6Address = make_shared<vector<DescribeIpv6AddressesResponseBodyIpv6AddressesIpv6Address>>(expect1);
      }
    }
  }


  virtual ~DescribeIpv6AddressesResponseBodyIpv6Addresses() = default;
};
class DescribeIpv6AddressesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeIpv6AddressesResponseBodyIpv6Addresses> ipv6Addresses{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeIpv6AddressesResponseBody() {}

  explicit DescribeIpv6AddressesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Addresses) {
      res["Ipv6Addresses"] = ipv6Addresses ? boost::any(ipv6Addresses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Addresses") != m.end() && !m["Ipv6Addresses"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6Addresses"].type()) {
        DescribeIpv6AddressesResponseBodyIpv6Addresses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6Addresses"]));
        ipv6Addresses = make_shared<DescribeIpv6AddressesResponseBodyIpv6Addresses>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeIpv6AddressesResponseBody() = default;
};
class DescribeIpv6AddressesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIpv6AddressesResponseBody> body{};

  DescribeIpv6AddressesResponse() {}

  explicit DescribeIpv6AddressesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIpv6AddressesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIpv6AddressesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIpv6AddressesResponse() = default;
};
class DescribeIpv6EgressOnlyRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ipv6EgressOnlyRuleId{};
  shared_ptr<string> ipv6GatewayId{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeIpv6EgressOnlyRulesRequest() {}

  explicit DescribeIpv6EgressOnlyRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ipv6EgressOnlyRuleId) {
      res["Ipv6EgressOnlyRuleId"] = boost::any(*ipv6EgressOnlyRuleId);
    }
    if (ipv6GatewayId) {
      res["Ipv6GatewayId"] = boost::any(*ipv6GatewayId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ipv6EgressOnlyRuleId") != m.end() && !m["Ipv6EgressOnlyRuleId"].empty()) {
      ipv6EgressOnlyRuleId = make_shared<string>(boost::any_cast<string>(m["Ipv6EgressOnlyRuleId"]));
    }
    if (m.find("Ipv6GatewayId") != m.end() && !m["Ipv6GatewayId"].empty()) {
      ipv6GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv6GatewayId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeIpv6EgressOnlyRulesRequest() = default;
};
class DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ipv6EgressOnlyRuleId{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};

  DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule() {}

  explicit DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ipv6EgressOnlyRuleId) {
      res["Ipv6EgressOnlyRuleId"] = boost::any(*ipv6EgressOnlyRuleId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ipv6EgressOnlyRuleId") != m.end() && !m["Ipv6EgressOnlyRuleId"].empty()) {
      ipv6EgressOnlyRuleId = make_shared<string>(boost::any_cast<string>(m["Ipv6EgressOnlyRuleId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule() = default;
};
class DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule>> ipv6EgressOnlyRule{};

  DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRules() {}

  explicit DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6EgressOnlyRule) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6EgressOnlyRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6EgressOnlyRule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6EgressOnlyRule") != m.end() && !m["Ipv6EgressOnlyRule"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6EgressOnlyRule"].type()) {
        vector<DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6EgressOnlyRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6EgressOnlyRule = make_shared<vector<DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRulesIpv6EgressOnlyRule>>(expect1);
      }
    }
  }


  virtual ~DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRules() = default;
};
class DescribeIpv6EgressOnlyRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRules> ipv6EgressOnlyRules{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeIpv6EgressOnlyRulesResponseBody() {}

  explicit DescribeIpv6EgressOnlyRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6EgressOnlyRules) {
      res["Ipv6EgressOnlyRules"] = ipv6EgressOnlyRules ? boost::any(ipv6EgressOnlyRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6EgressOnlyRules") != m.end() && !m["Ipv6EgressOnlyRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6EgressOnlyRules"].type()) {
        DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6EgressOnlyRules"]));
        ipv6EgressOnlyRules = make_shared<DescribeIpv6EgressOnlyRulesResponseBodyIpv6EgressOnlyRules>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeIpv6EgressOnlyRulesResponseBody() = default;
};
class DescribeIpv6EgressOnlyRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIpv6EgressOnlyRulesResponseBody> body{};

  DescribeIpv6EgressOnlyRulesResponse() {}

  explicit DescribeIpv6EgressOnlyRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIpv6EgressOnlyRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIpv6EgressOnlyRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIpv6EgressOnlyRulesResponse() = default;
};
class DescribeIpv6GatewayAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipv6GatewayId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeIpv6GatewayAttributeRequest() {}

  explicit DescribeIpv6GatewayAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6GatewayId) {
      res["Ipv6GatewayId"] = boost::any(*ipv6GatewayId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6GatewayId") != m.end() && !m["Ipv6GatewayId"].empty()) {
      ipv6GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv6GatewayId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeIpv6GatewayAttributeRequest() = default;
};
class DescribeIpv6GatewayAttributeResponseBodyTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeIpv6GatewayAttributeResponseBodyTagsTag() {}

  explicit DescribeIpv6GatewayAttributeResponseBodyTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeIpv6GatewayAttributeResponseBodyTagsTag() = default;
};
class DescribeIpv6GatewayAttributeResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIpv6GatewayAttributeResponseBodyTagsTag>> tag{};

  DescribeIpv6GatewayAttributeResponseBodyTags() {}

  explicit DescribeIpv6GatewayAttributeResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeIpv6GatewayAttributeResponseBodyTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIpv6GatewayAttributeResponseBodyTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeIpv6GatewayAttributeResponseBodyTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeIpv6GatewayAttributeResponseBodyTags() = default;
};
class DescribeIpv6GatewayAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> businessStatus{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> gatewayRouteTableId{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> ipv6GatewayId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> status{};
  shared_ptr<DescribeIpv6GatewayAttributeResponseBodyTags> tags{};
  shared_ptr<string> vpcId{};

  DescribeIpv6GatewayAttributeResponseBody() {}

  explicit DescribeIpv6GatewayAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (gatewayRouteTableId) {
      res["GatewayRouteTableId"] = boost::any(*gatewayRouteTableId);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (ipv6GatewayId) {
      res["Ipv6GatewayId"] = boost::any(*ipv6GatewayId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("GatewayRouteTableId") != m.end() && !m["GatewayRouteTableId"].empty()) {
      gatewayRouteTableId = make_shared<string>(boost::any_cast<string>(m["GatewayRouteTableId"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("Ipv6GatewayId") != m.end() && !m["Ipv6GatewayId"].empty()) {
      ipv6GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv6GatewayId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeIpv6GatewayAttributeResponseBodyTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeIpv6GatewayAttributeResponseBodyTags>(model1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeIpv6GatewayAttributeResponseBody() = default;
};
class DescribeIpv6GatewayAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIpv6GatewayAttributeResponseBody> body{};

  DescribeIpv6GatewayAttributeResponse() {}

  explicit DescribeIpv6GatewayAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIpv6GatewayAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIpv6GatewayAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIpv6GatewayAttributeResponse() = default;
};
class DescribeIpv6GatewaysRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeIpv6GatewaysRequestTags() {}

  explicit DescribeIpv6GatewaysRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeIpv6GatewaysRequestTags() = default;
};
class DescribeIpv6GatewaysRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipv6GatewayId{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<DescribeIpv6GatewaysRequestTags>> tags{};
  shared_ptr<string> vpcId{};

  DescribeIpv6GatewaysRequest() {}

  explicit DescribeIpv6GatewaysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6GatewayId) {
      res["Ipv6GatewayId"] = boost::any(*ipv6GatewayId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6GatewayId") != m.end() && !m["Ipv6GatewayId"].empty()) {
      ipv6GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv6GatewayId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeIpv6GatewaysRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIpv6GatewaysRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeIpv6GatewaysRequestTags>>(expect1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeIpv6GatewaysRequest() = default;
};
class DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTagsTag() {}

  explicit DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTagsTag() = default;
};
class DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTagsTag>> tag{};

  DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTags() {}

  explicit DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTags() = default;
};
class DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway : public Darabonba::Model {
public:
  shared_ptr<string> businessStatus{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> ipv6GatewayId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> status{};
  shared_ptr<DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTags> tags{};
  shared_ptr<string> vpcId{};

  DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway() {}

  explicit DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (ipv6GatewayId) {
      res["Ipv6GatewayId"] = boost::any(*ipv6GatewayId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("Ipv6GatewayId") != m.end() && !m["Ipv6GatewayId"].empty()) {
      ipv6GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv6GatewayId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6GatewayTags>(model1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway() = default;
};
class DescribeIpv6GatewaysResponseBodyIpv6Gateways : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway>> ipv6Gateway{};

  DescribeIpv6GatewaysResponseBodyIpv6Gateways() {}

  explicit DescribeIpv6GatewaysResponseBodyIpv6Gateways(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Gateway) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6Gateway){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6Gateway"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Gateway") != m.end() && !m["Ipv6Gateway"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6Gateway"].type()) {
        vector<DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6Gateway"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6Gateway = make_shared<vector<DescribeIpv6GatewaysResponseBodyIpv6GatewaysIpv6Gateway>>(expect1);
      }
    }
  }


  virtual ~DescribeIpv6GatewaysResponseBodyIpv6Gateways() = default;
};
class DescribeIpv6GatewaysResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeIpv6GatewaysResponseBodyIpv6Gateways> ipv6Gateways{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeIpv6GatewaysResponseBody() {}

  explicit DescribeIpv6GatewaysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6Gateways) {
      res["Ipv6Gateways"] = ipv6Gateways ? boost::any(ipv6Gateways->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6Gateways") != m.end() && !m["Ipv6Gateways"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6Gateways"].type()) {
        DescribeIpv6GatewaysResponseBodyIpv6Gateways model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6Gateways"]));
        ipv6Gateways = make_shared<DescribeIpv6GatewaysResponseBodyIpv6Gateways>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeIpv6GatewaysResponseBody() = default;
};
class DescribeIpv6GatewaysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIpv6GatewaysResponseBody> body{};

  DescribeIpv6GatewaysResponse() {}

  explicit DescribeIpv6GatewaysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIpv6GatewaysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIpv6GatewaysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIpv6GatewaysResponse() = default;
};
class DescribeNatGatewaysRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeNatGatewaysRequestTag() {}

  explicit DescribeNatGatewaysRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeNatGatewaysRequestTag() = default;
};
class DescribeNatGatewaysRequest : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> name{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> natType{};
  shared_ptr<string> networkType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> spec{};
  shared_ptr<string> status{};
  shared_ptr<vector<DescribeNatGatewaysRequestTag>> tag{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  DescribeNatGatewaysRequest() {}

  explicit DescribeNatGatewaysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (natType) {
      res["NatType"] = boost::any(*natType);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("NatType") != m.end() && !m["NatType"].empty()) {
      natType = make_shared<string>(boost::any_cast<string>(m["NatType"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeNatGatewaysRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNatGatewaysRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeNatGatewaysRequestTag>>(expect1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeNatGatewaysRequest() = default;
};
class DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> forwardTableId{};

  DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds() {}

  explicit DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardTableId) {
      res["ForwardTableId"] = boost::any(*forwardTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardTableId") != m.end() && !m["ForwardTableId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ForwardTableId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ForwardTableId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      forwardTableId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds() = default;
};
class DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayFullNatTableIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fullNatTableId{};

  DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayFullNatTableIds() {}

  explicit DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayFullNatTableIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fullNatTableId) {
      res["FullNatTableId"] = boost::any(*fullNatTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FullNatTableId") != m.end() && !m["FullNatTableId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FullNatTableId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FullNatTableId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fullNatTableId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayFullNatTableIds() = default;
};
class DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<bool> snatEntryEnabled{};
  shared_ptr<string> usingStatus{};

  DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList() {}

  explicit DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (snatEntryEnabled) {
      res["SnatEntryEnabled"] = boost::any(*snatEntryEnabled);
    }
    if (usingStatus) {
      res["UsingStatus"] = boost::any(*usingStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("SnatEntryEnabled") != m.end() && !m["SnatEntryEnabled"].empty()) {
      snatEntryEnabled = make_shared<bool>(boost::any_cast<bool>(m["SnatEntryEnabled"]));
    }
    if (m.find("UsingStatus") != m.end() && !m["UsingStatus"].empty()) {
      usingStatus = make_shared<string>(boost::any_cast<string>(m["UsingStatus"]));
    }
  }


  virtual ~DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList() = default;
};
class DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpLists : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList>> ipList{};

  DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpLists() {}

  explicit DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpLists(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipList) {
      vector<boost::any> temp1;
      for(auto item1:*ipList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpList") != m.end() && !m["IpList"].empty()) {
      if (typeid(vector<boost::any>) == m["IpList"].type()) {
        vector<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipList = make_shared<vector<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpListsIpList>>(expect1);
      }
    }
  }


  virtual ~DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpLists() = default;
};
class DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo : public Darabonba::Model {
public:
  shared_ptr<string> eniInstanceId{};
  shared_ptr<string> eniType{};
  shared_ptr<string> izNo{};
  shared_ptr<long> maxBandwidth{};
  shared_ptr<long> maxSessionEstablishRate{};
  shared_ptr<long> maxSessionQuota{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> vswitchId{};

  DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo() {}

  explicit DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eniInstanceId) {
      res["EniInstanceId"] = boost::any(*eniInstanceId);
    }
    if (eniType) {
      res["EniType"] = boost::any(*eniType);
    }
    if (izNo) {
      res["IzNo"] = boost::any(*izNo);
    }
    if (maxBandwidth) {
      res["MaxBandwidth"] = boost::any(*maxBandwidth);
    }
    if (maxSessionEstablishRate) {
      res["MaxSessionEstablishRate"] = boost::any(*maxSessionEstablishRate);
    }
    if (maxSessionQuota) {
      res["MaxSessionQuota"] = boost::any(*maxSessionQuota);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EniInstanceId") != m.end() && !m["EniInstanceId"].empty()) {
      eniInstanceId = make_shared<string>(boost::any_cast<string>(m["EniInstanceId"]));
    }
    if (m.find("EniType") != m.end() && !m["EniType"].empty()) {
      eniType = make_shared<string>(boost::any_cast<string>(m["EniType"]));
    }
    if (m.find("IzNo") != m.end() && !m["IzNo"].empty()) {
      izNo = make_shared<string>(boost::any_cast<string>(m["IzNo"]));
    }
    if (m.find("MaxBandwidth") != m.end() && !m["MaxBandwidth"].empty()) {
      maxBandwidth = make_shared<long>(boost::any_cast<long>(m["MaxBandwidth"]));
    }
    if (m.find("MaxSessionEstablishRate") != m.end() && !m["MaxSessionEstablishRate"].empty()) {
      maxSessionEstablishRate = make_shared<long>(boost::any_cast<long>(m["MaxSessionEstablishRate"]));
    }
    if (m.find("MaxSessionQuota") != m.end() && !m["MaxSessionQuota"].empty()) {
      maxSessionQuota = make_shared<long>(boost::any_cast<long>(m["MaxSessionQuota"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo() = default;
};
class DescribeNatGatewaysResponseBodyNatGatewaysNatGatewaySnatTableIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> snatTableId{};

  DescribeNatGatewaysResponseBodyNatGatewaysNatGatewaySnatTableIds() {}

  explicit DescribeNatGatewaysResponseBodyNatGatewaysNatGatewaySnatTableIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snatTableId) {
      res["SnatTableId"] = boost::any(*snatTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnatTableId") != m.end() && !m["SnatTableId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SnatTableId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SnatTableId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      snatTableId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeNatGatewaysResponseBodyNatGatewaysNatGatewaySnatTableIds() = default;
};
class DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTagsTag() {}

  explicit DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTagsTag() = default;
};
class DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTagsTag>> tag{};

  DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTags() {}

  explicit DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTags() = default;
};
class DescribeNatGatewaysResponseBodyNatGatewaysNatGateway : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> creationTime{};
  shared_ptr<bool> deletionProtection{};
  shared_ptr<string> description{};
  shared_ptr<bool> ecsMetricEnabled{};
  shared_ptr<string> eipBindMode{};
  shared_ptr<string> enableSessionLog{};
  shared_ptr<string> expiredTime{};
  shared_ptr<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds> forwardTableIds{};
  shared_ptr<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayFullNatTableIds> fullNatTableIds{};
  shared_ptr<bool> icmpReplyEnabled{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpLists> ipLists{};
  shared_ptr<string> name{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo> natGatewayPrivateInfo{};
  shared_ptr<string> natType{};
  shared_ptr<string> networkType{};
  shared_ptr<bool> privateLinkEnabled{};
  shared_ptr<string> privateLinkMode{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> securityProtectionEnabled{};
  shared_ptr<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewaySnatTableIds> snatTableIds{};
  shared_ptr<string> spec{};
  shared_ptr<string> status{};
  shared_ptr<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTags> tags{};
  shared_ptr<string> vpcId{};

  DescribeNatGatewaysResponseBodyNatGatewaysNatGateway() {}

  explicit DescribeNatGatewaysResponseBodyNatGatewaysNatGateway(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (deletionProtection) {
      res["DeletionProtection"] = boost::any(*deletionProtection);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ecsMetricEnabled) {
      res["EcsMetricEnabled"] = boost::any(*ecsMetricEnabled);
    }
    if (eipBindMode) {
      res["EipBindMode"] = boost::any(*eipBindMode);
    }
    if (enableSessionLog) {
      res["EnableSessionLog"] = boost::any(*enableSessionLog);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (forwardTableIds) {
      res["ForwardTableIds"] = forwardTableIds ? boost::any(forwardTableIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fullNatTableIds) {
      res["FullNatTableIds"] = fullNatTableIds ? boost::any(fullNatTableIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (icmpReplyEnabled) {
      res["IcmpReplyEnabled"] = boost::any(*icmpReplyEnabled);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (ipLists) {
      res["IpLists"] = ipLists ? boost::any(ipLists->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (natGatewayPrivateInfo) {
      res["NatGatewayPrivateInfo"] = natGatewayPrivateInfo ? boost::any(natGatewayPrivateInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (natType) {
      res["NatType"] = boost::any(*natType);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (privateLinkEnabled) {
      res["PrivateLinkEnabled"] = boost::any(*privateLinkEnabled);
    }
    if (privateLinkMode) {
      res["PrivateLinkMode"] = boost::any(*privateLinkMode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityProtectionEnabled) {
      res["SecurityProtectionEnabled"] = boost::any(*securityProtectionEnabled);
    }
    if (snatTableIds) {
      res["SnatTableIds"] = snatTableIds ? boost::any(snatTableIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DeletionProtection") != m.end() && !m["DeletionProtection"].empty()) {
      deletionProtection = make_shared<bool>(boost::any_cast<bool>(m["DeletionProtection"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EcsMetricEnabled") != m.end() && !m["EcsMetricEnabled"].empty()) {
      ecsMetricEnabled = make_shared<bool>(boost::any_cast<bool>(m["EcsMetricEnabled"]));
    }
    if (m.find("EipBindMode") != m.end() && !m["EipBindMode"].empty()) {
      eipBindMode = make_shared<string>(boost::any_cast<string>(m["EipBindMode"]));
    }
    if (m.find("EnableSessionLog") != m.end() && !m["EnableSessionLog"].empty()) {
      enableSessionLog = make_shared<string>(boost::any_cast<string>(m["EnableSessionLog"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("ForwardTableIds") != m.end() && !m["ForwardTableIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ForwardTableIds"].type()) {
        DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ForwardTableIds"]));
        forwardTableIds = make_shared<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds>(model1);
      }
    }
    if (m.find("FullNatTableIds") != m.end() && !m["FullNatTableIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["FullNatTableIds"].type()) {
        DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayFullNatTableIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FullNatTableIds"]));
        fullNatTableIds = make_shared<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayFullNatTableIds>(model1);
      }
    }
    if (m.find("IcmpReplyEnabled") != m.end() && !m["IcmpReplyEnabled"].empty()) {
      icmpReplyEnabled = make_shared<bool>(boost::any_cast<bool>(m["IcmpReplyEnabled"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("IpLists") != m.end() && !m["IpLists"].empty()) {
      if (typeid(map<string, boost::any>) == m["IpLists"].type()) {
        DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpLists model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IpLists"]));
        ipLists = make_shared<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayIpLists>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("NatGatewayPrivateInfo") != m.end() && !m["NatGatewayPrivateInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["NatGatewayPrivateInfo"].type()) {
        DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NatGatewayPrivateInfo"]));
        natGatewayPrivateInfo = make_shared<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayNatGatewayPrivateInfo>(model1);
      }
    }
    if (m.find("NatType") != m.end() && !m["NatType"].empty()) {
      natType = make_shared<string>(boost::any_cast<string>(m["NatType"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("PrivateLinkEnabled") != m.end() && !m["PrivateLinkEnabled"].empty()) {
      privateLinkEnabled = make_shared<bool>(boost::any_cast<bool>(m["PrivateLinkEnabled"]));
    }
    if (m.find("PrivateLinkMode") != m.end() && !m["PrivateLinkMode"].empty()) {
      privateLinkMode = make_shared<string>(boost::any_cast<string>(m["PrivateLinkMode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityProtectionEnabled") != m.end() && !m["SecurityProtectionEnabled"].empty()) {
      securityProtectionEnabled = make_shared<bool>(boost::any_cast<bool>(m["SecurityProtectionEnabled"]));
    }
    if (m.find("SnatTableIds") != m.end() && !m["SnatTableIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnatTableIds"].type()) {
        DescribeNatGatewaysResponseBodyNatGatewaysNatGatewaySnatTableIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnatTableIds"]));
        snatTableIds = make_shared<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewaySnatTableIds>(model1);
      }
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayTags>(model1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeNatGatewaysResponseBodyNatGatewaysNatGateway() = default;
};
class DescribeNatGatewaysResponseBodyNatGateways : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNatGatewaysResponseBodyNatGatewaysNatGateway>> natGateway{};

  DescribeNatGatewaysResponseBodyNatGateways() {}

  explicit DescribeNatGatewaysResponseBodyNatGateways(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (natGateway) {
      vector<boost::any> temp1;
      for(auto item1:*natGateway){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NatGateway"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NatGateway") != m.end() && !m["NatGateway"].empty()) {
      if (typeid(vector<boost::any>) == m["NatGateway"].type()) {
        vector<DescribeNatGatewaysResponseBodyNatGatewaysNatGateway> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NatGateway"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNatGatewaysResponseBodyNatGatewaysNatGateway model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        natGateway = make_shared<vector<DescribeNatGatewaysResponseBodyNatGatewaysNatGateway>>(expect1);
      }
    }
  }


  virtual ~DescribeNatGatewaysResponseBodyNatGateways() = default;
};
class DescribeNatGatewaysResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeNatGatewaysResponseBodyNatGateways> natGateways{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeNatGatewaysResponseBody() {}

  explicit DescribeNatGatewaysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (natGateways) {
      res["NatGateways"] = natGateways ? boost::any(natGateways->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NatGateways") != m.end() && !m["NatGateways"].empty()) {
      if (typeid(map<string, boost::any>) == m["NatGateways"].type()) {
        DescribeNatGatewaysResponseBodyNatGateways model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NatGateways"]));
        natGateways = make_shared<DescribeNatGatewaysResponseBodyNatGateways>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeNatGatewaysResponseBody() = default;
};
class DescribeNatGatewaysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNatGatewaysResponseBody> body{};

  DescribeNatGatewaysResponse() {}

  explicit DescribeNatGatewaysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNatGatewaysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNatGatewaysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNatGatewaysResponse() = default;
};
class DescribeNetworkAclAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> networkAclId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeNetworkAclAttributesRequest() {}

  explicit DescribeNetworkAclAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeNetworkAclAttributesRequest() = default;
};
class DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> destinationCidrIp{};
  shared_ptr<string> entryType{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> networkAclEntryId{};
  shared_ptr<string> networkAclEntryName{};
  shared_ptr<string> policy{};
  shared_ptr<string> port{};
  shared_ptr<string> protocol{};

  DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry() {}

  explicit DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationCidrIp) {
      res["DestinationCidrIp"] = boost::any(*destinationCidrIp);
    }
    if (entryType) {
      res["EntryType"] = boost::any(*entryType);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (networkAclEntryId) {
      res["NetworkAclEntryId"] = boost::any(*networkAclEntryId);
    }
    if (networkAclEntryName) {
      res["NetworkAclEntryName"] = boost::any(*networkAclEntryName);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationCidrIp") != m.end() && !m["DestinationCidrIp"].empty()) {
      destinationCidrIp = make_shared<string>(boost::any_cast<string>(m["DestinationCidrIp"]));
    }
    if (m.find("EntryType") != m.end() && !m["EntryType"].empty()) {
      entryType = make_shared<string>(boost::any_cast<string>(m["EntryType"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("NetworkAclEntryId") != m.end() && !m["NetworkAclEntryId"].empty()) {
      networkAclEntryId = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryId"]));
    }
    if (m.find("NetworkAclEntryName") != m.end() && !m["NetworkAclEntryName"].empty()) {
      networkAclEntryName = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryName"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry() = default;
};
class DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry>> egressAclEntry{};

  DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntries() {}

  explicit DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (egressAclEntry) {
      vector<boost::any> temp1;
      for(auto item1:*egressAclEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EgressAclEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EgressAclEntry") != m.end() && !m["EgressAclEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["EgressAclEntry"].type()) {
        vector<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EgressAclEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        egressAclEntry = make_shared<vector<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntriesEgressAclEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntries() = default;
};
class DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> entryType{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> networkAclEntryId{};
  shared_ptr<string> networkAclEntryName{};
  shared_ptr<string> policy{};
  shared_ptr<string> port{};
  shared_ptr<string> protocol{};
  shared_ptr<string> sourceCidrIp{};

  DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry() {}

  explicit DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (entryType) {
      res["EntryType"] = boost::any(*entryType);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (networkAclEntryId) {
      res["NetworkAclEntryId"] = boost::any(*networkAclEntryId);
    }
    if (networkAclEntryName) {
      res["NetworkAclEntryName"] = boost::any(*networkAclEntryName);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EntryType") != m.end() && !m["EntryType"].empty()) {
      entryType = make_shared<string>(boost::any_cast<string>(m["EntryType"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("NetworkAclEntryId") != m.end() && !m["NetworkAclEntryId"].empty()) {
      networkAclEntryId = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryId"]));
    }
    if (m.find("NetworkAclEntryName") != m.end() && !m["NetworkAclEntryName"].empty()) {
      networkAclEntryName = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryName"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
  }


  virtual ~DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry() = default;
};
class DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry>> ingressAclEntry{};

  DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntries() {}

  explicit DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ingressAclEntry) {
      vector<boost::any> temp1;
      for(auto item1:*ingressAclEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IngressAclEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IngressAclEntry") != m.end() && !m["IngressAclEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["IngressAclEntry"].type()) {
        vector<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IngressAclEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ingressAclEntry = make_shared<vector<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntriesIngressAclEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntries() = default;
};
class DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResourcesResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> status{};

  DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResourcesResource() {}

  explicit DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResourcesResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResourcesResource() = default;
};
class DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResourcesResource>> resource{};

  DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResources() {}

  explicit DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResourcesResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResourcesResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResourcesResource>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResources() = default;
};
class DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTagsTag() {}

  explicit DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTagsTag() = default;
};
class DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTagsTag>> tag{};

  DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTags() {}

  explicit DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTags() = default;
};
class DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntries> egressAclEntries{};
  shared_ptr<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntries> ingressAclEntries{};
  shared_ptr<string> networkAclId{};
  shared_ptr<string> networkAclName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResources> resources{};
  shared_ptr<string> status{};
  shared_ptr<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTags> tags{};
  shared_ptr<string> vpcId{};

  DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute() {}

  explicit DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (egressAclEntries) {
      res["EgressAclEntries"] = egressAclEntries ? boost::any(egressAclEntries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ingressAclEntries) {
      res["IngressAclEntries"] = ingressAclEntries ? boost::any(ingressAclEntries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (networkAclName) {
      res["NetworkAclName"] = boost::any(*networkAclName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resources) {
      res["Resources"] = resources ? boost::any(resources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EgressAclEntries") != m.end() && !m["EgressAclEntries"].empty()) {
      if (typeid(map<string, boost::any>) == m["EgressAclEntries"].type()) {
        DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EgressAclEntries"]));
        egressAclEntries = make_shared<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeEgressAclEntries>(model1);
      }
    }
    if (m.find("IngressAclEntries") != m.end() && !m["IngressAclEntries"].empty()) {
      if (typeid(map<string, boost::any>) == m["IngressAclEntries"].type()) {
        DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IngressAclEntries"]));
        ingressAclEntries = make_shared<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeIngressAclEntries>(model1);
      }
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("NetworkAclName") != m.end() && !m["NetworkAclName"].empty()) {
      networkAclName = make_shared<string>(boost::any_cast<string>(m["NetworkAclName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resources"].type()) {
        DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resources"]));
        resources = make_shared<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeResources>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeNetworkAclAttributesResponseBodyNetworkAclAttributeTags>(model1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute() = default;
};
class DescribeNetworkAclAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute> networkAclAttribute{};
  shared_ptr<string> requestId{};

  DescribeNetworkAclAttributesResponseBody() {}

  explicit DescribeNetworkAclAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAclAttribute) {
      res["NetworkAclAttribute"] = networkAclAttribute ? boost::any(networkAclAttribute->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAclAttribute") != m.end() && !m["NetworkAclAttribute"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkAclAttribute"].type()) {
        DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkAclAttribute"]));
        networkAclAttribute = make_shared<DescribeNetworkAclAttributesResponseBodyNetworkAclAttribute>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeNetworkAclAttributesResponseBody() = default;
};
class DescribeNetworkAclAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNetworkAclAttributesResponseBody> body{};

  DescribeNetworkAclAttributesResponse() {}

  explicit DescribeNetworkAclAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworkAclAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworkAclAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworkAclAttributesResponse() = default;
};
class DescribeNetworkAclsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeNetworkAclsRequestTags() {}

  explicit DescribeNetworkAclsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeNetworkAclsRequestTags() = default;
};
class DescribeNetworkAclsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> networkAclId{};
  shared_ptr<string> networkAclName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<DescribeNetworkAclsRequestTags>> tags{};
  shared_ptr<string> vpcId{};

  DescribeNetworkAclsRequest() {}

  explicit DescribeNetworkAclsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (networkAclName) {
      res["NetworkAclName"] = boost::any(*networkAclName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("NetworkAclName") != m.end() && !m["NetworkAclName"].empty()) {
      networkAclName = make_shared<string>(boost::any_cast<string>(m["NetworkAclName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeNetworkAclsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkAclsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeNetworkAclsRequestTags>>(expect1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeNetworkAclsRequest() = default;
};
class DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> destinationCidrIp{};
  shared_ptr<string> entryType{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> networkAclEntryId{};
  shared_ptr<string> networkAclEntryName{};
  shared_ptr<string> policy{};
  shared_ptr<string> port{};
  shared_ptr<string> protocol{};

  DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry() {}

  explicit DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationCidrIp) {
      res["DestinationCidrIp"] = boost::any(*destinationCidrIp);
    }
    if (entryType) {
      res["EntryType"] = boost::any(*entryType);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (networkAclEntryId) {
      res["NetworkAclEntryId"] = boost::any(*networkAclEntryId);
    }
    if (networkAclEntryName) {
      res["NetworkAclEntryName"] = boost::any(*networkAclEntryName);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationCidrIp") != m.end() && !m["DestinationCidrIp"].empty()) {
      destinationCidrIp = make_shared<string>(boost::any_cast<string>(m["DestinationCidrIp"]));
    }
    if (m.find("EntryType") != m.end() && !m["EntryType"].empty()) {
      entryType = make_shared<string>(boost::any_cast<string>(m["EntryType"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("NetworkAclEntryId") != m.end() && !m["NetworkAclEntryId"].empty()) {
      networkAclEntryId = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryId"]));
    }
    if (m.find("NetworkAclEntryName") != m.end() && !m["NetworkAclEntryName"].empty()) {
      networkAclEntryName = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryName"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry() = default;
};
class DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry>> egressAclEntry{};

  DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntries() {}

  explicit DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (egressAclEntry) {
      vector<boost::any> temp1;
      for(auto item1:*egressAclEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EgressAclEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EgressAclEntry") != m.end() && !m["EgressAclEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["EgressAclEntry"].type()) {
        vector<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EgressAclEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        egressAclEntry = make_shared<vector<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntriesEgressAclEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntries() = default;
};
class DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> entryType{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> networkAclEntryId{};
  shared_ptr<string> networkAclEntryName{};
  shared_ptr<string> policy{};
  shared_ptr<string> port{};
  shared_ptr<string> protocol{};
  shared_ptr<string> sourceCidrIp{};

  DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry() {}

  explicit DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (entryType) {
      res["EntryType"] = boost::any(*entryType);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (networkAclEntryId) {
      res["NetworkAclEntryId"] = boost::any(*networkAclEntryId);
    }
    if (networkAclEntryName) {
      res["NetworkAclEntryName"] = boost::any(*networkAclEntryName);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EntryType") != m.end() && !m["EntryType"].empty()) {
      entryType = make_shared<string>(boost::any_cast<string>(m["EntryType"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("NetworkAclEntryId") != m.end() && !m["NetworkAclEntryId"].empty()) {
      networkAclEntryId = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryId"]));
    }
    if (m.find("NetworkAclEntryName") != m.end() && !m["NetworkAclEntryName"].empty()) {
      networkAclEntryName = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryName"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
  }


  virtual ~DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry() = default;
};
class DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry>> ingressAclEntry{};

  DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntries() {}

  explicit DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ingressAclEntry) {
      vector<boost::any> temp1;
      for(auto item1:*ingressAclEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IngressAclEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IngressAclEntry") != m.end() && !m["IngressAclEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["IngressAclEntry"].type()) {
        vector<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IngressAclEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ingressAclEntry = make_shared<vector<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntriesIngressAclEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntries() = default;
};
class DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResourcesResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> status{};

  DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResourcesResource() {}

  explicit DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResourcesResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResourcesResource() = default;
};
class DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResourcesResource>> resource{};

  DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResources() {}

  explicit DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResourcesResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResourcesResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResourcesResource>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResources() = default;
};
class DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTagsTag() {}

  explicit DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTagsTag() = default;
};
class DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTagsTag>> tag{};

  DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTags() {}

  explicit DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTags() = default;
};
class DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntries> egressAclEntries{};
  shared_ptr<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntries> ingressAclEntries{};
  shared_ptr<string> networkAclId{};
  shared_ptr<string> networkAclName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResources> resources{};
  shared_ptr<string> status{};
  shared_ptr<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTags> tags{};
  shared_ptr<string> vpcId{};

  DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl() {}

  explicit DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (egressAclEntries) {
      res["EgressAclEntries"] = egressAclEntries ? boost::any(egressAclEntries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ingressAclEntries) {
      res["IngressAclEntries"] = ingressAclEntries ? boost::any(ingressAclEntries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (networkAclName) {
      res["NetworkAclName"] = boost::any(*networkAclName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resources) {
      res["Resources"] = resources ? boost::any(resources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EgressAclEntries") != m.end() && !m["EgressAclEntries"].empty()) {
      if (typeid(map<string, boost::any>) == m["EgressAclEntries"].type()) {
        DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EgressAclEntries"]));
        egressAclEntries = make_shared<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclEgressAclEntries>(model1);
      }
    }
    if (m.find("IngressAclEntries") != m.end() && !m["IngressAclEntries"].empty()) {
      if (typeid(map<string, boost::any>) == m["IngressAclEntries"].type()) {
        DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IngressAclEntries"]));
        ingressAclEntries = make_shared<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclIngressAclEntries>(model1);
      }
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("NetworkAclName") != m.end() && !m["NetworkAclName"].empty()) {
      networkAclName = make_shared<string>(boost::any_cast<string>(m["NetworkAclName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resources"].type()) {
        DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resources"]));
        resources = make_shared<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclResources>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAclTags>(model1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl() = default;
};
class DescribeNetworkAclsResponseBodyNetworkAcls : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl>> networkAcl{};

  DescribeNetworkAclsResponseBodyNetworkAcls() {}

  explicit DescribeNetworkAclsResponseBodyNetworkAcls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAcl) {
      vector<boost::any> temp1;
      for(auto item1:*networkAcl){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkAcl"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAcl") != m.end() && !m["NetworkAcl"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkAcl"].type()) {
        vector<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkAcl"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkAcl = make_shared<vector<DescribeNetworkAclsResponseBodyNetworkAclsNetworkAcl>>(expect1);
      }
    }
  }


  virtual ~DescribeNetworkAclsResponseBodyNetworkAcls() = default;
};
class DescribeNetworkAclsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeNetworkAclsResponseBodyNetworkAcls> networkAcls{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};

  DescribeNetworkAclsResponseBody() {}

  explicit DescribeNetworkAclsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAcls) {
      res["NetworkAcls"] = networkAcls ? boost::any(networkAcls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAcls") != m.end() && !m["NetworkAcls"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkAcls"].type()) {
        DescribeNetworkAclsResponseBodyNetworkAcls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkAcls"]));
        networkAcls = make_shared<DescribeNetworkAclsResponseBodyNetworkAcls>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~DescribeNetworkAclsResponseBody() = default;
};
class DescribeNetworkAclsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNetworkAclsResponseBody> body{};

  DescribeNetworkAclsResponse() {}

  explicit DescribeNetworkAclsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworkAclsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworkAclsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworkAclsResponse() = default;
};
class DescribePhysicalConnectionLOARequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribePhysicalConnectionLOARequest() {}

  explicit DescribePhysicalConnectionLOARequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribePhysicalConnectionLOARequest() = default;
};
class DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo : public Darabonba::Model {
public:
  shared_ptr<string> PMCertificateNo{};
  shared_ptr<string> PMCertificateType{};
  shared_ptr<string> PMContactInfo{};
  shared_ptr<string> PMGender{};
  shared_ptr<string> PMName{};

  DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo() {}

  explicit DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (PMCertificateNo) {
      res["PMCertificateNo"] = boost::any(*PMCertificateNo);
    }
    if (PMCertificateType) {
      res["PMCertificateType"] = boost::any(*PMCertificateType);
    }
    if (PMContactInfo) {
      res["PMContactInfo"] = boost::any(*PMContactInfo);
    }
    if (PMGender) {
      res["PMGender"] = boost::any(*PMGender);
    }
    if (PMName) {
      res["PMName"] = boost::any(*PMName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PMCertificateNo") != m.end() && !m["PMCertificateNo"].empty()) {
      PMCertificateNo = make_shared<string>(boost::any_cast<string>(m["PMCertificateNo"]));
    }
    if (m.find("PMCertificateType") != m.end() && !m["PMCertificateType"].empty()) {
      PMCertificateType = make_shared<string>(boost::any_cast<string>(m["PMCertificateType"]));
    }
    if (m.find("PMContactInfo") != m.end() && !m["PMContactInfo"].empty()) {
      PMContactInfo = make_shared<string>(boost::any_cast<string>(m["PMContactInfo"]));
    }
    if (m.find("PMGender") != m.end() && !m["PMGender"].empty()) {
      PMGender = make_shared<string>(boost::any_cast<string>(m["PMGender"]));
    }
    if (m.find("PMName") != m.end() && !m["PMName"].empty()) {
      PMName = make_shared<string>(boost::any_cast<string>(m["PMName"]));
    }
  }


  virtual ~DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo() = default;
};
class DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfo : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo>> PMInfo{};

  DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfo() {}

  explicit DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (PMInfo) {
      vector<boost::any> temp1;
      for(auto item1:*PMInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PMInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PMInfo") != m.end() && !m["PMInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PMInfo"].type()) {
        vector<DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PMInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        PMInfo = make_shared<vector<DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfoPMInfo>>(expect1);
      }
    }
  }


  virtual ~DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfo() = default;
};
class DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType : public Darabonba::Model {
public:
  shared_ptr<string> companyLocalizedName{};
  shared_ptr<string> companyName{};
  shared_ptr<string> constructionTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lineCode{};
  shared_ptr<string> lineLabel{};
  shared_ptr<string> lineSPContactInfo{};
  shared_ptr<string> lineServiceProvider{};
  shared_ptr<string> lineType{};
  shared_ptr<string> loaUrl{};
  shared_ptr<DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfo> PMInfo{};
  shared_ptr<string> SI{};
  shared_ptr<string> status{};

  DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType() {}

  explicit DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (companyLocalizedName) {
      res["CompanyLocalizedName"] = boost::any(*companyLocalizedName);
    }
    if (companyName) {
      res["CompanyName"] = boost::any(*companyName);
    }
    if (constructionTime) {
      res["ConstructionTime"] = boost::any(*constructionTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lineCode) {
      res["LineCode"] = boost::any(*lineCode);
    }
    if (lineLabel) {
      res["LineLabel"] = boost::any(*lineLabel);
    }
    if (lineSPContactInfo) {
      res["LineSPContactInfo"] = boost::any(*lineSPContactInfo);
    }
    if (lineServiceProvider) {
      res["LineServiceProvider"] = boost::any(*lineServiceProvider);
    }
    if (lineType) {
      res["LineType"] = boost::any(*lineType);
    }
    if (loaUrl) {
      res["LoaUrl"] = boost::any(*loaUrl);
    }
    if (PMInfo) {
      res["PMInfo"] = PMInfo ? boost::any(PMInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (SI) {
      res["SI"] = boost::any(*SI);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompanyLocalizedName") != m.end() && !m["CompanyLocalizedName"].empty()) {
      companyLocalizedName = make_shared<string>(boost::any_cast<string>(m["CompanyLocalizedName"]));
    }
    if (m.find("CompanyName") != m.end() && !m["CompanyName"].empty()) {
      companyName = make_shared<string>(boost::any_cast<string>(m["CompanyName"]));
    }
    if (m.find("ConstructionTime") != m.end() && !m["ConstructionTime"].empty()) {
      constructionTime = make_shared<string>(boost::any_cast<string>(m["ConstructionTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LineCode") != m.end() && !m["LineCode"].empty()) {
      lineCode = make_shared<string>(boost::any_cast<string>(m["LineCode"]));
    }
    if (m.find("LineLabel") != m.end() && !m["LineLabel"].empty()) {
      lineLabel = make_shared<string>(boost::any_cast<string>(m["LineLabel"]));
    }
    if (m.find("LineSPContactInfo") != m.end() && !m["LineSPContactInfo"].empty()) {
      lineSPContactInfo = make_shared<string>(boost::any_cast<string>(m["LineSPContactInfo"]));
    }
    if (m.find("LineServiceProvider") != m.end() && !m["LineServiceProvider"].empty()) {
      lineServiceProvider = make_shared<string>(boost::any_cast<string>(m["LineServiceProvider"]));
    }
    if (m.find("LineType") != m.end() && !m["LineType"].empty()) {
      lineType = make_shared<string>(boost::any_cast<string>(m["LineType"]));
    }
    if (m.find("LoaUrl") != m.end() && !m["LoaUrl"].empty()) {
      loaUrl = make_shared<string>(boost::any_cast<string>(m["LoaUrl"]));
    }
    if (m.find("PMInfo") != m.end() && !m["PMInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PMInfo"].type()) {
        DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PMInfo"]));
        PMInfo = make_shared<DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOATypePMInfo>(model1);
      }
    }
    if (m.find("SI") != m.end() && !m["SI"].empty()) {
      SI = make_shared<string>(boost::any_cast<string>(m["SI"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType() = default;
};
class DescribePhysicalConnectionLOAResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType> physicalConnectionLOAType{};
  shared_ptr<string> requestId{};

  DescribePhysicalConnectionLOAResponseBody() {}

  explicit DescribePhysicalConnectionLOAResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (physicalConnectionLOAType) {
      res["PhysicalConnectionLOAType"] = physicalConnectionLOAType ? boost::any(physicalConnectionLOAType->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhysicalConnectionLOAType") != m.end() && !m["PhysicalConnectionLOAType"].empty()) {
      if (typeid(map<string, boost::any>) == m["PhysicalConnectionLOAType"].type()) {
        DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PhysicalConnectionLOAType"]));
        physicalConnectionLOAType = make_shared<DescribePhysicalConnectionLOAResponseBodyPhysicalConnectionLOAType>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePhysicalConnectionLOAResponseBody() = default;
};
class DescribePhysicalConnectionLOAResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePhysicalConnectionLOAResponseBody> body{};

  DescribePhysicalConnectionLOAResponse() {}

  explicit DescribePhysicalConnectionLOAResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePhysicalConnectionLOAResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePhysicalConnectionLOAResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePhysicalConnectionLOAResponse() = default;
};
class DescribePhysicalConnectionsRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> value{};

  DescribePhysicalConnectionsRequestFilter() {}

  explicit DescribePhysicalConnectionsRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribePhysicalConnectionsRequestFilter() = default;
};
class DescribePhysicalConnectionsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribePhysicalConnectionsRequestTags() {}

  explicit DescribePhysicalConnectionsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribePhysicalConnectionsRequestTags() = default;
};
class DescribePhysicalConnectionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<vector<DescribePhysicalConnectionsRequestFilter>> filter{};
  shared_ptr<bool> includeReservationData{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<DescribePhysicalConnectionsRequestTags>> tags{};

  DescribePhysicalConnectionsRequest() {}

  explicit DescribePhysicalConnectionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    if (includeReservationData) {
      res["IncludeReservationData"] = boost::any(*includeReservationData);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribePhysicalConnectionsRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePhysicalConnectionsRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribePhysicalConnectionsRequestFilter>>(expect1);
      }
    }
    if (m.find("IncludeReservationData") != m.end() && !m["IncludeReservationData"].empty()) {
      includeReservationData = make_shared<bool>(boost::any_cast<bool>(m["IncludeReservationData"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribePhysicalConnectionsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePhysicalConnectionsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribePhysicalConnectionsRequestTags>>(expect1);
      }
    }
  }


  virtual ~DescribePhysicalConnectionsRequest() = default;
};
class DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionTypeTagsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionTypeTagsTags() {}

  explicit DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionTypeTagsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionTypeTagsTags() = default;
};
class DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionTypeTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionTypeTagsTags>> tags{};

  DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionTypeTags() {}

  explicit DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionTypeTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionTypeTagsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionTypeTagsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionTypeTagsTags>>(expect1);
      }
    }
  }


  virtual ~DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionTypeTags() = default;
};
class DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType : public Darabonba::Model {
public:
  shared_ptr<string> accessPointId{};
  shared_ptr<string> accessPointType{};
  shared_ptr<string> adDetailLocation{};
  shared_ptr<string> adLocation{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> circuitCode{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> enabledTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> expectSpec{};
  shared_ptr<string> hasReservationData{};
  shared_ptr<string> lineOperator{};
  shared_ptr<string> loaStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> orderMode{};
  shared_ptr<long> parentPhysicalConnectionAliUid{};
  shared_ptr<string> parentPhysicalConnectionId{};
  shared_ptr<string> peerLocation{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> portNumber{};
  shared_ptr<string> portType{};
  shared_ptr<string> productType{};
  shared_ptr<string> qosId{};
  shared_ptr<string> redundantPhysicalConnectionId{};
  shared_ptr<string> reservationActiveTime{};
  shared_ptr<string> reservationInternetChargeType{};
  shared_ptr<string> reservationOrderType{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> spec{};
  shared_ptr<string> status{};
  shared_ptr<DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionTypeTags> tags{};
  shared_ptr<string> type{};
  shared_ptr<long> virtualPhysicalConnectionCount{};
  shared_ptr<string> vlanId{};
  shared_ptr<string> vpconnStatus{};

  DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType() {}

  explicit DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (accessPointType) {
      res["AccessPointType"] = boost::any(*accessPointType);
    }
    if (adDetailLocation) {
      res["AdDetailLocation"] = boost::any(*adDetailLocation);
    }
    if (adLocation) {
      res["AdLocation"] = boost::any(*adLocation);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (circuitCode) {
      res["CircuitCode"] = boost::any(*circuitCode);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabledTime) {
      res["EnabledTime"] = boost::any(*enabledTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (expectSpec) {
      res["ExpectSpec"] = boost::any(*expectSpec);
    }
    if (hasReservationData) {
      res["HasReservationData"] = boost::any(*hasReservationData);
    }
    if (lineOperator) {
      res["LineOperator"] = boost::any(*lineOperator);
    }
    if (loaStatus) {
      res["LoaStatus"] = boost::any(*loaStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (orderMode) {
      res["OrderMode"] = boost::any(*orderMode);
    }
    if (parentPhysicalConnectionAliUid) {
      res["ParentPhysicalConnectionAliUid"] = boost::any(*parentPhysicalConnectionAliUid);
    }
    if (parentPhysicalConnectionId) {
      res["ParentPhysicalConnectionId"] = boost::any(*parentPhysicalConnectionId);
    }
    if (peerLocation) {
      res["PeerLocation"] = boost::any(*peerLocation);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (portNumber) {
      res["PortNumber"] = boost::any(*portNumber);
    }
    if (portType) {
      res["PortType"] = boost::any(*portType);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (redundantPhysicalConnectionId) {
      res["RedundantPhysicalConnectionId"] = boost::any(*redundantPhysicalConnectionId);
    }
    if (reservationActiveTime) {
      res["ReservationActiveTime"] = boost::any(*reservationActiveTime);
    }
    if (reservationInternetChargeType) {
      res["ReservationInternetChargeType"] = boost::any(*reservationInternetChargeType);
    }
    if (reservationOrderType) {
      res["ReservationOrderType"] = boost::any(*reservationOrderType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (virtualPhysicalConnectionCount) {
      res["VirtualPhysicalConnectionCount"] = boost::any(*virtualPhysicalConnectionCount);
    }
    if (vlanId) {
      res["VlanId"] = boost::any(*vlanId);
    }
    if (vpconnStatus) {
      res["VpconnStatus"] = boost::any(*vpconnStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<string>(boost::any_cast<string>(m["AccessPointId"]));
    }
    if (m.find("AccessPointType") != m.end() && !m["AccessPointType"].empty()) {
      accessPointType = make_shared<string>(boost::any_cast<string>(m["AccessPointType"]));
    }
    if (m.find("AdDetailLocation") != m.end() && !m["AdDetailLocation"].empty()) {
      adDetailLocation = make_shared<string>(boost::any_cast<string>(m["AdDetailLocation"]));
    }
    if (m.find("AdLocation") != m.end() && !m["AdLocation"].empty()) {
      adLocation = make_shared<string>(boost::any_cast<string>(m["AdLocation"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CircuitCode") != m.end() && !m["CircuitCode"].empty()) {
      circuitCode = make_shared<string>(boost::any_cast<string>(m["CircuitCode"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnabledTime") != m.end() && !m["EnabledTime"].empty()) {
      enabledTime = make_shared<string>(boost::any_cast<string>(m["EnabledTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ExpectSpec") != m.end() && !m["ExpectSpec"].empty()) {
      expectSpec = make_shared<string>(boost::any_cast<string>(m["ExpectSpec"]));
    }
    if (m.find("HasReservationData") != m.end() && !m["HasReservationData"].empty()) {
      hasReservationData = make_shared<string>(boost::any_cast<string>(m["HasReservationData"]));
    }
    if (m.find("LineOperator") != m.end() && !m["LineOperator"].empty()) {
      lineOperator = make_shared<string>(boost::any_cast<string>(m["LineOperator"]));
    }
    if (m.find("LoaStatus") != m.end() && !m["LoaStatus"].empty()) {
      loaStatus = make_shared<string>(boost::any_cast<string>(m["LoaStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrderMode") != m.end() && !m["OrderMode"].empty()) {
      orderMode = make_shared<string>(boost::any_cast<string>(m["OrderMode"]));
    }
    if (m.find("ParentPhysicalConnectionAliUid") != m.end() && !m["ParentPhysicalConnectionAliUid"].empty()) {
      parentPhysicalConnectionAliUid = make_shared<long>(boost::any_cast<long>(m["ParentPhysicalConnectionAliUid"]));
    }
    if (m.find("ParentPhysicalConnectionId") != m.end() && !m["ParentPhysicalConnectionId"].empty()) {
      parentPhysicalConnectionId = make_shared<string>(boost::any_cast<string>(m["ParentPhysicalConnectionId"]));
    }
    if (m.find("PeerLocation") != m.end() && !m["PeerLocation"].empty()) {
      peerLocation = make_shared<string>(boost::any_cast<string>(m["PeerLocation"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("PortNumber") != m.end() && !m["PortNumber"].empty()) {
      portNumber = make_shared<string>(boost::any_cast<string>(m["PortNumber"]));
    }
    if (m.find("PortType") != m.end() && !m["PortType"].empty()) {
      portType = make_shared<string>(boost::any_cast<string>(m["PortType"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("RedundantPhysicalConnectionId") != m.end() && !m["RedundantPhysicalConnectionId"].empty()) {
      redundantPhysicalConnectionId = make_shared<string>(boost::any_cast<string>(m["RedundantPhysicalConnectionId"]));
    }
    if (m.find("ReservationActiveTime") != m.end() && !m["ReservationActiveTime"].empty()) {
      reservationActiveTime = make_shared<string>(boost::any_cast<string>(m["ReservationActiveTime"]));
    }
    if (m.find("ReservationInternetChargeType") != m.end() && !m["ReservationInternetChargeType"].empty()) {
      reservationInternetChargeType = make_shared<string>(boost::any_cast<string>(m["ReservationInternetChargeType"]));
    }
    if (m.find("ReservationOrderType") != m.end() && !m["ReservationOrderType"].empty()) {
      reservationOrderType = make_shared<string>(boost::any_cast<string>(m["ReservationOrderType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionTypeTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionTypeTags>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VirtualPhysicalConnectionCount") != m.end() && !m["VirtualPhysicalConnectionCount"].empty()) {
      virtualPhysicalConnectionCount = make_shared<long>(boost::any_cast<long>(m["VirtualPhysicalConnectionCount"]));
    }
    if (m.find("VlanId") != m.end() && !m["VlanId"].empty()) {
      vlanId = make_shared<string>(boost::any_cast<string>(m["VlanId"]));
    }
    if (m.find("VpconnStatus") != m.end() && !m["VpconnStatus"].empty()) {
      vpconnStatus = make_shared<string>(boost::any_cast<string>(m["VpconnStatus"]));
    }
  }


  virtual ~DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType() = default;
};
class DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType>> physicalConnectionType{};

  DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet() {}

  explicit DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (physicalConnectionType) {
      vector<boost::any> temp1;
      for(auto item1:*physicalConnectionType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PhysicalConnectionType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhysicalConnectionType") != m.end() && !m["PhysicalConnectionType"].empty()) {
      if (typeid(vector<boost::any>) == m["PhysicalConnectionType"].type()) {
        vector<DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PhysicalConnectionType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        physicalConnectionType = make_shared<vector<DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType>>(expect1);
      }
    }
  }


  virtual ~DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet() = default;
};
class DescribePhysicalConnectionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet> physicalConnectionSet{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePhysicalConnectionsResponseBody() {}

  explicit DescribePhysicalConnectionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (physicalConnectionSet) {
      res["PhysicalConnectionSet"] = physicalConnectionSet ? boost::any(physicalConnectionSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PhysicalConnectionSet") != m.end() && !m["PhysicalConnectionSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["PhysicalConnectionSet"].type()) {
        DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PhysicalConnectionSet"]));
        physicalConnectionSet = make_shared<DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePhysicalConnectionsResponseBody() = default;
};
class DescribePhysicalConnectionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePhysicalConnectionsResponseBody> body{};

  DescribePhysicalConnectionsResponse() {}

  explicit DescribePhysicalConnectionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePhysicalConnectionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePhysicalConnectionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePhysicalConnectionsResponse() = default;
};
class DescribePublicIpAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribePublicIpAddressRequest() {}

  explicit DescribePublicIpAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribePublicIpAddressRequest() = default;
};
class DescribePublicIpAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> publicIpAddress{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  DescribePublicIpAddressResponseBody() {}

  explicit DescribePublicIpAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (publicIpAddress) {
      res["PublicIpAddress"] = boost::any(*publicIpAddress);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PublicIpAddress") != m.end() && !m["PublicIpAddress"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PublicIpAddress"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PublicIpAddress"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      publicIpAddress = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePublicIpAddressResponseBody() = default;
};
class DescribePublicIpAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePublicIpAddressResponseBody> body{};

  DescribePublicIpAddressResponse() {}

  explicit DescribePublicIpAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePublicIpAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePublicIpAddressResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePublicIpAddressResponse() = default;
};
class DescribeRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> productType{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeRegionsRequest() {}

  explicit DescribeRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeRegionsRequest() = default;
};
class DescribeRegionsResponseBodyRegionsRegion : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> regionEndpoint{};
  shared_ptr<string> regionId{};

  DescribeRegionsResponseBodyRegionsRegion() {}

  explicit DescribeRegionsResponseBodyRegionsRegion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionEndpoint) {
      res["RegionEndpoint"] = boost::any(*regionEndpoint);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionEndpoint") != m.end() && !m["RegionEndpoint"].empty()) {
      regionEndpoint = make_shared<string>(boost::any_cast<string>(m["RegionEndpoint"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRegionsResponseBodyRegionsRegion() = default;
};
class DescribeRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRegionsResponseBodyRegionsRegion>> region{};

  DescribeRegionsResponseBodyRegions() {}

  explicit DescribeRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      vector<boost::any> temp1;
      for(auto item1:*region){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Region"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      if (typeid(vector<boost::any>) == m["Region"].type()) {
        vector<DescribeRegionsResponseBodyRegionsRegion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Region"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionsResponseBodyRegionsRegion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        region = make_shared<vector<DescribeRegionsResponseBodyRegionsRegion>>(expect1);
      }
    }
  }


  virtual ~DescribeRegionsResponseBodyRegions() = default;
};
class DescribeRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeRegionsResponseBodyRegions> regions{};
  shared_ptr<string> requestId{};

  DescribeRegionsResponseBody() {}

  explicit DescribeRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regions) {
      res["Regions"] = regions ? boost::any(regions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Regions"].type()) {
        DescribeRegionsResponseBodyRegions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Regions"]));
        regions = make_shared<DescribeRegionsResponseBodyRegions>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRegionsResponseBody() = default;
};
class DescribeRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRegionsResponseBody> body{};

  DescribeRegionsResponse() {}

  explicit DescribeRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponse() = default;
};
class DescribeRouteEntryListRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> destCidrBlockList{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> ipVersion{};
  shared_ptr<long> maxResult{};
  shared_ptr<string> nextHopId{};
  shared_ptr<string> nextHopType{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeEntryId{};
  shared_ptr<string> routeEntryName{};
  shared_ptr<string> routeEntryType{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> serviceType{};

  DescribeRouteEntryListRequest() {}

  explicit DescribeRouteEntryListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destCidrBlockList) {
      res["DestCidrBlockList"] = boost::any(*destCidrBlockList);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (maxResult) {
      res["MaxResult"] = boost::any(*maxResult);
    }
    if (nextHopId) {
      res["NextHopId"] = boost::any(*nextHopId);
    }
    if (nextHopType) {
      res["NextHopType"] = boost::any(*nextHopType);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeEntryId) {
      res["RouteEntryId"] = boost::any(*routeEntryId);
    }
    if (routeEntryName) {
      res["RouteEntryName"] = boost::any(*routeEntryName);
    }
    if (routeEntryType) {
      res["RouteEntryType"] = boost::any(*routeEntryType);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestCidrBlockList") != m.end() && !m["DestCidrBlockList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DestCidrBlockList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DestCidrBlockList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      destCidrBlockList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("MaxResult") != m.end() && !m["MaxResult"].empty()) {
      maxResult = make_shared<long>(boost::any_cast<long>(m["MaxResult"]));
    }
    if (m.find("NextHopId") != m.end() && !m["NextHopId"].empty()) {
      nextHopId = make_shared<string>(boost::any_cast<string>(m["NextHopId"]));
    }
    if (m.find("NextHopType") != m.end() && !m["NextHopType"].empty()) {
      nextHopType = make_shared<string>(boost::any_cast<string>(m["NextHopType"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteEntryId") != m.end() && !m["RouteEntryId"].empty()) {
      routeEntryId = make_shared<string>(boost::any_cast<string>(m["RouteEntryId"]));
    }
    if (m.find("RouteEntryName") != m.end() && !m["RouteEntryName"].empty()) {
      routeEntryName = make_shared<string>(boost::any_cast<string>(m["RouteEntryName"]));
    }
    if (m.find("RouteEntryType") != m.end() && !m["RouteEntryType"].empty()) {
      routeEntryType = make_shared<string>(boost::any_cast<string>(m["RouteEntryType"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
  }


  virtual ~DescribeRouteEntryListRequest() = default;
};
class DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHopNextHopRelatedInfo : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> regionId{};

  DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHopNextHopRelatedInfo() {}

  explicit DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHopNextHopRelatedInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHopNextHopRelatedInfo() = default;
};
class DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop : public Darabonba::Model {
public:
  shared_ptr<long> enabled{};
  shared_ptr<string> nextHopId{};
  shared_ptr<string> nextHopRegionId{};
  shared_ptr<DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHopNextHopRelatedInfo> nextHopRelatedInfo{};
  shared_ptr<string> nextHopType{};
  shared_ptr<long> weight{};

  DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop() {}

  explicit DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (nextHopId) {
      res["NextHopId"] = boost::any(*nextHopId);
    }
    if (nextHopRegionId) {
      res["NextHopRegionId"] = boost::any(*nextHopRegionId);
    }
    if (nextHopRelatedInfo) {
      res["NextHopRelatedInfo"] = nextHopRelatedInfo ? boost::any(nextHopRelatedInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextHopType) {
      res["NextHopType"] = boost::any(*nextHopType);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<long>(boost::any_cast<long>(m["Enabled"]));
    }
    if (m.find("NextHopId") != m.end() && !m["NextHopId"].empty()) {
      nextHopId = make_shared<string>(boost::any_cast<string>(m["NextHopId"]));
    }
    if (m.find("NextHopRegionId") != m.end() && !m["NextHopRegionId"].empty()) {
      nextHopRegionId = make_shared<string>(boost::any_cast<string>(m["NextHopRegionId"]));
    }
    if (m.find("NextHopRelatedInfo") != m.end() && !m["NextHopRelatedInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["NextHopRelatedInfo"].type()) {
        DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHopNextHopRelatedInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NextHopRelatedInfo"]));
        nextHopRelatedInfo = make_shared<DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHopNextHopRelatedInfo>(model1);
      }
    }
    if (m.find("NextHopType") != m.end() && !m["NextHopType"].empty()) {
      nextHopType = make_shared<string>(boost::any_cast<string>(m["NextHopType"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop() = default;
};
class DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHops : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop>> nextHop{};

  DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHops() {}

  explicit DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHops(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextHop) {
      vector<boost::any> temp1;
      for(auto item1:*nextHop){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NextHop"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      if (typeid(vector<boost::any>) == m["NextHop"].type()) {
        vector<DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NextHop"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nextHop = make_shared<vector<DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHopsNextHop>>(expect1);
      }
    }
  }


  virtual ~DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHops() = default;
};
class DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> ipVersion{};
  shared_ptr<DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHops> nextHops{};
  shared_ptr<string> origin{};
  shared_ptr<string> routeEntryId{};
  shared_ptr<string> routeEntryName{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry() {}

  explicit DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (nextHops) {
      res["NextHops"] = nextHops ? boost::any(nextHops->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (origin) {
      res["Origin"] = boost::any(*origin);
    }
    if (routeEntryId) {
      res["RouteEntryId"] = boost::any(*routeEntryId);
    }
    if (routeEntryName) {
      res["RouteEntryName"] = boost::any(*routeEntryName);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("NextHops") != m.end() && !m["NextHops"].empty()) {
      if (typeid(map<string, boost::any>) == m["NextHops"].type()) {
        DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHops model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NextHops"]));
        nextHops = make_shared<DescribeRouteEntryListResponseBodyRouteEntrysRouteEntryNextHops>(model1);
      }
    }
    if (m.find("Origin") != m.end() && !m["Origin"].empty()) {
      origin = make_shared<string>(boost::any_cast<string>(m["Origin"]));
    }
    if (m.find("RouteEntryId") != m.end() && !m["RouteEntryId"].empty()) {
      routeEntryId = make_shared<string>(boost::any_cast<string>(m["RouteEntryId"]));
    }
    if (m.find("RouteEntryName") != m.end() && !m["RouteEntryName"].empty()) {
      routeEntryName = make_shared<string>(boost::any_cast<string>(m["RouteEntryName"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry() = default;
};
class DescribeRouteEntryListResponseBodyRouteEntrys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry>> routeEntry{};

  DescribeRouteEntryListResponseBodyRouteEntrys() {}

  explicit DescribeRouteEntryListResponseBodyRouteEntrys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeEntry) {
      vector<boost::any> temp1;
      for(auto item1:*routeEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouteEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteEntry") != m.end() && !m["RouteEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["RouteEntry"].type()) {
        vector<DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouteEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeEntry = make_shared<vector<DescribeRouteEntryListResponseBodyRouteEntrysRouteEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeRouteEntryListResponseBodyRouteEntrys() = default;
};
class DescribeRouteEntryListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRouteEntryListResponseBodyRouteEntrys> routeEntrys{};

  DescribeRouteEntryListResponseBody() {}

  explicit DescribeRouteEntryListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routeEntrys) {
      res["RouteEntrys"] = routeEntrys ? boost::any(routeEntrys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouteEntrys") != m.end() && !m["RouteEntrys"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteEntrys"].type()) {
        DescribeRouteEntryListResponseBodyRouteEntrys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteEntrys"]));
        routeEntrys = make_shared<DescribeRouteEntryListResponseBodyRouteEntrys>(model1);
      }
    }
  }


  virtual ~DescribeRouteEntryListResponseBody() = default;
};
class DescribeRouteEntryListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRouteEntryListResponseBody> body{};

  DescribeRouteEntryListResponse() {}

  explicit DescribeRouteEntryListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRouteEntryListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRouteEntryListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRouteEntryListResponse() = default;
};
class DescribeRouteTableListRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeRouteTableListRequestTag() {}

  explicit DescribeRouteTableListRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeRouteTableListRequestTag() = default;
};
class DescribeRouteTableListRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> routeTableName{};
  shared_ptr<string> routeTableType{};
  shared_ptr<string> routerId{};
  shared_ptr<string> routerType{};
  shared_ptr<vector<DescribeRouteTableListRequestTag>> tag{};
  shared_ptr<string> vpcId{};

  DescribeRouteTableListRequest() {}

  explicit DescribeRouteTableListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (routeTableName) {
      res["RouteTableName"] = boost::any(*routeTableName);
    }
    if (routeTableType) {
      res["RouteTableType"] = boost::any(*routeTableType);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    if (routerType) {
      res["RouterType"] = boost::any(*routerType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("RouteTableName") != m.end() && !m["RouteTableName"].empty()) {
      routeTableName = make_shared<string>(boost::any_cast<string>(m["RouteTableName"]));
    }
    if (m.find("RouteTableType") != m.end() && !m["RouteTableType"].empty()) {
      routeTableType = make_shared<string>(boost::any_cast<string>(m["RouteTableType"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
    if (m.find("RouterType") != m.end() && !m["RouterType"].empty()) {
      routerType = make_shared<string>(boost::any_cast<string>(m["RouterType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeRouteTableListRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRouteTableListRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeRouteTableListRequestTag>>(expect1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeRouteTableListRequest() = default;
};
class DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeGatewayIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> gatewayIds{};

  DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeGatewayIds() {}

  explicit DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeGatewayIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayIds) {
      res["GatewayIds"] = boost::any(*gatewayIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayIds") != m.end() && !m["GatewayIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GatewayIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GatewayIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      gatewayIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeGatewayIds() = default;
};
class DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTagsTag() {}

  explicit DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTagsTag() = default;
};
class DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTagsTag>> tag{};

  DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTags() {}

  explicit DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTags() = default;
};
class DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeVSwitchIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> vSwitchId{};

  DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeVSwitchIds() {}

  explicit DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeVSwitchIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeVSwitchIds() = default;
};
class DescribeRouteTableListResponseBodyRouterTableListRouterTableListType : public Darabonba::Model {
public:
  shared_ptr<string> associateType{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeGatewayIds> gatewayIds{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> routePropagationEnable{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> routeTableName{};
  shared_ptr<string> routeTableType{};
  shared_ptr<string> routerId{};
  shared_ptr<string> routerType{};
  shared_ptr<string> status{};
  shared_ptr<DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTags> tags{};
  shared_ptr<DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeVSwitchIds> vSwitchIds{};
  shared_ptr<string> vpcId{};

  DescribeRouteTableListResponseBodyRouterTableListRouterTableListType() {}

  explicit DescribeRouteTableListResponseBodyRouterTableListRouterTableListType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associateType) {
      res["AssociateType"] = boost::any(*associateType);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gatewayIds) {
      res["GatewayIds"] = gatewayIds ? boost::any(gatewayIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (routePropagationEnable) {
      res["RoutePropagationEnable"] = boost::any(*routePropagationEnable);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (routeTableName) {
      res["RouteTableName"] = boost::any(*routeTableName);
    }
    if (routeTableType) {
      res["RouteTableType"] = boost::any(*routeTableType);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    if (routerType) {
      res["RouterType"] = boost::any(*routerType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = vSwitchIds ? boost::any(vSwitchIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociateType") != m.end() && !m["AssociateType"].empty()) {
      associateType = make_shared<string>(boost::any_cast<string>(m["AssociateType"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GatewayIds") != m.end() && !m["GatewayIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["GatewayIds"].type()) {
        DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeGatewayIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GatewayIds"]));
        gatewayIds = make_shared<DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeGatewayIds>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RoutePropagationEnable") != m.end() && !m["RoutePropagationEnable"].empty()) {
      routePropagationEnable = make_shared<bool>(boost::any_cast<bool>(m["RoutePropagationEnable"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("RouteTableName") != m.end() && !m["RouteTableName"].empty()) {
      routeTableName = make_shared<string>(boost::any_cast<string>(m["RouteTableName"]));
    }
    if (m.find("RouteTableType") != m.end() && !m["RouteTableType"].empty()) {
      routeTableType = make_shared<string>(boost::any_cast<string>(m["RouteTableType"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
    if (m.find("RouterType") != m.end() && !m["RouterType"].empty()) {
      routerType = make_shared<string>(boost::any_cast<string>(m["RouterType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeTags>(model1);
      }
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["VSwitchIds"].type()) {
        DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeVSwitchIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VSwitchIds"]));
        vSwitchIds = make_shared<DescribeRouteTableListResponseBodyRouterTableListRouterTableListTypeVSwitchIds>(model1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeRouteTableListResponseBodyRouterTableListRouterTableListType() = default;
};
class DescribeRouteTableListResponseBodyRouterTableList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRouteTableListResponseBodyRouterTableListRouterTableListType>> routerTableListType{};

  DescribeRouteTableListResponseBodyRouterTableList() {}

  explicit DescribeRouteTableListResponseBodyRouterTableList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routerTableListType) {
      vector<boost::any> temp1;
      for(auto item1:*routerTableListType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouterTableListType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouterTableListType") != m.end() && !m["RouterTableListType"].empty()) {
      if (typeid(vector<boost::any>) == m["RouterTableListType"].type()) {
        vector<DescribeRouteTableListResponseBodyRouterTableListRouterTableListType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouterTableListType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRouteTableListResponseBodyRouterTableListRouterTableListType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routerTableListType = make_shared<vector<DescribeRouteTableListResponseBodyRouterTableListRouterTableListType>>(expect1);
      }
    }
  }


  virtual ~DescribeRouteTableListResponseBodyRouterTableList() = default;
};
class DescribeRouteTableListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRouteTableListResponseBodyRouterTableList> routerTableList{};
  shared_ptr<long> totalCount{};

  DescribeRouteTableListResponseBody() {}

  explicit DescribeRouteTableListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routerTableList) {
      res["RouterTableList"] = routerTableList ? boost::any(routerTableList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouterTableList") != m.end() && !m["RouterTableList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouterTableList"].type()) {
        DescribeRouteTableListResponseBodyRouterTableList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouterTableList"]));
        routerTableList = make_shared<DescribeRouteTableListResponseBodyRouterTableList>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeRouteTableListResponseBody() = default;
};
class DescribeRouteTableListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRouteTableListResponseBody> body{};

  DescribeRouteTableListResponse() {}

  explicit DescribeRouteTableListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRouteTableListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRouteTableListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRouteTableListResponse() = default;
};
class DescribeRouteTablesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> routeTableName{};
  shared_ptr<string> routerId{};
  shared_ptr<string> routerType{};
  shared_ptr<string> type{};
  shared_ptr<string> VRouterId{};

  DescribeRouteTablesRequest() {}

  explicit DescribeRouteTablesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (routeTableName) {
      res["RouteTableName"] = boost::any(*routeTableName);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    if (routerType) {
      res["RouterType"] = boost::any(*routerType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (VRouterId) {
      res["VRouterId"] = boost::any(*VRouterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("RouteTableName") != m.end() && !m["RouteTableName"].empty()) {
      routeTableName = make_shared<string>(boost::any_cast<string>(m["RouteTableName"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
    if (m.find("RouterType") != m.end() && !m["RouterType"].empty()) {
      routerType = make_shared<string>(boost::any_cast<string>(m["RouterType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VRouterId") != m.end() && !m["VRouterId"].empty()) {
      VRouterId = make_shared<string>(boost::any_cast<string>(m["VRouterId"]));
    }
  }


  virtual ~DescribeRouteTablesRequest() = default;
};
class DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop : public Darabonba::Model {
public:
  shared_ptr<long> enabled{};
  shared_ptr<string> nextHopId{};
  shared_ptr<string> nextHopType{};
  shared_ptr<long> weight{};

  DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop() {}

  explicit DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (nextHopId) {
      res["NextHopId"] = boost::any(*nextHopId);
    }
    if (nextHopType) {
      res["NextHopType"] = boost::any(*nextHopType);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<long>(boost::any_cast<long>(m["Enabled"]));
    }
    if (m.find("NextHopId") != m.end() && !m["NextHopId"].empty()) {
      nextHopId = make_shared<string>(boost::any_cast<string>(m["NextHopId"]));
    }
    if (m.find("NextHopType") != m.end() && !m["NextHopType"].empty()) {
      nextHopType = make_shared<string>(boost::any_cast<string>(m["NextHopType"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop() = default;
};
class DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop>> nextHop{};

  DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops() {}

  explicit DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextHop) {
      vector<boost::any> temp1;
      for(auto item1:*nextHop){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NextHop"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      if (typeid(vector<boost::any>) == m["NextHop"].type()) {
        vector<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NextHop"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nextHop = make_shared<vector<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop>>(expect1);
      }
    }
  }


  virtual ~DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops() = default;
};
class DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nextHopType{};
  shared_ptr<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops> nextHops{};
  shared_ptr<string> routeEntryId{};
  shared_ptr<string> routeEntryName{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry() {}

  explicit DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nextHopType) {
      res["NextHopType"] = boost::any(*nextHopType);
    }
    if (nextHops) {
      res["NextHops"] = nextHops ? boost::any(nextHops->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (routeEntryId) {
      res["RouteEntryId"] = boost::any(*routeEntryId);
    }
    if (routeEntryName) {
      res["RouteEntryName"] = boost::any(*routeEntryName);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NextHopType") != m.end() && !m["NextHopType"].empty()) {
      nextHopType = make_shared<string>(boost::any_cast<string>(m["NextHopType"]));
    }
    if (m.find("NextHops") != m.end() && !m["NextHops"].empty()) {
      if (typeid(map<string, boost::any>) == m["NextHops"].type()) {
        DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NextHops"]));
        nextHops = make_shared<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops>(model1);
      }
    }
    if (m.find("RouteEntryId") != m.end() && !m["RouteEntryId"].empty()) {
      routeEntryId = make_shared<string>(boost::any_cast<string>(m["RouteEntryId"]));
    }
    if (m.find("RouteEntryName") != m.end() && !m["RouteEntryName"].empty()) {
      routeEntryName = make_shared<string>(boost::any_cast<string>(m["RouteEntryName"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry() = default;
};
class DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry>> routeEntry{};

  DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys() {}

  explicit DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeEntry) {
      vector<boost::any> temp1;
      for(auto item1:*routeEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouteEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteEntry") != m.end() && !m["RouteEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["RouteEntry"].type()) {
        vector<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouteEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeEntry = make_shared<vector<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys() = default;
};
class DescribeRouteTablesResponseBodyRouteTablesRouteTableVSwitchIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> vSwitchId{};

  DescribeRouteTablesResponseBodyRouteTablesRouteTableVSwitchIds() {}

  explicit DescribeRouteTablesResponseBodyRouteTablesRouteTableVSwitchIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeRouteTablesResponseBodyRouteTablesRouteTableVSwitchIds() = default;
};
class DescribeRouteTablesResponseBodyRouteTablesRouteTable : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys> routeEntrys{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> routeTableType{};
  shared_ptr<string> status{};
  shared_ptr<string> VRouterId{};
  shared_ptr<DescribeRouteTablesResponseBodyRouteTablesRouteTableVSwitchIds> vSwitchIds{};

  DescribeRouteTablesResponseBodyRouteTablesRouteTable() {}

  explicit DescribeRouteTablesResponseBodyRouteTablesRouteTable(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (routeEntrys) {
      res["RouteEntrys"] = routeEntrys ? boost::any(routeEntrys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (routeTableType) {
      res["RouteTableType"] = boost::any(*routeTableType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (VRouterId) {
      res["VRouterId"] = boost::any(*VRouterId);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = vSwitchIds ? boost::any(vSwitchIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RouteEntrys") != m.end() && !m["RouteEntrys"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteEntrys"].type()) {
        DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteEntrys"]));
        routeEntrys = make_shared<DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys>(model1);
      }
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("RouteTableType") != m.end() && !m["RouteTableType"].empty()) {
      routeTableType = make_shared<string>(boost::any_cast<string>(m["RouteTableType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VRouterId") != m.end() && !m["VRouterId"].empty()) {
      VRouterId = make_shared<string>(boost::any_cast<string>(m["VRouterId"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["VSwitchIds"].type()) {
        DescribeRouteTablesResponseBodyRouteTablesRouteTableVSwitchIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VSwitchIds"]));
        vSwitchIds = make_shared<DescribeRouteTablesResponseBodyRouteTablesRouteTableVSwitchIds>(model1);
      }
    }
  }


  virtual ~DescribeRouteTablesResponseBodyRouteTablesRouteTable() = default;
};
class DescribeRouteTablesResponseBodyRouteTables : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRouteTablesResponseBodyRouteTablesRouteTable>> routeTable{};

  DescribeRouteTablesResponseBodyRouteTables() {}

  explicit DescribeRouteTablesResponseBodyRouteTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeTable) {
      vector<boost::any> temp1;
      for(auto item1:*routeTable){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouteTable"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteTable") != m.end() && !m["RouteTable"].empty()) {
      if (typeid(vector<boost::any>) == m["RouteTable"].type()) {
        vector<DescribeRouteTablesResponseBodyRouteTablesRouteTable> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouteTable"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRouteTablesResponseBodyRouteTablesRouteTable model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeTable = make_shared<vector<DescribeRouteTablesResponseBodyRouteTablesRouteTable>>(expect1);
      }
    }
  }


  virtual ~DescribeRouteTablesResponseBodyRouteTables() = default;
};
class DescribeRouteTablesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRouteTablesResponseBodyRouteTables> routeTables{};
  shared_ptr<long> totalCount{};

  DescribeRouteTablesResponseBody() {}

  explicit DescribeRouteTablesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routeTables) {
      res["RouteTables"] = routeTables ? boost::any(routeTables->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouteTables") != m.end() && !m["RouteTables"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteTables"].type()) {
        DescribeRouteTablesResponseBodyRouteTables model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteTables"]));
        routeTables = make_shared<DescribeRouteTablesResponseBodyRouteTables>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeRouteTablesResponseBody() = default;
};
class DescribeRouteTablesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRouteTablesResponseBody> body{};

  DescribeRouteTablesResponse() {}

  explicit DescribeRouteTablesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRouteTablesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRouteTablesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRouteTablesResponse() = default;
};
class DescribeRouterInterfaceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeRouterInterfaceAttributeRequest() {}

  explicit DescribeRouterInterfaceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeRouterInterfaceAttributeRequest() = default;
};
class DescribeRouterInterfaceAttributeResponseBodyTagsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeRouterInterfaceAttributeResponseBodyTagsTags() {}

  explicit DescribeRouterInterfaceAttributeResponseBodyTagsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeRouterInterfaceAttributeResponseBodyTagsTags() = default;
};
class DescribeRouterInterfaceAttributeResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRouterInterfaceAttributeResponseBodyTagsTags>> tags{};

  DescribeRouterInterfaceAttributeResponseBodyTags() {}

  explicit DescribeRouterInterfaceAttributeResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeRouterInterfaceAttributeResponseBodyTagsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRouterInterfaceAttributeResponseBodyTagsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeRouterInterfaceAttributeResponseBodyTagsTags>>(expect1);
      }
    }
  }


  virtual ~DescribeRouterInterfaceAttributeResponseBodyTags() = default;
};
class DescribeRouterInterfaceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accessPointId{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> code{};
  shared_ptr<string> connectedTime{};
  shared_ptr<string> creationTime{};
  shared_ptr<bool> crossBorder{};
  shared_ptr<string> description{};
  shared_ptr<string> endTime{};
  shared_ptr<string> fastLinkMode{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> hasReservationData{};
  shared_ptr<long> hcRate{};
  shared_ptr<long> hcThreshold{};
  shared_ptr<string> healthCheckSourceIp{};
  shared_ptr<string> healthCheckStatus{};
  shared_ptr<string> healthCheckTargetIp{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> oppositeAccessPointId{};
  shared_ptr<long> oppositeBandwidth{};
  shared_ptr<string> oppositeInterfaceBusinessStatus{};
  shared_ptr<string> oppositeInterfaceId{};
  shared_ptr<string> oppositeInterfaceOwnerId{};
  shared_ptr<string> oppositeInterfaceSpec{};
  shared_ptr<string> oppositeInterfaceStatus{};
  shared_ptr<string> oppositeRegionId{};
  shared_ptr<string> oppositeRouterId{};
  shared_ptr<string> oppositeRouterType{};
  shared_ptr<string> oppositeVpcInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> reservationActiveTime{};
  shared_ptr<string> reservationBandwidth{};
  shared_ptr<string> reservationInternetChargeType{};
  shared_ptr<string> reservationOrderType{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> role{};
  shared_ptr<string> routerId{};
  shared_ptr<string> routerInterfaceId{};
  shared_ptr<string> routerType{};
  shared_ptr<string> spec{};
  shared_ptr<string> status{};
  shared_ptr<bool> success{};
  shared_ptr<DescribeRouterInterfaceAttributeResponseBodyTags> tags{};
  shared_ptr<string> vpcInstanceId{};

  DescribeRouterInterfaceAttributeResponseBody() {}

  explicit DescribeRouterInterfaceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (connectedTime) {
      res["ConnectedTime"] = boost::any(*connectedTime);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (crossBorder) {
      res["CrossBorder"] = boost::any(*crossBorder);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fastLinkMode) {
      res["FastLinkMode"] = boost::any(*fastLinkMode);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (hasReservationData) {
      res["HasReservationData"] = boost::any(*hasReservationData);
    }
    if (hcRate) {
      res["HcRate"] = boost::any(*hcRate);
    }
    if (hcThreshold) {
      res["HcThreshold"] = boost::any(*hcThreshold);
    }
    if (healthCheckSourceIp) {
      res["HealthCheckSourceIp"] = boost::any(*healthCheckSourceIp);
    }
    if (healthCheckStatus) {
      res["HealthCheckStatus"] = boost::any(*healthCheckStatus);
    }
    if (healthCheckTargetIp) {
      res["HealthCheckTargetIp"] = boost::any(*healthCheckTargetIp);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (oppositeAccessPointId) {
      res["OppositeAccessPointId"] = boost::any(*oppositeAccessPointId);
    }
    if (oppositeBandwidth) {
      res["OppositeBandwidth"] = boost::any(*oppositeBandwidth);
    }
    if (oppositeInterfaceBusinessStatus) {
      res["OppositeInterfaceBusinessStatus"] = boost::any(*oppositeInterfaceBusinessStatus);
    }
    if (oppositeInterfaceId) {
      res["OppositeInterfaceId"] = boost::any(*oppositeInterfaceId);
    }
    if (oppositeInterfaceOwnerId) {
      res["OppositeInterfaceOwnerId"] = boost::any(*oppositeInterfaceOwnerId);
    }
    if (oppositeInterfaceSpec) {
      res["OppositeInterfaceSpec"] = boost::any(*oppositeInterfaceSpec);
    }
    if (oppositeInterfaceStatus) {
      res["OppositeInterfaceStatus"] = boost::any(*oppositeInterfaceStatus);
    }
    if (oppositeRegionId) {
      res["OppositeRegionId"] = boost::any(*oppositeRegionId);
    }
    if (oppositeRouterId) {
      res["OppositeRouterId"] = boost::any(*oppositeRouterId);
    }
    if (oppositeRouterType) {
      res["OppositeRouterType"] = boost::any(*oppositeRouterType);
    }
    if (oppositeVpcInstanceId) {
      res["OppositeVpcInstanceId"] = boost::any(*oppositeVpcInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (reservationActiveTime) {
      res["ReservationActiveTime"] = boost::any(*reservationActiveTime);
    }
    if (reservationBandwidth) {
      res["ReservationBandwidth"] = boost::any(*reservationBandwidth);
    }
    if (reservationInternetChargeType) {
      res["ReservationInternetChargeType"] = boost::any(*reservationInternetChargeType);
    }
    if (reservationOrderType) {
      res["ReservationOrderType"] = boost::any(*reservationOrderType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    if (routerInterfaceId) {
      res["RouterInterfaceId"] = boost::any(*routerInterfaceId);
    }
    if (routerType) {
      res["RouterType"] = boost::any(*routerType);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcInstanceId) {
      res["VpcInstanceId"] = boost::any(*vpcInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<string>(boost::any_cast<string>(m["AccessPointId"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ConnectedTime") != m.end() && !m["ConnectedTime"].empty()) {
      connectedTime = make_shared<string>(boost::any_cast<string>(m["ConnectedTime"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("CrossBorder") != m.end() && !m["CrossBorder"].empty()) {
      crossBorder = make_shared<bool>(boost::any_cast<bool>(m["CrossBorder"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FastLinkMode") != m.end() && !m["FastLinkMode"].empty()) {
      fastLinkMode = make_shared<string>(boost::any_cast<string>(m["FastLinkMode"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("HasReservationData") != m.end() && !m["HasReservationData"].empty()) {
      hasReservationData = make_shared<string>(boost::any_cast<string>(m["HasReservationData"]));
    }
    if (m.find("HcRate") != m.end() && !m["HcRate"].empty()) {
      hcRate = make_shared<long>(boost::any_cast<long>(m["HcRate"]));
    }
    if (m.find("HcThreshold") != m.end() && !m["HcThreshold"].empty()) {
      hcThreshold = make_shared<long>(boost::any_cast<long>(m["HcThreshold"]));
    }
    if (m.find("HealthCheckSourceIp") != m.end() && !m["HealthCheckSourceIp"].empty()) {
      healthCheckSourceIp = make_shared<string>(boost::any_cast<string>(m["HealthCheckSourceIp"]));
    }
    if (m.find("HealthCheckStatus") != m.end() && !m["HealthCheckStatus"].empty()) {
      healthCheckStatus = make_shared<string>(boost::any_cast<string>(m["HealthCheckStatus"]));
    }
    if (m.find("HealthCheckTargetIp") != m.end() && !m["HealthCheckTargetIp"].empty()) {
      healthCheckTargetIp = make_shared<string>(boost::any_cast<string>(m["HealthCheckTargetIp"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OppositeAccessPointId") != m.end() && !m["OppositeAccessPointId"].empty()) {
      oppositeAccessPointId = make_shared<string>(boost::any_cast<string>(m["OppositeAccessPointId"]));
    }
    if (m.find("OppositeBandwidth") != m.end() && !m["OppositeBandwidth"].empty()) {
      oppositeBandwidth = make_shared<long>(boost::any_cast<long>(m["OppositeBandwidth"]));
    }
    if (m.find("OppositeInterfaceBusinessStatus") != m.end() && !m["OppositeInterfaceBusinessStatus"].empty()) {
      oppositeInterfaceBusinessStatus = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceBusinessStatus"]));
    }
    if (m.find("OppositeInterfaceId") != m.end() && !m["OppositeInterfaceId"].empty()) {
      oppositeInterfaceId = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceId"]));
    }
    if (m.find("OppositeInterfaceOwnerId") != m.end() && !m["OppositeInterfaceOwnerId"].empty()) {
      oppositeInterfaceOwnerId = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceOwnerId"]));
    }
    if (m.find("OppositeInterfaceSpec") != m.end() && !m["OppositeInterfaceSpec"].empty()) {
      oppositeInterfaceSpec = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceSpec"]));
    }
    if (m.find("OppositeInterfaceStatus") != m.end() && !m["OppositeInterfaceStatus"].empty()) {
      oppositeInterfaceStatus = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceStatus"]));
    }
    if (m.find("OppositeRegionId") != m.end() && !m["OppositeRegionId"].empty()) {
      oppositeRegionId = make_shared<string>(boost::any_cast<string>(m["OppositeRegionId"]));
    }
    if (m.find("OppositeRouterId") != m.end() && !m["OppositeRouterId"].empty()) {
      oppositeRouterId = make_shared<string>(boost::any_cast<string>(m["OppositeRouterId"]));
    }
    if (m.find("OppositeRouterType") != m.end() && !m["OppositeRouterType"].empty()) {
      oppositeRouterType = make_shared<string>(boost::any_cast<string>(m["OppositeRouterType"]));
    }
    if (m.find("OppositeVpcInstanceId") != m.end() && !m["OppositeVpcInstanceId"].empty()) {
      oppositeVpcInstanceId = make_shared<string>(boost::any_cast<string>(m["OppositeVpcInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ReservationActiveTime") != m.end() && !m["ReservationActiveTime"].empty()) {
      reservationActiveTime = make_shared<string>(boost::any_cast<string>(m["ReservationActiveTime"]));
    }
    if (m.find("ReservationBandwidth") != m.end() && !m["ReservationBandwidth"].empty()) {
      reservationBandwidth = make_shared<string>(boost::any_cast<string>(m["ReservationBandwidth"]));
    }
    if (m.find("ReservationInternetChargeType") != m.end() && !m["ReservationInternetChargeType"].empty()) {
      reservationInternetChargeType = make_shared<string>(boost::any_cast<string>(m["ReservationInternetChargeType"]));
    }
    if (m.find("ReservationOrderType") != m.end() && !m["ReservationOrderType"].empty()) {
      reservationOrderType = make_shared<string>(boost::any_cast<string>(m["ReservationOrderType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
    if (m.find("RouterInterfaceId") != m.end() && !m["RouterInterfaceId"].empty()) {
      routerInterfaceId = make_shared<string>(boost::any_cast<string>(m["RouterInterfaceId"]));
    }
    if (m.find("RouterType") != m.end() && !m["RouterType"].empty()) {
      routerType = make_shared<string>(boost::any_cast<string>(m["RouterType"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeRouterInterfaceAttributeResponseBodyTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeRouterInterfaceAttributeResponseBodyTags>(model1);
      }
    }
    if (m.find("VpcInstanceId") != m.end() && !m["VpcInstanceId"].empty()) {
      vpcInstanceId = make_shared<string>(boost::any_cast<string>(m["VpcInstanceId"]));
    }
  }


  virtual ~DescribeRouterInterfaceAttributeResponseBody() = default;
};
class DescribeRouterInterfaceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRouterInterfaceAttributeResponseBody> body{};

  DescribeRouterInterfaceAttributeResponse() {}

  explicit DescribeRouterInterfaceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRouterInterfaceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRouterInterfaceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRouterInterfaceAttributeResponse() = default;
};
class DescribeRouterInterfacesRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> value{};

  DescribeRouterInterfacesRequestFilter() {}

  explicit DescribeRouterInterfacesRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeRouterInterfacesRequestFilter() = default;
};
class DescribeRouterInterfacesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeRouterInterfacesRequestTags() {}

  explicit DescribeRouterInterfacesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeRouterInterfacesRequestTags() = default;
};
class DescribeRouterInterfacesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRouterInterfacesRequestFilter>> filter{};
  shared_ptr<bool> includeReservationData{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<DescribeRouterInterfacesRequestTags>> tags{};

  DescribeRouterInterfacesRequest() {}

  explicit DescribeRouterInterfacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    if (includeReservationData) {
      res["IncludeReservationData"] = boost::any(*includeReservationData);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeRouterInterfacesRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRouterInterfacesRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeRouterInterfacesRequestFilter>>(expect1);
      }
    }
    if (m.find("IncludeReservationData") != m.end() && !m["IncludeReservationData"].empty()) {
      includeReservationData = make_shared<bool>(boost::any_cast<bool>(m["IncludeReservationData"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeRouterInterfacesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRouterInterfacesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeRouterInterfacesRequestTags>>(expect1);
      }
    }
  }


  virtual ~DescribeRouterInterfacesRequest() = default;
};
class DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTagsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTagsTags() {}

  explicit DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTagsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTagsTags() = default;
};
class DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTagsTags>> tags{};

  DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTags() {}

  explicit DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTagsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTagsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTagsTags>>(expect1);
      }
    }
  }


  virtual ~DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTags() = default;
};
class DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType : public Darabonba::Model {
public:
  shared_ptr<string> accessPointId{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> connectedTime{};
  shared_ptr<string> creationTime{};
  shared_ptr<bool> crossBorder{};
  shared_ptr<string> description{};
  shared_ptr<string> endTime{};
  shared_ptr<bool> fastLinkMode{};
  shared_ptr<string> hasReservationData{};
  shared_ptr<long> hcRate{};
  shared_ptr<long> hcThreshold{};
  shared_ptr<string> healthCheckSourceIp{};
  shared_ptr<string> healthCheckTargetIp{};
  shared_ptr<string> ipv6Status{};
  shared_ptr<string> name{};
  shared_ptr<string> oppositeAccessPointId{};
  shared_ptr<long> oppositeBandwidth{};
  shared_ptr<string> oppositeInterfaceBusinessStatus{};
  shared_ptr<string> oppositeInterfaceId{};
  shared_ptr<string> oppositeInterfaceOwnerId{};
  shared_ptr<string> oppositeInterfaceSpec{};
  shared_ptr<string> oppositeInterfaceStatus{};
  shared_ptr<string> oppositeRegionId{};
  shared_ptr<string> oppositeRouterId{};
  shared_ptr<string> oppositeRouterType{};
  shared_ptr<string> oppositeVpcInstanceId{};
  shared_ptr<string> reservationActiveTime{};
  shared_ptr<string> reservationBandwidth{};
  shared_ptr<string> reservationInternetChargeType{};
  shared_ptr<string> reservationOrderType{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> role{};
  shared_ptr<string> routerId{};
  shared_ptr<string> routerInterfaceId{};
  shared_ptr<string> routerType{};
  shared_ptr<string> spec{};
  shared_ptr<string> status{};
  shared_ptr<DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTags> tags{};
  shared_ptr<string> vpcInstanceId{};

  DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType() {}

  explicit DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (connectedTime) {
      res["ConnectedTime"] = boost::any(*connectedTime);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (crossBorder) {
      res["CrossBorder"] = boost::any(*crossBorder);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fastLinkMode) {
      res["FastLinkMode"] = boost::any(*fastLinkMode);
    }
    if (hasReservationData) {
      res["HasReservationData"] = boost::any(*hasReservationData);
    }
    if (hcRate) {
      res["HcRate"] = boost::any(*hcRate);
    }
    if (hcThreshold) {
      res["HcThreshold"] = boost::any(*hcThreshold);
    }
    if (healthCheckSourceIp) {
      res["HealthCheckSourceIp"] = boost::any(*healthCheckSourceIp);
    }
    if (healthCheckTargetIp) {
      res["HealthCheckTargetIp"] = boost::any(*healthCheckTargetIp);
    }
    if (ipv6Status) {
      res["Ipv6Status"] = boost::any(*ipv6Status);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (oppositeAccessPointId) {
      res["OppositeAccessPointId"] = boost::any(*oppositeAccessPointId);
    }
    if (oppositeBandwidth) {
      res["OppositeBandwidth"] = boost::any(*oppositeBandwidth);
    }
    if (oppositeInterfaceBusinessStatus) {
      res["OppositeInterfaceBusinessStatus"] = boost::any(*oppositeInterfaceBusinessStatus);
    }
    if (oppositeInterfaceId) {
      res["OppositeInterfaceId"] = boost::any(*oppositeInterfaceId);
    }
    if (oppositeInterfaceOwnerId) {
      res["OppositeInterfaceOwnerId"] = boost::any(*oppositeInterfaceOwnerId);
    }
    if (oppositeInterfaceSpec) {
      res["OppositeInterfaceSpec"] = boost::any(*oppositeInterfaceSpec);
    }
    if (oppositeInterfaceStatus) {
      res["OppositeInterfaceStatus"] = boost::any(*oppositeInterfaceStatus);
    }
    if (oppositeRegionId) {
      res["OppositeRegionId"] = boost::any(*oppositeRegionId);
    }
    if (oppositeRouterId) {
      res["OppositeRouterId"] = boost::any(*oppositeRouterId);
    }
    if (oppositeRouterType) {
      res["OppositeRouterType"] = boost::any(*oppositeRouterType);
    }
    if (oppositeVpcInstanceId) {
      res["OppositeVpcInstanceId"] = boost::any(*oppositeVpcInstanceId);
    }
    if (reservationActiveTime) {
      res["ReservationActiveTime"] = boost::any(*reservationActiveTime);
    }
    if (reservationBandwidth) {
      res["ReservationBandwidth"] = boost::any(*reservationBandwidth);
    }
    if (reservationInternetChargeType) {
      res["ReservationInternetChargeType"] = boost::any(*reservationInternetChargeType);
    }
    if (reservationOrderType) {
      res["ReservationOrderType"] = boost::any(*reservationOrderType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    if (routerInterfaceId) {
      res["RouterInterfaceId"] = boost::any(*routerInterfaceId);
    }
    if (routerType) {
      res["RouterType"] = boost::any(*routerType);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcInstanceId) {
      res["VpcInstanceId"] = boost::any(*vpcInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<string>(boost::any_cast<string>(m["AccessPointId"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ConnectedTime") != m.end() && !m["ConnectedTime"].empty()) {
      connectedTime = make_shared<string>(boost::any_cast<string>(m["ConnectedTime"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("CrossBorder") != m.end() && !m["CrossBorder"].empty()) {
      crossBorder = make_shared<bool>(boost::any_cast<bool>(m["CrossBorder"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FastLinkMode") != m.end() && !m["FastLinkMode"].empty()) {
      fastLinkMode = make_shared<bool>(boost::any_cast<bool>(m["FastLinkMode"]));
    }
    if (m.find("HasReservationData") != m.end() && !m["HasReservationData"].empty()) {
      hasReservationData = make_shared<string>(boost::any_cast<string>(m["HasReservationData"]));
    }
    if (m.find("HcRate") != m.end() && !m["HcRate"].empty()) {
      hcRate = make_shared<long>(boost::any_cast<long>(m["HcRate"]));
    }
    if (m.find("HcThreshold") != m.end() && !m["HcThreshold"].empty()) {
      hcThreshold = make_shared<long>(boost::any_cast<long>(m["HcThreshold"]));
    }
    if (m.find("HealthCheckSourceIp") != m.end() && !m["HealthCheckSourceIp"].empty()) {
      healthCheckSourceIp = make_shared<string>(boost::any_cast<string>(m["HealthCheckSourceIp"]));
    }
    if (m.find("HealthCheckTargetIp") != m.end() && !m["HealthCheckTargetIp"].empty()) {
      healthCheckTargetIp = make_shared<string>(boost::any_cast<string>(m["HealthCheckTargetIp"]));
    }
    if (m.find("Ipv6Status") != m.end() && !m["Ipv6Status"].empty()) {
      ipv6Status = make_shared<string>(boost::any_cast<string>(m["Ipv6Status"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OppositeAccessPointId") != m.end() && !m["OppositeAccessPointId"].empty()) {
      oppositeAccessPointId = make_shared<string>(boost::any_cast<string>(m["OppositeAccessPointId"]));
    }
    if (m.find("OppositeBandwidth") != m.end() && !m["OppositeBandwidth"].empty()) {
      oppositeBandwidth = make_shared<long>(boost::any_cast<long>(m["OppositeBandwidth"]));
    }
    if (m.find("OppositeInterfaceBusinessStatus") != m.end() && !m["OppositeInterfaceBusinessStatus"].empty()) {
      oppositeInterfaceBusinessStatus = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceBusinessStatus"]));
    }
    if (m.find("OppositeInterfaceId") != m.end() && !m["OppositeInterfaceId"].empty()) {
      oppositeInterfaceId = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceId"]));
    }
    if (m.find("OppositeInterfaceOwnerId") != m.end() && !m["OppositeInterfaceOwnerId"].empty()) {
      oppositeInterfaceOwnerId = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceOwnerId"]));
    }
    if (m.find("OppositeInterfaceSpec") != m.end() && !m["OppositeInterfaceSpec"].empty()) {
      oppositeInterfaceSpec = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceSpec"]));
    }
    if (m.find("OppositeInterfaceStatus") != m.end() && !m["OppositeInterfaceStatus"].empty()) {
      oppositeInterfaceStatus = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceStatus"]));
    }
    if (m.find("OppositeRegionId") != m.end() && !m["OppositeRegionId"].empty()) {
      oppositeRegionId = make_shared<string>(boost::any_cast<string>(m["OppositeRegionId"]));
    }
    if (m.find("OppositeRouterId") != m.end() && !m["OppositeRouterId"].empty()) {
      oppositeRouterId = make_shared<string>(boost::any_cast<string>(m["OppositeRouterId"]));
    }
    if (m.find("OppositeRouterType") != m.end() && !m["OppositeRouterType"].empty()) {
      oppositeRouterType = make_shared<string>(boost::any_cast<string>(m["OppositeRouterType"]));
    }
    if (m.find("OppositeVpcInstanceId") != m.end() && !m["OppositeVpcInstanceId"].empty()) {
      oppositeVpcInstanceId = make_shared<string>(boost::any_cast<string>(m["OppositeVpcInstanceId"]));
    }
    if (m.find("ReservationActiveTime") != m.end() && !m["ReservationActiveTime"].empty()) {
      reservationActiveTime = make_shared<string>(boost::any_cast<string>(m["ReservationActiveTime"]));
    }
    if (m.find("ReservationBandwidth") != m.end() && !m["ReservationBandwidth"].empty()) {
      reservationBandwidth = make_shared<string>(boost::any_cast<string>(m["ReservationBandwidth"]));
    }
    if (m.find("ReservationInternetChargeType") != m.end() && !m["ReservationInternetChargeType"].empty()) {
      reservationInternetChargeType = make_shared<string>(boost::any_cast<string>(m["ReservationInternetChargeType"]));
    }
    if (m.find("ReservationOrderType") != m.end() && !m["ReservationOrderType"].empty()) {
      reservationOrderType = make_shared<string>(boost::any_cast<string>(m["ReservationOrderType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
    if (m.find("RouterInterfaceId") != m.end() && !m["RouterInterfaceId"].empty()) {
      routerInterfaceId = make_shared<string>(boost::any_cast<string>(m["RouterInterfaceId"]));
    }
    if (m.find("RouterType") != m.end() && !m["RouterType"].empty()) {
      routerType = make_shared<string>(boost::any_cast<string>(m["RouterType"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceTypeTags>(model1);
      }
    }
    if (m.find("VpcInstanceId") != m.end() && !m["VpcInstanceId"].empty()) {
      vpcInstanceId = make_shared<string>(boost::any_cast<string>(m["VpcInstanceId"]));
    }
  }


  virtual ~DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType() = default;
};
class DescribeRouterInterfacesResponseBodyRouterInterfaceSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType>> routerInterfaceType{};

  DescribeRouterInterfacesResponseBodyRouterInterfaceSet() {}

  explicit DescribeRouterInterfacesResponseBodyRouterInterfaceSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routerInterfaceType) {
      vector<boost::any> temp1;
      for(auto item1:*routerInterfaceType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouterInterfaceType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouterInterfaceType") != m.end() && !m["RouterInterfaceType"].empty()) {
      if (typeid(vector<boost::any>) == m["RouterInterfaceType"].type()) {
        vector<DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouterInterfaceType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routerInterfaceType = make_shared<vector<DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType>>(expect1);
      }
    }
  }


  virtual ~DescribeRouterInterfacesResponseBodyRouterInterfaceSet() = default;
};
class DescribeRouterInterfacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRouterInterfacesResponseBodyRouterInterfaceSet> routerInterfaceSet{};
  shared_ptr<long> totalCount{};

  DescribeRouterInterfacesResponseBody() {}

  explicit DescribeRouterInterfacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routerInterfaceSet) {
      res["RouterInterfaceSet"] = routerInterfaceSet ? boost::any(routerInterfaceSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouterInterfaceSet") != m.end() && !m["RouterInterfaceSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouterInterfaceSet"].type()) {
        DescribeRouterInterfacesResponseBodyRouterInterfaceSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouterInterfaceSet"]));
        routerInterfaceSet = make_shared<DescribeRouterInterfacesResponseBodyRouterInterfaceSet>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeRouterInterfacesResponseBody() = default;
};
class DescribeRouterInterfacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRouterInterfacesResponseBody> body{};

  DescribeRouterInterfacesResponse() {}

  explicit DescribeRouterInterfacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRouterInterfacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRouterInterfacesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRouterInterfacesResponse() = default;
};
class DescribeServerRelatedGlobalAccelerationInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serverId{};
  shared_ptr<string> serverType{};

  DescribeServerRelatedGlobalAccelerationInstancesRequest() {}

  explicit DescribeServerRelatedGlobalAccelerationInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (serverType) {
      res["ServerType"] = boost::any(*serverType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("ServerType") != m.end() && !m["ServerType"].empty()) {
      serverType = make_shared<string>(boost::any_cast<string>(m["ServerType"]));
    }
  }


  virtual ~DescribeServerRelatedGlobalAccelerationInstancesRequest() = default;
};
class DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance : public Darabonba::Model {
public:
  shared_ptr<string> globalAccelerationInstanceId{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> regionId{};
  shared_ptr<string> serverIpAddress{};

  DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance() {}

  explicit DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalAccelerationInstanceId) {
      res["GlobalAccelerationInstanceId"] = boost::any(*globalAccelerationInstanceId);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serverIpAddress) {
      res["ServerIpAddress"] = boost::any(*serverIpAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalAccelerationInstanceId") != m.end() && !m["GlobalAccelerationInstanceId"].empty()) {
      globalAccelerationInstanceId = make_shared<string>(boost::any_cast<string>(m["GlobalAccelerationInstanceId"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ServerIpAddress") != m.end() && !m["ServerIpAddress"].empty()) {
      serverIpAddress = make_shared<string>(boost::any_cast<string>(m["ServerIpAddress"]));
    }
  }


  virtual ~DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance() = default;
};
class DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance>> globalAccelerationInstance{};

  DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances() {}

  explicit DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalAccelerationInstance) {
      vector<boost::any> temp1;
      for(auto item1:*globalAccelerationInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GlobalAccelerationInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalAccelerationInstance") != m.end() && !m["GlobalAccelerationInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["GlobalAccelerationInstance"].type()) {
        vector<DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GlobalAccelerationInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        globalAccelerationInstance = make_shared<vector<DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstancesGlobalAccelerationInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances() = default;
};
class DescribeServerRelatedGlobalAccelerationInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances> globalAccelerationInstances{};
  shared_ptr<string> requestId{};

  DescribeServerRelatedGlobalAccelerationInstancesResponseBody() {}

  explicit DescribeServerRelatedGlobalAccelerationInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalAccelerationInstances) {
      res["GlobalAccelerationInstances"] = globalAccelerationInstances ? boost::any(globalAccelerationInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalAccelerationInstances") != m.end() && !m["GlobalAccelerationInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["GlobalAccelerationInstances"].type()) {
        DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GlobalAccelerationInstances"]));
        globalAccelerationInstances = make_shared<DescribeServerRelatedGlobalAccelerationInstancesResponseBodyGlobalAccelerationInstances>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeServerRelatedGlobalAccelerationInstancesResponseBody() = default;
};
class DescribeServerRelatedGlobalAccelerationInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeServerRelatedGlobalAccelerationInstancesResponseBody> body{};

  DescribeServerRelatedGlobalAccelerationInstancesResponse() {}

  explicit DescribeServerRelatedGlobalAccelerationInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeServerRelatedGlobalAccelerationInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeServerRelatedGlobalAccelerationInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeServerRelatedGlobalAccelerationInstancesResponse() = default;
};
class DescribeSnatTableEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> snatEntryId{};
  shared_ptr<string> snatEntryName{};
  shared_ptr<string> snatIp{};
  shared_ptr<string> snatTableId{};
  shared_ptr<string> sourceCIDR{};
  shared_ptr<string> sourceVSwitchId{};

  DescribeSnatTableEntriesRequest() {}

  explicit DescribeSnatTableEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (snatEntryId) {
      res["SnatEntryId"] = boost::any(*snatEntryId);
    }
    if (snatEntryName) {
      res["SnatEntryName"] = boost::any(*snatEntryName);
    }
    if (snatIp) {
      res["SnatIp"] = boost::any(*snatIp);
    }
    if (snatTableId) {
      res["SnatTableId"] = boost::any(*snatTableId);
    }
    if (sourceCIDR) {
      res["SourceCIDR"] = boost::any(*sourceCIDR);
    }
    if (sourceVSwitchId) {
      res["SourceVSwitchId"] = boost::any(*sourceVSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SnatEntryId") != m.end() && !m["SnatEntryId"].empty()) {
      snatEntryId = make_shared<string>(boost::any_cast<string>(m["SnatEntryId"]));
    }
    if (m.find("SnatEntryName") != m.end() && !m["SnatEntryName"].empty()) {
      snatEntryName = make_shared<string>(boost::any_cast<string>(m["SnatEntryName"]));
    }
    if (m.find("SnatIp") != m.end() && !m["SnatIp"].empty()) {
      snatIp = make_shared<string>(boost::any_cast<string>(m["SnatIp"]));
    }
    if (m.find("SnatTableId") != m.end() && !m["SnatTableId"].empty()) {
      snatTableId = make_shared<string>(boost::any_cast<string>(m["SnatTableId"]));
    }
    if (m.find("SourceCIDR") != m.end() && !m["SourceCIDR"].empty()) {
      sourceCIDR = make_shared<string>(boost::any_cast<string>(m["SourceCIDR"]));
    }
    if (m.find("SourceVSwitchId") != m.end() && !m["SourceVSwitchId"].empty()) {
      sourceVSwitchId = make_shared<string>(boost::any_cast<string>(m["SourceVSwitchId"]));
    }
  }


  virtual ~DescribeSnatTableEntriesRequest() = default;
};
class DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry : public Darabonba::Model {
public:
  shared_ptr<string> eipAffinity{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> snatEntryId{};
  shared_ptr<string> snatEntryName{};
  shared_ptr<string> snatIp{};
  shared_ptr<string> snatTableId{};
  shared_ptr<string> sourceCIDR{};
  shared_ptr<string> sourceVSwitchId{};
  shared_ptr<string> status{};

  DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry() {}

  explicit DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eipAffinity) {
      res["EipAffinity"] = boost::any(*eipAffinity);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (snatEntryId) {
      res["SnatEntryId"] = boost::any(*snatEntryId);
    }
    if (snatEntryName) {
      res["SnatEntryName"] = boost::any(*snatEntryName);
    }
    if (snatIp) {
      res["SnatIp"] = boost::any(*snatIp);
    }
    if (snatTableId) {
      res["SnatTableId"] = boost::any(*snatTableId);
    }
    if (sourceCIDR) {
      res["SourceCIDR"] = boost::any(*sourceCIDR);
    }
    if (sourceVSwitchId) {
      res["SourceVSwitchId"] = boost::any(*sourceVSwitchId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EipAffinity") != m.end() && !m["EipAffinity"].empty()) {
      eipAffinity = make_shared<string>(boost::any_cast<string>(m["EipAffinity"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("SnatEntryId") != m.end() && !m["SnatEntryId"].empty()) {
      snatEntryId = make_shared<string>(boost::any_cast<string>(m["SnatEntryId"]));
    }
    if (m.find("SnatEntryName") != m.end() && !m["SnatEntryName"].empty()) {
      snatEntryName = make_shared<string>(boost::any_cast<string>(m["SnatEntryName"]));
    }
    if (m.find("SnatIp") != m.end() && !m["SnatIp"].empty()) {
      snatIp = make_shared<string>(boost::any_cast<string>(m["SnatIp"]));
    }
    if (m.find("SnatTableId") != m.end() && !m["SnatTableId"].empty()) {
      snatTableId = make_shared<string>(boost::any_cast<string>(m["SnatTableId"]));
    }
    if (m.find("SourceCIDR") != m.end() && !m["SourceCIDR"].empty()) {
      sourceCIDR = make_shared<string>(boost::any_cast<string>(m["SourceCIDR"]));
    }
    if (m.find("SourceVSwitchId") != m.end() && !m["SourceVSwitchId"].empty()) {
      sourceVSwitchId = make_shared<string>(boost::any_cast<string>(m["SourceVSwitchId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry() = default;
};
class DescribeSnatTableEntriesResponseBodySnatTableEntries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry>> snatTableEntry{};

  DescribeSnatTableEntriesResponseBodySnatTableEntries() {}

  explicit DescribeSnatTableEntriesResponseBodySnatTableEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snatTableEntry) {
      vector<boost::any> temp1;
      for(auto item1:*snatTableEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SnatTableEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnatTableEntry") != m.end() && !m["SnatTableEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["SnatTableEntry"].type()) {
        vector<DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SnatTableEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snatTableEntry = make_shared<vector<DescribeSnatTableEntriesResponseBodySnatTableEntriesSnatTableEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeSnatTableEntriesResponseBodySnatTableEntries() = default;
};
class DescribeSnatTableEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSnatTableEntriesResponseBodySnatTableEntries> snatTableEntries{};
  shared_ptr<long> totalCount{};

  DescribeSnatTableEntriesResponseBody() {}

  explicit DescribeSnatTableEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snatTableEntries) {
      res["SnatTableEntries"] = snatTableEntries ? boost::any(snatTableEntries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnatTableEntries") != m.end() && !m["SnatTableEntries"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnatTableEntries"].type()) {
        DescribeSnatTableEntriesResponseBodySnatTableEntries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnatTableEntries"]));
        snatTableEntries = make_shared<DescribeSnatTableEntriesResponseBodySnatTableEntries>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSnatTableEntriesResponseBody() = default;
};
class DescribeSnatTableEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSnatTableEntriesResponseBody> body{};

  DescribeSnatTableEntriesResponse() {}

  explicit DescribeSnatTableEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSnatTableEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSnatTableEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSnatTableEntriesResponse() = default;
};
class DescribeSslVpnClientCertRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sslVpnClientCertId{};

  DescribeSslVpnClientCertRequest() {}

  explicit DescribeSslVpnClientCertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sslVpnClientCertId) {
      res["SslVpnClientCertId"] = boost::any(*sslVpnClientCertId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SslVpnClientCertId") != m.end() && !m["SslVpnClientCertId"].empty()) {
      sslVpnClientCertId = make_shared<string>(boost::any_cast<string>(m["SslVpnClientCertId"]));
    }
  }


  virtual ~DescribeSslVpnClientCertRequest() = default;
};
class DescribeSslVpnClientCertResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> caCert{};
  shared_ptr<string> clientCert{};
  shared_ptr<string> clientConfig{};
  shared_ptr<string> clientKey{};
  shared_ptr<long> createTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sslVpnClientCertId{};
  shared_ptr<string> sslVpnServerId{};
  shared_ptr<string> status{};

  DescribeSslVpnClientCertResponseBody() {}

  explicit DescribeSslVpnClientCertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caCert) {
      res["CaCert"] = boost::any(*caCert);
    }
    if (clientCert) {
      res["ClientCert"] = boost::any(*clientCert);
    }
    if (clientConfig) {
      res["ClientConfig"] = boost::any(*clientConfig);
    }
    if (clientKey) {
      res["ClientKey"] = boost::any(*clientKey);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sslVpnClientCertId) {
      res["SslVpnClientCertId"] = boost::any(*sslVpnClientCertId);
    }
    if (sslVpnServerId) {
      res["SslVpnServerId"] = boost::any(*sslVpnServerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaCert") != m.end() && !m["CaCert"].empty()) {
      caCert = make_shared<string>(boost::any_cast<string>(m["CaCert"]));
    }
    if (m.find("ClientCert") != m.end() && !m["ClientCert"].empty()) {
      clientCert = make_shared<string>(boost::any_cast<string>(m["ClientCert"]));
    }
    if (m.find("ClientConfig") != m.end() && !m["ClientConfig"].empty()) {
      clientConfig = make_shared<string>(boost::any_cast<string>(m["ClientConfig"]));
    }
    if (m.find("ClientKey") != m.end() && !m["ClientKey"].empty()) {
      clientKey = make_shared<string>(boost::any_cast<string>(m["ClientKey"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SslVpnClientCertId") != m.end() && !m["SslVpnClientCertId"].empty()) {
      sslVpnClientCertId = make_shared<string>(boost::any_cast<string>(m["SslVpnClientCertId"]));
    }
    if (m.find("SslVpnServerId") != m.end() && !m["SslVpnServerId"].empty()) {
      sslVpnServerId = make_shared<string>(boost::any_cast<string>(m["SslVpnServerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSslVpnClientCertResponseBody() = default;
};
class DescribeSslVpnClientCertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSslVpnClientCertResponseBody> body{};

  DescribeSslVpnClientCertResponse() {}

  explicit DescribeSslVpnClientCertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSslVpnClientCertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSslVpnClientCertResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSslVpnClientCertResponse() = default;
};
class DescribeSslVpnClientCertsRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sslVpnClientCertId{};
  shared_ptr<string> sslVpnServerId{};

  DescribeSslVpnClientCertsRequest() {}

  explicit DescribeSslVpnClientCertsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sslVpnClientCertId) {
      res["SslVpnClientCertId"] = boost::any(*sslVpnClientCertId);
    }
    if (sslVpnServerId) {
      res["SslVpnServerId"] = boost::any(*sslVpnServerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SslVpnClientCertId") != m.end() && !m["SslVpnClientCertId"].empty()) {
      sslVpnClientCertId = make_shared<string>(boost::any_cast<string>(m["SslVpnClientCertId"]));
    }
    if (m.find("SslVpnServerId") != m.end() && !m["SslVpnServerId"].empty()) {
      sslVpnServerId = make_shared<string>(boost::any_cast<string>(m["SslVpnServerId"]));
    }
  }


  virtual ~DescribeSslVpnClientCertsRequest() = default;
};
class DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sslVpnClientCertId{};
  shared_ptr<string> sslVpnServerId{};
  shared_ptr<string> status{};

  DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey() {}

  explicit DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sslVpnClientCertId) {
      res["SslVpnClientCertId"] = boost::any(*sslVpnClientCertId);
    }
    if (sslVpnServerId) {
      res["SslVpnServerId"] = boost::any(*sslVpnServerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SslVpnClientCertId") != m.end() && !m["SslVpnClientCertId"].empty()) {
      sslVpnClientCertId = make_shared<string>(boost::any_cast<string>(m["SslVpnClientCertId"]));
    }
    if (m.find("SslVpnServerId") != m.end() && !m["SslVpnServerId"].empty()) {
      sslVpnServerId = make_shared<string>(boost::any_cast<string>(m["SslVpnServerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey() = default;
};
class DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey>> sslVpnClientCertKey{};

  DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeys() {}

  explicit DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sslVpnClientCertKey) {
      vector<boost::any> temp1;
      for(auto item1:*sslVpnClientCertKey){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SslVpnClientCertKey"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SslVpnClientCertKey") != m.end() && !m["SslVpnClientCertKey"].empty()) {
      if (typeid(vector<boost::any>) == m["SslVpnClientCertKey"].type()) {
        vector<DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SslVpnClientCertKey"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sslVpnClientCertKey = make_shared<vector<DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeysSslVpnClientCertKey>>(expect1);
      }
    }
  }


  virtual ~DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeys() = default;
};
class DescribeSslVpnClientCertsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeys> sslVpnClientCertKeys{};
  shared_ptr<long> totalCount{};

  DescribeSslVpnClientCertsResponseBody() {}

  explicit DescribeSslVpnClientCertsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sslVpnClientCertKeys) {
      res["SslVpnClientCertKeys"] = sslVpnClientCertKeys ? boost::any(sslVpnClientCertKeys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SslVpnClientCertKeys") != m.end() && !m["SslVpnClientCertKeys"].empty()) {
      if (typeid(map<string, boost::any>) == m["SslVpnClientCertKeys"].type()) {
        DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SslVpnClientCertKeys"]));
        sslVpnClientCertKeys = make_shared<DescribeSslVpnClientCertsResponseBodySslVpnClientCertKeys>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSslVpnClientCertsResponseBody() = default;
};
class DescribeSslVpnClientCertsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSslVpnClientCertsResponseBody> body{};

  DescribeSslVpnClientCertsResponse() {}

  explicit DescribeSslVpnClientCertsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSslVpnClientCertsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSslVpnClientCertsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSslVpnClientCertsResponse() = default;
};
class DescribeSslVpnClientsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpnGatewayId{};

  DescribeSslVpnClientsRequest() {}

  explicit DescribeSslVpnClientsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~DescribeSslVpnClientsRequest() = default;
};
class DescribeSslVpnClientsResponseBodyClientInfoList : public Darabonba::Model {
public:
  shared_ptr<string> commonName{};
  shared_ptr<long> connectedTime{};
  shared_ptr<string> ip{};
  shared_ptr<string> port{};
  shared_ptr<string> privateIp{};
  shared_ptr<long> receiveBytes{};
  shared_ptr<long> sendBytes{};
  shared_ptr<string> status{};

  DescribeSslVpnClientsResponseBodyClientInfoList() {}

  explicit DescribeSslVpnClientsResponseBodyClientInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (connectedTime) {
      res["ConnectedTime"] = boost::any(*connectedTime);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (privateIp) {
      res["PrivateIp"] = boost::any(*privateIp);
    }
    if (receiveBytes) {
      res["ReceiveBytes"] = boost::any(*receiveBytes);
    }
    if (sendBytes) {
      res["SendBytes"] = boost::any(*sendBytes);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("ConnectedTime") != m.end() && !m["ConnectedTime"].empty()) {
      connectedTime = make_shared<long>(boost::any_cast<long>(m["ConnectedTime"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("PrivateIp") != m.end() && !m["PrivateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["PrivateIp"]));
    }
    if (m.find("ReceiveBytes") != m.end() && !m["ReceiveBytes"].empty()) {
      receiveBytes = make_shared<long>(boost::any_cast<long>(m["ReceiveBytes"]));
    }
    if (m.find("SendBytes") != m.end() && !m["SendBytes"].empty()) {
      sendBytes = make_shared<long>(boost::any_cast<long>(m["SendBytes"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSslVpnClientsResponseBodyClientInfoList() = default;
};
class DescribeSslVpnClientsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSslVpnClientsResponseBodyClientInfoList>> clientInfoList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> vpnGatewayId{};

  DescribeSslVpnClientsResponseBody() {}

  explicit DescribeSslVpnClientsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*clientInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClientInfoList"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientInfoList") != m.end() && !m["ClientInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["ClientInfoList"].type()) {
        vector<DescribeSslVpnClientsResponseBodyClientInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClientInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSslVpnClientsResponseBodyClientInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clientInfoList = make_shared<vector<DescribeSslVpnClientsResponseBodyClientInfoList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~DescribeSslVpnClientsResponseBody() = default;
};
class DescribeSslVpnClientsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSslVpnClientsResponseBody> body{};

  DescribeSslVpnClientsResponse() {}

  explicit DescribeSslVpnClientsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSslVpnClientsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSslVpnClientsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSslVpnClientsResponse() = default;
};
class DescribeSslVpnServersRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sslVpnServerId{};
  shared_ptr<string> vpnGatewayId{};

  DescribeSslVpnServersRequest() {}

  explicit DescribeSslVpnServersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sslVpnServerId) {
      res["SslVpnServerId"] = boost::any(*sslVpnServerId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SslVpnServerId") != m.end() && !m["SslVpnServerId"].empty()) {
      sslVpnServerId = make_shared<string>(boost::any_cast<string>(m["SslVpnServerId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~DescribeSslVpnServersRequest() = default;
};
class DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer : public Darabonba::Model {
public:
  shared_ptr<string> cipher{};
  shared_ptr<string> clientIpPool{};
  shared_ptr<bool> compress{};
  shared_ptr<long> connections{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> enableMultiFactorAuth{};
  shared_ptr<string> IDaaSApplicationId{};
  shared_ptr<string> IDaaSInstanceId{};
  shared_ptr<string> IDaaSInstanceVersion{};
  shared_ptr<string> IDaaSRegionId{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> localSubnet{};
  shared_ptr<long> maxConnections{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> proto{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sslVpnServerId{};
  shared_ptr<string> vpnGatewayId{};

  DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer() {}

  explicit DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cipher) {
      res["Cipher"] = boost::any(*cipher);
    }
    if (clientIpPool) {
      res["ClientIpPool"] = boost::any(*clientIpPool);
    }
    if (compress) {
      res["Compress"] = boost::any(*compress);
    }
    if (connections) {
      res["Connections"] = boost::any(*connections);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (enableMultiFactorAuth) {
      res["EnableMultiFactorAuth"] = boost::any(*enableMultiFactorAuth);
    }
    if (IDaaSApplicationId) {
      res["IDaaSApplicationId"] = boost::any(*IDaaSApplicationId);
    }
    if (IDaaSInstanceId) {
      res["IDaaSInstanceId"] = boost::any(*IDaaSInstanceId);
    }
    if (IDaaSInstanceVersion) {
      res["IDaaSInstanceVersion"] = boost::any(*IDaaSInstanceVersion);
    }
    if (IDaaSRegionId) {
      res["IDaaSRegionId"] = boost::any(*IDaaSRegionId);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (localSubnet) {
      res["LocalSubnet"] = boost::any(*localSubnet);
    }
    if (maxConnections) {
      res["MaxConnections"] = boost::any(*maxConnections);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (proto) {
      res["Proto"] = boost::any(*proto);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sslVpnServerId) {
      res["SslVpnServerId"] = boost::any(*sslVpnServerId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cipher") != m.end() && !m["Cipher"].empty()) {
      cipher = make_shared<string>(boost::any_cast<string>(m["Cipher"]));
    }
    if (m.find("ClientIpPool") != m.end() && !m["ClientIpPool"].empty()) {
      clientIpPool = make_shared<string>(boost::any_cast<string>(m["ClientIpPool"]));
    }
    if (m.find("Compress") != m.end() && !m["Compress"].empty()) {
      compress = make_shared<bool>(boost::any_cast<bool>(m["Compress"]));
    }
    if (m.find("Connections") != m.end() && !m["Connections"].empty()) {
      connections = make_shared<long>(boost::any_cast<long>(m["Connections"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("EnableMultiFactorAuth") != m.end() && !m["EnableMultiFactorAuth"].empty()) {
      enableMultiFactorAuth = make_shared<bool>(boost::any_cast<bool>(m["EnableMultiFactorAuth"]));
    }
    if (m.find("IDaaSApplicationId") != m.end() && !m["IDaaSApplicationId"].empty()) {
      IDaaSApplicationId = make_shared<string>(boost::any_cast<string>(m["IDaaSApplicationId"]));
    }
    if (m.find("IDaaSInstanceId") != m.end() && !m["IDaaSInstanceId"].empty()) {
      IDaaSInstanceId = make_shared<string>(boost::any_cast<string>(m["IDaaSInstanceId"]));
    }
    if (m.find("IDaaSInstanceVersion") != m.end() && !m["IDaaSInstanceVersion"].empty()) {
      IDaaSInstanceVersion = make_shared<string>(boost::any_cast<string>(m["IDaaSInstanceVersion"]));
    }
    if (m.find("IDaaSRegionId") != m.end() && !m["IDaaSRegionId"].empty()) {
      IDaaSRegionId = make_shared<string>(boost::any_cast<string>(m["IDaaSRegionId"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("LocalSubnet") != m.end() && !m["LocalSubnet"].empty()) {
      localSubnet = make_shared<string>(boost::any_cast<string>(m["LocalSubnet"]));
    }
    if (m.find("MaxConnections") != m.end() && !m["MaxConnections"].empty()) {
      maxConnections = make_shared<long>(boost::any_cast<long>(m["MaxConnections"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Proto") != m.end() && !m["Proto"].empty()) {
      proto = make_shared<string>(boost::any_cast<string>(m["Proto"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SslVpnServerId") != m.end() && !m["SslVpnServerId"].empty()) {
      sslVpnServerId = make_shared<string>(boost::any_cast<string>(m["SslVpnServerId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer() = default;
};
class DescribeSslVpnServersResponseBodySslVpnServers : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer>> sslVpnServer{};

  DescribeSslVpnServersResponseBodySslVpnServers() {}

  explicit DescribeSslVpnServersResponseBodySslVpnServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sslVpnServer) {
      vector<boost::any> temp1;
      for(auto item1:*sslVpnServer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SslVpnServer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SslVpnServer") != m.end() && !m["SslVpnServer"].empty()) {
      if (typeid(vector<boost::any>) == m["SslVpnServer"].type()) {
        vector<DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SslVpnServer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sslVpnServer = make_shared<vector<DescribeSslVpnServersResponseBodySslVpnServersSslVpnServer>>(expect1);
      }
    }
  }


  virtual ~DescribeSslVpnServersResponseBodySslVpnServers() = default;
};
class DescribeSslVpnServersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSslVpnServersResponseBodySslVpnServers> sslVpnServers{};
  shared_ptr<long> totalCount{};

  DescribeSslVpnServersResponseBody() {}

  explicit DescribeSslVpnServersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sslVpnServers) {
      res["SslVpnServers"] = sslVpnServers ? boost::any(sslVpnServers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SslVpnServers") != m.end() && !m["SslVpnServers"].empty()) {
      if (typeid(map<string, boost::any>) == m["SslVpnServers"].type()) {
        DescribeSslVpnServersResponseBodySslVpnServers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SslVpnServers"]));
        sslVpnServers = make_shared<DescribeSslVpnServersResponseBodySslVpnServers>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSslVpnServersResponseBody() = default;
};
class DescribeSslVpnServersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSslVpnServersResponseBody> body{};

  DescribeSslVpnServersResponse() {}

  explicit DescribeSslVpnServersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSslVpnServersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSslVpnServersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSslVpnServersResponse() = default;
};
class DescribeTagKeysRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> maxResult{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};

  DescribeTagKeysRequest() {}

  explicit DescribeTagKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (maxResult) {
      res["MaxResult"] = boost::any(*maxResult);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("MaxResult") != m.end() && !m["MaxResult"].empty()) {
      maxResult = make_shared<long>(boost::any_cast<long>(m["MaxResult"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribeTagKeysRequest() = default;
};
class DescribeTagKeysResponseBodyTagKeysTagKey : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> type{};

  DescribeTagKeysResponseBodyTagKeysTagKey() {}

  explicit DescribeTagKeysResponseBodyTagKeysTagKey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeTagKeysResponseBodyTagKeysTagKey() = default;
};
class DescribeTagKeysResponseBodyTagKeys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTagKeysResponseBodyTagKeysTagKey>> tagKey{};

  DescribeTagKeysResponseBodyTagKeys() {}

  explicit DescribeTagKeysResponseBodyTagKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      vector<boost::any> temp1;
      for(auto item1:*tagKey){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagKey"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<DescribeTagKeysResponseBodyTagKeysTagKey> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagKey"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagKeysResponseBodyTagKeysTagKey model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagKey = make_shared<vector<DescribeTagKeysResponseBodyTagKeysTagKey>>(expect1);
      }
    }
  }


  virtual ~DescribeTagKeysResponseBodyTagKeys() = default;
};
class DescribeTagKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTagKeysResponseBodyTagKeys> tagKeys{};

  DescribeTagKeysResponseBody() {}

  explicit DescribeTagKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagKeys) {
      res["TagKeys"] = tagKeys ? boost::any(tagKeys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagKeys") != m.end() && !m["TagKeys"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagKeys"].type()) {
        DescribeTagKeysResponseBodyTagKeys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagKeys"]));
        tagKeys = make_shared<DescribeTagKeysResponseBodyTagKeys>(model1);
      }
    }
  }


  virtual ~DescribeTagKeysResponseBody() = default;
};
class DescribeTagKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTagKeysResponseBody> body{};

  DescribeTagKeysResponse() {}

  explicit DescribeTagKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagKeysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagKeysResponse() = default;
};
class DescribeTagKeysForExpressConnectRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> maxResult{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};

  DescribeTagKeysForExpressConnectRequest() {}

  explicit DescribeTagKeysForExpressConnectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (maxResult) {
      res["MaxResult"] = boost::any(*maxResult);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("MaxResult") != m.end() && !m["MaxResult"].empty()) {
      maxResult = make_shared<long>(boost::any_cast<long>(m["MaxResult"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribeTagKeysForExpressConnectRequest() = default;
};
class DescribeTagKeysForExpressConnectResponseBodyTagKeysTagKey : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> type{};

  DescribeTagKeysForExpressConnectResponseBodyTagKeysTagKey() {}

  explicit DescribeTagKeysForExpressConnectResponseBodyTagKeysTagKey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeTagKeysForExpressConnectResponseBodyTagKeysTagKey() = default;
};
class DescribeTagKeysForExpressConnectResponseBodyTagKeys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTagKeysForExpressConnectResponseBodyTagKeysTagKey>> tagKey{};

  DescribeTagKeysForExpressConnectResponseBodyTagKeys() {}

  explicit DescribeTagKeysForExpressConnectResponseBodyTagKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      vector<boost::any> temp1;
      for(auto item1:*tagKey){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagKey"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<DescribeTagKeysForExpressConnectResponseBodyTagKeysTagKey> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagKey"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagKeysForExpressConnectResponseBodyTagKeysTagKey model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagKey = make_shared<vector<DescribeTagKeysForExpressConnectResponseBodyTagKeysTagKey>>(expect1);
      }
    }
  }


  virtual ~DescribeTagKeysForExpressConnectResponseBodyTagKeys() = default;
};
class DescribeTagKeysForExpressConnectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTagKeysForExpressConnectResponseBodyTagKeys> tagKeys{};

  DescribeTagKeysForExpressConnectResponseBody() {}

  explicit DescribeTagKeysForExpressConnectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagKeys) {
      res["TagKeys"] = tagKeys ? boost::any(tagKeys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagKeys") != m.end() && !m["TagKeys"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagKeys"].type()) {
        DescribeTagKeysForExpressConnectResponseBodyTagKeys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagKeys"]));
        tagKeys = make_shared<DescribeTagKeysForExpressConnectResponseBodyTagKeys>(model1);
      }
    }
  }


  virtual ~DescribeTagKeysForExpressConnectResponseBody() = default;
};
class DescribeTagKeysForExpressConnectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTagKeysForExpressConnectResponseBody> body{};

  DescribeTagKeysForExpressConnectResponse() {}

  explicit DescribeTagKeysForExpressConnectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagKeysForExpressConnectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagKeysForExpressConnectResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagKeysForExpressConnectResponse() = default;
};
class DescribeTagsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeTagsRequestTag() {}

  explicit DescribeTagsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeTagsRequestTag() = default;
};
class DescribeTagsRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResult{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<DescribeTagsRequestTag>> tag{};

  DescribeTagsRequest() {}

  explicit DescribeTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResult) {
      res["MaxResult"] = boost::any(*maxResult);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResult") != m.end() && !m["MaxResult"].empty()) {
      maxResult = make_shared<long>(boost::any_cast<long>(m["MaxResult"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeTagsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeTagsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeTagsRequest() = default;
};
class DescribeTagsResponseBodyTagResourcesTagResource : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeTagsResponseBodyTagResourcesTagResource() {}

  explicit DescribeTagsResponseBodyTagResourcesTagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeTagsResponseBodyTagResourcesTagResource() = default;
};
class DescribeTagsResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTagsResponseBodyTagResourcesTagResource>> tagResource{};

  DescribeTagsResponseBodyTagResources() {}

  explicit DescribeTagsResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResource) {
      vector<boost::any> temp1;
      for(auto item1:*tagResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagResource") != m.end() && !m["TagResource"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResource"].type()) {
        vector<DescribeTagsResponseBodyTagResourcesTagResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagsResponseBodyTagResourcesTagResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResource = make_shared<vector<DescribeTagsResponseBodyTagResourcesTagResource>>(expect1);
      }
    }
  }


  virtual ~DescribeTagsResponseBodyTagResources() = default;
};
class DescribeTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTagsResponseBodyTagResources> tagResources{};

  DescribeTagsResponseBody() {}

  explicit DescribeTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      res["TagResources"] = tagResources ? boost::any(tagResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagResources"].type()) {
        DescribeTagsResponseBodyTagResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagResources"]));
        tagResources = make_shared<DescribeTagsResponseBodyTagResources>(model1);
      }
    }
  }


  virtual ~DescribeTagsResponseBody() = default;
};
class DescribeTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTagsResponseBody> body{};

  DescribeTagsResponse() {}

  explicit DescribeTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagsResponse() = default;
};
class DescribeVRoutersRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> VRouterId{};

  DescribeVRoutersRequest() {}

  explicit DescribeVRoutersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (VRouterId) {
      res["VRouterId"] = boost::any(*VRouterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VRouterId") != m.end() && !m["VRouterId"].empty()) {
      VRouterId = make_shared<string>(boost::any_cast<string>(m["VRouterId"]));
    }
  }


  virtual ~DescribeVRoutersRequest() = default;
};
class DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> routeTableId{};

  DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds() {}

  explicit DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RouteTableId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RouteTableId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      routeTableId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds() = default;
};
class DescribeVRoutersResponseBodyVRoutersVRouter : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds> routeTableIds{};
  shared_ptr<string> VRouterId{};
  shared_ptr<string> VRouterName{};
  shared_ptr<string> vpcId{};

  DescribeVRoutersResponseBodyVRoutersVRouter() {}

  explicit DescribeVRoutersResponseBodyVRoutersVRouter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (routeTableIds) {
      res["RouteTableIds"] = routeTableIds ? boost::any(routeTableIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (VRouterId) {
      res["VRouterId"] = boost::any(*VRouterId);
    }
    if (VRouterName) {
      res["VRouterName"] = boost::any(*VRouterName);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RouteTableIds") != m.end() && !m["RouteTableIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteTableIds"].type()) {
        DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteTableIds"]));
        routeTableIds = make_shared<DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds>(model1);
      }
    }
    if (m.find("VRouterId") != m.end() && !m["VRouterId"].empty()) {
      VRouterId = make_shared<string>(boost::any_cast<string>(m["VRouterId"]));
    }
    if (m.find("VRouterName") != m.end() && !m["VRouterName"].empty()) {
      VRouterName = make_shared<string>(boost::any_cast<string>(m["VRouterName"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeVRoutersResponseBodyVRoutersVRouter() = default;
};
class DescribeVRoutersResponseBodyVRouters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVRoutersResponseBodyVRoutersVRouter>> VRouter{};

  DescribeVRoutersResponseBodyVRouters() {}

  explicit DescribeVRoutersResponseBodyVRouters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (VRouter) {
      vector<boost::any> temp1;
      for(auto item1:*VRouter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VRouter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VRouter") != m.end() && !m["VRouter"].empty()) {
      if (typeid(vector<boost::any>) == m["VRouter"].type()) {
        vector<DescribeVRoutersResponseBodyVRoutersVRouter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VRouter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVRoutersResponseBodyVRoutersVRouter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        VRouter = make_shared<vector<DescribeVRoutersResponseBodyVRoutersVRouter>>(expect1);
      }
    }
  }


  virtual ~DescribeVRoutersResponseBodyVRouters() = default;
};
class DescribeVRoutersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeVRoutersResponseBodyVRouters> VRouters{};

  DescribeVRoutersResponseBody() {}

  explicit DescribeVRoutersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (VRouters) {
      res["VRouters"] = VRouters ? boost::any(VRouters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VRouters") != m.end() && !m["VRouters"].empty()) {
      if (typeid(map<string, boost::any>) == m["VRouters"].type()) {
        DescribeVRoutersResponseBodyVRouters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VRouters"]));
        VRouters = make_shared<DescribeVRoutersResponseBodyVRouters>(model1);
      }
    }
  }


  virtual ~DescribeVRoutersResponseBody() = default;
};
class DescribeVRoutersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVRoutersResponseBody> body{};

  DescribeVRoutersResponse() {}

  explicit DescribeVRoutersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVRoutersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVRoutersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVRoutersResponse() = default;
};
class DescribeVSwitchAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vSwitchId{};

  DescribeVSwitchAttributesRequest() {}

  explicit DescribeVSwitchAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~DescribeVSwitchAttributesRequest() = default;
};
class DescribeVSwitchAttributesResponseBodyRouteTable : public Darabonba::Model {
public:
  shared_ptr<string> routeTableId{};
  shared_ptr<string> routeTableType{};

  DescribeVSwitchAttributesResponseBodyRouteTable() {}

  explicit DescribeVSwitchAttributesResponseBodyRouteTable(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (routeTableType) {
      res["RouteTableType"] = boost::any(*routeTableType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("RouteTableType") != m.end() && !m["RouteTableType"].empty()) {
      routeTableType = make_shared<string>(boost::any_cast<string>(m["RouteTableType"]));
    }
  }


  virtual ~DescribeVSwitchAttributesResponseBodyRouteTable() = default;
};
class DescribeVSwitchAttributesResponseBodyTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeVSwitchAttributesResponseBodyTagsTag() {}

  explicit DescribeVSwitchAttributesResponseBodyTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVSwitchAttributesResponseBodyTagsTag() = default;
};
class DescribeVSwitchAttributesResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVSwitchAttributesResponseBodyTagsTag>> tag{};

  DescribeVSwitchAttributesResponseBodyTags() {}

  explicit DescribeVSwitchAttributesResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeVSwitchAttributesResponseBodyTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVSwitchAttributesResponseBodyTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeVSwitchAttributesResponseBodyTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeVSwitchAttributesResponseBodyTags() = default;
};
class DescribeVSwitchAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> availableIpAddressCount{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabledIpv6{};
  shared_ptr<string> ipv6CidrBlock{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> networkAclId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<DescribeVSwitchAttributesResponseBodyRouteTable> routeTable{};
  shared_ptr<string> shareType{};
  shared_ptr<string> status{};
  shared_ptr<DescribeVSwitchAttributesResponseBodyTags> tags{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vSwitchName{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  DescribeVSwitchAttributesResponseBody() {}

  explicit DescribeVSwitchAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableIpAddressCount) {
      res["AvailableIpAddressCount"] = boost::any(*availableIpAddressCount);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabledIpv6) {
      res["EnabledIpv6"] = boost::any(*enabledIpv6);
    }
    if (ipv6CidrBlock) {
      res["Ipv6CidrBlock"] = boost::any(*ipv6CidrBlock);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (routeTable) {
      res["RouteTable"] = routeTable ? boost::any(routeTable->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (shareType) {
      res["ShareType"] = boost::any(*shareType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableIpAddressCount") != m.end() && !m["AvailableIpAddressCount"].empty()) {
      availableIpAddressCount = make_shared<long>(boost::any_cast<long>(m["AvailableIpAddressCount"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnabledIpv6") != m.end() && !m["EnabledIpv6"].empty()) {
      enabledIpv6 = make_shared<bool>(boost::any_cast<bool>(m["EnabledIpv6"]));
    }
    if (m.find("Ipv6CidrBlock") != m.end() && !m["Ipv6CidrBlock"].empty()) {
      ipv6CidrBlock = make_shared<string>(boost::any_cast<string>(m["Ipv6CidrBlock"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RouteTable") != m.end() && !m["RouteTable"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteTable"].type()) {
        DescribeVSwitchAttributesResponseBodyRouteTable model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteTable"]));
        routeTable = make_shared<DescribeVSwitchAttributesResponseBodyRouteTable>(model1);
      }
    }
    if (m.find("ShareType") != m.end() && !m["ShareType"].empty()) {
      shareType = make_shared<string>(boost::any_cast<string>(m["ShareType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeVSwitchAttributesResponseBodyTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeVSwitchAttributesResponseBodyTags>(model1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeVSwitchAttributesResponseBody() = default;
};
class DescribeVSwitchAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVSwitchAttributesResponseBody> body{};

  DescribeVSwitchAttributesResponse() {}

  explicit DescribeVSwitchAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVSwitchAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVSwitchAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVSwitchAttributesResponse() = default;
};
class DescribeVSwitchesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeVSwitchesRequestTag() {}

  explicit DescribeVSwitchesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVSwitchesRequestTag() = default;
};
class DescribeVSwitchesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<bool> enableIpv6{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeTableId{};
  shared_ptr<vector<DescribeVSwitchesRequestTag>> tag{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vSwitchName{};
  shared_ptr<long> vSwitchOwnerId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  DescribeVSwitchesRequest() {}

  explicit DescribeVSwitchesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (enableIpv6) {
      res["EnableIpv6"] = boost::any(*enableIpv6);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    if (vSwitchOwnerId) {
      res["VSwitchOwnerId"] = boost::any(*vSwitchOwnerId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EnableIpv6") != m.end() && !m["EnableIpv6"].empty()) {
      enableIpv6 = make_shared<bool>(boost::any_cast<bool>(m["EnableIpv6"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeVSwitchesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVSwitchesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeVSwitchesRequestTag>>(expect1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
    if (m.find("VSwitchOwnerId") != m.end() && !m["VSwitchOwnerId"].empty()) {
      vSwitchOwnerId = make_shared<long>(boost::any_cast<long>(m["VSwitchOwnerId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeVSwitchesRequest() = default;
};
class DescribeVSwitchesResponseBodyVSwitchesVSwitchRouteTable : public Darabonba::Model {
public:
  shared_ptr<string> routeTableId{};
  shared_ptr<string> routeTableType{};

  DescribeVSwitchesResponseBodyVSwitchesVSwitchRouteTable() {}

  explicit DescribeVSwitchesResponseBodyVSwitchesVSwitchRouteTable(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (routeTableType) {
      res["RouteTableType"] = boost::any(*routeTableType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("RouteTableType") != m.end() && !m["RouteTableType"].empty()) {
      routeTableType = make_shared<string>(boost::any_cast<string>(m["RouteTableType"]));
    }
  }


  virtual ~DescribeVSwitchesResponseBodyVSwitchesVSwitchRouteTable() = default;
};
class DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag() {}

  explicit DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag() = default;
};
class DescribeVSwitchesResponseBodyVSwitchesVSwitchTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag>> tag{};

  DescribeVSwitchesResponseBodyVSwitchesVSwitchTags() {}

  explicit DescribeVSwitchesResponseBodyVSwitchesVSwitchTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeVSwitchesResponseBodyVSwitchesVSwitchTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeVSwitchesResponseBodyVSwitchesVSwitchTags() = default;
};
class DescribeVSwitchesResponseBodyVSwitchesVSwitch : public Darabonba::Model {
public:
  shared_ptr<long> availableIpAddressCount{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabledIpv6{};
  shared_ptr<string> ipv6CidrBlock{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> networkAclId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<DescribeVSwitchesResponseBodyVSwitchesVSwitchRouteTable> routeTable{};
  shared_ptr<string> shareType{};
  shared_ptr<string> status{};
  shared_ptr<DescribeVSwitchesResponseBodyVSwitchesVSwitchTags> tags{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vSwitchName{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  DescribeVSwitchesResponseBodyVSwitchesVSwitch() {}

  explicit DescribeVSwitchesResponseBodyVSwitchesVSwitch(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableIpAddressCount) {
      res["AvailableIpAddressCount"] = boost::any(*availableIpAddressCount);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabledIpv6) {
      res["EnabledIpv6"] = boost::any(*enabledIpv6);
    }
    if (ipv6CidrBlock) {
      res["Ipv6CidrBlock"] = boost::any(*ipv6CidrBlock);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (routeTable) {
      res["RouteTable"] = routeTable ? boost::any(routeTable->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (shareType) {
      res["ShareType"] = boost::any(*shareType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableIpAddressCount") != m.end() && !m["AvailableIpAddressCount"].empty()) {
      availableIpAddressCount = make_shared<long>(boost::any_cast<long>(m["AvailableIpAddressCount"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnabledIpv6") != m.end() && !m["EnabledIpv6"].empty()) {
      enabledIpv6 = make_shared<bool>(boost::any_cast<bool>(m["EnabledIpv6"]));
    }
    if (m.find("Ipv6CidrBlock") != m.end() && !m["Ipv6CidrBlock"].empty()) {
      ipv6CidrBlock = make_shared<string>(boost::any_cast<string>(m["Ipv6CidrBlock"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RouteTable") != m.end() && !m["RouteTable"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteTable"].type()) {
        DescribeVSwitchesResponseBodyVSwitchesVSwitchRouteTable model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteTable"]));
        routeTable = make_shared<DescribeVSwitchesResponseBodyVSwitchesVSwitchRouteTable>(model1);
      }
    }
    if (m.find("ShareType") != m.end() && !m["ShareType"].empty()) {
      shareType = make_shared<string>(boost::any_cast<string>(m["ShareType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeVSwitchesResponseBodyVSwitchesVSwitchTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeVSwitchesResponseBodyVSwitchesVSwitchTags>(model1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeVSwitchesResponseBodyVSwitchesVSwitch() = default;
};
class DescribeVSwitchesResponseBodyVSwitches : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVSwitchesResponseBodyVSwitchesVSwitch>> vSwitch{};

  DescribeVSwitchesResponseBodyVSwitches() {}

  explicit DescribeVSwitchesResponseBodyVSwitches(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitch) {
      vector<boost::any> temp1;
      for(auto item1:*vSwitch){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VSwitch"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitch") != m.end() && !m["VSwitch"].empty()) {
      if (typeid(vector<boost::any>) == m["VSwitch"].type()) {
        vector<DescribeVSwitchesResponseBodyVSwitchesVSwitch> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VSwitch"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVSwitchesResponseBodyVSwitchesVSwitch model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vSwitch = make_shared<vector<DescribeVSwitchesResponseBodyVSwitchesVSwitch>>(expect1);
      }
    }
  }


  virtual ~DescribeVSwitchesResponseBodyVSwitches() = default;
};
class DescribeVSwitchesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeVSwitchesResponseBodyVSwitches> vSwitches{};

  DescribeVSwitchesResponseBody() {}

  explicit DescribeVSwitchesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vSwitches) {
      res["VSwitches"] = vSwitches ? boost::any(vSwitches->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VSwitches") != m.end() && !m["VSwitches"].empty()) {
      if (typeid(map<string, boost::any>) == m["VSwitches"].type()) {
        DescribeVSwitchesResponseBodyVSwitches model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VSwitches"]));
        vSwitches = make_shared<DescribeVSwitchesResponseBodyVSwitches>(model1);
      }
    }
  }


  virtual ~DescribeVSwitchesResponseBody() = default;
};
class DescribeVSwitchesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVSwitchesResponseBody> body{};

  DescribeVSwitchesResponse() {}

  explicit DescribeVSwitchesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVSwitchesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVSwitchesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVSwitchesResponse() = default;
};
class DescribeVbrHaRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vbrHaId{};
  shared_ptr<string> vbrId{};

  DescribeVbrHaRequest() {}

  explicit DescribeVbrHaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vbrHaId) {
      res["VbrHaId"] = boost::any(*vbrHaId);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VbrHaId") != m.end() && !m["VbrHaId"].empty()) {
      vbrHaId = make_shared<string>(boost::any_cast<string>(m["VbrHaId"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
  }


  virtual ~DescribeVbrHaRequest() = default;
};
class DescribeVbrHaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> peerVbrId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<string> vbrHaId{};
  shared_ptr<string> vbrId{};

  DescribeVbrHaResponseBody() {}

  explicit DescribeVbrHaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (peerVbrId) {
      res["PeerVbrId"] = boost::any(*peerVbrId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vbrHaId) {
      res["VbrHaId"] = boost::any(*vbrHaId);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PeerVbrId") != m.end() && !m["PeerVbrId"].empty()) {
      peerVbrId = make_shared<string>(boost::any_cast<string>(m["PeerVbrId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VbrHaId") != m.end() && !m["VbrHaId"].empty()) {
      vbrHaId = make_shared<string>(boost::any_cast<string>(m["VbrHaId"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
  }


  virtual ~DescribeVbrHaResponseBody() = default;
};
class DescribeVbrHaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVbrHaResponseBody> body{};

  DescribeVbrHaResponse() {}

  explicit DescribeVbrHaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVbrHaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVbrHaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVbrHaResponse() = default;
};
class DescribeVcoRouteEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeEntryType{};
  shared_ptr<string> vpnConnectionId{};

  DescribeVcoRouteEntriesRequest() {}

  explicit DescribeVcoRouteEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeEntryType) {
      res["RouteEntryType"] = boost::any(*routeEntryType);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteEntryType") != m.end() && !m["RouteEntryType"].empty()) {
      routeEntryType = make_shared<string>(boost::any_cast<string>(m["RouteEntryType"]));
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
  }


  virtual ~DescribeVcoRouteEntriesRequest() = default;
};
class DescribeVcoRouteEntriesResponseBodyVcoRouteEntries : public Darabonba::Model {
public:
  shared_ptr<string> asPath{};
  shared_ptr<string> community{};
  shared_ptr<long> createTime{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> routeDest{};
  shared_ptr<string> routeEntryType{};
  shared_ptr<string> source{};
  shared_ptr<string> state{};
  shared_ptr<string> vpnConnectionId{};
  shared_ptr<long> weight{};

  DescribeVcoRouteEntriesResponseBodyVcoRouteEntries() {}

  explicit DescribeVcoRouteEntriesResponseBodyVcoRouteEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asPath) {
      res["AsPath"] = boost::any(*asPath);
    }
    if (community) {
      res["Community"] = boost::any(*community);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (routeDest) {
      res["RouteDest"] = boost::any(*routeDest);
    }
    if (routeEntryType) {
      res["RouteEntryType"] = boost::any(*routeEntryType);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsPath") != m.end() && !m["AsPath"].empty()) {
      asPath = make_shared<string>(boost::any_cast<string>(m["AsPath"]));
    }
    if (m.find("Community") != m.end() && !m["Community"].empty()) {
      community = make_shared<string>(boost::any_cast<string>(m["Community"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("RouteDest") != m.end() && !m["RouteDest"].empty()) {
      routeDest = make_shared<string>(boost::any_cast<string>(m["RouteDest"]));
    }
    if (m.find("RouteEntryType") != m.end() && !m["RouteEntryType"].empty()) {
      routeEntryType = make_shared<string>(boost::any_cast<string>(m["RouteEntryType"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DescribeVcoRouteEntriesResponseBodyVcoRouteEntries() = default;
};
class DescribeVcoRouteEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeVcoRouteEntriesResponseBodyVcoRouteEntries>> vcoRouteEntries{};

  DescribeVcoRouteEntriesResponseBody() {}

  explicit DescribeVcoRouteEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vcoRouteEntries) {
      vector<boost::any> temp1;
      for(auto item1:*vcoRouteEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VcoRouteEntries"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VcoRouteEntries") != m.end() && !m["VcoRouteEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["VcoRouteEntries"].type()) {
        vector<DescribeVcoRouteEntriesResponseBodyVcoRouteEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VcoRouteEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVcoRouteEntriesResponseBodyVcoRouteEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vcoRouteEntries = make_shared<vector<DescribeVcoRouteEntriesResponseBodyVcoRouteEntries>>(expect1);
      }
    }
  }


  virtual ~DescribeVcoRouteEntriesResponseBody() = default;
};
class DescribeVcoRouteEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVcoRouteEntriesResponseBody> body{};

  DescribeVcoRouteEntriesResponse() {}

  explicit DescribeVcoRouteEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVcoRouteEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVcoRouteEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVcoRouteEntriesResponse() = default;
};
class DescribeVirtualBorderRoutersRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> value{};

  DescribeVirtualBorderRoutersRequestFilter() {}

  explicit DescribeVirtualBorderRoutersRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVirtualBorderRoutersRequestFilter() = default;
};
class DescribeVirtualBorderRoutersRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeVirtualBorderRoutersRequestTags() {}

  explicit DescribeVirtualBorderRoutersRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVirtualBorderRoutersRequestTags() = default;
};
class DescribeVirtualBorderRoutersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVirtualBorderRoutersRequestFilter>> filter{};
  shared_ptr<bool> includeCrossAccountVbr{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<DescribeVirtualBorderRoutersRequestTags>> tags{};

  DescribeVirtualBorderRoutersRequest() {}

  explicit DescribeVirtualBorderRoutersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    if (includeCrossAccountVbr) {
      res["IncludeCrossAccountVbr"] = boost::any(*includeCrossAccountVbr);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeVirtualBorderRoutersRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVirtualBorderRoutersRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeVirtualBorderRoutersRequestFilter>>(expect1);
      }
    }
    if (m.find("IncludeCrossAccountVbr") != m.end() && !m["IncludeCrossAccountVbr"].empty()) {
      includeCrossAccountVbr = make_shared<bool>(boost::any_cast<bool>(m["IncludeCrossAccountVbr"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeVirtualBorderRoutersRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVirtualBorderRoutersRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeVirtualBorderRoutersRequestTags>>(expect1);
      }
    }
  }


  virtual ~DescribeVirtualBorderRoutersRequest() = default;
};
class DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCensAssociatedCen : public Darabonba::Model {
public:
  shared_ptr<string> cenId{};
  shared_ptr<long> cenOwnerId{};
  shared_ptr<string> cenStatus{};

  DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCensAssociatedCen() {}

  explicit DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCensAssociatedCen(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cenId) {
      res["CenId"] = boost::any(*cenId);
    }
    if (cenOwnerId) {
      res["CenOwnerId"] = boost::any(*cenOwnerId);
    }
    if (cenStatus) {
      res["CenStatus"] = boost::any(*cenStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CenId") != m.end() && !m["CenId"].empty()) {
      cenId = make_shared<string>(boost::any_cast<string>(m["CenId"]));
    }
    if (m.find("CenOwnerId") != m.end() && !m["CenOwnerId"].empty()) {
      cenOwnerId = make_shared<long>(boost::any_cast<long>(m["CenOwnerId"]));
    }
    if (m.find("CenStatus") != m.end() && !m["CenStatus"].empty()) {
      cenStatus = make_shared<string>(boost::any_cast<string>(m["CenStatus"]));
    }
  }


  virtual ~DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCensAssociatedCen() = default;
};
class DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCens : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCensAssociatedCen>> associatedCen{};

  DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCens() {}

  explicit DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCens(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associatedCen) {
      vector<boost::any> temp1;
      for(auto item1:*associatedCen){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AssociatedCen"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociatedCen") != m.end() && !m["AssociatedCen"].empty()) {
      if (typeid(vector<boost::any>) == m["AssociatedCen"].type()) {
        vector<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCensAssociatedCen> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AssociatedCen"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCensAssociatedCen model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        associatedCen = make_shared<vector<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCensAssociatedCen>>(expect1);
      }
    }
  }


  virtual ~DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCens() = default;
};
class DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection : public Darabonba::Model {
public:
  shared_ptr<string> circuitCode{};
  shared_ptr<bool> enableIpv6{};
  shared_ptr<string> localGatewayIp{};
  shared_ptr<string> localIpv6GatewayIp{};
  shared_ptr<string> peerGatewayIp{};
  shared_ptr<string> peerIpv6GatewayIp{};
  shared_ptr<string> peeringIpv6SubnetMask{};
  shared_ptr<string> peeringSubnetMask{};
  shared_ptr<string> physicalConnectionBusinessStatus{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> physicalConnectionOwnerUid{};
  shared_ptr<string> physicalConnectionStatus{};
  shared_ptr<string> status{};
  shared_ptr<string> vlanId{};
  shared_ptr<string> vlanInterfaceId{};

  DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection() {}

  explicit DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (circuitCode) {
      res["CircuitCode"] = boost::any(*circuitCode);
    }
    if (enableIpv6) {
      res["EnableIpv6"] = boost::any(*enableIpv6);
    }
    if (localGatewayIp) {
      res["LocalGatewayIp"] = boost::any(*localGatewayIp);
    }
    if (localIpv6GatewayIp) {
      res["LocalIpv6GatewayIp"] = boost::any(*localIpv6GatewayIp);
    }
    if (peerGatewayIp) {
      res["PeerGatewayIp"] = boost::any(*peerGatewayIp);
    }
    if (peerIpv6GatewayIp) {
      res["PeerIpv6GatewayIp"] = boost::any(*peerIpv6GatewayIp);
    }
    if (peeringIpv6SubnetMask) {
      res["PeeringIpv6SubnetMask"] = boost::any(*peeringIpv6SubnetMask);
    }
    if (peeringSubnetMask) {
      res["PeeringSubnetMask"] = boost::any(*peeringSubnetMask);
    }
    if (physicalConnectionBusinessStatus) {
      res["PhysicalConnectionBusinessStatus"] = boost::any(*physicalConnectionBusinessStatus);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (physicalConnectionOwnerUid) {
      res["PhysicalConnectionOwnerUid"] = boost::any(*physicalConnectionOwnerUid);
    }
    if (physicalConnectionStatus) {
      res["PhysicalConnectionStatus"] = boost::any(*physicalConnectionStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vlanId) {
      res["VlanId"] = boost::any(*vlanId);
    }
    if (vlanInterfaceId) {
      res["VlanInterfaceId"] = boost::any(*vlanInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CircuitCode") != m.end() && !m["CircuitCode"].empty()) {
      circuitCode = make_shared<string>(boost::any_cast<string>(m["CircuitCode"]));
    }
    if (m.find("EnableIpv6") != m.end() && !m["EnableIpv6"].empty()) {
      enableIpv6 = make_shared<bool>(boost::any_cast<bool>(m["EnableIpv6"]));
    }
    if (m.find("LocalGatewayIp") != m.end() && !m["LocalGatewayIp"].empty()) {
      localGatewayIp = make_shared<string>(boost::any_cast<string>(m["LocalGatewayIp"]));
    }
    if (m.find("LocalIpv6GatewayIp") != m.end() && !m["LocalIpv6GatewayIp"].empty()) {
      localIpv6GatewayIp = make_shared<string>(boost::any_cast<string>(m["LocalIpv6GatewayIp"]));
    }
    if (m.find("PeerGatewayIp") != m.end() && !m["PeerGatewayIp"].empty()) {
      peerGatewayIp = make_shared<string>(boost::any_cast<string>(m["PeerGatewayIp"]));
    }
    if (m.find("PeerIpv6GatewayIp") != m.end() && !m["PeerIpv6GatewayIp"].empty()) {
      peerIpv6GatewayIp = make_shared<string>(boost::any_cast<string>(m["PeerIpv6GatewayIp"]));
    }
    if (m.find("PeeringIpv6SubnetMask") != m.end() && !m["PeeringIpv6SubnetMask"].empty()) {
      peeringIpv6SubnetMask = make_shared<string>(boost::any_cast<string>(m["PeeringIpv6SubnetMask"]));
    }
    if (m.find("PeeringSubnetMask") != m.end() && !m["PeeringSubnetMask"].empty()) {
      peeringSubnetMask = make_shared<string>(boost::any_cast<string>(m["PeeringSubnetMask"]));
    }
    if (m.find("PhysicalConnectionBusinessStatus") != m.end() && !m["PhysicalConnectionBusinessStatus"].empty()) {
      physicalConnectionBusinessStatus = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionBusinessStatus"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("PhysicalConnectionOwnerUid") != m.end() && !m["PhysicalConnectionOwnerUid"].empty()) {
      physicalConnectionOwnerUid = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionOwnerUid"]));
    }
    if (m.find("PhysicalConnectionStatus") != m.end() && !m["PhysicalConnectionStatus"].empty()) {
      physicalConnectionStatus = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VlanId") != m.end() && !m["VlanId"].empty()) {
      vlanId = make_shared<string>(boost::any_cast<string>(m["VlanId"]));
    }
    if (m.find("VlanInterfaceId") != m.end() && !m["VlanInterfaceId"].empty()) {
      vlanInterfaceId = make_shared<string>(boost::any_cast<string>(m["VlanInterfaceId"]));
    }
  }


  virtual ~DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection() = default;
};
class DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnections : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection>> associatedPhysicalConnection{};

  DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnections() {}

  explicit DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnections(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associatedPhysicalConnection) {
      vector<boost::any> temp1;
      for(auto item1:*associatedPhysicalConnection){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AssociatedPhysicalConnection"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociatedPhysicalConnection") != m.end() && !m["AssociatedPhysicalConnection"].empty()) {
      if (typeid(vector<boost::any>) == m["AssociatedPhysicalConnection"].type()) {
        vector<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AssociatedPhysicalConnection"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        associatedPhysicalConnection = make_shared<vector<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnectionsAssociatedPhysicalConnection>>(expect1);
      }
    }
  }


  virtual ~DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnections() = default;
};
class DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTagsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTagsTags() {}

  explicit DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTagsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTagsTags() = default;
};
class DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTagsTags>> tags{};

  DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTags() {}

  explicit DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTagsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTagsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTagsTags>>(expect1);
      }
    }
  }


  virtual ~DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTags() = default;
};
class DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType : public Darabonba::Model {
public:
  shared_ptr<string> accessPointId{};
  shared_ptr<string> activationTime{};
  shared_ptr<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCens> associatedCens{};
  shared_ptr<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnections> associatedPhysicalConnections{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> circuitCode{};
  shared_ptr<string> cloudBoxInstanceId{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<long> detectMultiplier{};
  shared_ptr<string> eccId{};
  shared_ptr<string> ecrAttatchStatus{};
  shared_ptr<string> ecrId{};
  shared_ptr<string> ecrOwnerId{};
  shared_ptr<bool> enableIpv6{};
  shared_ptr<string> localGatewayIp{};
  shared_ptr<string> localIpv6GatewayIp{};
  shared_ptr<long> minRxInterval{};
  shared_ptr<long> minTxInterval{};
  shared_ptr<string> name{};
  shared_ptr<string> PConnVbrChargeType{};
  shared_ptr<string> PConnVbrExpireTime{};
  shared_ptr<string> peerGatewayIp{};
  shared_ptr<string> peerIpv6GatewayIp{};
  shared_ptr<string> peeringIpv6SubnetMask{};
  shared_ptr<string> peeringSubnetMask{};
  shared_ptr<string> physicalConnectionBusinessStatus{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> physicalConnectionOwnerUid{};
  shared_ptr<string> physicalConnectionStatus{};
  shared_ptr<string> recoveryTime{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> routeTableId{};
  shared_ptr<bool> sitelinkEnable{};
  shared_ptr<string> status{};
  shared_ptr<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTags> tags{};
  shared_ptr<string> terminationTime{};
  shared_ptr<string> type{};
  shared_ptr<string> vbrId{};
  shared_ptr<long> vlanId{};
  shared_ptr<string> vlanInterfaceId{};

  DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType() {}

  explicit DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (activationTime) {
      res["ActivationTime"] = boost::any(*activationTime);
    }
    if (associatedCens) {
      res["AssociatedCens"] = associatedCens ? boost::any(associatedCens->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (associatedPhysicalConnections) {
      res["AssociatedPhysicalConnections"] = associatedPhysicalConnections ? boost::any(associatedPhysicalConnections->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (circuitCode) {
      res["CircuitCode"] = boost::any(*circuitCode);
    }
    if (cloudBoxInstanceId) {
      res["CloudBoxInstanceId"] = boost::any(*cloudBoxInstanceId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (detectMultiplier) {
      res["DetectMultiplier"] = boost::any(*detectMultiplier);
    }
    if (eccId) {
      res["EccId"] = boost::any(*eccId);
    }
    if (ecrAttatchStatus) {
      res["EcrAttatchStatus"] = boost::any(*ecrAttatchStatus);
    }
    if (ecrId) {
      res["EcrId"] = boost::any(*ecrId);
    }
    if (ecrOwnerId) {
      res["EcrOwnerId"] = boost::any(*ecrOwnerId);
    }
    if (enableIpv6) {
      res["EnableIpv6"] = boost::any(*enableIpv6);
    }
    if (localGatewayIp) {
      res["LocalGatewayIp"] = boost::any(*localGatewayIp);
    }
    if (localIpv6GatewayIp) {
      res["LocalIpv6GatewayIp"] = boost::any(*localIpv6GatewayIp);
    }
    if (minRxInterval) {
      res["MinRxInterval"] = boost::any(*minRxInterval);
    }
    if (minTxInterval) {
      res["MinTxInterval"] = boost::any(*minTxInterval);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (PConnVbrChargeType) {
      res["PConnVbrChargeType"] = boost::any(*PConnVbrChargeType);
    }
    if (PConnVbrExpireTime) {
      res["PConnVbrExpireTime"] = boost::any(*PConnVbrExpireTime);
    }
    if (peerGatewayIp) {
      res["PeerGatewayIp"] = boost::any(*peerGatewayIp);
    }
    if (peerIpv6GatewayIp) {
      res["PeerIpv6GatewayIp"] = boost::any(*peerIpv6GatewayIp);
    }
    if (peeringIpv6SubnetMask) {
      res["PeeringIpv6SubnetMask"] = boost::any(*peeringIpv6SubnetMask);
    }
    if (peeringSubnetMask) {
      res["PeeringSubnetMask"] = boost::any(*peeringSubnetMask);
    }
    if (physicalConnectionBusinessStatus) {
      res["PhysicalConnectionBusinessStatus"] = boost::any(*physicalConnectionBusinessStatus);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (physicalConnectionOwnerUid) {
      res["PhysicalConnectionOwnerUid"] = boost::any(*physicalConnectionOwnerUid);
    }
    if (physicalConnectionStatus) {
      res["PhysicalConnectionStatus"] = boost::any(*physicalConnectionStatus);
    }
    if (recoveryTime) {
      res["RecoveryTime"] = boost::any(*recoveryTime);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (sitelinkEnable) {
      res["SitelinkEnable"] = boost::any(*sitelinkEnable);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (terminationTime) {
      res["TerminationTime"] = boost::any(*terminationTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    if (vlanId) {
      res["VlanId"] = boost::any(*vlanId);
    }
    if (vlanInterfaceId) {
      res["VlanInterfaceId"] = boost::any(*vlanInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<string>(boost::any_cast<string>(m["AccessPointId"]));
    }
    if (m.find("ActivationTime") != m.end() && !m["ActivationTime"].empty()) {
      activationTime = make_shared<string>(boost::any_cast<string>(m["ActivationTime"]));
    }
    if (m.find("AssociatedCens") != m.end() && !m["AssociatedCens"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssociatedCens"].type()) {
        DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCens model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssociatedCens"]));
        associatedCens = make_shared<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedCens>(model1);
      }
    }
    if (m.find("AssociatedPhysicalConnections") != m.end() && !m["AssociatedPhysicalConnections"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssociatedPhysicalConnections"].type()) {
        DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnections model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssociatedPhysicalConnections"]));
        associatedPhysicalConnections = make_shared<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeAssociatedPhysicalConnections>(model1);
      }
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("CircuitCode") != m.end() && !m["CircuitCode"].empty()) {
      circuitCode = make_shared<string>(boost::any_cast<string>(m["CircuitCode"]));
    }
    if (m.find("CloudBoxInstanceId") != m.end() && !m["CloudBoxInstanceId"].empty()) {
      cloudBoxInstanceId = make_shared<string>(boost::any_cast<string>(m["CloudBoxInstanceId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DetectMultiplier") != m.end() && !m["DetectMultiplier"].empty()) {
      detectMultiplier = make_shared<long>(boost::any_cast<long>(m["DetectMultiplier"]));
    }
    if (m.find("EccId") != m.end() && !m["EccId"].empty()) {
      eccId = make_shared<string>(boost::any_cast<string>(m["EccId"]));
    }
    if (m.find("EcrAttatchStatus") != m.end() && !m["EcrAttatchStatus"].empty()) {
      ecrAttatchStatus = make_shared<string>(boost::any_cast<string>(m["EcrAttatchStatus"]));
    }
    if (m.find("EcrId") != m.end() && !m["EcrId"].empty()) {
      ecrId = make_shared<string>(boost::any_cast<string>(m["EcrId"]));
    }
    if (m.find("EcrOwnerId") != m.end() && !m["EcrOwnerId"].empty()) {
      ecrOwnerId = make_shared<string>(boost::any_cast<string>(m["EcrOwnerId"]));
    }
    if (m.find("EnableIpv6") != m.end() && !m["EnableIpv6"].empty()) {
      enableIpv6 = make_shared<bool>(boost::any_cast<bool>(m["EnableIpv6"]));
    }
    if (m.find("LocalGatewayIp") != m.end() && !m["LocalGatewayIp"].empty()) {
      localGatewayIp = make_shared<string>(boost::any_cast<string>(m["LocalGatewayIp"]));
    }
    if (m.find("LocalIpv6GatewayIp") != m.end() && !m["LocalIpv6GatewayIp"].empty()) {
      localIpv6GatewayIp = make_shared<string>(boost::any_cast<string>(m["LocalIpv6GatewayIp"]));
    }
    if (m.find("MinRxInterval") != m.end() && !m["MinRxInterval"].empty()) {
      minRxInterval = make_shared<long>(boost::any_cast<long>(m["MinRxInterval"]));
    }
    if (m.find("MinTxInterval") != m.end() && !m["MinTxInterval"].empty()) {
      minTxInterval = make_shared<long>(boost::any_cast<long>(m["MinTxInterval"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PConnVbrChargeType") != m.end() && !m["PConnVbrChargeType"].empty()) {
      PConnVbrChargeType = make_shared<string>(boost::any_cast<string>(m["PConnVbrChargeType"]));
    }
    if (m.find("PConnVbrExpireTime") != m.end() && !m["PConnVbrExpireTime"].empty()) {
      PConnVbrExpireTime = make_shared<string>(boost::any_cast<string>(m["PConnVbrExpireTime"]));
    }
    if (m.find("PeerGatewayIp") != m.end() && !m["PeerGatewayIp"].empty()) {
      peerGatewayIp = make_shared<string>(boost::any_cast<string>(m["PeerGatewayIp"]));
    }
    if (m.find("PeerIpv6GatewayIp") != m.end() && !m["PeerIpv6GatewayIp"].empty()) {
      peerIpv6GatewayIp = make_shared<string>(boost::any_cast<string>(m["PeerIpv6GatewayIp"]));
    }
    if (m.find("PeeringIpv6SubnetMask") != m.end() && !m["PeeringIpv6SubnetMask"].empty()) {
      peeringIpv6SubnetMask = make_shared<string>(boost::any_cast<string>(m["PeeringIpv6SubnetMask"]));
    }
    if (m.find("PeeringSubnetMask") != m.end() && !m["PeeringSubnetMask"].empty()) {
      peeringSubnetMask = make_shared<string>(boost::any_cast<string>(m["PeeringSubnetMask"]));
    }
    if (m.find("PhysicalConnectionBusinessStatus") != m.end() && !m["PhysicalConnectionBusinessStatus"].empty()) {
      physicalConnectionBusinessStatus = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionBusinessStatus"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("PhysicalConnectionOwnerUid") != m.end() && !m["PhysicalConnectionOwnerUid"].empty()) {
      physicalConnectionOwnerUid = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionOwnerUid"]));
    }
    if (m.find("PhysicalConnectionStatus") != m.end() && !m["PhysicalConnectionStatus"].empty()) {
      physicalConnectionStatus = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionStatus"]));
    }
    if (m.find("RecoveryTime") != m.end() && !m["RecoveryTime"].empty()) {
      recoveryTime = make_shared<string>(boost::any_cast<string>(m["RecoveryTime"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("SitelinkEnable") != m.end() && !m["SitelinkEnable"].empty()) {
      sitelinkEnable = make_shared<bool>(boost::any_cast<bool>(m["SitelinkEnable"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterTypeTags>(model1);
      }
    }
    if (m.find("TerminationTime") != m.end() && !m["TerminationTime"].empty()) {
      terminationTime = make_shared<string>(boost::any_cast<string>(m["TerminationTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
    if (m.find("VlanId") != m.end() && !m["VlanId"].empty()) {
      vlanId = make_shared<long>(boost::any_cast<long>(m["VlanId"]));
    }
    if (m.find("VlanInterfaceId") != m.end() && !m["VlanInterfaceId"].empty()) {
      vlanInterfaceId = make_shared<string>(boost::any_cast<string>(m["VlanInterfaceId"]));
    }
  }


  virtual ~DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType() = default;
};
class DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType>> virtualBorderRouterType{};

  DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet() {}

  explicit DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (virtualBorderRouterType) {
      vector<boost::any> temp1;
      for(auto item1:*virtualBorderRouterType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VirtualBorderRouterType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VirtualBorderRouterType") != m.end() && !m["VirtualBorderRouterType"].empty()) {
      if (typeid(vector<boost::any>) == m["VirtualBorderRouterType"].type()) {
        vector<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VirtualBorderRouterType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        virtualBorderRouterType = make_shared<vector<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType>>(expect1);
      }
    }
  }


  virtual ~DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet() = default;
};
class DescribeVirtualBorderRoutersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet> virtualBorderRouterSet{};

  DescribeVirtualBorderRoutersResponseBody() {}

  explicit DescribeVirtualBorderRoutersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (virtualBorderRouterSet) {
      res["VirtualBorderRouterSet"] = virtualBorderRouterSet ? boost::any(virtualBorderRouterSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VirtualBorderRouterSet") != m.end() && !m["VirtualBorderRouterSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["VirtualBorderRouterSet"].type()) {
        DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VirtualBorderRouterSet"]));
        virtualBorderRouterSet = make_shared<DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet>(model1);
      }
    }
  }


  virtual ~DescribeVirtualBorderRoutersResponseBody() = default;
};
class DescribeVirtualBorderRoutersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVirtualBorderRoutersResponseBody> body{};

  DescribeVirtualBorderRoutersResponse() {}

  explicit DescribeVirtualBorderRoutersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVirtualBorderRoutersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVirtualBorderRoutersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVirtualBorderRoutersResponse() = default;
};
class DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> value{};

  DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter() {}

  explicit DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter() = default;
};
class DescribeVirtualBorderRoutersForPhysicalConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter>> filter{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DescribeVirtualBorderRoutersForPhysicalConnectionRequest() {}

  explicit DescribeVirtualBorderRoutersForPhysicalConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeVirtualBorderRoutersForPhysicalConnectionRequest() = default;
};
class DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType : public Darabonba::Model {
public:
  shared_ptr<string> activationTime{};
  shared_ptr<string> bandwidth{};
  shared_ptr<string> bandwidthStatus{};
  shared_ptr<string> circuitCode{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> eccId{};
  shared_ptr<bool> enableIpv6{};
  shared_ptr<string> localGatewayIp{};
  shared_ptr<string> localIpv6GatewayIp{};
  shared_ptr<string> PConnVbrBussinessStatus{};
  shared_ptr<string> PConnVbrChargeType{};
  shared_ptr<string> PConnVbrExpireTime{};
  shared_ptr<string> peerGatewayIp{};
  shared_ptr<string> peerIpv6GatewayIp{};
  shared_ptr<string> peeringIpv6SubnetMask{};
  shared_ptr<string> peeringSubnetMask{};
  shared_ptr<string> recoveryTime{};
  shared_ptr<string> status{};
  shared_ptr<string> terminationTime{};
  shared_ptr<string> type{};
  shared_ptr<string> vbrId{};
  shared_ptr<long> vbrOwnerUid{};
  shared_ptr<long> vlanId{};

  DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType() {}

  explicit DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activationTime) {
      res["ActivationTime"] = boost::any(*activationTime);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (bandwidthStatus) {
      res["BandwidthStatus"] = boost::any(*bandwidthStatus);
    }
    if (circuitCode) {
      res["CircuitCode"] = boost::any(*circuitCode);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (eccId) {
      res["EccId"] = boost::any(*eccId);
    }
    if (enableIpv6) {
      res["EnableIpv6"] = boost::any(*enableIpv6);
    }
    if (localGatewayIp) {
      res["LocalGatewayIp"] = boost::any(*localGatewayIp);
    }
    if (localIpv6GatewayIp) {
      res["LocalIpv6GatewayIp"] = boost::any(*localIpv6GatewayIp);
    }
    if (PConnVbrBussinessStatus) {
      res["PConnVbrBussinessStatus"] = boost::any(*PConnVbrBussinessStatus);
    }
    if (PConnVbrChargeType) {
      res["PConnVbrChargeType"] = boost::any(*PConnVbrChargeType);
    }
    if (PConnVbrExpireTime) {
      res["PConnVbrExpireTime"] = boost::any(*PConnVbrExpireTime);
    }
    if (peerGatewayIp) {
      res["PeerGatewayIp"] = boost::any(*peerGatewayIp);
    }
    if (peerIpv6GatewayIp) {
      res["PeerIpv6GatewayIp"] = boost::any(*peerIpv6GatewayIp);
    }
    if (peeringIpv6SubnetMask) {
      res["PeeringIpv6SubnetMask"] = boost::any(*peeringIpv6SubnetMask);
    }
    if (peeringSubnetMask) {
      res["PeeringSubnetMask"] = boost::any(*peeringSubnetMask);
    }
    if (recoveryTime) {
      res["RecoveryTime"] = boost::any(*recoveryTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (terminationTime) {
      res["TerminationTime"] = boost::any(*terminationTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    if (vbrOwnerUid) {
      res["VbrOwnerUid"] = boost::any(*vbrOwnerUid);
    }
    if (vlanId) {
      res["VlanId"] = boost::any(*vlanId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivationTime") != m.end() && !m["ActivationTime"].empty()) {
      activationTime = make_shared<string>(boost::any_cast<string>(m["ActivationTime"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("BandwidthStatus") != m.end() && !m["BandwidthStatus"].empty()) {
      bandwidthStatus = make_shared<string>(boost::any_cast<string>(m["BandwidthStatus"]));
    }
    if (m.find("CircuitCode") != m.end() && !m["CircuitCode"].empty()) {
      circuitCode = make_shared<string>(boost::any_cast<string>(m["CircuitCode"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("EccId") != m.end() && !m["EccId"].empty()) {
      eccId = make_shared<string>(boost::any_cast<string>(m["EccId"]));
    }
    if (m.find("EnableIpv6") != m.end() && !m["EnableIpv6"].empty()) {
      enableIpv6 = make_shared<bool>(boost::any_cast<bool>(m["EnableIpv6"]));
    }
    if (m.find("LocalGatewayIp") != m.end() && !m["LocalGatewayIp"].empty()) {
      localGatewayIp = make_shared<string>(boost::any_cast<string>(m["LocalGatewayIp"]));
    }
    if (m.find("LocalIpv6GatewayIp") != m.end() && !m["LocalIpv6GatewayIp"].empty()) {
      localIpv6GatewayIp = make_shared<string>(boost::any_cast<string>(m["LocalIpv6GatewayIp"]));
    }
    if (m.find("PConnVbrBussinessStatus") != m.end() && !m["PConnVbrBussinessStatus"].empty()) {
      PConnVbrBussinessStatus = make_shared<string>(boost::any_cast<string>(m["PConnVbrBussinessStatus"]));
    }
    if (m.find("PConnVbrChargeType") != m.end() && !m["PConnVbrChargeType"].empty()) {
      PConnVbrChargeType = make_shared<string>(boost::any_cast<string>(m["PConnVbrChargeType"]));
    }
    if (m.find("PConnVbrExpireTime") != m.end() && !m["PConnVbrExpireTime"].empty()) {
      PConnVbrExpireTime = make_shared<string>(boost::any_cast<string>(m["PConnVbrExpireTime"]));
    }
    if (m.find("PeerGatewayIp") != m.end() && !m["PeerGatewayIp"].empty()) {
      peerGatewayIp = make_shared<string>(boost::any_cast<string>(m["PeerGatewayIp"]));
    }
    if (m.find("PeerIpv6GatewayIp") != m.end() && !m["PeerIpv6GatewayIp"].empty()) {
      peerIpv6GatewayIp = make_shared<string>(boost::any_cast<string>(m["PeerIpv6GatewayIp"]));
    }
    if (m.find("PeeringIpv6SubnetMask") != m.end() && !m["PeeringIpv6SubnetMask"].empty()) {
      peeringIpv6SubnetMask = make_shared<string>(boost::any_cast<string>(m["PeeringIpv6SubnetMask"]));
    }
    if (m.find("PeeringSubnetMask") != m.end() && !m["PeeringSubnetMask"].empty()) {
      peeringSubnetMask = make_shared<string>(boost::any_cast<string>(m["PeeringSubnetMask"]));
    }
    if (m.find("RecoveryTime") != m.end() && !m["RecoveryTime"].empty()) {
      recoveryTime = make_shared<string>(boost::any_cast<string>(m["RecoveryTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TerminationTime") != m.end() && !m["TerminationTime"].empty()) {
      terminationTime = make_shared<string>(boost::any_cast<string>(m["TerminationTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
    if (m.find("VbrOwnerUid") != m.end() && !m["VbrOwnerUid"].empty()) {
      vbrOwnerUid = make_shared<long>(boost::any_cast<long>(m["VbrOwnerUid"]));
    }
    if (m.find("VlanId") != m.end() && !m["VlanId"].empty()) {
      vlanId = make_shared<long>(boost::any_cast<long>(m["VlanId"]));
    }
  }


  virtual ~DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType() = default;
};
class DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType>> virtualBorderRouterForPhysicalConnectionType{};

  DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet() {}

  explicit DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (virtualBorderRouterForPhysicalConnectionType) {
      vector<boost::any> temp1;
      for(auto item1:*virtualBorderRouterForPhysicalConnectionType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VirtualBorderRouterForPhysicalConnectionType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VirtualBorderRouterForPhysicalConnectionType") != m.end() && !m["VirtualBorderRouterForPhysicalConnectionType"].empty()) {
      if (typeid(vector<boost::any>) == m["VirtualBorderRouterForPhysicalConnectionType"].type()) {
        vector<DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VirtualBorderRouterForPhysicalConnectionType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        virtualBorderRouterForPhysicalConnectionType = make_shared<vector<DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType>>(expect1);
      }
    }
  }


  virtual ~DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet() = default;
};
class DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet> virtualBorderRouterForPhysicalConnectionSet{};

  DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody() {}

  explicit DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (virtualBorderRouterForPhysicalConnectionSet) {
      res["VirtualBorderRouterForPhysicalConnectionSet"] = virtualBorderRouterForPhysicalConnectionSet ? boost::any(virtualBorderRouterForPhysicalConnectionSet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VirtualBorderRouterForPhysicalConnectionSet") != m.end() && !m["VirtualBorderRouterForPhysicalConnectionSet"].empty()) {
      if (typeid(map<string, boost::any>) == m["VirtualBorderRouterForPhysicalConnectionSet"].type()) {
        DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VirtualBorderRouterForPhysicalConnectionSet"]));
        virtualBorderRouterForPhysicalConnectionSet = make_shared<DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet>(model1);
      }
    }
  }


  virtual ~DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody() = default;
};
class DescribeVirtualBorderRoutersForPhysicalConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody> body{};

  DescribeVirtualBorderRoutersForPhysicalConnectionResponse() {}

  explicit DescribeVirtualBorderRoutersForPhysicalConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVirtualBorderRoutersForPhysicalConnectionResponse() = default;
};
class DescribeVpcAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpcId{};

  DescribeVpcAttributeRequest() {}

  explicit DescribeVpcAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeVpcAttributeRequest() = default;
};
class DescribeVpcAttributeResponseBodyAssociatedCensAssociatedCen : public Darabonba::Model {
public:
  shared_ptr<string> cenId{};
  shared_ptr<long> cenOwnerId{};
  shared_ptr<string> cenStatus{};

  DescribeVpcAttributeResponseBodyAssociatedCensAssociatedCen() {}

  explicit DescribeVpcAttributeResponseBodyAssociatedCensAssociatedCen(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cenId) {
      res["CenId"] = boost::any(*cenId);
    }
    if (cenOwnerId) {
      res["CenOwnerId"] = boost::any(*cenOwnerId);
    }
    if (cenStatus) {
      res["CenStatus"] = boost::any(*cenStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CenId") != m.end() && !m["CenId"].empty()) {
      cenId = make_shared<string>(boost::any_cast<string>(m["CenId"]));
    }
    if (m.find("CenOwnerId") != m.end() && !m["CenOwnerId"].empty()) {
      cenOwnerId = make_shared<long>(boost::any_cast<long>(m["CenOwnerId"]));
    }
    if (m.find("CenStatus") != m.end() && !m["CenStatus"].empty()) {
      cenStatus = make_shared<string>(boost::any_cast<string>(m["CenStatus"]));
    }
  }


  virtual ~DescribeVpcAttributeResponseBodyAssociatedCensAssociatedCen() = default;
};
class DescribeVpcAttributeResponseBodyAssociatedCens : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpcAttributeResponseBodyAssociatedCensAssociatedCen>> associatedCen{};

  DescribeVpcAttributeResponseBodyAssociatedCens() {}

  explicit DescribeVpcAttributeResponseBodyAssociatedCens(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associatedCen) {
      vector<boost::any> temp1;
      for(auto item1:*associatedCen){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AssociatedCen"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociatedCen") != m.end() && !m["AssociatedCen"].empty()) {
      if (typeid(vector<boost::any>) == m["AssociatedCen"].type()) {
        vector<DescribeVpcAttributeResponseBodyAssociatedCensAssociatedCen> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AssociatedCen"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcAttributeResponseBodyAssociatedCensAssociatedCen model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        associatedCen = make_shared<vector<DescribeVpcAttributeResponseBodyAssociatedCensAssociatedCen>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcAttributeResponseBodyAssociatedCens() = default;
};
class DescribeVpcAttributeResponseBodyAssociatedPropagationSourcesAssociatedPropagationSources : public Darabonba::Model {
public:
  shared_ptr<bool> routePropagated{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<long> sourceOwnerId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> status{};

  DescribeVpcAttributeResponseBodyAssociatedPropagationSourcesAssociatedPropagationSources() {}

  explicit DescribeVpcAttributeResponseBodyAssociatedPropagationSourcesAssociatedPropagationSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routePropagated) {
      res["RoutePropagated"] = boost::any(*routePropagated);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (sourceOwnerId) {
      res["SourceOwnerId"] = boost::any(*sourceOwnerId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoutePropagated") != m.end() && !m["RoutePropagated"].empty()) {
      routePropagated = make_shared<bool>(boost::any_cast<bool>(m["RoutePropagated"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("SourceOwnerId") != m.end() && !m["SourceOwnerId"].empty()) {
      sourceOwnerId = make_shared<long>(boost::any_cast<long>(m["SourceOwnerId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeVpcAttributeResponseBodyAssociatedPropagationSourcesAssociatedPropagationSources() = default;
};
class DescribeVpcAttributeResponseBodyAssociatedPropagationSources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpcAttributeResponseBodyAssociatedPropagationSourcesAssociatedPropagationSources>> associatedPropagationSources{};

  DescribeVpcAttributeResponseBodyAssociatedPropagationSources() {}

  explicit DescribeVpcAttributeResponseBodyAssociatedPropagationSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associatedPropagationSources) {
      vector<boost::any> temp1;
      for(auto item1:*associatedPropagationSources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AssociatedPropagationSources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociatedPropagationSources") != m.end() && !m["AssociatedPropagationSources"].empty()) {
      if (typeid(vector<boost::any>) == m["AssociatedPropagationSources"].type()) {
        vector<DescribeVpcAttributeResponseBodyAssociatedPropagationSourcesAssociatedPropagationSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AssociatedPropagationSources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcAttributeResponseBodyAssociatedPropagationSourcesAssociatedPropagationSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        associatedPropagationSources = make_shared<vector<DescribeVpcAttributeResponseBodyAssociatedPropagationSourcesAssociatedPropagationSources>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcAttributeResponseBodyAssociatedPropagationSources() = default;
};
class DescribeVpcAttributeResponseBodyCloudResourcesCloudResourceSetType : public Darabonba::Model {
public:
  shared_ptr<long> resourceCount{};
  shared_ptr<string> resourceType{};

  DescribeVpcAttributeResponseBodyCloudResourcesCloudResourceSetType() {}

  explicit DescribeVpcAttributeResponseBodyCloudResourcesCloudResourceSetType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceCount) {
      res["ResourceCount"] = boost::any(*resourceCount);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceCount") != m.end() && !m["ResourceCount"].empty()) {
      resourceCount = make_shared<long>(boost::any_cast<long>(m["ResourceCount"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribeVpcAttributeResponseBodyCloudResourcesCloudResourceSetType() = default;
};
class DescribeVpcAttributeResponseBodyCloudResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpcAttributeResponseBodyCloudResourcesCloudResourceSetType>> cloudResourceSetType{};

  DescribeVpcAttributeResponseBodyCloudResources() {}

  explicit DescribeVpcAttributeResponseBodyCloudResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudResourceSetType) {
      vector<boost::any> temp1;
      for(auto item1:*cloudResourceSetType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CloudResourceSetType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudResourceSetType") != m.end() && !m["CloudResourceSetType"].empty()) {
      if (typeid(vector<boost::any>) == m["CloudResourceSetType"].type()) {
        vector<DescribeVpcAttributeResponseBodyCloudResourcesCloudResourceSetType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CloudResourceSetType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcAttributeResponseBodyCloudResourcesCloudResourceSetType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cloudResourceSetType = make_shared<vector<DescribeVpcAttributeResponseBodyCloudResourcesCloudResourceSetType>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcAttributeResponseBodyCloudResources() = default;
};
class DescribeVpcAttributeResponseBodyIpv6CidrBlocksIpv6CidrBlock : public Darabonba::Model {
public:
  shared_ptr<string> ipv6CidrBlock{};
  shared_ptr<string> ipv6Isp{};

  DescribeVpcAttributeResponseBodyIpv6CidrBlocksIpv6CidrBlock() {}

  explicit DescribeVpcAttributeResponseBodyIpv6CidrBlocksIpv6CidrBlock(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6CidrBlock) {
      res["Ipv6CidrBlock"] = boost::any(*ipv6CidrBlock);
    }
    if (ipv6Isp) {
      res["Ipv6Isp"] = boost::any(*ipv6Isp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6CidrBlock") != m.end() && !m["Ipv6CidrBlock"].empty()) {
      ipv6CidrBlock = make_shared<string>(boost::any_cast<string>(m["Ipv6CidrBlock"]));
    }
    if (m.find("Ipv6Isp") != m.end() && !m["Ipv6Isp"].empty()) {
      ipv6Isp = make_shared<string>(boost::any_cast<string>(m["Ipv6Isp"]));
    }
  }


  virtual ~DescribeVpcAttributeResponseBodyIpv6CidrBlocksIpv6CidrBlock() = default;
};
class DescribeVpcAttributeResponseBodyIpv6CidrBlocks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpcAttributeResponseBodyIpv6CidrBlocksIpv6CidrBlock>> ipv6CidrBlock{};

  DescribeVpcAttributeResponseBodyIpv6CidrBlocks() {}

  explicit DescribeVpcAttributeResponseBodyIpv6CidrBlocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6CidrBlock) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6CidrBlock){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6CidrBlock"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6CidrBlock") != m.end() && !m["Ipv6CidrBlock"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6CidrBlock"].type()) {
        vector<DescribeVpcAttributeResponseBodyIpv6CidrBlocksIpv6CidrBlock> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6CidrBlock"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcAttributeResponseBodyIpv6CidrBlocksIpv6CidrBlock model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6CidrBlock = make_shared<vector<DescribeVpcAttributeResponseBodyIpv6CidrBlocksIpv6CidrBlock>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcAttributeResponseBodyIpv6CidrBlocks() = default;
};
class DescribeVpcAttributeResponseBodySecondaryCidrBlocks : public Darabonba::Model {
public:
  shared_ptr<vector<string>> secondaryCidrBlock{};

  DescribeVpcAttributeResponseBodySecondaryCidrBlocks() {}

  explicit DescribeVpcAttributeResponseBodySecondaryCidrBlocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (secondaryCidrBlock) {
      res["SecondaryCidrBlock"] = boost::any(*secondaryCidrBlock);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecondaryCidrBlock") != m.end() && !m["SecondaryCidrBlock"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecondaryCidrBlock"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecondaryCidrBlock"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      secondaryCidrBlock = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVpcAttributeResponseBodySecondaryCidrBlocks() = default;
};
class DescribeVpcAttributeResponseBodyTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeVpcAttributeResponseBodyTagsTag() {}

  explicit DescribeVpcAttributeResponseBodyTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVpcAttributeResponseBodyTagsTag() = default;
};
class DescribeVpcAttributeResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpcAttributeResponseBodyTagsTag>> tag{};

  DescribeVpcAttributeResponseBodyTags() {}

  explicit DescribeVpcAttributeResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeVpcAttributeResponseBodyTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcAttributeResponseBodyTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeVpcAttributeResponseBodyTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcAttributeResponseBodyTags() = default;
};
class DescribeVpcAttributeResponseBodyUserCidrs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> userCidr{};

  DescribeVpcAttributeResponseBodyUserCidrs() {}

  explicit DescribeVpcAttributeResponseBodyUserCidrs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserCidr"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserCidr"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userCidr = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVpcAttributeResponseBodyUserCidrs() = default;
};
class DescribeVpcAttributeResponseBodyVSwitchIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> vSwitchId{};

  DescribeVpcAttributeResponseBodyVSwitchIds() {}

  explicit DescribeVpcAttributeResponseBodyVSwitchIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVpcAttributeResponseBodyVSwitchIds() = default;
};
class DescribeVpcAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVpcAttributeResponseBodyAssociatedCens> associatedCens{};
  shared_ptr<DescribeVpcAttributeResponseBodyAssociatedPropagationSources> associatedPropagationSources{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<bool> classicLinkEnabled{};
  shared_ptr<DescribeVpcAttributeResponseBodyCloudResources> cloudResources{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> dhcpOptionsSetId{};
  shared_ptr<string> dhcpOptionsSetStatus{};
  shared_ptr<bool> enabledIpv6{};
  shared_ptr<string> ipv4GatewayId{};
  shared_ptr<string> ipv6CidrBlock{};
  shared_ptr<DescribeVpcAttributeResponseBodyIpv6CidrBlocks> ipv6CidrBlocks{};
  shared_ptr<bool> isDefault{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<DescribeVpcAttributeResponseBodySecondaryCidrBlocks> secondaryCidrBlocks{};
  shared_ptr<string> status{};
  shared_ptr<bool> supportIpv4Gateway{};
  shared_ptr<DescribeVpcAttributeResponseBodyTags> tags{};
  shared_ptr<DescribeVpcAttributeResponseBodyUserCidrs> userCidrs{};
  shared_ptr<string> VRouterId{};
  shared_ptr<DescribeVpcAttributeResponseBodyVSwitchIds> vSwitchIds{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcName{};

  DescribeVpcAttributeResponseBody() {}

  explicit DescribeVpcAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associatedCens) {
      res["AssociatedCens"] = associatedCens ? boost::any(associatedCens->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (associatedPropagationSources) {
      res["AssociatedPropagationSources"] = associatedPropagationSources ? boost::any(associatedPropagationSources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (classicLinkEnabled) {
      res["ClassicLinkEnabled"] = boost::any(*classicLinkEnabled);
    }
    if (cloudResources) {
      res["CloudResources"] = cloudResources ? boost::any(cloudResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dhcpOptionsSetId) {
      res["DhcpOptionsSetId"] = boost::any(*dhcpOptionsSetId);
    }
    if (dhcpOptionsSetStatus) {
      res["DhcpOptionsSetStatus"] = boost::any(*dhcpOptionsSetStatus);
    }
    if (enabledIpv6) {
      res["EnabledIpv6"] = boost::any(*enabledIpv6);
    }
    if (ipv4GatewayId) {
      res["Ipv4GatewayId"] = boost::any(*ipv4GatewayId);
    }
    if (ipv6CidrBlock) {
      res["Ipv6CidrBlock"] = boost::any(*ipv6CidrBlock);
    }
    if (ipv6CidrBlocks) {
      res["Ipv6CidrBlocks"] = ipv6CidrBlocks ? boost::any(ipv6CidrBlocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (secondaryCidrBlocks) {
      res["SecondaryCidrBlocks"] = secondaryCidrBlocks ? boost::any(secondaryCidrBlocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (supportIpv4Gateway) {
      res["SupportIpv4Gateway"] = boost::any(*supportIpv4Gateway);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userCidrs) {
      res["UserCidrs"] = userCidrs ? boost::any(userCidrs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (VRouterId) {
      res["VRouterId"] = boost::any(*VRouterId);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = vSwitchIds ? boost::any(vSwitchIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociatedCens") != m.end() && !m["AssociatedCens"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssociatedCens"].type()) {
        DescribeVpcAttributeResponseBodyAssociatedCens model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssociatedCens"]));
        associatedCens = make_shared<DescribeVpcAttributeResponseBodyAssociatedCens>(model1);
      }
    }
    if (m.find("AssociatedPropagationSources") != m.end() && !m["AssociatedPropagationSources"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssociatedPropagationSources"].type()) {
        DescribeVpcAttributeResponseBodyAssociatedPropagationSources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssociatedPropagationSources"]));
        associatedPropagationSources = make_shared<DescribeVpcAttributeResponseBodyAssociatedPropagationSources>(model1);
      }
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("ClassicLinkEnabled") != m.end() && !m["ClassicLinkEnabled"].empty()) {
      classicLinkEnabled = make_shared<bool>(boost::any_cast<bool>(m["ClassicLinkEnabled"]));
    }
    if (m.find("CloudResources") != m.end() && !m["CloudResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["CloudResources"].type()) {
        DescribeVpcAttributeResponseBodyCloudResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CloudResources"]));
        cloudResources = make_shared<DescribeVpcAttributeResponseBodyCloudResources>(model1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DhcpOptionsSetId") != m.end() && !m["DhcpOptionsSetId"].empty()) {
      dhcpOptionsSetId = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetId"]));
    }
    if (m.find("DhcpOptionsSetStatus") != m.end() && !m["DhcpOptionsSetStatus"].empty()) {
      dhcpOptionsSetStatus = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetStatus"]));
    }
    if (m.find("EnabledIpv6") != m.end() && !m["EnabledIpv6"].empty()) {
      enabledIpv6 = make_shared<bool>(boost::any_cast<bool>(m["EnabledIpv6"]));
    }
    if (m.find("Ipv4GatewayId") != m.end() && !m["Ipv4GatewayId"].empty()) {
      ipv4GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayId"]));
    }
    if (m.find("Ipv6CidrBlock") != m.end() && !m["Ipv6CidrBlock"].empty()) {
      ipv6CidrBlock = make_shared<string>(boost::any_cast<string>(m["Ipv6CidrBlock"]));
    }
    if (m.find("Ipv6CidrBlocks") != m.end() && !m["Ipv6CidrBlocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6CidrBlocks"].type()) {
        DescribeVpcAttributeResponseBodyIpv6CidrBlocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6CidrBlocks"]));
        ipv6CidrBlocks = make_shared<DescribeVpcAttributeResponseBodyIpv6CidrBlocks>(model1);
      }
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecondaryCidrBlocks") != m.end() && !m["SecondaryCidrBlocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecondaryCidrBlocks"].type()) {
        DescribeVpcAttributeResponseBodySecondaryCidrBlocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecondaryCidrBlocks"]));
        secondaryCidrBlocks = make_shared<DescribeVpcAttributeResponseBodySecondaryCidrBlocks>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SupportIpv4Gateway") != m.end() && !m["SupportIpv4Gateway"].empty()) {
      supportIpv4Gateway = make_shared<bool>(boost::any_cast<bool>(m["SupportIpv4Gateway"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeVpcAttributeResponseBodyTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeVpcAttributeResponseBodyTags>(model1);
      }
    }
    if (m.find("UserCidrs") != m.end() && !m["UserCidrs"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserCidrs"].type()) {
        DescribeVpcAttributeResponseBodyUserCidrs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserCidrs"]));
        userCidrs = make_shared<DescribeVpcAttributeResponseBodyUserCidrs>(model1);
      }
    }
    if (m.find("VRouterId") != m.end() && !m["VRouterId"].empty()) {
      VRouterId = make_shared<string>(boost::any_cast<string>(m["VRouterId"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["VSwitchIds"].type()) {
        DescribeVpcAttributeResponseBodyVSwitchIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VSwitchIds"]));
        vSwitchIds = make_shared<DescribeVpcAttributeResponseBodyVSwitchIds>(model1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
  }


  virtual ~DescribeVpcAttributeResponseBody() = default;
};
class DescribeVpcAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVpcAttributeResponseBody> body{};

  DescribeVpcAttributeResponse() {}

  explicit DescribeVpcAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpcAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpcAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpcAttributeResponse() = default;
};
class DescribeVpcsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeVpcsRequestTag() {}

  explicit DescribeVpcsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVpcsRequestTag() = default;
};
class DescribeVpcsRequest : public Darabonba::Model {
public:
  shared_ptr<string> dhcpOptionsSetId{};
  shared_ptr<bool> dryRun{};
  shared_ptr<bool> enableIpv6{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<DescribeVpcsRequestTag>> tag{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcName{};
  shared_ptr<long> vpcOwnerId{};

  DescribeVpcsRequest() {}

  explicit DescribeVpcsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dhcpOptionsSetId) {
      res["DhcpOptionsSetId"] = boost::any(*dhcpOptionsSetId);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (enableIpv6) {
      res["EnableIpv6"] = boost::any(*enableIpv6);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    if (vpcOwnerId) {
      res["VpcOwnerId"] = boost::any(*vpcOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DhcpOptionsSetId") != m.end() && !m["DhcpOptionsSetId"].empty()) {
      dhcpOptionsSetId = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetId"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EnableIpv6") != m.end() && !m["EnableIpv6"].empty()) {
      enableIpv6 = make_shared<bool>(boost::any_cast<bool>(m["EnableIpv6"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeVpcsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeVpcsRequestTag>>(expect1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
    if (m.find("VpcOwnerId") != m.end() && !m["VpcOwnerId"].empty()) {
      vpcOwnerId = make_shared<long>(boost::any_cast<long>(m["VpcOwnerId"]));
    }
  }


  virtual ~DescribeVpcsRequest() = default;
};
class DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocksIpv6CidrBlock : public Darabonba::Model {
public:
  shared_ptr<string> ipv6CidrBlock{};
  shared_ptr<string> ipv6Isp{};

  DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocksIpv6CidrBlock() {}

  explicit DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocksIpv6CidrBlock(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6CidrBlock) {
      res["Ipv6CidrBlock"] = boost::any(*ipv6CidrBlock);
    }
    if (ipv6Isp) {
      res["Ipv6Isp"] = boost::any(*ipv6Isp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6CidrBlock") != m.end() && !m["Ipv6CidrBlock"].empty()) {
      ipv6CidrBlock = make_shared<string>(boost::any_cast<string>(m["Ipv6CidrBlock"]));
    }
    if (m.find("Ipv6Isp") != m.end() && !m["Ipv6Isp"].empty()) {
      ipv6Isp = make_shared<string>(boost::any_cast<string>(m["Ipv6Isp"]));
    }
  }


  virtual ~DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocksIpv6CidrBlock() = default;
};
class DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocksIpv6CidrBlock>> ipv6CidrBlock{};

  DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocks() {}

  explicit DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv6CidrBlock) {
      vector<boost::any> temp1;
      for(auto item1:*ipv6CidrBlock){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv6CidrBlock"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv6CidrBlock") != m.end() && !m["Ipv6CidrBlock"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv6CidrBlock"].type()) {
        vector<DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocksIpv6CidrBlock> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv6CidrBlock"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocksIpv6CidrBlock model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv6CidrBlock = make_shared<vector<DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocksIpv6CidrBlock>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocks() = default;
};
class DescribeVpcsResponseBodyVpcsVpcNatGatewayIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> natGatewayIds{};

  DescribeVpcsResponseBodyVpcsVpcNatGatewayIds() {}

  explicit DescribeVpcsResponseBodyVpcsVpcNatGatewayIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (natGatewayIds) {
      res["NatGatewayIds"] = boost::any(*natGatewayIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NatGatewayIds") != m.end() && !m["NatGatewayIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NatGatewayIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NatGatewayIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      natGatewayIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVpcsResponseBodyVpcsVpcNatGatewayIds() = default;
};
class DescribeVpcsResponseBodyVpcsVpcRouterTableIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> routerTableIds{};

  DescribeVpcsResponseBodyVpcsVpcRouterTableIds() {}

  explicit DescribeVpcsResponseBodyVpcsVpcRouterTableIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routerTableIds) {
      res["RouterTableIds"] = boost::any(*routerTableIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouterTableIds") != m.end() && !m["RouterTableIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RouterTableIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RouterTableIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      routerTableIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVpcsResponseBodyVpcsVpcRouterTableIds() = default;
};
class DescribeVpcsResponseBodyVpcsVpcSecondaryCidrBlocks : public Darabonba::Model {
public:
  shared_ptr<vector<string>> secondaryCidrBlock{};

  DescribeVpcsResponseBodyVpcsVpcSecondaryCidrBlocks() {}

  explicit DescribeVpcsResponseBodyVpcsVpcSecondaryCidrBlocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (secondaryCidrBlock) {
      res["SecondaryCidrBlock"] = boost::any(*secondaryCidrBlock);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecondaryCidrBlock") != m.end() && !m["SecondaryCidrBlock"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecondaryCidrBlock"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecondaryCidrBlock"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      secondaryCidrBlock = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVpcsResponseBodyVpcsVpcSecondaryCidrBlocks() = default;
};
class DescribeVpcsResponseBodyVpcsVpcTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeVpcsResponseBodyVpcsVpcTagsTag() {}

  explicit DescribeVpcsResponseBodyVpcsVpcTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVpcsResponseBodyVpcsVpcTagsTag() = default;
};
class DescribeVpcsResponseBodyVpcsVpcTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpcsResponseBodyVpcsVpcTagsTag>> tag{};

  DescribeVpcsResponseBodyVpcsVpcTags() {}

  explicit DescribeVpcsResponseBodyVpcsVpcTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeVpcsResponseBodyVpcsVpcTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcsResponseBodyVpcsVpcTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeVpcsResponseBodyVpcsVpcTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcsResponseBodyVpcsVpcTags() = default;
};
class DescribeVpcsResponseBodyVpcsVpcUserCidrs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> userCidr{};

  DescribeVpcsResponseBodyVpcsVpcUserCidrs() {}

  explicit DescribeVpcsResponseBodyVpcsVpcUserCidrs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userCidr) {
      res["UserCidr"] = boost::any(*userCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserCidr") != m.end() && !m["UserCidr"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserCidr"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserCidr"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userCidr = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVpcsResponseBodyVpcsVpcUserCidrs() = default;
};
class DescribeVpcsResponseBodyVpcsVpcVSwitchIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> vSwitchId{};

  DescribeVpcsResponseBodyVpcsVpcVSwitchIds() {}

  explicit DescribeVpcsResponseBodyVpcsVpcVSwitchIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVpcsResponseBodyVpcsVpcVSwitchIds() = default;
};
class DescribeVpcsResponseBodyVpcsVpc : public Darabonba::Model {
public:
  shared_ptr<string> cenStatus{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> dhcpOptionsSetId{};
  shared_ptr<string> dhcpOptionsSetStatus{};
  shared_ptr<bool> enabledIpv6{};
  shared_ptr<string> ipv6CidrBlock{};
  shared_ptr<DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocks> ipv6CidrBlocks{};
  shared_ptr<bool> isDefault{};
  shared_ptr<DescribeVpcsResponseBodyVpcsVpcNatGatewayIds> natGatewayIds{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<DescribeVpcsResponseBodyVpcsVpcRouterTableIds> routerTableIds{};
  shared_ptr<DescribeVpcsResponseBodyVpcsVpcSecondaryCidrBlocks> secondaryCidrBlocks{};
  shared_ptr<string> status{};
  shared_ptr<DescribeVpcsResponseBodyVpcsVpcTags> tags{};
  shared_ptr<DescribeVpcsResponseBodyVpcsVpcUserCidrs> userCidrs{};
  shared_ptr<string> VRouterId{};
  shared_ptr<DescribeVpcsResponseBodyVpcsVpcVSwitchIds> vSwitchIds{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcName{};

  DescribeVpcsResponseBodyVpcsVpc() {}

  explicit DescribeVpcsResponseBodyVpcsVpc(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cenStatus) {
      res["CenStatus"] = boost::any(*cenStatus);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dhcpOptionsSetId) {
      res["DhcpOptionsSetId"] = boost::any(*dhcpOptionsSetId);
    }
    if (dhcpOptionsSetStatus) {
      res["DhcpOptionsSetStatus"] = boost::any(*dhcpOptionsSetStatus);
    }
    if (enabledIpv6) {
      res["EnabledIpv6"] = boost::any(*enabledIpv6);
    }
    if (ipv6CidrBlock) {
      res["Ipv6CidrBlock"] = boost::any(*ipv6CidrBlock);
    }
    if (ipv6CidrBlocks) {
      res["Ipv6CidrBlocks"] = ipv6CidrBlocks ? boost::any(ipv6CidrBlocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (natGatewayIds) {
      res["NatGatewayIds"] = natGatewayIds ? boost::any(natGatewayIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (routerTableIds) {
      res["RouterTableIds"] = routerTableIds ? boost::any(routerTableIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (secondaryCidrBlocks) {
      res["SecondaryCidrBlocks"] = secondaryCidrBlocks ? boost::any(secondaryCidrBlocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userCidrs) {
      res["UserCidrs"] = userCidrs ? boost::any(userCidrs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (VRouterId) {
      res["VRouterId"] = boost::any(*VRouterId);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = vSwitchIds ? boost::any(vSwitchIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CenStatus") != m.end() && !m["CenStatus"].empty()) {
      cenStatus = make_shared<string>(boost::any_cast<string>(m["CenStatus"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DhcpOptionsSetId") != m.end() && !m["DhcpOptionsSetId"].empty()) {
      dhcpOptionsSetId = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetId"]));
    }
    if (m.find("DhcpOptionsSetStatus") != m.end() && !m["DhcpOptionsSetStatus"].empty()) {
      dhcpOptionsSetStatus = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetStatus"]));
    }
    if (m.find("EnabledIpv6") != m.end() && !m["EnabledIpv6"].empty()) {
      enabledIpv6 = make_shared<bool>(boost::any_cast<bool>(m["EnabledIpv6"]));
    }
    if (m.find("Ipv6CidrBlock") != m.end() && !m["Ipv6CidrBlock"].empty()) {
      ipv6CidrBlock = make_shared<string>(boost::any_cast<string>(m["Ipv6CidrBlock"]));
    }
    if (m.find("Ipv6CidrBlocks") != m.end() && !m["Ipv6CidrBlocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["Ipv6CidrBlocks"].type()) {
        DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Ipv6CidrBlocks"]));
        ipv6CidrBlocks = make_shared<DescribeVpcsResponseBodyVpcsVpcIpv6CidrBlocks>(model1);
      }
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("NatGatewayIds") != m.end() && !m["NatGatewayIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NatGatewayIds"].type()) {
        DescribeVpcsResponseBodyVpcsVpcNatGatewayIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NatGatewayIds"]));
        natGatewayIds = make_shared<DescribeVpcsResponseBodyVpcsVpcNatGatewayIds>(model1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RouterTableIds") != m.end() && !m["RouterTableIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouterTableIds"].type()) {
        DescribeVpcsResponseBodyVpcsVpcRouterTableIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouterTableIds"]));
        routerTableIds = make_shared<DescribeVpcsResponseBodyVpcsVpcRouterTableIds>(model1);
      }
    }
    if (m.find("SecondaryCidrBlocks") != m.end() && !m["SecondaryCidrBlocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecondaryCidrBlocks"].type()) {
        DescribeVpcsResponseBodyVpcsVpcSecondaryCidrBlocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecondaryCidrBlocks"]));
        secondaryCidrBlocks = make_shared<DescribeVpcsResponseBodyVpcsVpcSecondaryCidrBlocks>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeVpcsResponseBodyVpcsVpcTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeVpcsResponseBodyVpcsVpcTags>(model1);
      }
    }
    if (m.find("UserCidrs") != m.end() && !m["UserCidrs"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserCidrs"].type()) {
        DescribeVpcsResponseBodyVpcsVpcUserCidrs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserCidrs"]));
        userCidrs = make_shared<DescribeVpcsResponseBodyVpcsVpcUserCidrs>(model1);
      }
    }
    if (m.find("VRouterId") != m.end() && !m["VRouterId"].empty()) {
      VRouterId = make_shared<string>(boost::any_cast<string>(m["VRouterId"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["VSwitchIds"].type()) {
        DescribeVpcsResponseBodyVpcsVpcVSwitchIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VSwitchIds"]));
        vSwitchIds = make_shared<DescribeVpcsResponseBodyVpcsVpcVSwitchIds>(model1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
  }


  virtual ~DescribeVpcsResponseBodyVpcsVpc() = default;
};
class DescribeVpcsResponseBodyVpcs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpcsResponseBodyVpcsVpc>> vpc{};

  DescribeVpcsResponseBodyVpcs() {}

  explicit DescribeVpcsResponseBodyVpcs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpc) {
      vector<boost::any> temp1;
      for(auto item1:*vpc){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Vpc"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Vpc") != m.end() && !m["Vpc"].empty()) {
      if (typeid(vector<boost::any>) == m["Vpc"].type()) {
        vector<DescribeVpcsResponseBodyVpcsVpc> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Vpc"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcsResponseBodyVpcsVpc model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpc = make_shared<vector<DescribeVpcsResponseBodyVpcsVpc>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcsResponseBodyVpcs() = default;
};
class DescribeVpcsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeVpcsResponseBodyVpcs> vpcs{};

  DescribeVpcsResponseBody() {}

  explicit DescribeVpcsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vpcs) {
      res["Vpcs"] = vpcs ? boost::any(vpcs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Vpcs") != m.end() && !m["Vpcs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Vpcs"].type()) {
        DescribeVpcsResponseBodyVpcs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Vpcs"]));
        vpcs = make_shared<DescribeVpcsResponseBodyVpcs>(model1);
      }
    }
  }


  virtual ~DescribeVpcsResponseBody() = default;
};
class DescribeVpcsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVpcsResponseBody> body{};

  DescribeVpcsResponse() {}

  explicit DescribeVpcsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpcsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpcsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpcsResponse() = default;
};
class DescribeVpnAttachmentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpnConnectionId{};

  DescribeVpnAttachmentsRequest() {}

  explicit DescribeVpnAttachmentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachType) {
      res["AttachType"] = boost::any(*attachType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachType") != m.end() && !m["AttachType"].empty()) {
      attachType = make_shared<string>(boost::any_cast<string>(m["AttachType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
  }


  virtual ~DescribeVpnAttachmentsRequest() = default;
};
class DescribeVpnAttachmentsResponseBodyVpnAttachments : public Darabonba::Model {
public:
  shared_ptr<string> attachType{};
  shared_ptr<bool> crossAccountAuthorized{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> transitRouterId{};
  shared_ptr<string> transitRouterName{};

  DescribeVpnAttachmentsResponseBodyVpnAttachments() {}

  explicit DescribeVpnAttachmentsResponseBodyVpnAttachments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachType) {
      res["AttachType"] = boost::any(*attachType);
    }
    if (crossAccountAuthorized) {
      res["CrossAccountAuthorized"] = boost::any(*crossAccountAuthorized);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (transitRouterId) {
      res["TransitRouterId"] = boost::any(*transitRouterId);
    }
    if (transitRouterName) {
      res["TransitRouterName"] = boost::any(*transitRouterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachType") != m.end() && !m["AttachType"].empty()) {
      attachType = make_shared<string>(boost::any_cast<string>(m["AttachType"]));
    }
    if (m.find("CrossAccountAuthorized") != m.end() && !m["CrossAccountAuthorized"].empty()) {
      crossAccountAuthorized = make_shared<bool>(boost::any_cast<bool>(m["CrossAccountAuthorized"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TransitRouterId") != m.end() && !m["TransitRouterId"].empty()) {
      transitRouterId = make_shared<string>(boost::any_cast<string>(m["TransitRouterId"]));
    }
    if (m.find("TransitRouterName") != m.end() && !m["TransitRouterName"].empty()) {
      transitRouterName = make_shared<string>(boost::any_cast<string>(m["TransitRouterName"]));
    }
  }


  virtual ~DescribeVpnAttachmentsResponseBodyVpnAttachments() = default;
};
class DescribeVpnAttachmentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeVpnAttachmentsResponseBodyVpnAttachments>> vpnAttachments{};

  DescribeVpnAttachmentsResponseBody() {}

  explicit DescribeVpnAttachmentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vpnAttachments) {
      vector<boost::any> temp1;
      for(auto item1:*vpnAttachments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpnAttachments"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VpnAttachments") != m.end() && !m["VpnAttachments"].empty()) {
      if (typeid(vector<boost::any>) == m["VpnAttachments"].type()) {
        vector<DescribeVpnAttachmentsResponseBodyVpnAttachments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpnAttachments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpnAttachmentsResponseBodyVpnAttachments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpnAttachments = make_shared<vector<DescribeVpnAttachmentsResponseBodyVpnAttachments>>(expect1);
      }
    }
  }


  virtual ~DescribeVpnAttachmentsResponseBody() = default;
};
class DescribeVpnAttachmentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVpnAttachmentsResponseBody> body{};

  DescribeVpnAttachmentsResponse() {}

  explicit DescribeVpnAttachmentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpnAttachmentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpnAttachmentsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpnAttachmentsResponse() = default;
};
class DescribeVpnConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpnConnectionId{};

  DescribeVpnConnectionRequest() {}

  explicit DescribeVpnConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
  }


  virtual ~DescribeVpnConnectionRequest() = default;
};
class DescribeVpnConnectionResponseBodyIkeConfig : public Darabonba::Model {
public:
  shared_ptr<string> ikeAuthAlg{};
  shared_ptr<string> ikeEncAlg{};
  shared_ptr<long> ikeLifetime{};
  shared_ptr<string> ikeMode{};
  shared_ptr<string> ikePfs{};
  shared_ptr<string> ikeVersion{};
  shared_ptr<string> localId{};
  shared_ptr<string> psk{};
  shared_ptr<string> remoteId{};

  DescribeVpnConnectionResponseBodyIkeConfig() {}

  explicit DescribeVpnConnectionResponseBodyIkeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ikeAuthAlg) {
      res["IkeAuthAlg"] = boost::any(*ikeAuthAlg);
    }
    if (ikeEncAlg) {
      res["IkeEncAlg"] = boost::any(*ikeEncAlg);
    }
    if (ikeLifetime) {
      res["IkeLifetime"] = boost::any(*ikeLifetime);
    }
    if (ikeMode) {
      res["IkeMode"] = boost::any(*ikeMode);
    }
    if (ikePfs) {
      res["IkePfs"] = boost::any(*ikePfs);
    }
    if (ikeVersion) {
      res["IkeVersion"] = boost::any(*ikeVersion);
    }
    if (localId) {
      res["LocalId"] = boost::any(*localId);
    }
    if (psk) {
      res["Psk"] = boost::any(*psk);
    }
    if (remoteId) {
      res["RemoteId"] = boost::any(*remoteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IkeAuthAlg") != m.end() && !m["IkeAuthAlg"].empty()) {
      ikeAuthAlg = make_shared<string>(boost::any_cast<string>(m["IkeAuthAlg"]));
    }
    if (m.find("IkeEncAlg") != m.end() && !m["IkeEncAlg"].empty()) {
      ikeEncAlg = make_shared<string>(boost::any_cast<string>(m["IkeEncAlg"]));
    }
    if (m.find("IkeLifetime") != m.end() && !m["IkeLifetime"].empty()) {
      ikeLifetime = make_shared<long>(boost::any_cast<long>(m["IkeLifetime"]));
    }
    if (m.find("IkeMode") != m.end() && !m["IkeMode"].empty()) {
      ikeMode = make_shared<string>(boost::any_cast<string>(m["IkeMode"]));
    }
    if (m.find("IkePfs") != m.end() && !m["IkePfs"].empty()) {
      ikePfs = make_shared<string>(boost::any_cast<string>(m["IkePfs"]));
    }
    if (m.find("IkeVersion") != m.end() && !m["IkeVersion"].empty()) {
      ikeVersion = make_shared<string>(boost::any_cast<string>(m["IkeVersion"]));
    }
    if (m.find("LocalId") != m.end() && !m["LocalId"].empty()) {
      localId = make_shared<string>(boost::any_cast<string>(m["LocalId"]));
    }
    if (m.find("Psk") != m.end() && !m["Psk"].empty()) {
      psk = make_shared<string>(boost::any_cast<string>(m["Psk"]));
    }
    if (m.find("RemoteId") != m.end() && !m["RemoteId"].empty()) {
      remoteId = make_shared<string>(boost::any_cast<string>(m["RemoteId"]));
    }
  }


  virtual ~DescribeVpnConnectionResponseBodyIkeConfig() = default;
};
class DescribeVpnConnectionResponseBodyIpsecConfig : public Darabonba::Model {
public:
  shared_ptr<string> ipsecAuthAlg{};
  shared_ptr<string> ipsecEncAlg{};
  shared_ptr<long> ipsecLifetime{};
  shared_ptr<string> ipsecPfs{};

  DescribeVpnConnectionResponseBodyIpsecConfig() {}

  explicit DescribeVpnConnectionResponseBodyIpsecConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipsecAuthAlg) {
      res["IpsecAuthAlg"] = boost::any(*ipsecAuthAlg);
    }
    if (ipsecEncAlg) {
      res["IpsecEncAlg"] = boost::any(*ipsecEncAlg);
    }
    if (ipsecLifetime) {
      res["IpsecLifetime"] = boost::any(*ipsecLifetime);
    }
    if (ipsecPfs) {
      res["IpsecPfs"] = boost::any(*ipsecPfs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpsecAuthAlg") != m.end() && !m["IpsecAuthAlg"].empty()) {
      ipsecAuthAlg = make_shared<string>(boost::any_cast<string>(m["IpsecAuthAlg"]));
    }
    if (m.find("IpsecEncAlg") != m.end() && !m["IpsecEncAlg"].empty()) {
      ipsecEncAlg = make_shared<string>(boost::any_cast<string>(m["IpsecEncAlg"]));
    }
    if (m.find("IpsecLifetime") != m.end() && !m["IpsecLifetime"].empty()) {
      ipsecLifetime = make_shared<long>(boost::any_cast<long>(m["IpsecLifetime"]));
    }
    if (m.find("IpsecPfs") != m.end() && !m["IpsecPfs"].empty()) {
      ipsecPfs = make_shared<string>(boost::any_cast<string>(m["IpsecPfs"]));
    }
  }


  virtual ~DescribeVpnConnectionResponseBodyIpsecConfig() = default;
};
class DescribeVpnConnectionResponseBodyTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeVpnConnectionResponseBodyTagsTag() {}

  explicit DescribeVpnConnectionResponseBodyTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVpnConnectionResponseBodyTagsTag() = default;
};
class DescribeVpnConnectionResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpnConnectionResponseBodyTagsTag>> tag{};

  DescribeVpnConnectionResponseBodyTags() {}

  explicit DescribeVpnConnectionResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeVpnConnectionResponseBodyTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpnConnectionResponseBodyTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeVpnConnectionResponseBodyTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeVpnConnectionResponseBodyTags() = default;
};
class DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig : public Darabonba::Model {
public:
  shared_ptr<string> bgpStatus{};
  shared_ptr<string> localAsn{};
  shared_ptr<string> localBgpIp{};
  shared_ptr<string> peerAsn{};
  shared_ptr<string> peerBgpIp{};
  shared_ptr<string> tunnelCidr{};

  DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig() {}

  explicit DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgpStatus) {
      res["BgpStatus"] = boost::any(*bgpStatus);
    }
    if (localAsn) {
      res["LocalAsn"] = boost::any(*localAsn);
    }
    if (localBgpIp) {
      res["LocalBgpIp"] = boost::any(*localBgpIp);
    }
    if (peerAsn) {
      res["PeerAsn"] = boost::any(*peerAsn);
    }
    if (peerBgpIp) {
      res["PeerBgpIp"] = boost::any(*peerBgpIp);
    }
    if (tunnelCidr) {
      res["TunnelCidr"] = boost::any(*tunnelCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgpStatus") != m.end() && !m["BgpStatus"].empty()) {
      bgpStatus = make_shared<string>(boost::any_cast<string>(m["BgpStatus"]));
    }
    if (m.find("LocalAsn") != m.end() && !m["LocalAsn"].empty()) {
      localAsn = make_shared<string>(boost::any_cast<string>(m["LocalAsn"]));
    }
    if (m.find("LocalBgpIp") != m.end() && !m["LocalBgpIp"].empty()) {
      localBgpIp = make_shared<string>(boost::any_cast<string>(m["LocalBgpIp"]));
    }
    if (m.find("PeerAsn") != m.end() && !m["PeerAsn"].empty()) {
      peerAsn = make_shared<string>(boost::any_cast<string>(m["PeerAsn"]));
    }
    if (m.find("PeerBgpIp") != m.end() && !m["PeerBgpIp"].empty()) {
      peerBgpIp = make_shared<string>(boost::any_cast<string>(m["PeerBgpIp"]));
    }
    if (m.find("TunnelCidr") != m.end() && !m["TunnelCidr"].empty()) {
      tunnelCidr = make_shared<string>(boost::any_cast<string>(m["TunnelCidr"]));
    }
  }


  virtual ~DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig() = default;
};
class DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig : public Darabonba::Model {
public:
  shared_ptr<string> ikeAuthAlg{};
  shared_ptr<string> ikeEncAlg{};
  shared_ptr<string> ikeLifetime{};
  shared_ptr<string> ikeMode{};
  shared_ptr<string> ikePfs{};
  shared_ptr<string> ikeVersion{};
  shared_ptr<string> localId{};
  shared_ptr<string> psk{};
  shared_ptr<string> remoteId{};

  DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig() {}

  explicit DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ikeAuthAlg) {
      res["IkeAuthAlg"] = boost::any(*ikeAuthAlg);
    }
    if (ikeEncAlg) {
      res["IkeEncAlg"] = boost::any(*ikeEncAlg);
    }
    if (ikeLifetime) {
      res["IkeLifetime"] = boost::any(*ikeLifetime);
    }
    if (ikeMode) {
      res["IkeMode"] = boost::any(*ikeMode);
    }
    if (ikePfs) {
      res["IkePfs"] = boost::any(*ikePfs);
    }
    if (ikeVersion) {
      res["IkeVersion"] = boost::any(*ikeVersion);
    }
    if (localId) {
      res["LocalId"] = boost::any(*localId);
    }
    if (psk) {
      res["Psk"] = boost::any(*psk);
    }
    if (remoteId) {
      res["RemoteId"] = boost::any(*remoteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IkeAuthAlg") != m.end() && !m["IkeAuthAlg"].empty()) {
      ikeAuthAlg = make_shared<string>(boost::any_cast<string>(m["IkeAuthAlg"]));
    }
    if (m.find("IkeEncAlg") != m.end() && !m["IkeEncAlg"].empty()) {
      ikeEncAlg = make_shared<string>(boost::any_cast<string>(m["IkeEncAlg"]));
    }
    if (m.find("IkeLifetime") != m.end() && !m["IkeLifetime"].empty()) {
      ikeLifetime = make_shared<string>(boost::any_cast<string>(m["IkeLifetime"]));
    }
    if (m.find("IkeMode") != m.end() && !m["IkeMode"].empty()) {
      ikeMode = make_shared<string>(boost::any_cast<string>(m["IkeMode"]));
    }
    if (m.find("IkePfs") != m.end() && !m["IkePfs"].empty()) {
      ikePfs = make_shared<string>(boost::any_cast<string>(m["IkePfs"]));
    }
    if (m.find("IkeVersion") != m.end() && !m["IkeVersion"].empty()) {
      ikeVersion = make_shared<string>(boost::any_cast<string>(m["IkeVersion"]));
    }
    if (m.find("LocalId") != m.end() && !m["LocalId"].empty()) {
      localId = make_shared<string>(boost::any_cast<string>(m["LocalId"]));
    }
    if (m.find("Psk") != m.end() && !m["Psk"].empty()) {
      psk = make_shared<string>(boost::any_cast<string>(m["Psk"]));
    }
    if (m.find("RemoteId") != m.end() && !m["RemoteId"].empty()) {
      remoteId = make_shared<string>(boost::any_cast<string>(m["RemoteId"]));
    }
  }


  virtual ~DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig() = default;
};
class DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig : public Darabonba::Model {
public:
  shared_ptr<string> ipsecAuthAlg{};
  shared_ptr<string> ipsecEncAlg{};
  shared_ptr<string> ipsecLifetime{};
  shared_ptr<string> ipsecPfs{};

  DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig() {}

  explicit DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipsecAuthAlg) {
      res["IpsecAuthAlg"] = boost::any(*ipsecAuthAlg);
    }
    if (ipsecEncAlg) {
      res["IpsecEncAlg"] = boost::any(*ipsecEncAlg);
    }
    if (ipsecLifetime) {
      res["IpsecLifetime"] = boost::any(*ipsecLifetime);
    }
    if (ipsecPfs) {
      res["IpsecPfs"] = boost::any(*ipsecPfs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpsecAuthAlg") != m.end() && !m["IpsecAuthAlg"].empty()) {
      ipsecAuthAlg = make_shared<string>(boost::any_cast<string>(m["IpsecAuthAlg"]));
    }
    if (m.find("IpsecEncAlg") != m.end() && !m["IpsecEncAlg"].empty()) {
      ipsecEncAlg = make_shared<string>(boost::any_cast<string>(m["IpsecEncAlg"]));
    }
    if (m.find("IpsecLifetime") != m.end() && !m["IpsecLifetime"].empty()) {
      ipsecLifetime = make_shared<string>(boost::any_cast<string>(m["IpsecLifetime"]));
    }
    if (m.find("IpsecPfs") != m.end() && !m["IpsecPfs"].empty()) {
      ipsecPfs = make_shared<string>(boost::any_cast<string>(m["IpsecPfs"]));
    }
  }


  virtual ~DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig() = default;
};
class DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions : public Darabonba::Model {
public:
  shared_ptr<string> customerGatewayId{};
  shared_ptr<string> enableDpd{};
  shared_ptr<string> enableNatTraversal{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> remoteCaCertificate{};
  shared_ptr<string> role{};
  shared_ptr<string> state{};
  shared_ptr<string> status{};
  shared_ptr<DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig> tunnelBgpConfig{};
  shared_ptr<string> tunnelId{};
  shared_ptr<DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig> tunnelIkeConfig{};
  shared_ptr<DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig> tunnelIpsecConfig{};
  shared_ptr<string> zoneNo{};

  DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions() {}

  explicit DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (enableDpd) {
      res["EnableDpd"] = boost::any(*enableDpd);
    }
    if (enableNatTraversal) {
      res["EnableNatTraversal"] = boost::any(*enableNatTraversal);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (remoteCaCertificate) {
      res["RemoteCaCertificate"] = boost::any(*remoteCaCertificate);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tunnelBgpConfig) {
      res["TunnelBgpConfig"] = tunnelBgpConfig ? boost::any(tunnelBgpConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tunnelId) {
      res["TunnelId"] = boost::any(*tunnelId);
    }
    if (tunnelIkeConfig) {
      res["TunnelIkeConfig"] = tunnelIkeConfig ? boost::any(tunnelIkeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tunnelIpsecConfig) {
      res["TunnelIpsecConfig"] = tunnelIpsecConfig ? boost::any(tunnelIpsecConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (zoneNo) {
      res["ZoneNo"] = boost::any(*zoneNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("EnableDpd") != m.end() && !m["EnableDpd"].empty()) {
      enableDpd = make_shared<string>(boost::any_cast<string>(m["EnableDpd"]));
    }
    if (m.find("EnableNatTraversal") != m.end() && !m["EnableNatTraversal"].empty()) {
      enableNatTraversal = make_shared<string>(boost::any_cast<string>(m["EnableNatTraversal"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("RemoteCaCertificate") != m.end() && !m["RemoteCaCertificate"].empty()) {
      remoteCaCertificate = make_shared<string>(boost::any_cast<string>(m["RemoteCaCertificate"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TunnelBgpConfig") != m.end() && !m["TunnelBgpConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelBgpConfig"].type()) {
        DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelBgpConfig"]));
        tunnelBgpConfig = make_shared<DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig>(model1);
      }
    }
    if (m.find("TunnelId") != m.end() && !m["TunnelId"].empty()) {
      tunnelId = make_shared<string>(boost::any_cast<string>(m["TunnelId"]));
    }
    if (m.find("TunnelIkeConfig") != m.end() && !m["TunnelIkeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelIkeConfig"].type()) {
        DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelIkeConfig"]));
        tunnelIkeConfig = make_shared<DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig>(model1);
      }
    }
    if (m.find("TunnelIpsecConfig") != m.end() && !m["TunnelIpsecConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelIpsecConfig"].type()) {
        DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelIpsecConfig"]));
        tunnelIpsecConfig = make_shared<DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig>(model1);
      }
    }
    if (m.find("ZoneNo") != m.end() && !m["ZoneNo"].empty()) {
      zoneNo = make_shared<string>(boost::any_cast<string>(m["ZoneNo"]));
    }
  }


  virtual ~DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions() = default;
};
class DescribeVpnConnectionResponseBodyTunnelOptionsSpecification : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions>> tunnelOptions{};

  DescribeVpnConnectionResponseBodyTunnelOptionsSpecification() {}

  explicit DescribeVpnConnectionResponseBodyTunnelOptionsSpecification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tunnelOptions) {
      vector<boost::any> temp1;
      for(auto item1:*tunnelOptions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TunnelOptions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TunnelOptions") != m.end() && !m["TunnelOptions"].empty()) {
      if (typeid(vector<boost::any>) == m["TunnelOptions"].type()) {
        vector<DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TunnelOptions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tunnelOptions = make_shared<vector<DescribeVpnConnectionResponseBodyTunnelOptionsSpecificationTunnelOptions>>(expect1);
      }
    }
  }


  virtual ~DescribeVpnConnectionResponseBodyTunnelOptionsSpecification() = default;
};
class DescribeVpnConnectionResponseBodyVcoHealthCheck : public Darabonba::Model {
public:
  shared_ptr<string> dip{};
  shared_ptr<string> enable{};
  shared_ptr<long> interval{};
  shared_ptr<string> policy{};
  shared_ptr<long> retry{};
  shared_ptr<string> sip{};
  shared_ptr<string> status{};

  DescribeVpnConnectionResponseBodyVcoHealthCheck() {}

  explicit DescribeVpnConnectionResponseBodyVcoHealthCheck(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dip) {
      res["Dip"] = boost::any(*dip);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (retry) {
      res["Retry"] = boost::any(*retry);
    }
    if (sip) {
      res["Sip"] = boost::any(*sip);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dip") != m.end() && !m["Dip"].empty()) {
      dip = make_shared<string>(boost::any_cast<string>(m["Dip"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Retry") != m.end() && !m["Retry"].empty()) {
      retry = make_shared<long>(boost::any_cast<long>(m["Retry"]));
    }
    if (m.find("Sip") != m.end() && !m["Sip"].empty()) {
      sip = make_shared<string>(boost::any_cast<string>(m["Sip"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeVpnConnectionResponseBodyVcoHealthCheck() = default;
};
class DescribeVpnConnectionResponseBodyVpnBgpConfig : public Darabonba::Model {
public:
  shared_ptr<string> authKey{};
  shared_ptr<string> enableBgp{};
  shared_ptr<long> localAsn{};
  shared_ptr<string> localBgpIp{};
  shared_ptr<long> peerAsn{};
  shared_ptr<string> peerBgpIp{};
  shared_ptr<string> status{};
  shared_ptr<string> tunnelCidr{};

  DescribeVpnConnectionResponseBodyVpnBgpConfig() {}

  explicit DescribeVpnConnectionResponseBodyVpnBgpConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (enableBgp) {
      res["EnableBgp"] = boost::any(*enableBgp);
    }
    if (localAsn) {
      res["LocalAsn"] = boost::any(*localAsn);
    }
    if (localBgpIp) {
      res["LocalBgpIp"] = boost::any(*localBgpIp);
    }
    if (peerAsn) {
      res["PeerAsn"] = boost::any(*peerAsn);
    }
    if (peerBgpIp) {
      res["PeerBgpIp"] = boost::any(*peerBgpIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tunnelCidr) {
      res["TunnelCidr"] = boost::any(*tunnelCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("EnableBgp") != m.end() && !m["EnableBgp"].empty()) {
      enableBgp = make_shared<string>(boost::any_cast<string>(m["EnableBgp"]));
    }
    if (m.find("LocalAsn") != m.end() && !m["LocalAsn"].empty()) {
      localAsn = make_shared<long>(boost::any_cast<long>(m["LocalAsn"]));
    }
    if (m.find("LocalBgpIp") != m.end() && !m["LocalBgpIp"].empty()) {
      localBgpIp = make_shared<string>(boost::any_cast<string>(m["LocalBgpIp"]));
    }
    if (m.find("PeerAsn") != m.end() && !m["PeerAsn"].empty()) {
      peerAsn = make_shared<long>(boost::any_cast<long>(m["PeerAsn"]));
    }
    if (m.find("PeerBgpIp") != m.end() && !m["PeerBgpIp"].empty()) {
      peerBgpIp = make_shared<string>(boost::any_cast<string>(m["PeerBgpIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TunnelCidr") != m.end() && !m["TunnelCidr"].empty()) {
      tunnelCidr = make_shared<string>(boost::any_cast<string>(m["TunnelCidr"]));
    }
  }


  virtual ~DescribeVpnConnectionResponseBodyVpnBgpConfig() = default;
};
class DescribeVpnConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> attachInstanceId{};
  shared_ptr<string> attachType{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> crossAccountAuthorized{};
  shared_ptr<string> customerGatewayId{};
  shared_ptr<bool> effectImmediately{};
  shared_ptr<bool> enableDpd{};
  shared_ptr<bool> enableNatTraversal{};
  shared_ptr<bool> enableTunnelsBgp{};
  shared_ptr<DescribeVpnConnectionResponseBodyIkeConfig> ikeConfig{};
  shared_ptr<string> internetIp{};
  shared_ptr<DescribeVpnConnectionResponseBodyIpsecConfig> ipsecConfig{};
  shared_ptr<string> localSubnet{};
  shared_ptr<string> name{};
  shared_ptr<string> networkType{};
  shared_ptr<string> remoteCaCertificate{};
  shared_ptr<string> remoteSubnet{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> spec{};
  shared_ptr<string> state{};
  shared_ptr<string> status{};
  shared_ptr<DescribeVpnConnectionResponseBodyTags> tags{};
  shared_ptr<string> transitRouterId{};
  shared_ptr<string> transitRouterName{};
  shared_ptr<DescribeVpnConnectionResponseBodyTunnelOptionsSpecification> tunnelOptionsSpecification{};
  shared_ptr<DescribeVpnConnectionResponseBodyVcoHealthCheck> vcoHealthCheck{};
  shared_ptr<DescribeVpnConnectionResponseBodyVpnBgpConfig> vpnBgpConfig{};
  shared_ptr<string> vpnConnectionId{};
  shared_ptr<string> vpnGatewayId{};
  shared_ptr<string> zoneNo{};

  DescribeVpnConnectionResponseBody() {}

  explicit DescribeVpnConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachInstanceId) {
      res["AttachInstanceId"] = boost::any(*attachInstanceId);
    }
    if (attachType) {
      res["AttachType"] = boost::any(*attachType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (crossAccountAuthorized) {
      res["CrossAccountAuthorized"] = boost::any(*crossAccountAuthorized);
    }
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (effectImmediately) {
      res["EffectImmediately"] = boost::any(*effectImmediately);
    }
    if (enableDpd) {
      res["EnableDpd"] = boost::any(*enableDpd);
    }
    if (enableNatTraversal) {
      res["EnableNatTraversal"] = boost::any(*enableNatTraversal);
    }
    if (enableTunnelsBgp) {
      res["EnableTunnelsBgp"] = boost::any(*enableTunnelsBgp);
    }
    if (ikeConfig) {
      res["IkeConfig"] = ikeConfig ? boost::any(ikeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (ipsecConfig) {
      res["IpsecConfig"] = ipsecConfig ? boost::any(ipsecConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (localSubnet) {
      res["LocalSubnet"] = boost::any(*localSubnet);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (remoteCaCertificate) {
      res["RemoteCaCertificate"] = boost::any(*remoteCaCertificate);
    }
    if (remoteSubnet) {
      res["RemoteSubnet"] = boost::any(*remoteSubnet);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transitRouterId) {
      res["TransitRouterId"] = boost::any(*transitRouterId);
    }
    if (transitRouterName) {
      res["TransitRouterName"] = boost::any(*transitRouterName);
    }
    if (tunnelOptionsSpecification) {
      res["TunnelOptionsSpecification"] = tunnelOptionsSpecification ? boost::any(tunnelOptionsSpecification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vcoHealthCheck) {
      res["VcoHealthCheck"] = vcoHealthCheck ? boost::any(vcoHealthCheck->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpnBgpConfig) {
      res["VpnBgpConfig"] = vpnBgpConfig ? boost::any(vpnBgpConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    if (zoneNo) {
      res["ZoneNo"] = boost::any(*zoneNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachInstanceId") != m.end() && !m["AttachInstanceId"].empty()) {
      attachInstanceId = make_shared<string>(boost::any_cast<string>(m["AttachInstanceId"]));
    }
    if (m.find("AttachType") != m.end() && !m["AttachType"].empty()) {
      attachType = make_shared<string>(boost::any_cast<string>(m["AttachType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CrossAccountAuthorized") != m.end() && !m["CrossAccountAuthorized"].empty()) {
      crossAccountAuthorized = make_shared<bool>(boost::any_cast<bool>(m["CrossAccountAuthorized"]));
    }
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("EffectImmediately") != m.end() && !m["EffectImmediately"].empty()) {
      effectImmediately = make_shared<bool>(boost::any_cast<bool>(m["EffectImmediately"]));
    }
    if (m.find("EnableDpd") != m.end() && !m["EnableDpd"].empty()) {
      enableDpd = make_shared<bool>(boost::any_cast<bool>(m["EnableDpd"]));
    }
    if (m.find("EnableNatTraversal") != m.end() && !m["EnableNatTraversal"].empty()) {
      enableNatTraversal = make_shared<bool>(boost::any_cast<bool>(m["EnableNatTraversal"]));
    }
    if (m.find("EnableTunnelsBgp") != m.end() && !m["EnableTunnelsBgp"].empty()) {
      enableTunnelsBgp = make_shared<bool>(boost::any_cast<bool>(m["EnableTunnelsBgp"]));
    }
    if (m.find("IkeConfig") != m.end() && !m["IkeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IkeConfig"].type()) {
        DescribeVpnConnectionResponseBodyIkeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IkeConfig"]));
        ikeConfig = make_shared<DescribeVpnConnectionResponseBodyIkeConfig>(model1);
      }
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IpsecConfig") != m.end() && !m["IpsecConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IpsecConfig"].type()) {
        DescribeVpnConnectionResponseBodyIpsecConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IpsecConfig"]));
        ipsecConfig = make_shared<DescribeVpnConnectionResponseBodyIpsecConfig>(model1);
      }
    }
    if (m.find("LocalSubnet") != m.end() && !m["LocalSubnet"].empty()) {
      localSubnet = make_shared<string>(boost::any_cast<string>(m["LocalSubnet"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("RemoteCaCertificate") != m.end() && !m["RemoteCaCertificate"].empty()) {
      remoteCaCertificate = make_shared<string>(boost::any_cast<string>(m["RemoteCaCertificate"]));
    }
    if (m.find("RemoteSubnet") != m.end() && !m["RemoteSubnet"].empty()) {
      remoteSubnet = make_shared<string>(boost::any_cast<string>(m["RemoteSubnet"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeVpnConnectionResponseBodyTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeVpnConnectionResponseBodyTags>(model1);
      }
    }
    if (m.find("TransitRouterId") != m.end() && !m["TransitRouterId"].empty()) {
      transitRouterId = make_shared<string>(boost::any_cast<string>(m["TransitRouterId"]));
    }
    if (m.find("TransitRouterName") != m.end() && !m["TransitRouterName"].empty()) {
      transitRouterName = make_shared<string>(boost::any_cast<string>(m["TransitRouterName"]));
    }
    if (m.find("TunnelOptionsSpecification") != m.end() && !m["TunnelOptionsSpecification"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelOptionsSpecification"].type()) {
        DescribeVpnConnectionResponseBodyTunnelOptionsSpecification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelOptionsSpecification"]));
        tunnelOptionsSpecification = make_shared<DescribeVpnConnectionResponseBodyTunnelOptionsSpecification>(model1);
      }
    }
    if (m.find("VcoHealthCheck") != m.end() && !m["VcoHealthCheck"].empty()) {
      if (typeid(map<string, boost::any>) == m["VcoHealthCheck"].type()) {
        DescribeVpnConnectionResponseBodyVcoHealthCheck model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VcoHealthCheck"]));
        vcoHealthCheck = make_shared<DescribeVpnConnectionResponseBodyVcoHealthCheck>(model1);
      }
    }
    if (m.find("VpnBgpConfig") != m.end() && !m["VpnBgpConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpnBgpConfig"].type()) {
        DescribeVpnConnectionResponseBodyVpnBgpConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpnBgpConfig"]));
        vpnBgpConfig = make_shared<DescribeVpnConnectionResponseBodyVpnBgpConfig>(model1);
      }
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
    if (m.find("ZoneNo") != m.end() && !m["ZoneNo"].empty()) {
      zoneNo = make_shared<string>(boost::any_cast<string>(m["ZoneNo"]));
    }
  }


  virtual ~DescribeVpnConnectionResponseBody() = default;
};
class DescribeVpnConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVpnConnectionResponseBody> body{};

  DescribeVpnConnectionResponse() {}

  explicit DescribeVpnConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpnConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpnConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpnConnectionResponse() = default;
};
class DescribeVpnConnectionLogsRequest : public Darabonba::Model {
public:
  shared_ptr<long> from{};
  shared_ptr<long> minutePeriod{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> to{};
  shared_ptr<string> tunnelId{};
  shared_ptr<string> vpnConnectionId{};

  DescribeVpnConnectionLogsRequest() {}

  explicit DescribeVpnConnectionLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (minutePeriod) {
      res["MinutePeriod"] = boost::any(*minutePeriod);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (tunnelId) {
      res["TunnelId"] = boost::any(*tunnelId);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<long>(boost::any_cast<long>(m["From"]));
    }
    if (m.find("MinutePeriod") != m.end() && !m["MinutePeriod"].empty()) {
      minutePeriod = make_shared<long>(boost::any_cast<long>(m["MinutePeriod"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<long>(boost::any_cast<long>(m["To"]));
    }
    if (m.find("TunnelId") != m.end() && !m["TunnelId"].empty()) {
      tunnelId = make_shared<string>(boost::any_cast<string>(m["TunnelId"]));
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
  }


  virtual ~DescribeVpnConnectionLogsRequest() = default;
};
class DescribeVpnConnectionLogsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> logs{};

  DescribeVpnConnectionLogsResponseBodyData() {}

  explicit DescribeVpnConnectionLogsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logs) {
      res["Logs"] = boost::any(*logs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Logs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      logs = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVpnConnectionLogsResponseBodyData() = default;
};
class DescribeVpnConnectionLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<DescribeVpnConnectionLogsResponseBodyData> data{};
  shared_ptr<bool> isCompleted{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};

  DescribeVpnConnectionLogsResponseBody() {}

  explicit DescribeVpnConnectionLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isCompleted) {
      res["IsCompleted"] = boost::any(*isCompleted);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeVpnConnectionLogsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeVpnConnectionLogsResponseBodyData>(model1);
      }
    }
    if (m.find("IsCompleted") != m.end() && !m["IsCompleted"].empty()) {
      isCompleted = make_shared<bool>(boost::any_cast<bool>(m["IsCompleted"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVpnConnectionLogsResponseBody() = default;
};
class DescribeVpnConnectionLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVpnConnectionLogsResponseBody> body{};

  DescribeVpnConnectionLogsResponse() {}

  explicit DescribeVpnConnectionLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpnConnectionLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpnConnectionLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpnConnectionLogsResponse() = default;
};
class DescribeVpnConnectionsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeVpnConnectionsRequestTag() {}

  explicit DescribeVpnConnectionsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVpnConnectionsRequestTag() = default;
};
class DescribeVpnConnectionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> customerGatewayId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<DescribeVpnConnectionsRequestTag>> tag{};
  shared_ptr<string> vpnConnectionId{};
  shared_ptr<string> vpnGatewayId{};

  DescribeVpnConnectionsRequest() {}

  explicit DescribeVpnConnectionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeVpnConnectionsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpnConnectionsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeVpnConnectionsRequestTag>>(expect1);
      }
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~DescribeVpnConnectionsRequest() = default;
};
class DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig : public Darabonba::Model {
public:
  shared_ptr<string> ikeAuthAlg{};
  shared_ptr<string> ikeEncAlg{};
  shared_ptr<long> ikeLifetime{};
  shared_ptr<string> ikeMode{};
  shared_ptr<string> ikePfs{};
  shared_ptr<string> ikeVersion{};
  shared_ptr<string> localId{};
  shared_ptr<string> psk{};
  shared_ptr<string> remoteId{};

  DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig() {}

  explicit DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ikeAuthAlg) {
      res["IkeAuthAlg"] = boost::any(*ikeAuthAlg);
    }
    if (ikeEncAlg) {
      res["IkeEncAlg"] = boost::any(*ikeEncAlg);
    }
    if (ikeLifetime) {
      res["IkeLifetime"] = boost::any(*ikeLifetime);
    }
    if (ikeMode) {
      res["IkeMode"] = boost::any(*ikeMode);
    }
    if (ikePfs) {
      res["IkePfs"] = boost::any(*ikePfs);
    }
    if (ikeVersion) {
      res["IkeVersion"] = boost::any(*ikeVersion);
    }
    if (localId) {
      res["LocalId"] = boost::any(*localId);
    }
    if (psk) {
      res["Psk"] = boost::any(*psk);
    }
    if (remoteId) {
      res["RemoteId"] = boost::any(*remoteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IkeAuthAlg") != m.end() && !m["IkeAuthAlg"].empty()) {
      ikeAuthAlg = make_shared<string>(boost::any_cast<string>(m["IkeAuthAlg"]));
    }
    if (m.find("IkeEncAlg") != m.end() && !m["IkeEncAlg"].empty()) {
      ikeEncAlg = make_shared<string>(boost::any_cast<string>(m["IkeEncAlg"]));
    }
    if (m.find("IkeLifetime") != m.end() && !m["IkeLifetime"].empty()) {
      ikeLifetime = make_shared<long>(boost::any_cast<long>(m["IkeLifetime"]));
    }
    if (m.find("IkeMode") != m.end() && !m["IkeMode"].empty()) {
      ikeMode = make_shared<string>(boost::any_cast<string>(m["IkeMode"]));
    }
    if (m.find("IkePfs") != m.end() && !m["IkePfs"].empty()) {
      ikePfs = make_shared<string>(boost::any_cast<string>(m["IkePfs"]));
    }
    if (m.find("IkeVersion") != m.end() && !m["IkeVersion"].empty()) {
      ikeVersion = make_shared<string>(boost::any_cast<string>(m["IkeVersion"]));
    }
    if (m.find("LocalId") != m.end() && !m["LocalId"].empty()) {
      localId = make_shared<string>(boost::any_cast<string>(m["LocalId"]));
    }
    if (m.find("Psk") != m.end() && !m["Psk"].empty()) {
      psk = make_shared<string>(boost::any_cast<string>(m["Psk"]));
    }
    if (m.find("RemoteId") != m.end() && !m["RemoteId"].empty()) {
      remoteId = make_shared<string>(boost::any_cast<string>(m["RemoteId"]));
    }
  }


  virtual ~DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig() = default;
};
class DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig : public Darabonba::Model {
public:
  shared_ptr<string> ipsecAuthAlg{};
  shared_ptr<string> ipsecEncAlg{};
  shared_ptr<long> ipsecLifetime{};
  shared_ptr<string> ipsecPfs{};

  DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig() {}

  explicit DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipsecAuthAlg) {
      res["IpsecAuthAlg"] = boost::any(*ipsecAuthAlg);
    }
    if (ipsecEncAlg) {
      res["IpsecEncAlg"] = boost::any(*ipsecEncAlg);
    }
    if (ipsecLifetime) {
      res["IpsecLifetime"] = boost::any(*ipsecLifetime);
    }
    if (ipsecPfs) {
      res["IpsecPfs"] = boost::any(*ipsecPfs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpsecAuthAlg") != m.end() && !m["IpsecAuthAlg"].empty()) {
      ipsecAuthAlg = make_shared<string>(boost::any_cast<string>(m["IpsecAuthAlg"]));
    }
    if (m.find("IpsecEncAlg") != m.end() && !m["IpsecEncAlg"].empty()) {
      ipsecEncAlg = make_shared<string>(boost::any_cast<string>(m["IpsecEncAlg"]));
    }
    if (m.find("IpsecLifetime") != m.end() && !m["IpsecLifetime"].empty()) {
      ipsecLifetime = make_shared<long>(boost::any_cast<long>(m["IpsecLifetime"]));
    }
    if (m.find("IpsecPfs") != m.end() && !m["IpsecPfs"].empty()) {
      ipsecPfs = make_shared<string>(boost::any_cast<string>(m["IpsecPfs"]));
    }
  }


  virtual ~DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig() = default;
};
class DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTagTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTagTag() {}

  explicit DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTagTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTagTag() = default;
};
class DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTag : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTagTag>> tag{};

  DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTag() {}

  explicit DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTagTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTagTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTagTag>>(expect1);
      }
    }
  }


  virtual ~DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTag() = default;
};
class DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig : public Darabonba::Model {
public:
  shared_ptr<string> bgpStatus{};
  shared_ptr<string> localAsn{};
  shared_ptr<string> localBgpIp{};
  shared_ptr<string> peerAsn{};
  shared_ptr<string> peerBgpIp{};
  shared_ptr<string> tunnelCidr{};

  DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig() {}

  explicit DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgpStatus) {
      res["BgpStatus"] = boost::any(*bgpStatus);
    }
    if (localAsn) {
      res["LocalAsn"] = boost::any(*localAsn);
    }
    if (localBgpIp) {
      res["LocalBgpIp"] = boost::any(*localBgpIp);
    }
    if (peerAsn) {
      res["PeerAsn"] = boost::any(*peerAsn);
    }
    if (peerBgpIp) {
      res["PeerBgpIp"] = boost::any(*peerBgpIp);
    }
    if (tunnelCidr) {
      res["TunnelCidr"] = boost::any(*tunnelCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgpStatus") != m.end() && !m["BgpStatus"].empty()) {
      bgpStatus = make_shared<string>(boost::any_cast<string>(m["BgpStatus"]));
    }
    if (m.find("LocalAsn") != m.end() && !m["LocalAsn"].empty()) {
      localAsn = make_shared<string>(boost::any_cast<string>(m["LocalAsn"]));
    }
    if (m.find("LocalBgpIp") != m.end() && !m["LocalBgpIp"].empty()) {
      localBgpIp = make_shared<string>(boost::any_cast<string>(m["LocalBgpIp"]));
    }
    if (m.find("PeerAsn") != m.end() && !m["PeerAsn"].empty()) {
      peerAsn = make_shared<string>(boost::any_cast<string>(m["PeerAsn"]));
    }
    if (m.find("PeerBgpIp") != m.end() && !m["PeerBgpIp"].empty()) {
      peerBgpIp = make_shared<string>(boost::any_cast<string>(m["PeerBgpIp"]));
    }
    if (m.find("TunnelCidr") != m.end() && !m["TunnelCidr"].empty()) {
      tunnelCidr = make_shared<string>(boost::any_cast<string>(m["TunnelCidr"]));
    }
  }


  virtual ~DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig() = default;
};
class DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig : public Darabonba::Model {
public:
  shared_ptr<string> ikeAuthAlg{};
  shared_ptr<string> ikeEncAlg{};
  shared_ptr<string> ikeLifetime{};
  shared_ptr<string> ikeMode{};
  shared_ptr<string> ikePfs{};
  shared_ptr<string> ikeVersion{};
  shared_ptr<string> localId{};
  shared_ptr<string> psk{};
  shared_ptr<string> remoteId{};

  DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig() {}

  explicit DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ikeAuthAlg) {
      res["IkeAuthAlg"] = boost::any(*ikeAuthAlg);
    }
    if (ikeEncAlg) {
      res["IkeEncAlg"] = boost::any(*ikeEncAlg);
    }
    if (ikeLifetime) {
      res["IkeLifetime"] = boost::any(*ikeLifetime);
    }
    if (ikeMode) {
      res["IkeMode"] = boost::any(*ikeMode);
    }
    if (ikePfs) {
      res["IkePfs"] = boost::any(*ikePfs);
    }
    if (ikeVersion) {
      res["IkeVersion"] = boost::any(*ikeVersion);
    }
    if (localId) {
      res["LocalId"] = boost::any(*localId);
    }
    if (psk) {
      res["Psk"] = boost::any(*psk);
    }
    if (remoteId) {
      res["RemoteId"] = boost::any(*remoteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IkeAuthAlg") != m.end() && !m["IkeAuthAlg"].empty()) {
      ikeAuthAlg = make_shared<string>(boost::any_cast<string>(m["IkeAuthAlg"]));
    }
    if (m.find("IkeEncAlg") != m.end() && !m["IkeEncAlg"].empty()) {
      ikeEncAlg = make_shared<string>(boost::any_cast<string>(m["IkeEncAlg"]));
    }
    if (m.find("IkeLifetime") != m.end() && !m["IkeLifetime"].empty()) {
      ikeLifetime = make_shared<string>(boost::any_cast<string>(m["IkeLifetime"]));
    }
    if (m.find("IkeMode") != m.end() && !m["IkeMode"].empty()) {
      ikeMode = make_shared<string>(boost::any_cast<string>(m["IkeMode"]));
    }
    if (m.find("IkePfs") != m.end() && !m["IkePfs"].empty()) {
      ikePfs = make_shared<string>(boost::any_cast<string>(m["IkePfs"]));
    }
    if (m.find("IkeVersion") != m.end() && !m["IkeVersion"].empty()) {
      ikeVersion = make_shared<string>(boost::any_cast<string>(m["IkeVersion"]));
    }
    if (m.find("LocalId") != m.end() && !m["LocalId"].empty()) {
      localId = make_shared<string>(boost::any_cast<string>(m["LocalId"]));
    }
    if (m.find("Psk") != m.end() && !m["Psk"].empty()) {
      psk = make_shared<string>(boost::any_cast<string>(m["Psk"]));
    }
    if (m.find("RemoteId") != m.end() && !m["RemoteId"].empty()) {
      remoteId = make_shared<string>(boost::any_cast<string>(m["RemoteId"]));
    }
  }


  virtual ~DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig() = default;
};
class DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig : public Darabonba::Model {
public:
  shared_ptr<string> ipsecAuthAlg{};
  shared_ptr<string> ipsecEncAlg{};
  shared_ptr<string> ipsecLifetime{};
  shared_ptr<string> ipsecPfs{};

  DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig() {}

  explicit DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipsecAuthAlg) {
      res["IpsecAuthAlg"] = boost::any(*ipsecAuthAlg);
    }
    if (ipsecEncAlg) {
      res["IpsecEncAlg"] = boost::any(*ipsecEncAlg);
    }
    if (ipsecLifetime) {
      res["IpsecLifetime"] = boost::any(*ipsecLifetime);
    }
    if (ipsecPfs) {
      res["IpsecPfs"] = boost::any(*ipsecPfs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpsecAuthAlg") != m.end() && !m["IpsecAuthAlg"].empty()) {
      ipsecAuthAlg = make_shared<string>(boost::any_cast<string>(m["IpsecAuthAlg"]));
    }
    if (m.find("IpsecEncAlg") != m.end() && !m["IpsecEncAlg"].empty()) {
      ipsecEncAlg = make_shared<string>(boost::any_cast<string>(m["IpsecEncAlg"]));
    }
    if (m.find("IpsecLifetime") != m.end() && !m["IpsecLifetime"].empty()) {
      ipsecLifetime = make_shared<string>(boost::any_cast<string>(m["IpsecLifetime"]));
    }
    if (m.find("IpsecPfs") != m.end() && !m["IpsecPfs"].empty()) {
      ipsecPfs = make_shared<string>(boost::any_cast<string>(m["IpsecPfs"]));
    }
  }


  virtual ~DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig() = default;
};
class DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions : public Darabonba::Model {
public:
  shared_ptr<string> customerGatewayId{};
  shared_ptr<string> enableDpd{};
  shared_ptr<string> enableNatTraversal{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> remoteCaCertificate{};
  shared_ptr<string> role{};
  shared_ptr<string> state{};
  shared_ptr<string> status{};
  shared_ptr<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig> tunnelBgpConfig{};
  shared_ptr<string> tunnelId{};
  shared_ptr<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig> tunnelIkeConfig{};
  shared_ptr<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig> tunnelIpsecConfig{};
  shared_ptr<string> zoneNo{};

  DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions() {}

  explicit DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (enableDpd) {
      res["EnableDpd"] = boost::any(*enableDpd);
    }
    if (enableNatTraversal) {
      res["EnableNatTraversal"] = boost::any(*enableNatTraversal);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (remoteCaCertificate) {
      res["RemoteCaCertificate"] = boost::any(*remoteCaCertificate);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tunnelBgpConfig) {
      res["TunnelBgpConfig"] = tunnelBgpConfig ? boost::any(tunnelBgpConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tunnelId) {
      res["TunnelId"] = boost::any(*tunnelId);
    }
    if (tunnelIkeConfig) {
      res["TunnelIkeConfig"] = tunnelIkeConfig ? boost::any(tunnelIkeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tunnelIpsecConfig) {
      res["TunnelIpsecConfig"] = tunnelIpsecConfig ? boost::any(tunnelIpsecConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (zoneNo) {
      res["ZoneNo"] = boost::any(*zoneNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("EnableDpd") != m.end() && !m["EnableDpd"].empty()) {
      enableDpd = make_shared<string>(boost::any_cast<string>(m["EnableDpd"]));
    }
    if (m.find("EnableNatTraversal") != m.end() && !m["EnableNatTraversal"].empty()) {
      enableNatTraversal = make_shared<string>(boost::any_cast<string>(m["EnableNatTraversal"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("RemoteCaCertificate") != m.end() && !m["RemoteCaCertificate"].empty()) {
      remoteCaCertificate = make_shared<string>(boost::any_cast<string>(m["RemoteCaCertificate"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TunnelBgpConfig") != m.end() && !m["TunnelBgpConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelBgpConfig"].type()) {
        DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelBgpConfig"]));
        tunnelBgpConfig = make_shared<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig>(model1);
      }
    }
    if (m.find("TunnelId") != m.end() && !m["TunnelId"].empty()) {
      tunnelId = make_shared<string>(boost::any_cast<string>(m["TunnelId"]));
    }
    if (m.find("TunnelIkeConfig") != m.end() && !m["TunnelIkeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelIkeConfig"].type()) {
        DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelIkeConfig"]));
        tunnelIkeConfig = make_shared<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig>(model1);
      }
    }
    if (m.find("TunnelIpsecConfig") != m.end() && !m["TunnelIpsecConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelIpsecConfig"].type()) {
        DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelIpsecConfig"]));
        tunnelIpsecConfig = make_shared<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig>(model1);
      }
    }
    if (m.find("ZoneNo") != m.end() && !m["ZoneNo"].empty()) {
      zoneNo = make_shared<string>(boost::any_cast<string>(m["ZoneNo"]));
    }
  }


  virtual ~DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions() = default;
};
class DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecification : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions>> tunnelOptions{};

  DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecification() {}

  explicit DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tunnelOptions) {
      vector<boost::any> temp1;
      for(auto item1:*tunnelOptions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TunnelOptions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TunnelOptions") != m.end() && !m["TunnelOptions"].empty()) {
      if (typeid(vector<boost::any>) == m["TunnelOptions"].type()) {
        vector<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TunnelOptions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tunnelOptions = make_shared<vector<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecificationTunnelOptions>>(expect1);
      }
    }
  }


  virtual ~DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecification() = default;
};
class DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck : public Darabonba::Model {
public:
  shared_ptr<string> dip{};
  shared_ptr<string> enable{};
  shared_ptr<long> interval{};
  shared_ptr<string> policy{};
  shared_ptr<long> retry{};
  shared_ptr<string> sip{};
  shared_ptr<string> status{};

  DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck() {}

  explicit DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dip) {
      res["Dip"] = boost::any(*dip);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (retry) {
      res["Retry"] = boost::any(*retry);
    }
    if (sip) {
      res["Sip"] = boost::any(*sip);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dip") != m.end() && !m["Dip"].empty()) {
      dip = make_shared<string>(boost::any_cast<string>(m["Dip"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Retry") != m.end() && !m["Retry"].empty()) {
      retry = make_shared<long>(boost::any_cast<long>(m["Retry"]));
    }
    if (m.find("Sip") != m.end() && !m["Sip"].empty()) {
      sip = make_shared<string>(boost::any_cast<string>(m["Sip"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck() = default;
};
class DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig : public Darabonba::Model {
public:
  shared_ptr<string> authKey{};
  shared_ptr<long> localAsn{};
  shared_ptr<string> localBgpIp{};
  shared_ptr<long> peerAsn{};
  shared_ptr<string> peerBgpIp{};
  shared_ptr<string> status{};
  shared_ptr<string> tunnelCidr{};

  DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig() {}

  explicit DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (localAsn) {
      res["LocalAsn"] = boost::any(*localAsn);
    }
    if (localBgpIp) {
      res["LocalBgpIp"] = boost::any(*localBgpIp);
    }
    if (peerAsn) {
      res["PeerAsn"] = boost::any(*peerAsn);
    }
    if (peerBgpIp) {
      res["PeerBgpIp"] = boost::any(*peerBgpIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tunnelCidr) {
      res["TunnelCidr"] = boost::any(*tunnelCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("LocalAsn") != m.end() && !m["LocalAsn"].empty()) {
      localAsn = make_shared<long>(boost::any_cast<long>(m["LocalAsn"]));
    }
    if (m.find("LocalBgpIp") != m.end() && !m["LocalBgpIp"].empty()) {
      localBgpIp = make_shared<string>(boost::any_cast<string>(m["LocalBgpIp"]));
    }
    if (m.find("PeerAsn") != m.end() && !m["PeerAsn"].empty()) {
      peerAsn = make_shared<long>(boost::any_cast<long>(m["PeerAsn"]));
    }
    if (m.find("PeerBgpIp") != m.end() && !m["PeerBgpIp"].empty()) {
      peerBgpIp = make_shared<string>(boost::any_cast<string>(m["PeerBgpIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TunnelCidr") != m.end() && !m["TunnelCidr"].empty()) {
      tunnelCidr = make_shared<string>(boost::any_cast<string>(m["TunnelCidr"]));
    }
  }


  virtual ~DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig() = default;
};
class DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection : public Darabonba::Model {
public:
  shared_ptr<string> attachInstanceId{};
  shared_ptr<string> attachType{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> crossAccountAuthorized{};
  shared_ptr<string> customerGatewayId{};
  shared_ptr<bool> effectImmediately{};
  shared_ptr<bool> enableDpd{};
  shared_ptr<bool> enableNatTraversal{};
  shared_ptr<bool> enableTunnelsBgp{};
  shared_ptr<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig> ikeConfig{};
  shared_ptr<string> internetIp{};
  shared_ptr<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig> ipsecConfig{};
  shared_ptr<string> localSubnet{};
  shared_ptr<string> name{};
  shared_ptr<string> networkType{};
  shared_ptr<string> remoteCaCertificate{};
  shared_ptr<string> remoteSubnet{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> spec{};
  shared_ptr<string> state{};
  shared_ptr<string> status{};
  shared_ptr<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTag> tag{};
  shared_ptr<string> transitRouterId{};
  shared_ptr<string> transitRouterName{};
  shared_ptr<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecification> tunnelOptionsSpecification{};
  shared_ptr<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck> vcoHealthCheck{};
  shared_ptr<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig> vpnBgpConfig{};
  shared_ptr<string> vpnConnectionId{};
  shared_ptr<string> vpnGatewayId{};

  DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection() {}

  explicit DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachInstanceId) {
      res["AttachInstanceId"] = boost::any(*attachInstanceId);
    }
    if (attachType) {
      res["AttachType"] = boost::any(*attachType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (crossAccountAuthorized) {
      res["CrossAccountAuthorized"] = boost::any(*crossAccountAuthorized);
    }
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (effectImmediately) {
      res["EffectImmediately"] = boost::any(*effectImmediately);
    }
    if (enableDpd) {
      res["EnableDpd"] = boost::any(*enableDpd);
    }
    if (enableNatTraversal) {
      res["EnableNatTraversal"] = boost::any(*enableNatTraversal);
    }
    if (enableTunnelsBgp) {
      res["EnableTunnelsBgp"] = boost::any(*enableTunnelsBgp);
    }
    if (ikeConfig) {
      res["IkeConfig"] = ikeConfig ? boost::any(ikeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (ipsecConfig) {
      res["IpsecConfig"] = ipsecConfig ? boost::any(ipsecConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (localSubnet) {
      res["LocalSubnet"] = boost::any(*localSubnet);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (remoteCaCertificate) {
      res["RemoteCaCertificate"] = boost::any(*remoteCaCertificate);
    }
    if (remoteSubnet) {
      res["RemoteSubnet"] = boost::any(*remoteSubnet);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      res["Tag"] = tag ? boost::any(tag->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transitRouterId) {
      res["TransitRouterId"] = boost::any(*transitRouterId);
    }
    if (transitRouterName) {
      res["TransitRouterName"] = boost::any(*transitRouterName);
    }
    if (tunnelOptionsSpecification) {
      res["TunnelOptionsSpecification"] = tunnelOptionsSpecification ? boost::any(tunnelOptionsSpecification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vcoHealthCheck) {
      res["VcoHealthCheck"] = vcoHealthCheck ? boost::any(vcoHealthCheck->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpnBgpConfig) {
      res["VpnBgpConfig"] = vpnBgpConfig ? boost::any(vpnBgpConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachInstanceId") != m.end() && !m["AttachInstanceId"].empty()) {
      attachInstanceId = make_shared<string>(boost::any_cast<string>(m["AttachInstanceId"]));
    }
    if (m.find("AttachType") != m.end() && !m["AttachType"].empty()) {
      attachType = make_shared<string>(boost::any_cast<string>(m["AttachType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CrossAccountAuthorized") != m.end() && !m["CrossAccountAuthorized"].empty()) {
      crossAccountAuthorized = make_shared<bool>(boost::any_cast<bool>(m["CrossAccountAuthorized"]));
    }
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("EffectImmediately") != m.end() && !m["EffectImmediately"].empty()) {
      effectImmediately = make_shared<bool>(boost::any_cast<bool>(m["EffectImmediately"]));
    }
    if (m.find("EnableDpd") != m.end() && !m["EnableDpd"].empty()) {
      enableDpd = make_shared<bool>(boost::any_cast<bool>(m["EnableDpd"]));
    }
    if (m.find("EnableNatTraversal") != m.end() && !m["EnableNatTraversal"].empty()) {
      enableNatTraversal = make_shared<bool>(boost::any_cast<bool>(m["EnableNatTraversal"]));
    }
    if (m.find("EnableTunnelsBgp") != m.end() && !m["EnableTunnelsBgp"].empty()) {
      enableTunnelsBgp = make_shared<bool>(boost::any_cast<bool>(m["EnableTunnelsBgp"]));
    }
    if (m.find("IkeConfig") != m.end() && !m["IkeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IkeConfig"].type()) {
        DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IkeConfig"]));
        ikeConfig = make_shared<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIkeConfig>(model1);
      }
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IpsecConfig") != m.end() && !m["IpsecConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IpsecConfig"].type()) {
        DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IpsecConfig"]));
        ipsecConfig = make_shared<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionIpsecConfig>(model1);
      }
    }
    if (m.find("LocalSubnet") != m.end() && !m["LocalSubnet"].empty()) {
      localSubnet = make_shared<string>(boost::any_cast<string>(m["LocalSubnet"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("RemoteCaCertificate") != m.end() && !m["RemoteCaCertificate"].empty()) {
      remoteCaCertificate = make_shared<string>(boost::any_cast<string>(m["RemoteCaCertificate"]));
    }
    if (m.find("RemoteSubnet") != m.end() && !m["RemoteSubnet"].empty()) {
      remoteSubnet = make_shared<string>(boost::any_cast<string>(m["RemoteSubnet"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tag"].type()) {
        DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTag model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tag"]));
        tag = make_shared<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTag>(model1);
      }
    }
    if (m.find("TransitRouterId") != m.end() && !m["TransitRouterId"].empty()) {
      transitRouterId = make_shared<string>(boost::any_cast<string>(m["TransitRouterId"]));
    }
    if (m.find("TransitRouterName") != m.end() && !m["TransitRouterName"].empty()) {
      transitRouterName = make_shared<string>(boost::any_cast<string>(m["TransitRouterName"]));
    }
    if (m.find("TunnelOptionsSpecification") != m.end() && !m["TunnelOptionsSpecification"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelOptionsSpecification"].type()) {
        DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelOptionsSpecification"]));
        tunnelOptionsSpecification = make_shared<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionTunnelOptionsSpecification>(model1);
      }
    }
    if (m.find("VcoHealthCheck") != m.end() && !m["VcoHealthCheck"].empty()) {
      if (typeid(map<string, boost::any>) == m["VcoHealthCheck"].type()) {
        DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VcoHealthCheck"]));
        vcoHealthCheck = make_shared<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVcoHealthCheck>(model1);
      }
    }
    if (m.find("VpnBgpConfig") != m.end() && !m["VpnBgpConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpnBgpConfig"].type()) {
        DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpnBgpConfig"]));
        vpnBgpConfig = make_shared<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnectionVpnBgpConfig>(model1);
      }
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection() = default;
};
class DescribeVpnConnectionsResponseBodyVpnConnections : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection>> vpnConnection{};

  DescribeVpnConnectionsResponseBodyVpnConnections() {}

  explicit DescribeVpnConnectionsResponseBodyVpnConnections(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpnConnection) {
      vector<boost::any> temp1;
      for(auto item1:*vpnConnection){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpnConnection"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpnConnection") != m.end() && !m["VpnConnection"].empty()) {
      if (typeid(vector<boost::any>) == m["VpnConnection"].type()) {
        vector<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpnConnection"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpnConnection = make_shared<vector<DescribeVpnConnectionsResponseBodyVpnConnectionsVpnConnection>>(expect1);
      }
    }
  }


  virtual ~DescribeVpnConnectionsResponseBodyVpnConnections() = default;
};
class DescribeVpnConnectionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeVpnConnectionsResponseBodyVpnConnections> vpnConnections{};

  DescribeVpnConnectionsResponseBody() {}

  explicit DescribeVpnConnectionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vpnConnections) {
      res["VpnConnections"] = vpnConnections ? boost::any(vpnConnections->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VpnConnections") != m.end() && !m["VpnConnections"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpnConnections"].type()) {
        DescribeVpnConnectionsResponseBodyVpnConnections model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpnConnections"]));
        vpnConnections = make_shared<DescribeVpnConnectionsResponseBodyVpnConnections>(model1);
      }
    }
  }


  virtual ~DescribeVpnConnectionsResponseBody() = default;
};
class DescribeVpnConnectionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVpnConnectionsResponseBody> body{};

  DescribeVpnConnectionsResponse() {}

  explicit DescribeVpnConnectionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpnConnectionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpnConnectionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpnConnectionsResponse() = default;
};
class DescribeVpnCrossAccountAuthorizationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpnConnectionId{};

  DescribeVpnCrossAccountAuthorizationsRequest() {}

  explicit DescribeVpnCrossAccountAuthorizationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
  }


  virtual ~DescribeVpnCrossAccountAuthorizationsRequest() = default;
};
class DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations : public Darabonba::Model {
public:
  shared_ptr<long> aliUid{};
  shared_ptr<string> bindInstance{};
  shared_ptr<string> bindProduct{};
  shared_ptr<long> bindUid{};
  shared_ptr<long> creationTime{};
  shared_ptr<string> vpnConnectionId{};

  DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations() {}

  explicit DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (bindInstance) {
      res["BindInstance"] = boost::any(*bindInstance);
    }
    if (bindProduct) {
      res["BindProduct"] = boost::any(*bindProduct);
    }
    if (bindUid) {
      res["BindUid"] = boost::any(*bindUid);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("BindInstance") != m.end() && !m["BindInstance"].empty()) {
      bindInstance = make_shared<string>(boost::any_cast<string>(m["BindInstance"]));
    }
    if (m.find("BindProduct") != m.end() && !m["BindProduct"].empty()) {
      bindProduct = make_shared<string>(boost::any_cast<string>(m["BindProduct"]));
    }
    if (m.find("BindUid") != m.end() && !m["BindUid"].empty()) {
      bindUid = make_shared<long>(boost::any_cast<long>(m["BindUid"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
  }


  virtual ~DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations() = default;
};
class DescribeVpnCrossAccountAuthorizationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations>> crossAccountAuthorizations{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeVpnCrossAccountAuthorizationsResponseBody() {}

  explicit DescribeVpnCrossAccountAuthorizationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (crossAccountAuthorizations) {
      vector<boost::any> temp1;
      for(auto item1:*crossAccountAuthorizations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CrossAccountAuthorizations"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CrossAccountAuthorizations") != m.end() && !m["CrossAccountAuthorizations"].empty()) {
      if (typeid(vector<boost::any>) == m["CrossAccountAuthorizations"].type()) {
        vector<DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CrossAccountAuthorizations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        crossAccountAuthorizations = make_shared<vector<DescribeVpnCrossAccountAuthorizationsResponseBodyCrossAccountAuthorizations>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeVpnCrossAccountAuthorizationsResponseBody() = default;
};
class DescribeVpnCrossAccountAuthorizationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVpnCrossAccountAuthorizationsResponseBody> body{};

  DescribeVpnCrossAccountAuthorizationsResponse() {}

  explicit DescribeVpnCrossAccountAuthorizationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpnCrossAccountAuthorizationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpnCrossAccountAuthorizationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpnCrossAccountAuthorizationsResponse() = default;
};
class DescribeVpnGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<bool> includeReservationData{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpnGatewayId{};

  DescribeVpnGatewayRequest() {}

  explicit DescribeVpnGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (includeReservationData) {
      res["IncludeReservationData"] = boost::any(*includeReservationData);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IncludeReservationData") != m.end() && !m["IncludeReservationData"].empty()) {
      includeReservationData = make_shared<bool>(boost::any_cast<bool>(m["IncludeReservationData"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~DescribeVpnGatewayRequest() = default;
};
class DescribeVpnGatewayResponseBodyEniInstanceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> eniInstanceId{};

  DescribeVpnGatewayResponseBodyEniInstanceIds() {}

  explicit DescribeVpnGatewayResponseBodyEniInstanceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eniInstanceId) {
      res["EniInstanceId"] = boost::any(*eniInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EniInstanceId") != m.end() && !m["EniInstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EniInstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EniInstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eniInstanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVpnGatewayResponseBodyEniInstanceIds() = default;
};
class DescribeVpnGatewayResponseBodyReservationData : public Darabonba::Model {
public:
  shared_ptr<string> reservationEndTime{};
  shared_ptr<string> reservationIpsec{};
  shared_ptr<long> reservationMaxConnections{};
  shared_ptr<string> reservationOrderType{};
  shared_ptr<string> reservationSpec{};
  shared_ptr<string> reservationSsl{};
  shared_ptr<string> status{};

  DescribeVpnGatewayResponseBodyReservationData() {}

  explicit DescribeVpnGatewayResponseBodyReservationData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reservationEndTime) {
      res["ReservationEndTime"] = boost::any(*reservationEndTime);
    }
    if (reservationIpsec) {
      res["ReservationIpsec"] = boost::any(*reservationIpsec);
    }
    if (reservationMaxConnections) {
      res["ReservationMaxConnections"] = boost::any(*reservationMaxConnections);
    }
    if (reservationOrderType) {
      res["ReservationOrderType"] = boost::any(*reservationOrderType);
    }
    if (reservationSpec) {
      res["ReservationSpec"] = boost::any(*reservationSpec);
    }
    if (reservationSsl) {
      res["ReservationSsl"] = boost::any(*reservationSsl);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReservationEndTime") != m.end() && !m["ReservationEndTime"].empty()) {
      reservationEndTime = make_shared<string>(boost::any_cast<string>(m["ReservationEndTime"]));
    }
    if (m.find("ReservationIpsec") != m.end() && !m["ReservationIpsec"].empty()) {
      reservationIpsec = make_shared<string>(boost::any_cast<string>(m["ReservationIpsec"]));
    }
    if (m.find("ReservationMaxConnections") != m.end() && !m["ReservationMaxConnections"].empty()) {
      reservationMaxConnections = make_shared<long>(boost::any_cast<long>(m["ReservationMaxConnections"]));
    }
    if (m.find("ReservationOrderType") != m.end() && !m["ReservationOrderType"].empty()) {
      reservationOrderType = make_shared<string>(boost::any_cast<string>(m["ReservationOrderType"]));
    }
    if (m.find("ReservationSpec") != m.end() && !m["ReservationSpec"].empty()) {
      reservationSpec = make_shared<string>(boost::any_cast<string>(m["ReservationSpec"]));
    }
    if (m.find("ReservationSsl") != m.end() && !m["ReservationSsl"].empty()) {
      reservationSsl = make_shared<string>(boost::any_cast<string>(m["ReservationSsl"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeVpnGatewayResponseBodyReservationData() = default;
};
class DescribeVpnGatewayResponseBodyTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeVpnGatewayResponseBodyTagsTag() {}

  explicit DescribeVpnGatewayResponseBodyTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVpnGatewayResponseBodyTagsTag() = default;
};
class DescribeVpnGatewayResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpnGatewayResponseBodyTagsTag>> tag{};

  DescribeVpnGatewayResponseBodyTags() {}

  explicit DescribeVpnGatewayResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeVpnGatewayResponseBodyTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpnGatewayResponseBodyTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeVpnGatewayResponseBodyTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeVpnGatewayResponseBodyTags() = default;
};
class DescribeVpnGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> autoPropagate{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> chargeType{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> disasterRecoveryInternetIp{};
  shared_ptr<string> disasterRecoveryVSwitchId{};
  shared_ptr<bool> enableBgp{};
  shared_ptr<long> endTime{};
  shared_ptr<DescribeVpnGatewayResponseBodyEniInstanceIds> eniInstanceIds{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> ipsecVpn{};
  shared_ptr<string> name{};
  shared_ptr<string> networkType{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeVpnGatewayResponseBodyReservationData> reservationData{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> spec{};
  shared_ptr<long> sslMaxConnections{};
  shared_ptr<string> sslVpn{};
  shared_ptr<string> sslVpnInternetIp{};
  shared_ptr<string> status{};
  shared_ptr<string> tag{};
  shared_ptr<DescribeVpnGatewayResponseBodyTags> tags{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpnGatewayId{};
  shared_ptr<string> vpnType{};

  DescribeVpnGatewayResponseBody() {}

  explicit DescribeVpnGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPropagate) {
      res["AutoPropagate"] = boost::any(*autoPropagate);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disasterRecoveryInternetIp) {
      res["DisasterRecoveryInternetIp"] = boost::any(*disasterRecoveryInternetIp);
    }
    if (disasterRecoveryVSwitchId) {
      res["DisasterRecoveryVSwitchId"] = boost::any(*disasterRecoveryVSwitchId);
    }
    if (enableBgp) {
      res["EnableBgp"] = boost::any(*enableBgp);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eniInstanceIds) {
      res["EniInstanceIds"] = eniInstanceIds ? boost::any(eniInstanceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (ipsecVpn) {
      res["IpsecVpn"] = boost::any(*ipsecVpn);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (reservationData) {
      res["ReservationData"] = reservationData ? boost::any(reservationData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (sslMaxConnections) {
      res["SslMaxConnections"] = boost::any(*sslMaxConnections);
    }
    if (sslVpn) {
      res["SslVpn"] = boost::any(*sslVpn);
    }
    if (sslVpnInternetIp) {
      res["SslVpnInternetIp"] = boost::any(*sslVpnInternetIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    if (vpnType) {
      res["VpnType"] = boost::any(*vpnType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPropagate") != m.end() && !m["AutoPropagate"].empty()) {
      autoPropagate = make_shared<bool>(boost::any_cast<bool>(m["AutoPropagate"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisasterRecoveryInternetIp") != m.end() && !m["DisasterRecoveryInternetIp"].empty()) {
      disasterRecoveryInternetIp = make_shared<string>(boost::any_cast<string>(m["DisasterRecoveryInternetIp"]));
    }
    if (m.find("DisasterRecoveryVSwitchId") != m.end() && !m["DisasterRecoveryVSwitchId"].empty()) {
      disasterRecoveryVSwitchId = make_shared<string>(boost::any_cast<string>(m["DisasterRecoveryVSwitchId"]));
    }
    if (m.find("EnableBgp") != m.end() && !m["EnableBgp"].empty()) {
      enableBgp = make_shared<bool>(boost::any_cast<bool>(m["EnableBgp"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EniInstanceIds") != m.end() && !m["EniInstanceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["EniInstanceIds"].type()) {
        DescribeVpnGatewayResponseBodyEniInstanceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EniInstanceIds"]));
        eniInstanceIds = make_shared<DescribeVpnGatewayResponseBodyEniInstanceIds>(model1);
      }
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IpsecVpn") != m.end() && !m["IpsecVpn"].empty()) {
      ipsecVpn = make_shared<string>(boost::any_cast<string>(m["IpsecVpn"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ReservationData") != m.end() && !m["ReservationData"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReservationData"].type()) {
        DescribeVpnGatewayResponseBodyReservationData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReservationData"]));
        reservationData = make_shared<DescribeVpnGatewayResponseBodyReservationData>(model1);
      }
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("SslMaxConnections") != m.end() && !m["SslMaxConnections"].empty()) {
      sslMaxConnections = make_shared<long>(boost::any_cast<long>(m["SslMaxConnections"]));
    }
    if (m.find("SslVpn") != m.end() && !m["SslVpn"].empty()) {
      sslVpn = make_shared<string>(boost::any_cast<string>(m["SslVpn"]));
    }
    if (m.find("SslVpnInternetIp") != m.end() && !m["SslVpnInternetIp"].empty()) {
      sslVpnInternetIp = make_shared<string>(boost::any_cast<string>(m["SslVpnInternetIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeVpnGatewayResponseBodyTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeVpnGatewayResponseBodyTags>(model1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
    if (m.find("VpnType") != m.end() && !m["VpnType"].empty()) {
      vpnType = make_shared<string>(boost::any_cast<string>(m["VpnType"]));
    }
  }


  virtual ~DescribeVpnGatewayResponseBody() = default;
};
class DescribeVpnGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVpnGatewayResponseBody> body{};

  DescribeVpnGatewayResponse() {}

  explicit DescribeVpnGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpnGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpnGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpnGatewayResponse() = default;
};
class DescribeVpnGatewayAvailableZonesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> spec{};

  DescribeVpnGatewayAvailableZonesRequest() {}

  explicit DescribeVpnGatewayAvailableZonesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~DescribeVpnGatewayAvailableZonesRequest() = default;
};
class DescribeVpnGatewayAvailableZonesResponseBodyAvailableZoneIdList : public Darabonba::Model {
public:
  shared_ptr<string> zoneId{};
  shared_ptr<string> zoneName{};

  DescribeVpnGatewayAvailableZonesResponseBodyAvailableZoneIdList() {}

  explicit DescribeVpnGatewayAvailableZonesResponseBodyAvailableZoneIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (zoneName) {
      res["ZoneName"] = boost::any(*zoneName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("ZoneName") != m.end() && !m["ZoneName"].empty()) {
      zoneName = make_shared<string>(boost::any_cast<string>(m["ZoneName"]));
    }
  }


  virtual ~DescribeVpnGatewayAvailableZonesResponseBodyAvailableZoneIdList() = default;
};
class DescribeVpnGatewayAvailableZonesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpnGatewayAvailableZonesResponseBodyAvailableZoneIdList>> availableZoneIdList{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};

  DescribeVpnGatewayAvailableZonesResponseBody() {}

  explicit DescribeVpnGatewayAvailableZonesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableZoneIdList) {
      vector<boost::any> temp1;
      for(auto item1:*availableZoneIdList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableZoneIdList"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableZoneIdList") != m.end() && !m["AvailableZoneIdList"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableZoneIdList"].type()) {
        vector<DescribeVpnGatewayAvailableZonesResponseBodyAvailableZoneIdList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableZoneIdList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpnGatewayAvailableZonesResponseBodyAvailableZoneIdList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableZoneIdList = make_shared<vector<DescribeVpnGatewayAvailableZonesResponseBodyAvailableZoneIdList>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVpnGatewayAvailableZonesResponseBody() = default;
};
class DescribeVpnGatewayAvailableZonesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVpnGatewayAvailableZonesResponseBody> body{};

  DescribeVpnGatewayAvailableZonesResponse() {}

  explicit DescribeVpnGatewayAvailableZonesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpnGatewayAvailableZonesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpnGatewayAvailableZonesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpnGatewayAvailableZonesResponse() = default;
};
class DescribeVpnGatewaysRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeVpnGatewaysRequestTag() {}

  explicit DescribeVpnGatewaysRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVpnGatewaysRequestTag() = default;
};
class DescribeVpnGatewaysRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessStatus{};
  shared_ptr<bool> includeReservationData{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};
  shared_ptr<vector<DescribeVpnGatewaysRequestTag>> tag{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpnGatewayId{};

  DescribeVpnGatewaysRequest() {}

  explicit DescribeVpnGatewaysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (includeReservationData) {
      res["IncludeReservationData"] = boost::any(*includeReservationData);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("IncludeReservationData") != m.end() && !m["IncludeReservationData"].empty()) {
      includeReservationData = make_shared<bool>(boost::any_cast<bool>(m["IncludeReservationData"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeVpnGatewaysRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpnGatewaysRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeVpnGatewaysRequestTag>>(expect1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~DescribeVpnGatewaysRequest() = default;
};
class DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayEniInstanceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> eniInstanceId{};

  DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayEniInstanceIds() {}

  explicit DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayEniInstanceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eniInstanceId) {
      res["EniInstanceId"] = boost::any(*eniInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EniInstanceId") != m.end() && !m["EniInstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EniInstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EniInstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eniInstanceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayEniInstanceIds() = default;
};
class DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData : public Darabonba::Model {
public:
  shared_ptr<string> reservationEndTime{};
  shared_ptr<string> reservationIpsec{};
  shared_ptr<long> reservationMaxConnections{};
  shared_ptr<string> reservationOrderType{};
  shared_ptr<string> reservationSpec{};
  shared_ptr<string> reservationSsl{};
  shared_ptr<string> status{};

  DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData() {}

  explicit DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reservationEndTime) {
      res["ReservationEndTime"] = boost::any(*reservationEndTime);
    }
    if (reservationIpsec) {
      res["ReservationIpsec"] = boost::any(*reservationIpsec);
    }
    if (reservationMaxConnections) {
      res["ReservationMaxConnections"] = boost::any(*reservationMaxConnections);
    }
    if (reservationOrderType) {
      res["ReservationOrderType"] = boost::any(*reservationOrderType);
    }
    if (reservationSpec) {
      res["ReservationSpec"] = boost::any(*reservationSpec);
    }
    if (reservationSsl) {
      res["ReservationSsl"] = boost::any(*reservationSsl);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReservationEndTime") != m.end() && !m["ReservationEndTime"].empty()) {
      reservationEndTime = make_shared<string>(boost::any_cast<string>(m["ReservationEndTime"]));
    }
    if (m.find("ReservationIpsec") != m.end() && !m["ReservationIpsec"].empty()) {
      reservationIpsec = make_shared<string>(boost::any_cast<string>(m["ReservationIpsec"]));
    }
    if (m.find("ReservationMaxConnections") != m.end() && !m["ReservationMaxConnections"].empty()) {
      reservationMaxConnections = make_shared<long>(boost::any_cast<long>(m["ReservationMaxConnections"]));
    }
    if (m.find("ReservationOrderType") != m.end() && !m["ReservationOrderType"].empty()) {
      reservationOrderType = make_shared<string>(boost::any_cast<string>(m["ReservationOrderType"]));
    }
    if (m.find("ReservationSpec") != m.end() && !m["ReservationSpec"].empty()) {
      reservationSpec = make_shared<string>(boost::any_cast<string>(m["ReservationSpec"]));
    }
    if (m.find("ReservationSsl") != m.end() && !m["ReservationSsl"].empty()) {
      reservationSsl = make_shared<string>(boost::any_cast<string>(m["ReservationSsl"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData() = default;
};
class DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTagsTag() {}

  explicit DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTagsTag() = default;
};
class DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTagsTag>> tag{};

  DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTags() {}

  explicit DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTags() = default;
};
class DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway : public Darabonba::Model {
public:
  shared_ptr<bool> autoPropagate{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> chargeType{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> disasterRecoveryInternetIp{};
  shared_ptr<string> disasterRecoveryVSwitchId{};
  shared_ptr<bool> enableBgp{};
  shared_ptr<long> endTime{};
  shared_ptr<DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayEniInstanceIds> eniInstanceIds{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> ipsecVpn{};
  shared_ptr<string> name{};
  shared_ptr<string> networkType{};
  shared_ptr<DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData> reservationData{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> spec{};
  shared_ptr<long> sslMaxConnections{};
  shared_ptr<string> sslVpn{};
  shared_ptr<string> sslVpnInternetIp{};
  shared_ptr<string> status{};
  shared_ptr<string> tag{};
  shared_ptr<DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTags> tags{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpnGatewayId{};
  shared_ptr<string> vpnType{};

  DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway() {}

  explicit DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPropagate) {
      res["AutoPropagate"] = boost::any(*autoPropagate);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disasterRecoveryInternetIp) {
      res["DisasterRecoveryInternetIp"] = boost::any(*disasterRecoveryInternetIp);
    }
    if (disasterRecoveryVSwitchId) {
      res["DisasterRecoveryVSwitchId"] = boost::any(*disasterRecoveryVSwitchId);
    }
    if (enableBgp) {
      res["EnableBgp"] = boost::any(*enableBgp);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eniInstanceIds) {
      res["EniInstanceIds"] = eniInstanceIds ? boost::any(eniInstanceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (ipsecVpn) {
      res["IpsecVpn"] = boost::any(*ipsecVpn);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (reservationData) {
      res["ReservationData"] = reservationData ? boost::any(reservationData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (sslMaxConnections) {
      res["SslMaxConnections"] = boost::any(*sslMaxConnections);
    }
    if (sslVpn) {
      res["SslVpn"] = boost::any(*sslVpn);
    }
    if (sslVpnInternetIp) {
      res["SslVpnInternetIp"] = boost::any(*sslVpnInternetIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    if (vpnType) {
      res["VpnType"] = boost::any(*vpnType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPropagate") != m.end() && !m["AutoPropagate"].empty()) {
      autoPropagate = make_shared<bool>(boost::any_cast<bool>(m["AutoPropagate"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisasterRecoveryInternetIp") != m.end() && !m["DisasterRecoveryInternetIp"].empty()) {
      disasterRecoveryInternetIp = make_shared<string>(boost::any_cast<string>(m["DisasterRecoveryInternetIp"]));
    }
    if (m.find("DisasterRecoveryVSwitchId") != m.end() && !m["DisasterRecoveryVSwitchId"].empty()) {
      disasterRecoveryVSwitchId = make_shared<string>(boost::any_cast<string>(m["DisasterRecoveryVSwitchId"]));
    }
    if (m.find("EnableBgp") != m.end() && !m["EnableBgp"].empty()) {
      enableBgp = make_shared<bool>(boost::any_cast<bool>(m["EnableBgp"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EniInstanceIds") != m.end() && !m["EniInstanceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["EniInstanceIds"].type()) {
        DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayEniInstanceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EniInstanceIds"]));
        eniInstanceIds = make_shared<DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayEniInstanceIds>(model1);
      }
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IpsecVpn") != m.end() && !m["IpsecVpn"].empty()) {
      ipsecVpn = make_shared<string>(boost::any_cast<string>(m["IpsecVpn"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("ReservationData") != m.end() && !m["ReservationData"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReservationData"].type()) {
        DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReservationData"]));
        reservationData = make_shared<DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayReservationData>(model1);
      }
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("SslMaxConnections") != m.end() && !m["SslMaxConnections"].empty()) {
      sslMaxConnections = make_shared<long>(boost::any_cast<long>(m["SslMaxConnections"]));
    }
    if (m.find("SslVpn") != m.end() && !m["SslVpn"].empty()) {
      sslVpn = make_shared<string>(boost::any_cast<string>(m["SslVpn"]));
    }
    if (m.find("SslVpnInternetIp") != m.end() && !m["SslVpnInternetIp"].empty()) {
      sslVpnInternetIp = make_shared<string>(boost::any_cast<string>(m["SslVpnInternetIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGatewayTags>(model1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
    if (m.find("VpnType") != m.end() && !m["VpnType"].empty()) {
      vpnType = make_shared<string>(boost::any_cast<string>(m["VpnType"]));
    }
  }


  virtual ~DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway() = default;
};
class DescribeVpnGatewaysResponseBodyVpnGateways : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway>> vpnGateway{};

  DescribeVpnGatewaysResponseBodyVpnGateways() {}

  explicit DescribeVpnGatewaysResponseBodyVpnGateways(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpnGateway) {
      vector<boost::any> temp1;
      for(auto item1:*vpnGateway){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpnGateway"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpnGateway") != m.end() && !m["VpnGateway"].empty()) {
      if (typeid(vector<boost::any>) == m["VpnGateway"].type()) {
        vector<DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpnGateway"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpnGateway = make_shared<vector<DescribeVpnGatewaysResponseBodyVpnGatewaysVpnGateway>>(expect1);
      }
    }
  }


  virtual ~DescribeVpnGatewaysResponseBodyVpnGateways() = default;
};
class DescribeVpnGatewaysResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeVpnGatewaysResponseBodyVpnGateways> vpnGateways{};

  DescribeVpnGatewaysResponseBody() {}

  explicit DescribeVpnGatewaysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vpnGateways) {
      res["VpnGateways"] = vpnGateways ? boost::any(vpnGateways->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VpnGateways") != m.end() && !m["VpnGateways"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpnGateways"].type()) {
        DescribeVpnGatewaysResponseBodyVpnGateways model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpnGateways"]));
        vpnGateways = make_shared<DescribeVpnGatewaysResponseBodyVpnGateways>(model1);
      }
    }
  }


  virtual ~DescribeVpnGatewaysResponseBody() = default;
};
class DescribeVpnGatewaysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVpnGatewaysResponseBody> body{};

  DescribeVpnGatewaysResponse() {}

  explicit DescribeVpnGatewaysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpnGatewaysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpnGatewaysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpnGatewaysResponse() = default;
};
class DescribeVpnPbrRouteEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpnGatewayId{};

  DescribeVpnPbrRouteEntriesRequest() {}

  explicit DescribeVpnPbrRouteEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~DescribeVpnPbrRouteEntriesRequest() = default;
};
class DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> nextHopTunnelId{};
  shared_ptr<long> priority{};
  shared_ptr<string> routeDest{};
  shared_ptr<string> routeSource{};
  shared_ptr<string> state{};
  shared_ptr<string> vpnInstanceId{};
  shared_ptr<long> weight{};

  DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry() {}

  explicit DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (nextHopTunnelId) {
      res["NextHopTunnelId"] = boost::any(*nextHopTunnelId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (routeDest) {
      res["RouteDest"] = boost::any(*routeDest);
    }
    if (routeSource) {
      res["RouteSource"] = boost::any(*routeSource);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (vpnInstanceId) {
      res["VpnInstanceId"] = boost::any(*vpnInstanceId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("NextHopTunnelId") != m.end() && !m["NextHopTunnelId"].empty()) {
      nextHopTunnelId = make_shared<string>(boost::any_cast<string>(m["NextHopTunnelId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RouteDest") != m.end() && !m["RouteDest"].empty()) {
      routeDest = make_shared<string>(boost::any_cast<string>(m["RouteDest"]));
    }
    if (m.find("RouteSource") != m.end() && !m["RouteSource"].empty()) {
      routeSource = make_shared<string>(boost::any_cast<string>(m["RouteSource"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("VpnInstanceId") != m.end() && !m["VpnInstanceId"].empty()) {
      vpnInstanceId = make_shared<string>(boost::any_cast<string>(m["VpnInstanceId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry() = default;
};
class DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry>> vpnPbrRouteEntry{};

  DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntries() {}

  explicit DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpnPbrRouteEntry) {
      vector<boost::any> temp1;
      for(auto item1:*vpnPbrRouteEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpnPbrRouteEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpnPbrRouteEntry") != m.end() && !m["VpnPbrRouteEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["VpnPbrRouteEntry"].type()) {
        vector<DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpnPbrRouteEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpnPbrRouteEntry = make_shared<vector<DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntriesVpnPbrRouteEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntries() = default;
};
class DescribeVpnPbrRouteEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntries> vpnPbrRouteEntries{};

  DescribeVpnPbrRouteEntriesResponseBody() {}

  explicit DescribeVpnPbrRouteEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vpnPbrRouteEntries) {
      res["VpnPbrRouteEntries"] = vpnPbrRouteEntries ? boost::any(vpnPbrRouteEntries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VpnPbrRouteEntries") != m.end() && !m["VpnPbrRouteEntries"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpnPbrRouteEntries"].type()) {
        DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpnPbrRouteEntries"]));
        vpnPbrRouteEntries = make_shared<DescribeVpnPbrRouteEntriesResponseBodyVpnPbrRouteEntries>(model1);
      }
    }
  }


  virtual ~DescribeVpnPbrRouteEntriesResponseBody() = default;
};
class DescribeVpnPbrRouteEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVpnPbrRouteEntriesResponseBody> body{};

  DescribeVpnPbrRouteEntriesResponse() {}

  explicit DescribeVpnPbrRouteEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpnPbrRouteEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpnPbrRouteEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpnPbrRouteEntriesResponse() = default;
};
class DescribeVpnRouteEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeEntryType{};
  shared_ptr<string> vpnGatewayId{};

  DescribeVpnRouteEntriesRequest() {}

  explicit DescribeVpnRouteEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeEntryType) {
      res["RouteEntryType"] = boost::any(*routeEntryType);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteEntryType") != m.end() && !m["RouteEntryType"].empty()) {
      routeEntryType = make_shared<string>(boost::any_cast<string>(m["RouteEntryType"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~DescribeVpnRouteEntriesRequest() = default;
};
class DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry : public Darabonba::Model {
public:
  shared_ptr<string> asPath{};
  shared_ptr<string> community{};
  shared_ptr<long> createTime{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> nextHopTunnelId{};
  shared_ptr<string> routeDest{};
  shared_ptr<string> routeEntryType{};
  shared_ptr<string> source{};
  shared_ptr<string> state{};
  shared_ptr<string> vpnInstanceId{};
  shared_ptr<long> weight{};

  DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry() {}

  explicit DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asPath) {
      res["AsPath"] = boost::any(*asPath);
    }
    if (community) {
      res["Community"] = boost::any(*community);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (nextHopTunnelId) {
      res["NextHopTunnelId"] = boost::any(*nextHopTunnelId);
    }
    if (routeDest) {
      res["RouteDest"] = boost::any(*routeDest);
    }
    if (routeEntryType) {
      res["RouteEntryType"] = boost::any(*routeEntryType);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (vpnInstanceId) {
      res["VpnInstanceId"] = boost::any(*vpnInstanceId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsPath") != m.end() && !m["AsPath"].empty()) {
      asPath = make_shared<string>(boost::any_cast<string>(m["AsPath"]));
    }
    if (m.find("Community") != m.end() && !m["Community"].empty()) {
      community = make_shared<string>(boost::any_cast<string>(m["Community"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("NextHopTunnelId") != m.end() && !m["NextHopTunnelId"].empty()) {
      nextHopTunnelId = make_shared<string>(boost::any_cast<string>(m["NextHopTunnelId"]));
    }
    if (m.find("RouteDest") != m.end() && !m["RouteDest"].empty()) {
      routeDest = make_shared<string>(boost::any_cast<string>(m["RouteDest"]));
    }
    if (m.find("RouteEntryType") != m.end() && !m["RouteEntryType"].empty()) {
      routeEntryType = make_shared<string>(boost::any_cast<string>(m["RouteEntryType"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("VpnInstanceId") != m.end() && !m["VpnInstanceId"].empty()) {
      vpnInstanceId = make_shared<string>(boost::any_cast<string>(m["VpnInstanceId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry() = default;
};
class DescribeVpnRouteEntriesResponseBodyVpnRouteEntries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry>> vpnRouteEntry{};

  DescribeVpnRouteEntriesResponseBodyVpnRouteEntries() {}

  explicit DescribeVpnRouteEntriesResponseBodyVpnRouteEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpnRouteEntry) {
      vector<boost::any> temp1;
      for(auto item1:*vpnRouteEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpnRouteEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpnRouteEntry") != m.end() && !m["VpnRouteEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["VpnRouteEntry"].type()) {
        vector<DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpnRouteEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpnRouteEntry = make_shared<vector<DescribeVpnRouteEntriesResponseBodyVpnRouteEntriesVpnRouteEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeVpnRouteEntriesResponseBodyVpnRouteEntries() = default;
};
class DescribeVpnRouteEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeVpnRouteEntriesResponseBodyVpnRouteEntries> vpnRouteEntries{};

  DescribeVpnRouteEntriesResponseBody() {}

  explicit DescribeVpnRouteEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vpnRouteEntries) {
      res["VpnRouteEntries"] = vpnRouteEntries ? boost::any(vpnRouteEntries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VpnRouteEntries") != m.end() && !m["VpnRouteEntries"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpnRouteEntries"].type()) {
        DescribeVpnRouteEntriesResponseBodyVpnRouteEntries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpnRouteEntries"]));
        vpnRouteEntries = make_shared<DescribeVpnRouteEntriesResponseBodyVpnRouteEntries>(model1);
      }
    }
  }


  virtual ~DescribeVpnRouteEntriesResponseBody() = default;
};
class DescribeVpnRouteEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVpnRouteEntriesResponseBody> body{};

  DescribeVpnRouteEntriesResponse() {}

  explicit DescribeVpnRouteEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpnRouteEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpnRouteEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpnRouteEntriesResponse() = default;
};
class DescribeVpnSslServerLogsRequest : public Darabonba::Model {
public:
  shared_ptr<long> from{};
  shared_ptr<long> minutePeriod{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sslVpnClientCertId{};
  shared_ptr<long> to{};
  shared_ptr<string> vpnSslServerId{};

  DescribeVpnSslServerLogsRequest() {}

  explicit DescribeVpnSslServerLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (minutePeriod) {
      res["MinutePeriod"] = boost::any(*minutePeriod);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sslVpnClientCertId) {
      res["SslVpnClientCertId"] = boost::any(*sslVpnClientCertId);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (vpnSslServerId) {
      res["VpnSslServerId"] = boost::any(*vpnSslServerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<long>(boost::any_cast<long>(m["From"]));
    }
    if (m.find("MinutePeriod") != m.end() && !m["MinutePeriod"].empty()) {
      minutePeriod = make_shared<long>(boost::any_cast<long>(m["MinutePeriod"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SslVpnClientCertId") != m.end() && !m["SslVpnClientCertId"].empty()) {
      sslVpnClientCertId = make_shared<string>(boost::any_cast<string>(m["SslVpnClientCertId"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<long>(boost::any_cast<long>(m["To"]));
    }
    if (m.find("VpnSslServerId") != m.end() && !m["VpnSslServerId"].empty()) {
      vpnSslServerId = make_shared<string>(boost::any_cast<string>(m["VpnSslServerId"]));
    }
  }


  virtual ~DescribeVpnSslServerLogsRequest() = default;
};
class DescribeVpnSslServerLogsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> logs{};

  DescribeVpnSslServerLogsResponseBodyData() {}

  explicit DescribeVpnSslServerLogsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logs) {
      res["Logs"] = boost::any(*logs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Logs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      logs = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVpnSslServerLogsResponseBodyData() = default;
};
class DescribeVpnSslServerLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<DescribeVpnSslServerLogsResponseBodyData> data{};
  shared_ptr<bool> isCompleted{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};

  DescribeVpnSslServerLogsResponseBody() {}

  explicit DescribeVpnSslServerLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isCompleted) {
      res["IsCompleted"] = boost::any(*isCompleted);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeVpnSslServerLogsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeVpnSslServerLogsResponseBodyData>(model1);
      }
    }
    if (m.find("IsCompleted") != m.end() && !m["IsCompleted"].empty()) {
      isCompleted = make_shared<bool>(boost::any_cast<bool>(m["IsCompleted"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVpnSslServerLogsResponseBody() = default;
};
class DescribeVpnSslServerLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVpnSslServerLogsResponseBody> body{};

  DescribeVpnSslServerLogsResponse() {}

  explicit DescribeVpnSslServerLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpnSslServerLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpnSslServerLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpnSslServerLogsResponse() = default;
};
class DescribeZonesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> zoneType{};

  DescribeZonesRequest() {}

  explicit DescribeZonesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (zoneType) {
      res["ZoneType"] = boost::any(*zoneType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ZoneType") != m.end() && !m["ZoneType"].empty()) {
      zoneType = make_shared<string>(boost::any_cast<string>(m["ZoneType"]));
    }
  }


  virtual ~DescribeZonesRequest() = default;
};
class DescribeZonesResponseBodyZonesZone : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> zoneType{};

  DescribeZonesResponseBodyZonesZone() {}

  explicit DescribeZonesResponseBodyZonesZone(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (zoneType) {
      res["ZoneType"] = boost::any(*zoneType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("ZoneType") != m.end() && !m["ZoneType"].empty()) {
      zoneType = make_shared<string>(boost::any_cast<string>(m["ZoneType"]));
    }
  }


  virtual ~DescribeZonesResponseBodyZonesZone() = default;
};
class DescribeZonesResponseBodyZones : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeZonesResponseBodyZonesZone>> zone{};

  DescribeZonesResponseBodyZones() {}

  explicit DescribeZonesResponseBodyZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zone) {
      vector<boost::any> temp1;
      for(auto item1:*zone){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Zone"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Zone") != m.end() && !m["Zone"].empty()) {
      if (typeid(vector<boost::any>) == m["Zone"].type()) {
        vector<DescribeZonesResponseBodyZonesZone> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Zone"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeZonesResponseBodyZonesZone model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zone = make_shared<vector<DescribeZonesResponseBodyZonesZone>>(expect1);
      }
    }
  }


  virtual ~DescribeZonesResponseBodyZones() = default;
};
class DescribeZonesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeZonesResponseBodyZones> zones{};

  DescribeZonesResponseBody() {}

  explicit DescribeZonesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (zones) {
      res["Zones"] = zones ? boost::any(zones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Zones") != m.end() && !m["Zones"].empty()) {
      if (typeid(map<string, boost::any>) == m["Zones"].type()) {
        DescribeZonesResponseBodyZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Zones"]));
        zones = make_shared<DescribeZonesResponseBodyZones>(model1);
      }
    }
  }


  virtual ~DescribeZonesResponseBody() = default;
};
class DescribeZonesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeZonesResponseBody> body{};

  DescribeZonesResponse() {}

  explicit DescribeZonesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeZonesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeZonesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeZonesResponse() = default;
};
class DetachDhcpOptionsSetFromVpcRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> dhcpOptionsSetId{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpcId{};

  DetachDhcpOptionsSetFromVpcRequest() {}

  explicit DetachDhcpOptionsSetFromVpcRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dhcpOptionsSetId) {
      res["DhcpOptionsSetId"] = boost::any(*dhcpOptionsSetId);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DhcpOptionsSetId") != m.end() && !m["DhcpOptionsSetId"].empty()) {
      dhcpOptionsSetId = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetId"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DetachDhcpOptionsSetFromVpcRequest() = default;
};
class DetachDhcpOptionsSetFromVpcResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DetachDhcpOptionsSetFromVpcResponseBody() {}

  explicit DetachDhcpOptionsSetFromVpcResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachDhcpOptionsSetFromVpcResponseBody() = default;
};
class DetachDhcpOptionsSetFromVpcResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachDhcpOptionsSetFromVpcResponseBody> body{};

  DetachDhcpOptionsSetFromVpcResponse() {}

  explicit DetachDhcpOptionsSetFromVpcResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachDhcpOptionsSetFromVpcResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachDhcpOptionsSetFromVpcResponseBody>(model1);
      }
    }
  }


  virtual ~DetachDhcpOptionsSetFromVpcResponse() = default;
};
class DiagnoseVpnConnectionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> tunnelIds{};
  shared_ptr<vector<string>> vpnConnectionIds{};
  shared_ptr<string> vpnGatewayId{};

  DiagnoseVpnConnectionsRequest() {}

  explicit DiagnoseVpnConnectionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tunnelIds) {
      res["TunnelIds"] = boost::any(*tunnelIds);
    }
    if (vpnConnectionIds) {
      res["VpnConnectionIds"] = boost::any(*vpnConnectionIds);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TunnelIds") != m.end() && !m["TunnelIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TunnelIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TunnelIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tunnelIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VpnConnectionIds") != m.end() && !m["VpnConnectionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VpnConnectionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VpnConnectionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vpnConnectionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~DiagnoseVpnConnectionsRequest() = default;
};
class DiagnoseVpnConnectionsResponseBodyVpnConnections : public Darabonba::Model {
public:
  shared_ptr<string> failedReason{};
  shared_ptr<string> failedReasonCode{};
  shared_ptr<long> failedTime{};
  shared_ptr<string> mismatchLocalParam{};
  shared_ptr<string> mismatchRemoteParam{};
  shared_ptr<string> severity{};
  shared_ptr<string> sourceLog{};
  shared_ptr<string> tunnelId{};
  shared_ptr<string> vpnConnectionId{};

  DiagnoseVpnConnectionsResponseBodyVpnConnections() {}

  explicit DiagnoseVpnConnectionsResponseBodyVpnConnections(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedReason) {
      res["FailedReason"] = boost::any(*failedReason);
    }
    if (failedReasonCode) {
      res["FailedReasonCode"] = boost::any(*failedReasonCode);
    }
    if (failedTime) {
      res["FailedTime"] = boost::any(*failedTime);
    }
    if (mismatchLocalParam) {
      res["MismatchLocalParam"] = boost::any(*mismatchLocalParam);
    }
    if (mismatchRemoteParam) {
      res["MismatchRemoteParam"] = boost::any(*mismatchRemoteParam);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (sourceLog) {
      res["SourceLog"] = boost::any(*sourceLog);
    }
    if (tunnelId) {
      res["TunnelId"] = boost::any(*tunnelId);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedReason") != m.end() && !m["FailedReason"].empty()) {
      failedReason = make_shared<string>(boost::any_cast<string>(m["FailedReason"]));
    }
    if (m.find("FailedReasonCode") != m.end() && !m["FailedReasonCode"].empty()) {
      failedReasonCode = make_shared<string>(boost::any_cast<string>(m["FailedReasonCode"]));
    }
    if (m.find("FailedTime") != m.end() && !m["FailedTime"].empty()) {
      failedTime = make_shared<long>(boost::any_cast<long>(m["FailedTime"]));
    }
    if (m.find("MismatchLocalParam") != m.end() && !m["MismatchLocalParam"].empty()) {
      mismatchLocalParam = make_shared<string>(boost::any_cast<string>(m["MismatchLocalParam"]));
    }
    if (m.find("MismatchRemoteParam") != m.end() && !m["MismatchRemoteParam"].empty()) {
      mismatchRemoteParam = make_shared<string>(boost::any_cast<string>(m["MismatchRemoteParam"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("SourceLog") != m.end() && !m["SourceLog"].empty()) {
      sourceLog = make_shared<string>(boost::any_cast<string>(m["SourceLog"]));
    }
    if (m.find("TunnelId") != m.end() && !m["TunnelId"].empty()) {
      tunnelId = make_shared<string>(boost::any_cast<string>(m["TunnelId"]));
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
  }


  virtual ~DiagnoseVpnConnectionsResponseBodyVpnConnections() = default;
};
class DiagnoseVpnConnectionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DiagnoseVpnConnectionsResponseBodyVpnConnections>> vpnConnections{};

  DiagnoseVpnConnectionsResponseBody() {}

  explicit DiagnoseVpnConnectionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vpnConnections) {
      vector<boost::any> temp1;
      for(auto item1:*vpnConnections){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpnConnections"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VpnConnections") != m.end() && !m["VpnConnections"].empty()) {
      if (typeid(vector<boost::any>) == m["VpnConnections"].type()) {
        vector<DiagnoseVpnConnectionsResponseBodyVpnConnections> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpnConnections"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DiagnoseVpnConnectionsResponseBodyVpnConnections model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpnConnections = make_shared<vector<DiagnoseVpnConnectionsResponseBodyVpnConnections>>(expect1);
      }
    }
  }


  virtual ~DiagnoseVpnConnectionsResponseBody() = default;
};
class DiagnoseVpnConnectionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DiagnoseVpnConnectionsResponseBody> body{};

  DiagnoseVpnConnectionsResponse() {}

  explicit DiagnoseVpnConnectionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DiagnoseVpnConnectionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DiagnoseVpnConnectionsResponseBody>(model1);
      }
    }
  }


  virtual ~DiagnoseVpnConnectionsResponse() = default;
};
class DiagnoseVpnGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> IPsecExtendInfo{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> vpnGatewayId{};

  DiagnoseVpnGatewayRequest() {}

  explicit DiagnoseVpnGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (IPsecExtendInfo) {
      res["IPsecExtendInfo"] = boost::any(*IPsecExtendInfo);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("IPsecExtendInfo") != m.end() && !m["IPsecExtendInfo"].empty()) {
      IPsecExtendInfo = make_shared<string>(boost::any_cast<string>(m["IPsecExtendInfo"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~DiagnoseVpnGatewayRequest() = default;
};
class DiagnoseVpnGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> diagnoseId{};
  shared_ptr<string> requestId{};

  DiagnoseVpnGatewayResponseBody() {}

  explicit DiagnoseVpnGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diagnoseId) {
      res["DiagnoseId"] = boost::any(*diagnoseId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiagnoseId") != m.end() && !m["DiagnoseId"].empty()) {
      diagnoseId = make_shared<string>(boost::any_cast<string>(m["DiagnoseId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DiagnoseVpnGatewayResponseBody() = default;
};
class DiagnoseVpnGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DiagnoseVpnGatewayResponseBody> body{};

  DiagnoseVpnGatewayResponse() {}

  explicit DiagnoseVpnGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DiagnoseVpnGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DiagnoseVpnGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DiagnoseVpnGatewayResponse() = default;
};
class DisableNatGatewayEcsMetricRequest : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> regionId{};

  DisableNatGatewayEcsMetricRequest() {}

  explicit DisableNatGatewayEcsMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DisableNatGatewayEcsMetricRequest() = default;
};
class DisableNatGatewayEcsMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableNatGatewayEcsMetricResponseBody() {}

  explicit DisableNatGatewayEcsMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableNatGatewayEcsMetricResponseBody() = default;
};
class DisableNatGatewayEcsMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableNatGatewayEcsMetricResponseBody> body{};

  DisableNatGatewayEcsMetricResponse() {}

  explicit DisableNatGatewayEcsMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableNatGatewayEcsMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableNatGatewayEcsMetricResponseBody>(model1);
      }
    }
  }


  virtual ~DisableNatGatewayEcsMetricResponse() = default;
};
class DisableVpcClassicLinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpcId{};

  DisableVpcClassicLinkRequest() {}

  explicit DisableVpcClassicLinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DisableVpcClassicLinkRequest() = default;
};
class DisableVpcClassicLinkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableVpcClassicLinkResponseBody() {}

  explicit DisableVpcClassicLinkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableVpcClassicLinkResponseBody() = default;
};
class DisableVpcClassicLinkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableVpcClassicLinkResponseBody> body{};

  DisableVpcClassicLinkResponse() {}

  explicit DisableVpcClassicLinkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableVpcClassicLinkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableVpcClassicLinkResponseBody>(model1);
      }
    }
  }


  virtual ~DisableVpcClassicLinkResponse() = default;
};
class DissociateRouteTableFromGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> gatewayId{};
  shared_ptr<string> gatewayType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeTableId{};

  DissociateRouteTableFromGatewayRequest() {}

  explicit DissociateRouteTableFromGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayType) {
      res["GatewayType"] = boost::any(*gatewayType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<string>(boost::any_cast<string>(m["GatewayId"]));
    }
    if (m.find("GatewayType") != m.end() && !m["GatewayType"].empty()) {
      gatewayType = make_shared<string>(boost::any_cast<string>(m["GatewayType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
  }


  virtual ~DissociateRouteTableFromGatewayRequest() = default;
};
class DissociateRouteTableFromGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DissociateRouteTableFromGatewayResponseBody() {}

  explicit DissociateRouteTableFromGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DissociateRouteTableFromGatewayResponseBody() = default;
};
class DissociateRouteTableFromGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DissociateRouteTableFromGatewayResponseBody> body{};

  DissociateRouteTableFromGatewayResponse() {}

  explicit DissociateRouteTableFromGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DissociateRouteTableFromGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DissociateRouteTableFromGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DissociateRouteTableFromGatewayResponse() = default;
};
class DissociateRouteTablesFromVpcGatewayEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> routeTableIds{};

  DissociateRouteTablesFromVpcGatewayEndpointRequest() {}

  explicit DissociateRouteTablesFromVpcGatewayEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeTableIds) {
      res["RouteTableIds"] = boost::any(*routeTableIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteTableIds") != m.end() && !m["RouteTableIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RouteTableIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RouteTableIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      routeTableIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DissociateRouteTablesFromVpcGatewayEndpointRequest() = default;
};
class DissociateRouteTablesFromVpcGatewayEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DissociateRouteTablesFromVpcGatewayEndpointResponseBody() {}

  explicit DissociateRouteTablesFromVpcGatewayEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DissociateRouteTablesFromVpcGatewayEndpointResponseBody() = default;
};
class DissociateRouteTablesFromVpcGatewayEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DissociateRouteTablesFromVpcGatewayEndpointResponseBody> body{};

  DissociateRouteTablesFromVpcGatewayEndpointResponse() {}

  explicit DissociateRouteTablesFromVpcGatewayEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DissociateRouteTablesFromVpcGatewayEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DissociateRouteTablesFromVpcGatewayEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~DissociateRouteTablesFromVpcGatewayEndpointResponse() = default;
};
class DissociateVpnGatewayWithCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> certificateId{};
  shared_ptr<string> certificateType{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vpnGatewayId{};

  DissociateVpnGatewayWithCertificateRequest() {}

  explicit DissociateVpnGatewayWithCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    if (certificateType) {
      res["CertificateType"] = boost::any(*certificateType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
    if (m.find("CertificateType") != m.end() && !m["CertificateType"].empty()) {
      certificateType = make_shared<string>(boost::any_cast<string>(m["CertificateType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~DissociateVpnGatewayWithCertificateRequest() = default;
};
class DissociateVpnGatewayWithCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DissociateVpnGatewayWithCertificateResponseBody() {}

  explicit DissociateVpnGatewayWithCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DissociateVpnGatewayWithCertificateResponseBody() = default;
};
class DissociateVpnGatewayWithCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DissociateVpnGatewayWithCertificateResponseBody> body{};

  DissociateVpnGatewayWithCertificateResponse() {}

  explicit DissociateVpnGatewayWithCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DissociateVpnGatewayWithCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DissociateVpnGatewayWithCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~DissociateVpnGatewayWithCertificateResponse() = default;
};
class DownloadVpnConnectionConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpnConnectionId{};

  DownloadVpnConnectionConfigRequest() {}

  explicit DownloadVpnConnectionConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
  }


  virtual ~DownloadVpnConnectionConfigRequest() = default;
};
class DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig : public Darabonba::Model {
public:
  shared_ptr<string> ikeAuthAlg{};
  shared_ptr<string> ikeEncAlg{};
  shared_ptr<long> ikeLifetime{};
  shared_ptr<string> ikeMode{};
  shared_ptr<string> ikePfs{};
  shared_ptr<string> ikeVersion{};
  shared_ptr<string> localId{};
  shared_ptr<string> psk{};
  shared_ptr<string> remoteId{};

  DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig() {}

  explicit DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ikeAuthAlg) {
      res["IkeAuthAlg"] = boost::any(*ikeAuthAlg);
    }
    if (ikeEncAlg) {
      res["IkeEncAlg"] = boost::any(*ikeEncAlg);
    }
    if (ikeLifetime) {
      res["IkeLifetime"] = boost::any(*ikeLifetime);
    }
    if (ikeMode) {
      res["IkeMode"] = boost::any(*ikeMode);
    }
    if (ikePfs) {
      res["IkePfs"] = boost::any(*ikePfs);
    }
    if (ikeVersion) {
      res["IkeVersion"] = boost::any(*ikeVersion);
    }
    if (localId) {
      res["LocalId"] = boost::any(*localId);
    }
    if (psk) {
      res["Psk"] = boost::any(*psk);
    }
    if (remoteId) {
      res["RemoteId"] = boost::any(*remoteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IkeAuthAlg") != m.end() && !m["IkeAuthAlg"].empty()) {
      ikeAuthAlg = make_shared<string>(boost::any_cast<string>(m["IkeAuthAlg"]));
    }
    if (m.find("IkeEncAlg") != m.end() && !m["IkeEncAlg"].empty()) {
      ikeEncAlg = make_shared<string>(boost::any_cast<string>(m["IkeEncAlg"]));
    }
    if (m.find("IkeLifetime") != m.end() && !m["IkeLifetime"].empty()) {
      ikeLifetime = make_shared<long>(boost::any_cast<long>(m["IkeLifetime"]));
    }
    if (m.find("IkeMode") != m.end() && !m["IkeMode"].empty()) {
      ikeMode = make_shared<string>(boost::any_cast<string>(m["IkeMode"]));
    }
    if (m.find("IkePfs") != m.end() && !m["IkePfs"].empty()) {
      ikePfs = make_shared<string>(boost::any_cast<string>(m["IkePfs"]));
    }
    if (m.find("IkeVersion") != m.end() && !m["IkeVersion"].empty()) {
      ikeVersion = make_shared<string>(boost::any_cast<string>(m["IkeVersion"]));
    }
    if (m.find("LocalId") != m.end() && !m["LocalId"].empty()) {
      localId = make_shared<string>(boost::any_cast<string>(m["LocalId"]));
    }
    if (m.find("Psk") != m.end() && !m["Psk"].empty()) {
      psk = make_shared<string>(boost::any_cast<string>(m["Psk"]));
    }
    if (m.find("RemoteId") != m.end() && !m["RemoteId"].empty()) {
      remoteId = make_shared<string>(boost::any_cast<string>(m["RemoteId"]));
    }
  }


  virtual ~DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig() = default;
};
class DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig : public Darabonba::Model {
public:
  shared_ptr<string> ipsecAuthAlg{};
  shared_ptr<string> ipsecEncAlg{};
  shared_ptr<long> ipsecLifetime{};
  shared_ptr<string> ipsecPfs{};

  DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig() {}

  explicit DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipsecAuthAlg) {
      res["IpsecAuthAlg"] = boost::any(*ipsecAuthAlg);
    }
    if (ipsecEncAlg) {
      res["IpsecEncAlg"] = boost::any(*ipsecEncAlg);
    }
    if (ipsecLifetime) {
      res["IpsecLifetime"] = boost::any(*ipsecLifetime);
    }
    if (ipsecPfs) {
      res["IpsecPfs"] = boost::any(*ipsecPfs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpsecAuthAlg") != m.end() && !m["IpsecAuthAlg"].empty()) {
      ipsecAuthAlg = make_shared<string>(boost::any_cast<string>(m["IpsecAuthAlg"]));
    }
    if (m.find("IpsecEncAlg") != m.end() && !m["IpsecEncAlg"].empty()) {
      ipsecEncAlg = make_shared<string>(boost::any_cast<string>(m["IpsecEncAlg"]));
    }
    if (m.find("IpsecLifetime") != m.end() && !m["IpsecLifetime"].empty()) {
      ipsecLifetime = make_shared<long>(boost::any_cast<long>(m["IpsecLifetime"]));
    }
    if (m.find("IpsecPfs") != m.end() && !m["IpsecPfs"].empty()) {
      ipsecPfs = make_shared<string>(boost::any_cast<string>(m["IpsecPfs"]));
    }
  }


  virtual ~DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig() = default;
};
class DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig : public Darabonba::Model {
public:
  shared_ptr<string> ikeAuthAlg{};
  shared_ptr<string> ikeEncAlg{};
  shared_ptr<long> ikeLifetime{};
  shared_ptr<string> ikeMode{};
  shared_ptr<string> ikePfs{};
  shared_ptr<string> ikeVersion{};
  shared_ptr<string> localId{};
  shared_ptr<string> psk{};
  shared_ptr<string> remoteId{};

  DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig() {}

  explicit DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ikeAuthAlg) {
      res["IkeAuthAlg"] = boost::any(*ikeAuthAlg);
    }
    if (ikeEncAlg) {
      res["IkeEncAlg"] = boost::any(*ikeEncAlg);
    }
    if (ikeLifetime) {
      res["IkeLifetime"] = boost::any(*ikeLifetime);
    }
    if (ikeMode) {
      res["IkeMode"] = boost::any(*ikeMode);
    }
    if (ikePfs) {
      res["IkePfs"] = boost::any(*ikePfs);
    }
    if (ikeVersion) {
      res["IkeVersion"] = boost::any(*ikeVersion);
    }
    if (localId) {
      res["LocalId"] = boost::any(*localId);
    }
    if (psk) {
      res["Psk"] = boost::any(*psk);
    }
    if (remoteId) {
      res["RemoteId"] = boost::any(*remoteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IkeAuthAlg") != m.end() && !m["IkeAuthAlg"].empty()) {
      ikeAuthAlg = make_shared<string>(boost::any_cast<string>(m["IkeAuthAlg"]));
    }
    if (m.find("IkeEncAlg") != m.end() && !m["IkeEncAlg"].empty()) {
      ikeEncAlg = make_shared<string>(boost::any_cast<string>(m["IkeEncAlg"]));
    }
    if (m.find("IkeLifetime") != m.end() && !m["IkeLifetime"].empty()) {
      ikeLifetime = make_shared<long>(boost::any_cast<long>(m["IkeLifetime"]));
    }
    if (m.find("IkeMode") != m.end() && !m["IkeMode"].empty()) {
      ikeMode = make_shared<string>(boost::any_cast<string>(m["IkeMode"]));
    }
    if (m.find("IkePfs") != m.end() && !m["IkePfs"].empty()) {
      ikePfs = make_shared<string>(boost::any_cast<string>(m["IkePfs"]));
    }
    if (m.find("IkeVersion") != m.end() && !m["IkeVersion"].empty()) {
      ikeVersion = make_shared<string>(boost::any_cast<string>(m["IkeVersion"]));
    }
    if (m.find("LocalId") != m.end() && !m["LocalId"].empty()) {
      localId = make_shared<string>(boost::any_cast<string>(m["LocalId"]));
    }
    if (m.find("Psk") != m.end() && !m["Psk"].empty()) {
      psk = make_shared<string>(boost::any_cast<string>(m["Psk"]));
    }
    if (m.find("RemoteId") != m.end() && !m["RemoteId"].empty()) {
      remoteId = make_shared<string>(boost::any_cast<string>(m["RemoteId"]));
    }
  }


  virtual ~DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig() = default;
};
class DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig : public Darabonba::Model {
public:
  shared_ptr<string> ipsecAuthAlg{};
  shared_ptr<string> ipsecEncAlg{};
  shared_ptr<long> ipsecLifetime{};
  shared_ptr<string> ipsecPfs{};

  DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig() {}

  explicit DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipsecAuthAlg) {
      res["IpsecAuthAlg"] = boost::any(*ipsecAuthAlg);
    }
    if (ipsecEncAlg) {
      res["IpsecEncAlg"] = boost::any(*ipsecEncAlg);
    }
    if (ipsecLifetime) {
      res["IpsecLifetime"] = boost::any(*ipsecLifetime);
    }
    if (ipsecPfs) {
      res["IpsecPfs"] = boost::any(*ipsecPfs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpsecAuthAlg") != m.end() && !m["IpsecAuthAlg"].empty()) {
      ipsecAuthAlg = make_shared<string>(boost::any_cast<string>(m["IpsecAuthAlg"]));
    }
    if (m.find("IpsecEncAlg") != m.end() && !m["IpsecEncAlg"].empty()) {
      ipsecEncAlg = make_shared<string>(boost::any_cast<string>(m["IpsecEncAlg"]));
    }
    if (m.find("IpsecLifetime") != m.end() && !m["IpsecLifetime"].empty()) {
      ipsecLifetime = make_shared<long>(boost::any_cast<long>(m["IpsecLifetime"]));
    }
    if (m.find("IpsecPfs") != m.end() && !m["IpsecPfs"].empty()) {
      ipsecPfs = make_shared<string>(boost::any_cast<string>(m["IpsecPfs"]));
    }
  }


  virtual ~DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig() = default;
};
class DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig : public Darabonba::Model {
public:
  shared_ptr<DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig> ikeConfig{};
  shared_ptr<DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig> ipsecConfig{};
  shared_ptr<string> local{};
  shared_ptr<string> remote{};
  shared_ptr<string> tunnelId{};

  DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig() {}

  explicit DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ikeConfig) {
      res["IkeConfig"] = ikeConfig ? boost::any(ikeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipsecConfig) {
      res["IpsecConfig"] = ipsecConfig ? boost::any(ipsecConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (local) {
      res["Local"] = boost::any(*local);
    }
    if (remote) {
      res["Remote"] = boost::any(*remote);
    }
    if (tunnelId) {
      res["TunnelId"] = boost::any(*tunnelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IkeConfig") != m.end() && !m["IkeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IkeConfig"].type()) {
        DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IkeConfig"]));
        ikeConfig = make_shared<DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIkeConfig>(model1);
      }
    }
    if (m.find("IpsecConfig") != m.end() && !m["IpsecConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IpsecConfig"].type()) {
        DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IpsecConfig"]));
        ipsecConfig = make_shared<DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfigIpsecConfig>(model1);
      }
    }
    if (m.find("Local") != m.end() && !m["Local"].empty()) {
      local = make_shared<string>(boost::any_cast<string>(m["Local"]));
    }
    if (m.find("Remote") != m.end() && !m["Remote"].empty()) {
      remote = make_shared<string>(boost::any_cast<string>(m["Remote"]));
    }
    if (m.find("TunnelId") != m.end() && !m["TunnelId"].empty()) {
      tunnelId = make_shared<string>(boost::any_cast<string>(m["TunnelId"]));
    }
  }


  virtual ~DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig() = default;
};
class DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfig : public Darabonba::Model {
public:
  shared_ptr<vector<DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig>> tunnelConfig{};

  DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfig() {}

  explicit DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tunnelConfig) {
      vector<boost::any> temp1;
      for(auto item1:*tunnelConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TunnelConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TunnelConfig") != m.end() && !m["TunnelConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["TunnelConfig"].type()) {
        vector<DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TunnelConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tunnelConfig = make_shared<vector<DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfigTunnelConfig>>(expect1);
      }
    }
  }


  virtual ~DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfig() = default;
};
class DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig : public Darabonba::Model {
public:
  shared_ptr<DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig> ikeConfig{};
  shared_ptr<DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig> ipsecConfig{};
  shared_ptr<string> local{};
  shared_ptr<string> localSubnet{};
  shared_ptr<string> remote{};
  shared_ptr<string> remoteSubnet{};
  shared_ptr<DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfig> tunnelsConfig{};

  DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig() {}

  explicit DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ikeConfig) {
      res["IkeConfig"] = ikeConfig ? boost::any(ikeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipsecConfig) {
      res["IpsecConfig"] = ipsecConfig ? boost::any(ipsecConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (local) {
      res["Local"] = boost::any(*local);
    }
    if (localSubnet) {
      res["LocalSubnet"] = boost::any(*localSubnet);
    }
    if (remote) {
      res["Remote"] = boost::any(*remote);
    }
    if (remoteSubnet) {
      res["RemoteSubnet"] = boost::any(*remoteSubnet);
    }
    if (tunnelsConfig) {
      res["TunnelsConfig"] = tunnelsConfig ? boost::any(tunnelsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IkeConfig") != m.end() && !m["IkeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IkeConfig"].type()) {
        DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IkeConfig"]));
        ikeConfig = make_shared<DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIkeConfig>(model1);
      }
    }
    if (m.find("IpsecConfig") != m.end() && !m["IpsecConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IpsecConfig"].type()) {
        DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IpsecConfig"]));
        ipsecConfig = make_shared<DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigIpsecConfig>(model1);
      }
    }
    if (m.find("Local") != m.end() && !m["Local"].empty()) {
      local = make_shared<string>(boost::any_cast<string>(m["Local"]));
    }
    if (m.find("LocalSubnet") != m.end() && !m["LocalSubnet"].empty()) {
      localSubnet = make_shared<string>(boost::any_cast<string>(m["LocalSubnet"]));
    }
    if (m.find("Remote") != m.end() && !m["Remote"].empty()) {
      remote = make_shared<string>(boost::any_cast<string>(m["Remote"]));
    }
    if (m.find("RemoteSubnet") != m.end() && !m["RemoteSubnet"].empty()) {
      remoteSubnet = make_shared<string>(boost::any_cast<string>(m["RemoteSubnet"]));
    }
    if (m.find("TunnelsConfig") != m.end() && !m["TunnelsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelsConfig"].type()) {
        DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelsConfig"]));
        tunnelsConfig = make_shared<DownloadVpnConnectionConfigResponseBodyVpnConnectionConfigTunnelsConfig>(model1);
      }
    }
  }


  virtual ~DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig() = default;
};
class DownloadVpnConnectionConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig> vpnConnectionConfig{};

  DownloadVpnConnectionConfigResponseBody() {}

  explicit DownloadVpnConnectionConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vpnConnectionConfig) {
      res["VpnConnectionConfig"] = vpnConnectionConfig ? boost::any(vpnConnectionConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VpnConnectionConfig") != m.end() && !m["VpnConnectionConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpnConnectionConfig"].type()) {
        DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpnConnectionConfig"]));
        vpnConnectionConfig = make_shared<DownloadVpnConnectionConfigResponseBodyVpnConnectionConfig>(model1);
      }
    }
  }


  virtual ~DownloadVpnConnectionConfigResponseBody() = default;
};
class DownloadVpnConnectionConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DownloadVpnConnectionConfigResponseBody> body{};

  DownloadVpnConnectionConfigResponse() {}

  explicit DownloadVpnConnectionConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadVpnConnectionConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadVpnConnectionConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadVpnConnectionConfigResponse() = default;
};
class EnableNatGatewayEcsMetricRequest : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> regionId{};

  EnableNatGatewayEcsMetricRequest() {}

  explicit EnableNatGatewayEcsMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~EnableNatGatewayEcsMetricRequest() = default;
};
class EnableNatGatewayEcsMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableNatGatewayEcsMetricResponseBody() {}

  explicit EnableNatGatewayEcsMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableNatGatewayEcsMetricResponseBody() = default;
};
class EnableNatGatewayEcsMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableNatGatewayEcsMetricResponseBody> body{};

  EnableNatGatewayEcsMetricResponse() {}

  explicit EnableNatGatewayEcsMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableNatGatewayEcsMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableNatGatewayEcsMetricResponseBody>(model1);
      }
    }
  }


  virtual ~EnableNatGatewayEcsMetricResponse() = default;
};
class EnablePhysicalConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<bool> byPassSp{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  EnablePhysicalConnectionRequest() {}

  explicit EnablePhysicalConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (byPassSp) {
      res["ByPassSp"] = boost::any(*byPassSp);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ByPassSp") != m.end() && !m["ByPassSp"].empty()) {
      byPassSp = make_shared<bool>(boost::any_cast<bool>(m["ByPassSp"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~EnablePhysicalConnectionRequest() = default;
};
class EnablePhysicalConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnablePhysicalConnectionResponseBody() {}

  explicit EnablePhysicalConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnablePhysicalConnectionResponseBody() = default;
};
class EnablePhysicalConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnablePhysicalConnectionResponseBody> body{};

  EnablePhysicalConnectionResponse() {}

  explicit EnablePhysicalConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnablePhysicalConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnablePhysicalConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~EnablePhysicalConnectionResponse() = default;
};
class EnableVpcClassicLinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpcId{};

  EnableVpcClassicLinkRequest() {}

  explicit EnableVpcClassicLinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~EnableVpcClassicLinkRequest() = default;
};
class EnableVpcClassicLinkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableVpcClassicLinkResponseBody() {}

  explicit EnableVpcClassicLinkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableVpcClassicLinkResponseBody() = default;
};
class EnableVpcClassicLinkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableVpcClassicLinkResponseBody> body{};

  EnableVpcClassicLinkResponse() {}

  explicit EnableVpcClassicLinkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableVpcClassicLinkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableVpcClassicLinkResponseBody>(model1);
      }
    }
  }


  virtual ~EnableVpcClassicLinkResponse() = default;
};
class EnableVpcIpv4GatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ipv4GatewayId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> routeTableList{};

  EnableVpcIpv4GatewayRequest() {}

  explicit EnableVpcIpv4GatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ipv4GatewayId) {
      res["Ipv4GatewayId"] = boost::any(*ipv4GatewayId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeTableList) {
      res["RouteTableList"] = boost::any(*routeTableList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("Ipv4GatewayId") != m.end() && !m["Ipv4GatewayId"].empty()) {
      ipv4GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteTableList") != m.end() && !m["RouteTableList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RouteTableList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RouteTableList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      routeTableList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~EnableVpcIpv4GatewayRequest() = default;
};
class EnableVpcIpv4GatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableVpcIpv4GatewayResponseBody() {}

  explicit EnableVpcIpv4GatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableVpcIpv4GatewayResponseBody() = default;
};
class EnableVpcIpv4GatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableVpcIpv4GatewayResponseBody> body{};

  EnableVpcIpv4GatewayResponse() {}

  explicit EnableVpcIpv4GatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableVpcIpv4GatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableVpcIpv4GatewayResponseBody>(model1);
      }
    }
  }


  virtual ~EnableVpcIpv4GatewayResponse() = default;
};
class GetDhcpOptionsSetRequest : public Darabonba::Model {
public:
  shared_ptr<string> dhcpOptionsSetId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  GetDhcpOptionsSetRequest() {}

  explicit GetDhcpOptionsSetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dhcpOptionsSetId) {
      res["DhcpOptionsSetId"] = boost::any(*dhcpOptionsSetId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DhcpOptionsSetId") != m.end() && !m["DhcpOptionsSetId"].empty()) {
      dhcpOptionsSetId = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GetDhcpOptionsSetRequest() = default;
};
class GetDhcpOptionsSetResponseBodyAssociateVpcs : public Darabonba::Model {
public:
  shared_ptr<string> associateStatus{};
  shared_ptr<string> vpcId{};

  GetDhcpOptionsSetResponseBodyAssociateVpcs() {}

  explicit GetDhcpOptionsSetResponseBodyAssociateVpcs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associateStatus) {
      res["AssociateStatus"] = boost::any(*associateStatus);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociateStatus") != m.end() && !m["AssociateStatus"].empty()) {
      associateStatus = make_shared<string>(boost::any_cast<string>(m["AssociateStatus"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~GetDhcpOptionsSetResponseBodyAssociateVpcs() = default;
};
class GetDhcpOptionsSetResponseBodyDhcpOptions : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> domainNameServers{};
  shared_ptr<string> ipv6LeaseTime{};
  shared_ptr<string> leaseTime{};

  GetDhcpOptionsSetResponseBodyDhcpOptions() {}

  explicit GetDhcpOptionsSetResponseBodyDhcpOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainNameServers) {
      res["DomainNameServers"] = boost::any(*domainNameServers);
    }
    if (ipv6LeaseTime) {
      res["Ipv6LeaseTime"] = boost::any(*ipv6LeaseTime);
    }
    if (leaseTime) {
      res["LeaseTime"] = boost::any(*leaseTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainNameServers") != m.end() && !m["DomainNameServers"].empty()) {
      domainNameServers = make_shared<string>(boost::any_cast<string>(m["DomainNameServers"]));
    }
    if (m.find("Ipv6LeaseTime") != m.end() && !m["Ipv6LeaseTime"].empty()) {
      ipv6LeaseTime = make_shared<string>(boost::any_cast<string>(m["Ipv6LeaseTime"]));
    }
    if (m.find("LeaseTime") != m.end() && !m["LeaseTime"].empty()) {
      leaseTime = make_shared<string>(boost::any_cast<string>(m["LeaseTime"]));
    }
  }


  virtual ~GetDhcpOptionsSetResponseBodyDhcpOptions() = default;
};
class GetDhcpOptionsSetResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetDhcpOptionsSetResponseBodyTags() {}

  explicit GetDhcpOptionsSetResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetDhcpOptionsSetResponseBodyTags() = default;
};
class GetDhcpOptionsSetResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetDhcpOptionsSetResponseBodyAssociateVpcs>> associateVpcs{};
  shared_ptr<GetDhcpOptionsSetResponseBodyDhcpOptions> dhcpOptions{};
  shared_ptr<string> dhcpOptionsSetDescription{};
  shared_ptr<string> dhcpOptionsSetId{};
  shared_ptr<string> dhcpOptionsSetName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> status{};
  shared_ptr<vector<GetDhcpOptionsSetResponseBodyTags>> tags{};

  GetDhcpOptionsSetResponseBody() {}

  explicit GetDhcpOptionsSetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associateVpcs) {
      vector<boost::any> temp1;
      for(auto item1:*associateVpcs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AssociateVpcs"] = boost::any(temp1);
    }
    if (dhcpOptions) {
      res["DhcpOptions"] = dhcpOptions ? boost::any(dhcpOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dhcpOptionsSetDescription) {
      res["DhcpOptionsSetDescription"] = boost::any(*dhcpOptionsSetDescription);
    }
    if (dhcpOptionsSetId) {
      res["DhcpOptionsSetId"] = boost::any(*dhcpOptionsSetId);
    }
    if (dhcpOptionsSetName) {
      res["DhcpOptionsSetName"] = boost::any(*dhcpOptionsSetName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociateVpcs") != m.end() && !m["AssociateVpcs"].empty()) {
      if (typeid(vector<boost::any>) == m["AssociateVpcs"].type()) {
        vector<GetDhcpOptionsSetResponseBodyAssociateVpcs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AssociateVpcs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDhcpOptionsSetResponseBodyAssociateVpcs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        associateVpcs = make_shared<vector<GetDhcpOptionsSetResponseBodyAssociateVpcs>>(expect1);
      }
    }
    if (m.find("DhcpOptions") != m.end() && !m["DhcpOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["DhcpOptions"].type()) {
        GetDhcpOptionsSetResponseBodyDhcpOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DhcpOptions"]));
        dhcpOptions = make_shared<GetDhcpOptionsSetResponseBodyDhcpOptions>(model1);
      }
    }
    if (m.find("DhcpOptionsSetDescription") != m.end() && !m["DhcpOptionsSetDescription"].empty()) {
      dhcpOptionsSetDescription = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetDescription"]));
    }
    if (m.find("DhcpOptionsSetId") != m.end() && !m["DhcpOptionsSetId"].empty()) {
      dhcpOptionsSetId = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetId"]));
    }
    if (m.find("DhcpOptionsSetName") != m.end() && !m["DhcpOptionsSetName"].empty()) {
      dhcpOptionsSetName = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetDhcpOptionsSetResponseBodyTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDhcpOptionsSetResponseBodyTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetDhcpOptionsSetResponseBodyTags>>(expect1);
      }
    }
  }


  virtual ~GetDhcpOptionsSetResponseBody() = default;
};
class GetDhcpOptionsSetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDhcpOptionsSetResponseBody> body{};

  GetDhcpOptionsSetResponse() {}

  explicit GetDhcpOptionsSetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDhcpOptionsSetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDhcpOptionsSetResponseBody>(model1);
      }
    }
  }


  virtual ~GetDhcpOptionsSetResponse() = default;
};
class GetFlowLogServiceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  GetFlowLogServiceStatusRequest() {}

  explicit GetFlowLogServiceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GetFlowLogServiceStatusRequest() = default;
};
class GetFlowLogServiceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> requestId{};

  GetFlowLogServiceStatusResponseBody() {}

  explicit GetFlowLogServiceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetFlowLogServiceStatusResponseBody() = default;
};
class GetFlowLogServiceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFlowLogServiceStatusResponseBody> body{};

  GetFlowLogServiceStatusResponse() {}

  explicit GetFlowLogServiceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFlowLogServiceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFlowLogServiceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetFlowLogServiceStatusResponse() = default;
};
class GetIpv4GatewayAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipv4GatewayId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  GetIpv4GatewayAttributeRequest() {}

  explicit GetIpv4GatewayAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv4GatewayId) {
      res["Ipv4GatewayId"] = boost::any(*ipv4GatewayId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv4GatewayId") != m.end() && !m["Ipv4GatewayId"].empty()) {
      ipv4GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GetIpv4GatewayAttributeRequest() = default;
};
class GetIpv4GatewayAttributeResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetIpv4GatewayAttributeResponseBodyTags() {}

  explicit GetIpv4GatewayAttributeResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetIpv4GatewayAttributeResponseBodyTags() = default;
};
class GetIpv4GatewayAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> ipv4GatewayDescription{};
  shared_ptr<string> ipv4GatewayId{};
  shared_ptr<string> ipv4GatewayName{};
  shared_ptr<string> ipv4GatewayRouteTableId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> status{};
  shared_ptr<vector<GetIpv4GatewayAttributeResponseBodyTags>> tags{};
  shared_ptr<string> vpcId{};

  GetIpv4GatewayAttributeResponseBody() {}

  explicit GetIpv4GatewayAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (ipv4GatewayDescription) {
      res["Ipv4GatewayDescription"] = boost::any(*ipv4GatewayDescription);
    }
    if (ipv4GatewayId) {
      res["Ipv4GatewayId"] = boost::any(*ipv4GatewayId);
    }
    if (ipv4GatewayName) {
      res["Ipv4GatewayName"] = boost::any(*ipv4GatewayName);
    }
    if (ipv4GatewayRouteTableId) {
      res["Ipv4GatewayRouteTableId"] = boost::any(*ipv4GatewayRouteTableId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Ipv4GatewayDescription") != m.end() && !m["Ipv4GatewayDescription"].empty()) {
      ipv4GatewayDescription = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayDescription"]));
    }
    if (m.find("Ipv4GatewayId") != m.end() && !m["Ipv4GatewayId"].empty()) {
      ipv4GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayId"]));
    }
    if (m.find("Ipv4GatewayName") != m.end() && !m["Ipv4GatewayName"].empty()) {
      ipv4GatewayName = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayName"]));
    }
    if (m.find("Ipv4GatewayRouteTableId") != m.end() && !m["Ipv4GatewayRouteTableId"].empty()) {
      ipv4GatewayRouteTableId = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayRouteTableId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetIpv4GatewayAttributeResponseBodyTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetIpv4GatewayAttributeResponseBodyTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetIpv4GatewayAttributeResponseBodyTags>>(expect1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~GetIpv4GatewayAttributeResponseBody() = default;
};
class GetIpv4GatewayAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetIpv4GatewayAttributeResponseBody> body{};

  GetIpv4GatewayAttributeResponse() {}

  explicit GetIpv4GatewayAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetIpv4GatewayAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetIpv4GatewayAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~GetIpv4GatewayAttributeResponse() = default;
};
class GetNatGatewayAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  GetNatGatewayAttributeRequest() {}

  explicit GetNatGatewayAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GetNatGatewayAttributeRequest() = default;
};
class GetNatGatewayAttributeResponseBodyBillingConfig : public Darabonba::Model {
public:
  shared_ptr<string> autoPay{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> spec{};

  GetNatGatewayAttributeResponseBodyBillingConfig() {}

  explicit GetNatGatewayAttributeResponseBodyBillingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<string>(boost::any_cast<string>(m["AutoPay"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~GetNatGatewayAttributeResponseBodyBillingConfig() = default;
};
class GetNatGatewayAttributeResponseBodyDeletionProtectionInfo : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};

  GetNatGatewayAttributeResponseBodyDeletionProtectionInfo() {}

  explicit GetNatGatewayAttributeResponseBodyDeletionProtectionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
  }


  virtual ~GetNatGatewayAttributeResponseBodyDeletionProtectionInfo() = default;
};
class GetNatGatewayAttributeResponseBodyForwardTable : public Darabonba::Model {
public:
  shared_ptr<long> forwardEntryCount{};
  shared_ptr<string> forwardTableId{};

  GetNatGatewayAttributeResponseBodyForwardTable() {}

  explicit GetNatGatewayAttributeResponseBodyForwardTable(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardEntryCount) {
      res["ForwardEntryCount"] = boost::any(*forwardEntryCount);
    }
    if (forwardTableId) {
      res["ForwardTableId"] = boost::any(*forwardTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardEntryCount") != m.end() && !m["ForwardEntryCount"].empty()) {
      forwardEntryCount = make_shared<long>(boost::any_cast<long>(m["ForwardEntryCount"]));
    }
    if (m.find("ForwardTableId") != m.end() && !m["ForwardTableId"].empty()) {
      forwardTableId = make_shared<string>(boost::any_cast<string>(m["ForwardTableId"]));
    }
  }


  virtual ~GetNatGatewayAttributeResponseBodyForwardTable() = default;
};
class GetNatGatewayAttributeResponseBodyFullNatTable : public Darabonba::Model {
public:
  shared_ptr<long> fullNatEntryCount{};
  shared_ptr<string> fullNatTableId{};

  GetNatGatewayAttributeResponseBodyFullNatTable() {}

  explicit GetNatGatewayAttributeResponseBodyFullNatTable(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fullNatEntryCount) {
      res["FullNatEntryCount"] = boost::any(*fullNatEntryCount);
    }
    if (fullNatTableId) {
      res["FullNatTableId"] = boost::any(*fullNatTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FullNatEntryCount") != m.end() && !m["FullNatEntryCount"].empty()) {
      fullNatEntryCount = make_shared<long>(boost::any_cast<long>(m["FullNatEntryCount"]));
    }
    if (m.find("FullNatTableId") != m.end() && !m["FullNatTableId"].empty()) {
      fullNatTableId = make_shared<string>(boost::any_cast<string>(m["FullNatTableId"]));
    }
  }


  virtual ~GetNatGatewayAttributeResponseBodyFullNatTable() = default;
};
class GetNatGatewayAttributeResponseBodyIpList : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> usingStatus{};

  GetNatGatewayAttributeResponseBodyIpList() {}

  explicit GetNatGatewayAttributeResponseBodyIpList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (usingStatus) {
      res["UsingStatus"] = boost::any(*usingStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("UsingStatus") != m.end() && !m["UsingStatus"].empty()) {
      usingStatus = make_shared<string>(boost::any_cast<string>(m["UsingStatus"]));
    }
  }


  virtual ~GetNatGatewayAttributeResponseBodyIpList() = default;
};
class GetNatGatewayAttributeResponseBodyLogDelivery : public Darabonba::Model {
public:
  shared_ptr<string> deliverLogsErrorMessage{};
  shared_ptr<string> deliveryStatus{};
  shared_ptr<string> logDeliveryType{};
  shared_ptr<string> logDestination{};

  GetNatGatewayAttributeResponseBodyLogDelivery() {}

  explicit GetNatGatewayAttributeResponseBodyLogDelivery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliverLogsErrorMessage) {
      res["DeliverLogsErrorMessage"] = boost::any(*deliverLogsErrorMessage);
    }
    if (deliveryStatus) {
      res["DeliveryStatus"] = boost::any(*deliveryStatus);
    }
    if (logDeliveryType) {
      res["LogDeliveryType"] = boost::any(*logDeliveryType);
    }
    if (logDestination) {
      res["LogDestination"] = boost::any(*logDestination);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliverLogsErrorMessage") != m.end() && !m["DeliverLogsErrorMessage"].empty()) {
      deliverLogsErrorMessage = make_shared<string>(boost::any_cast<string>(m["DeliverLogsErrorMessage"]));
    }
    if (m.find("DeliveryStatus") != m.end() && !m["DeliveryStatus"].empty()) {
      deliveryStatus = make_shared<string>(boost::any_cast<string>(m["DeliveryStatus"]));
    }
    if (m.find("LogDeliveryType") != m.end() && !m["LogDeliveryType"].empty()) {
      logDeliveryType = make_shared<string>(boost::any_cast<string>(m["LogDeliveryType"]));
    }
    if (m.find("LogDestination") != m.end() && !m["LogDestination"].empty()) {
      logDestination = make_shared<string>(boost::any_cast<string>(m["LogDestination"]));
    }
  }


  virtual ~GetNatGatewayAttributeResponseBodyLogDelivery() = default;
};
class GetNatGatewayAttributeResponseBodyPrivateInfo : public Darabonba::Model {
public:
  shared_ptr<string> eniInstanceId{};
  shared_ptr<string> izNo{};
  shared_ptr<long> maxBandwidth{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> vswitchId{};

  GetNatGatewayAttributeResponseBodyPrivateInfo() {}

  explicit GetNatGatewayAttributeResponseBodyPrivateInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eniInstanceId) {
      res["EniInstanceId"] = boost::any(*eniInstanceId);
    }
    if (izNo) {
      res["IzNo"] = boost::any(*izNo);
    }
    if (maxBandwidth) {
      res["MaxBandwidth"] = boost::any(*maxBandwidth);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EniInstanceId") != m.end() && !m["EniInstanceId"].empty()) {
      eniInstanceId = make_shared<string>(boost::any_cast<string>(m["EniInstanceId"]));
    }
    if (m.find("IzNo") != m.end() && !m["IzNo"].empty()) {
      izNo = make_shared<string>(boost::any_cast<string>(m["IzNo"]));
    }
    if (m.find("MaxBandwidth") != m.end() && !m["MaxBandwidth"].empty()) {
      maxBandwidth = make_shared<long>(boost::any_cast<long>(m["MaxBandwidth"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~GetNatGatewayAttributeResponseBodyPrivateInfo() = default;
};
class GetNatGatewayAttributeResponseBodySnatTable : public Darabonba::Model {
public:
  shared_ptr<long> snatEntryCount{};
  shared_ptr<string> snatTableId{};

  GetNatGatewayAttributeResponseBodySnatTable() {}

  explicit GetNatGatewayAttributeResponseBodySnatTable(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snatEntryCount) {
      res["SnatEntryCount"] = boost::any(*snatEntryCount);
    }
    if (snatTableId) {
      res["SnatTableId"] = boost::any(*snatTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnatEntryCount") != m.end() && !m["SnatEntryCount"].empty()) {
      snatEntryCount = make_shared<long>(boost::any_cast<long>(m["SnatEntryCount"]));
    }
    if (m.find("SnatTableId") != m.end() && !m["SnatTableId"].empty()) {
      snatTableId = make_shared<string>(boost::any_cast<string>(m["SnatTableId"]));
    }
  }


  virtual ~GetNatGatewayAttributeResponseBodySnatTable() = default;
};
class GetNatGatewayAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetNatGatewayAttributeResponseBodyBillingConfig> billingConfig{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> creationTime{};
  shared_ptr<GetNatGatewayAttributeResponseBodyDeletionProtectionInfo> deletionProtectionInfo{};
  shared_ptr<string> description{};
  shared_ptr<bool> ecsMetricEnabled{};
  shared_ptr<bool> enableSessionLog{};
  shared_ptr<string> expiredTime{};
  shared_ptr<GetNatGatewayAttributeResponseBodyForwardTable> forwardTable{};
  shared_ptr<GetNatGatewayAttributeResponseBodyFullNatTable> fullNatTable{};
  shared_ptr<vector<GetNatGatewayAttributeResponseBodyIpList>> ipList{};
  shared_ptr<GetNatGatewayAttributeResponseBodyLogDelivery> logDelivery{};
  shared_ptr<string> name{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> natType{};
  shared_ptr<string> networkType{};
  shared_ptr<GetNatGatewayAttributeResponseBodyPrivateInfo> privateInfo{};
  shared_ptr<bool> privateLinkEnabled{};
  shared_ptr<string> privateLinkMode{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<GetNatGatewayAttributeResponseBodySnatTable> snatTable{};
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};

  GetNatGatewayAttributeResponseBody() {}

  explicit GetNatGatewayAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billingConfig) {
      res["BillingConfig"] = billingConfig ? boost::any(billingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (deletionProtectionInfo) {
      res["DeletionProtectionInfo"] = deletionProtectionInfo ? boost::any(deletionProtectionInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ecsMetricEnabled) {
      res["EcsMetricEnabled"] = boost::any(*ecsMetricEnabled);
    }
    if (enableSessionLog) {
      res["EnableSessionLog"] = boost::any(*enableSessionLog);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (forwardTable) {
      res["ForwardTable"] = forwardTable ? boost::any(forwardTable->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fullNatTable) {
      res["FullNatTable"] = fullNatTable ? boost::any(fullNatTable->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipList) {
      vector<boost::any> temp1;
      for(auto item1:*ipList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpList"] = boost::any(temp1);
    }
    if (logDelivery) {
      res["LogDelivery"] = logDelivery ? boost::any(logDelivery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (natType) {
      res["NatType"] = boost::any(*natType);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (privateInfo) {
      res["PrivateInfo"] = privateInfo ? boost::any(privateInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privateLinkEnabled) {
      res["PrivateLinkEnabled"] = boost::any(*privateLinkEnabled);
    }
    if (privateLinkMode) {
      res["PrivateLinkMode"] = boost::any(*privateLinkMode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (snatTable) {
      res["SnatTable"] = snatTable ? boost::any(snatTable->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillingConfig") != m.end() && !m["BillingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["BillingConfig"].type()) {
        GetNatGatewayAttributeResponseBodyBillingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BillingConfig"]));
        billingConfig = make_shared<GetNatGatewayAttributeResponseBodyBillingConfig>(model1);
      }
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DeletionProtectionInfo") != m.end() && !m["DeletionProtectionInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeletionProtectionInfo"].type()) {
        GetNatGatewayAttributeResponseBodyDeletionProtectionInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeletionProtectionInfo"]));
        deletionProtectionInfo = make_shared<GetNatGatewayAttributeResponseBodyDeletionProtectionInfo>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EcsMetricEnabled") != m.end() && !m["EcsMetricEnabled"].empty()) {
      ecsMetricEnabled = make_shared<bool>(boost::any_cast<bool>(m["EcsMetricEnabled"]));
    }
    if (m.find("EnableSessionLog") != m.end() && !m["EnableSessionLog"].empty()) {
      enableSessionLog = make_shared<bool>(boost::any_cast<bool>(m["EnableSessionLog"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("ForwardTable") != m.end() && !m["ForwardTable"].empty()) {
      if (typeid(map<string, boost::any>) == m["ForwardTable"].type()) {
        GetNatGatewayAttributeResponseBodyForwardTable model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ForwardTable"]));
        forwardTable = make_shared<GetNatGatewayAttributeResponseBodyForwardTable>(model1);
      }
    }
    if (m.find("FullNatTable") != m.end() && !m["FullNatTable"].empty()) {
      if (typeid(map<string, boost::any>) == m["FullNatTable"].type()) {
        GetNatGatewayAttributeResponseBodyFullNatTable model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FullNatTable"]));
        fullNatTable = make_shared<GetNatGatewayAttributeResponseBodyFullNatTable>(model1);
      }
    }
    if (m.find("IpList") != m.end() && !m["IpList"].empty()) {
      if (typeid(vector<boost::any>) == m["IpList"].type()) {
        vector<GetNatGatewayAttributeResponseBodyIpList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetNatGatewayAttributeResponseBodyIpList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipList = make_shared<vector<GetNatGatewayAttributeResponseBodyIpList>>(expect1);
      }
    }
    if (m.find("LogDelivery") != m.end() && !m["LogDelivery"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogDelivery"].type()) {
        GetNatGatewayAttributeResponseBodyLogDelivery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogDelivery"]));
        logDelivery = make_shared<GetNatGatewayAttributeResponseBodyLogDelivery>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("NatType") != m.end() && !m["NatType"].empty()) {
      natType = make_shared<string>(boost::any_cast<string>(m["NatType"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("PrivateInfo") != m.end() && !m["PrivateInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivateInfo"].type()) {
        GetNatGatewayAttributeResponseBodyPrivateInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivateInfo"]));
        privateInfo = make_shared<GetNatGatewayAttributeResponseBodyPrivateInfo>(model1);
      }
    }
    if (m.find("PrivateLinkEnabled") != m.end() && !m["PrivateLinkEnabled"].empty()) {
      privateLinkEnabled = make_shared<bool>(boost::any_cast<bool>(m["PrivateLinkEnabled"]));
    }
    if (m.find("PrivateLinkMode") != m.end() && !m["PrivateLinkMode"].empty()) {
      privateLinkMode = make_shared<string>(boost::any_cast<string>(m["PrivateLinkMode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SnatTable") != m.end() && !m["SnatTable"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnatTable"].type()) {
        GetNatGatewayAttributeResponseBodySnatTable model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnatTable"]));
        snatTable = make_shared<GetNatGatewayAttributeResponseBodySnatTable>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~GetNatGatewayAttributeResponseBody() = default;
};
class GetNatGatewayAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNatGatewayAttributeResponseBody> body{};

  GetNatGatewayAttributeResponse() {}

  explicit GetNatGatewayAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNatGatewayAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNatGatewayAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~GetNatGatewayAttributeResponse() = default;
};
class GetPhysicalConnectionServiceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  GetPhysicalConnectionServiceStatusRequest() {}

  explicit GetPhysicalConnectionServiceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GetPhysicalConnectionServiceStatusRequest() = default;
};
class GetPhysicalConnectionServiceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> requestId{};

  GetPhysicalConnectionServiceStatusResponseBody() {}

  explicit GetPhysicalConnectionServiceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPhysicalConnectionServiceStatusResponseBody() = default;
};
class GetPhysicalConnectionServiceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPhysicalConnectionServiceStatusResponseBody> body{};

  GetPhysicalConnectionServiceStatusResponse() {}

  explicit GetPhysicalConnectionServiceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPhysicalConnectionServiceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPhysicalConnectionServiceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetPhysicalConnectionServiceStatusResponse() = default;
};
class GetTrafficMirrorServiceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  GetTrafficMirrorServiceStatusRequest() {}

  explicit GetTrafficMirrorServiceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GetTrafficMirrorServiceStatusRequest() = default;
};
class GetTrafficMirrorServiceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> requestId{};

  GetTrafficMirrorServiceStatusResponseBody() {}

  explicit GetTrafficMirrorServiceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetTrafficMirrorServiceStatusResponseBody() = default;
};
class GetTrafficMirrorServiceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTrafficMirrorServiceStatusResponseBody> body{};

  GetTrafficMirrorServiceStatusResponse() {}

  explicit GetTrafficMirrorServiceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTrafficMirrorServiceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTrafficMirrorServiceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetTrafficMirrorServiceStatusResponse() = default;
};
class GetVSwitchCidrReservationUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vSwitchCidrReservationId{};

  GetVSwitchCidrReservationUsageRequest() {}

  explicit GetVSwitchCidrReservationUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vSwitchCidrReservationId) {
      res["VSwitchCidrReservationId"] = boost::any(*vSwitchCidrReservationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VSwitchCidrReservationId") != m.end() && !m["VSwitchCidrReservationId"].empty()) {
      vSwitchCidrReservationId = make_shared<string>(boost::any_cast<string>(m["VSwitchCidrReservationId"]));
    }
  }


  virtual ~GetVSwitchCidrReservationUsageRequest() = default;
};
class GetVSwitchCidrReservationUsageResponseBodyCidrReservationUsages : public Darabonba::Model {
public:
  shared_ptr<string> ipPrefixCidr{};
  shared_ptr<string> ipPrefixId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> vSwitchCidrReservationId{};
  shared_ptr<string> vSwitchId{};

  GetVSwitchCidrReservationUsageResponseBodyCidrReservationUsages() {}

  explicit GetVSwitchCidrReservationUsageResponseBodyCidrReservationUsages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipPrefixCidr) {
      res["IpPrefixCidr"] = boost::any(*ipPrefixCidr);
    }
    if (ipPrefixId) {
      res["IpPrefixId"] = boost::any(*ipPrefixId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (vSwitchCidrReservationId) {
      res["VSwitchCidrReservationId"] = boost::any(*vSwitchCidrReservationId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpPrefixCidr") != m.end() && !m["IpPrefixCidr"].empty()) {
      ipPrefixCidr = make_shared<string>(boost::any_cast<string>(m["IpPrefixCidr"]));
    }
    if (m.find("IpPrefixId") != m.end() && !m["IpPrefixId"].empty()) {
      ipPrefixId = make_shared<string>(boost::any_cast<string>(m["IpPrefixId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("VSwitchCidrReservationId") != m.end() && !m["VSwitchCidrReservationId"].empty()) {
      vSwitchCidrReservationId = make_shared<string>(boost::any_cast<string>(m["VSwitchCidrReservationId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~GetVSwitchCidrReservationUsageResponseBodyCidrReservationUsages() = default;
};
class GetVSwitchCidrReservationUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetVSwitchCidrReservationUsageResponseBodyCidrReservationUsages>> cidrReservationUsages{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  GetVSwitchCidrReservationUsageResponseBody() {}

  explicit GetVSwitchCidrReservationUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrReservationUsages) {
      vector<boost::any> temp1;
      for(auto item1:*cidrReservationUsages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CidrReservationUsages"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrReservationUsages") != m.end() && !m["CidrReservationUsages"].empty()) {
      if (typeid(vector<boost::any>) == m["CidrReservationUsages"].type()) {
        vector<GetVSwitchCidrReservationUsageResponseBodyCidrReservationUsages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CidrReservationUsages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetVSwitchCidrReservationUsageResponseBodyCidrReservationUsages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cidrReservationUsages = make_shared<vector<GetVSwitchCidrReservationUsageResponseBodyCidrReservationUsages>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetVSwitchCidrReservationUsageResponseBody() = default;
};
class GetVSwitchCidrReservationUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVSwitchCidrReservationUsageResponseBody> body{};

  GetVSwitchCidrReservationUsageResponse() {}

  explicit GetVSwitchCidrReservationUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVSwitchCidrReservationUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVSwitchCidrReservationUsageResponseBody>(model1);
      }
    }
  }


  virtual ~GetVSwitchCidrReservationUsageResponse() = default;
};
class GetVpcGatewayEndpointAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> endpointId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  GetVpcGatewayEndpointAttributeRequest() {}

  explicit GetVpcGatewayEndpointAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GetVpcGatewayEndpointAttributeRequest() = default;
};
class GetVpcGatewayEndpointAttributeResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetVpcGatewayEndpointAttributeResponseBodyTags() {}

  explicit GetVpcGatewayEndpointAttributeResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetVpcGatewayEndpointAttributeResponseBodyTags() = default;
};
class GetVpcGatewayEndpointAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> endpointDescription{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> endpointStatus{};
  shared_ptr<string> policyDocument{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<string>> routeTables{};
  shared_ptr<string> serviceName{};
  shared_ptr<vector<GetVpcGatewayEndpointAttributeResponseBodyTags>> tags{};
  shared_ptr<string> vpcId{};

  GetVpcGatewayEndpointAttributeResponseBody() {}

  explicit GetVpcGatewayEndpointAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (endpointDescription) {
      res["EndpointDescription"] = boost::any(*endpointDescription);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (endpointStatus) {
      res["EndpointStatus"] = boost::any(*endpointStatus);
    }
    if (policyDocument) {
      res["PolicyDocument"] = boost::any(*policyDocument);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (routeTables) {
      res["RouteTables"] = boost::any(*routeTables);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("EndpointDescription") != m.end() && !m["EndpointDescription"].empty()) {
      endpointDescription = make_shared<string>(boost::any_cast<string>(m["EndpointDescription"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("EndpointStatus") != m.end() && !m["EndpointStatus"].empty()) {
      endpointStatus = make_shared<string>(boost::any_cast<string>(m["EndpointStatus"]));
    }
    if (m.find("PolicyDocument") != m.end() && !m["PolicyDocument"].empty()) {
      policyDocument = make_shared<string>(boost::any_cast<string>(m["PolicyDocument"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RouteTables") != m.end() && !m["RouteTables"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RouteTables"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RouteTables"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      routeTables = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetVpcGatewayEndpointAttributeResponseBodyTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetVpcGatewayEndpointAttributeResponseBodyTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetVpcGatewayEndpointAttributeResponseBodyTags>>(expect1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~GetVpcGatewayEndpointAttributeResponseBody() = default;
};
class GetVpcGatewayEndpointAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVpcGatewayEndpointAttributeResponseBody> body{};

  GetVpcGatewayEndpointAttributeResponse() {}

  explicit GetVpcGatewayEndpointAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVpcGatewayEndpointAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVpcGatewayEndpointAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~GetVpcGatewayEndpointAttributeResponse() = default;
};
class GetVpcPrefixListAssociationsRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prefixListId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  GetVpcPrefixListAssociationsRequest() {}

  explicit GetVpcPrefixListAssociationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prefixListId) {
      res["PrefixListId"] = boost::any(*prefixListId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PrefixListId") != m.end() && !m["PrefixListId"].empty()) {
      prefixListId = make_shared<string>(boost::any_cast<string>(m["PrefixListId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GetVpcPrefixListAssociationsRequest() = default;
};
class GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation : public Darabonba::Model {
public:
  shared_ptr<string> ownerId{};
  shared_ptr<string> prefixListId{};
  shared_ptr<string> reason{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceUid{};
  shared_ptr<string> status{};

  GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation() {}

  explicit GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prefixListId) {
      res["PrefixListId"] = boost::any(*prefixListId);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceUid) {
      res["ResourceUid"] = boost::any(*resourceUid);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("PrefixListId") != m.end() && !m["PrefixListId"].empty()) {
      prefixListId = make_shared<string>(boost::any_cast<string>(m["PrefixListId"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceUid") != m.end() && !m["ResourceUid"].empty()) {
      resourceUid = make_shared<string>(boost::any_cast<string>(m["ResourceUid"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation() = default;
};
class GetVpcPrefixListAssociationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation>> prefixListAssociation{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  GetVpcPrefixListAssociationsResponseBody() {}

  explicit GetVpcPrefixListAssociationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (prefixListAssociation) {
      vector<boost::any> temp1;
      for(auto item1:*prefixListAssociation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrefixListAssociation"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PrefixListAssociation") != m.end() && !m["PrefixListAssociation"].empty()) {
      if (typeid(vector<boost::any>) == m["PrefixListAssociation"].type()) {
        vector<GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrefixListAssociation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        prefixListAssociation = make_shared<vector<GetVpcPrefixListAssociationsResponseBodyPrefixListAssociation>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetVpcPrefixListAssociationsResponseBody() = default;
};
class GetVpcPrefixListAssociationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVpcPrefixListAssociationsResponseBody> body{};

  GetVpcPrefixListAssociationsResponse() {}

  explicit GetVpcPrefixListAssociationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVpcPrefixListAssociationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVpcPrefixListAssociationsResponseBody>(model1);
      }
    }
  }


  virtual ~GetVpcPrefixListAssociationsResponse() = default;
};
class GetVpcPrefixListEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prefixListId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  GetVpcPrefixListEntriesRequest() {}

  explicit GetVpcPrefixListEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prefixListId) {
      res["PrefixListId"] = boost::any(*prefixListId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PrefixListId") != m.end() && !m["PrefixListId"].empty()) {
      prefixListId = make_shared<string>(boost::any_cast<string>(m["PrefixListId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GetVpcPrefixListEntriesRequest() = default;
};
class GetVpcPrefixListEntriesResponseBodyPrefixListEntry : public Darabonba::Model {
public:
  shared_ptr<string> cidr{};
  shared_ptr<string> description{};
  shared_ptr<string> prefixListId{};
  shared_ptr<string> regionId{};

  GetVpcPrefixListEntriesResponseBodyPrefixListEntry() {}

  explicit GetVpcPrefixListEntriesResponseBodyPrefixListEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidr) {
      res["Cidr"] = boost::any(*cidr);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (prefixListId) {
      res["PrefixListId"] = boost::any(*prefixListId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cidr") != m.end() && !m["Cidr"].empty()) {
      cidr = make_shared<string>(boost::any_cast<string>(m["Cidr"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("PrefixListId") != m.end() && !m["PrefixListId"].empty()) {
      prefixListId = make_shared<string>(boost::any_cast<string>(m["PrefixListId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetVpcPrefixListEntriesResponseBodyPrefixListEntry() = default;
};
class GetVpcPrefixListEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<GetVpcPrefixListEntriesResponseBodyPrefixListEntry>> prefixListEntry{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  GetVpcPrefixListEntriesResponseBody() {}

  explicit GetVpcPrefixListEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (prefixListEntry) {
      vector<boost::any> temp1;
      for(auto item1:*prefixListEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrefixListEntry"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PrefixListEntry") != m.end() && !m["PrefixListEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["PrefixListEntry"].type()) {
        vector<GetVpcPrefixListEntriesResponseBodyPrefixListEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrefixListEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetVpcPrefixListEntriesResponseBodyPrefixListEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        prefixListEntry = make_shared<vector<GetVpcPrefixListEntriesResponseBodyPrefixListEntry>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetVpcPrefixListEntriesResponseBody() = default;
};
class GetVpcPrefixListEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVpcPrefixListEntriesResponseBody> body{};

  GetVpcPrefixListEntriesResponse() {}

  explicit GetVpcPrefixListEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVpcPrefixListEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVpcPrefixListEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~GetVpcPrefixListEntriesResponse() = default;
};
class GetVpcRouteEntrySummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeEntryType{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> vpcId{};

  GetVpcRouteEntrySummaryRequest() {}

  explicit GetVpcRouteEntrySummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeEntryType) {
      res["RouteEntryType"] = boost::any(*routeEntryType);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteEntryType") != m.end() && !m["RouteEntryType"].empty()) {
      routeEntryType = make_shared<string>(boost::any_cast<string>(m["RouteEntryType"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~GetVpcRouteEntrySummaryRequest() = default;
};
class GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarysEntrySummarys : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> routeEntryType{};

  GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarysEntrySummarys() {}

  explicit GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarysEntrySummarys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (routeEntryType) {
      res["RouteEntryType"] = boost::any(*routeEntryType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("RouteEntryType") != m.end() && !m["RouteEntryType"].empty()) {
      routeEntryType = make_shared<string>(boost::any_cast<string>(m["RouteEntryType"]));
    }
  }


  virtual ~GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarysEntrySummarys() = default;
};
class GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarys : public Darabonba::Model {
public:
  shared_ptr<vector<GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarysEntrySummarys>> entrySummarys{};
  shared_ptr<string> routeTableId{};

  GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarys() {}

  explicit GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entrySummarys) {
      vector<boost::any> temp1;
      for(auto item1:*entrySummarys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EntrySummarys"] = boost::any(temp1);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntrySummarys") != m.end() && !m["EntrySummarys"].empty()) {
      if (typeid(vector<boost::any>) == m["EntrySummarys"].type()) {
        vector<GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarysEntrySummarys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EntrySummarys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarysEntrySummarys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entrySummarys = make_shared<vector<GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarysEntrySummarys>>(expect1);
      }
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
  }


  virtual ~GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarys() = default;
};
class GetVpcRouteEntrySummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarys>> routeEntrySummarys{};

  GetVpcRouteEntrySummaryResponseBody() {}

  explicit GetVpcRouteEntrySummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routeEntrySummarys) {
      vector<boost::any> temp1;
      for(auto item1:*routeEntrySummarys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouteEntrySummarys"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RouteEntrySummarys") != m.end() && !m["RouteEntrySummarys"].empty()) {
      if (typeid(vector<boost::any>) == m["RouteEntrySummarys"].type()) {
        vector<GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouteEntrySummarys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeEntrySummarys = make_shared<vector<GetVpcRouteEntrySummaryResponseBodyRouteEntrySummarys>>(expect1);
      }
    }
  }


  virtual ~GetVpcRouteEntrySummaryResponseBody() = default;
};
class GetVpcRouteEntrySummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVpcRouteEntrySummaryResponseBody> body{};

  GetVpcRouteEntrySummaryResponse() {}

  explicit GetVpcRouteEntrySummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVpcRouteEntrySummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVpcRouteEntrySummaryResponseBody>(model1);
      }
    }
  }


  virtual ~GetVpcRouteEntrySummaryResponse() = default;
};
class GetVpnGatewayDiagnoseResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> diagnoseId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vpnGatewayId{};

  GetVpnGatewayDiagnoseResultRequest() {}

  explicit GetVpnGatewayDiagnoseResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (diagnoseId) {
      res["DiagnoseId"] = boost::any(*diagnoseId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DiagnoseId") != m.end() && !m["DiagnoseId"].empty()) {
      diagnoseId = make_shared<string>(boost::any_cast<string>(m["DiagnoseId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~GetVpnGatewayDiagnoseResultRequest() = default;
};
class GetVpnGatewayDiagnoseResultResponseBodyDiagnoseResult : public Darabonba::Model {
public:
  shared_ptr<string> diagnoseName{};
  shared_ptr<string> diagnoseResultDescription{};
  shared_ptr<string> diagnoseResultLevel{};

  GetVpnGatewayDiagnoseResultResponseBodyDiagnoseResult() {}

  explicit GetVpnGatewayDiagnoseResultResponseBodyDiagnoseResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diagnoseName) {
      res["DiagnoseName"] = boost::any(*diagnoseName);
    }
    if (diagnoseResultDescription) {
      res["DiagnoseResultDescription"] = boost::any(*diagnoseResultDescription);
    }
    if (diagnoseResultLevel) {
      res["DiagnoseResultLevel"] = boost::any(*diagnoseResultLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiagnoseName") != m.end() && !m["DiagnoseName"].empty()) {
      diagnoseName = make_shared<string>(boost::any_cast<string>(m["DiagnoseName"]));
    }
    if (m.find("DiagnoseResultDescription") != m.end() && !m["DiagnoseResultDescription"].empty()) {
      diagnoseResultDescription = make_shared<string>(boost::any_cast<string>(m["DiagnoseResultDescription"]));
    }
    if (m.find("DiagnoseResultLevel") != m.end() && !m["DiagnoseResultLevel"].empty()) {
      diagnoseResultLevel = make_shared<string>(boost::any_cast<string>(m["DiagnoseResultLevel"]));
    }
  }


  virtual ~GetVpnGatewayDiagnoseResultResponseBodyDiagnoseResult() = default;
};
class GetVpnGatewayDiagnoseResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> beginTime{};
  shared_ptr<string> diagnoseId{};
  shared_ptr<vector<GetVpnGatewayDiagnoseResultResponseBodyDiagnoseResult>> diagnoseResult{};
  shared_ptr<string> finishTime{};
  shared_ptr<long> finishedCount{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceInstanceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> vpnGatewayId{};

  GetVpnGatewayDiagnoseResultResponseBody() {}

  explicit GetVpnGatewayDiagnoseResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (diagnoseId) {
      res["DiagnoseId"] = boost::any(*diagnoseId);
    }
    if (diagnoseResult) {
      vector<boost::any> temp1;
      for(auto item1:*diagnoseResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiagnoseResult"] = boost::any(temp1);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (finishedCount) {
      res["FinishedCount"] = boost::any(*finishedCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceInstanceId) {
      res["ResourceInstanceId"] = boost::any(*resourceInstanceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
    if (m.find("DiagnoseId") != m.end() && !m["DiagnoseId"].empty()) {
      diagnoseId = make_shared<string>(boost::any_cast<string>(m["DiagnoseId"]));
    }
    if (m.find("DiagnoseResult") != m.end() && !m["DiagnoseResult"].empty()) {
      if (typeid(vector<boost::any>) == m["DiagnoseResult"].type()) {
        vector<GetVpnGatewayDiagnoseResultResponseBodyDiagnoseResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiagnoseResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetVpnGatewayDiagnoseResultResponseBodyDiagnoseResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diagnoseResult = make_shared<vector<GetVpnGatewayDiagnoseResultResponseBodyDiagnoseResult>>(expect1);
      }
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("FinishedCount") != m.end() && !m["FinishedCount"].empty()) {
      finishedCount = make_shared<long>(boost::any_cast<long>(m["FinishedCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceInstanceId") != m.end() && !m["ResourceInstanceId"].empty()) {
      resourceInstanceId = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~GetVpnGatewayDiagnoseResultResponseBody() = default;
};
class GetVpnGatewayDiagnoseResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVpnGatewayDiagnoseResultResponseBody> body{};

  GetVpnGatewayDiagnoseResultResponse() {}

  explicit GetVpnGatewayDiagnoseResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVpnGatewayDiagnoseResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVpnGatewayDiagnoseResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetVpnGatewayDiagnoseResultResponse() = default;
};
class GrantInstanceToCenRequest : public Darabonba::Model {
public:
  shared_ptr<string> cenId{};
  shared_ptr<long> cenOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  GrantInstanceToCenRequest() {}

  explicit GrantInstanceToCenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cenId) {
      res["CenId"] = boost::any(*cenId);
    }
    if (cenOwnerId) {
      res["CenOwnerId"] = boost::any(*cenOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CenId") != m.end() && !m["CenId"].empty()) {
      cenId = make_shared<string>(boost::any_cast<string>(m["CenId"]));
    }
    if (m.find("CenOwnerId") != m.end() && !m["CenOwnerId"].empty()) {
      cenOwnerId = make_shared<long>(boost::any_cast<long>(m["CenOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GrantInstanceToCenRequest() = default;
};
class GrantInstanceToCenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  GrantInstanceToCenResponseBody() {}

  explicit GrantInstanceToCenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GrantInstanceToCenResponseBody() = default;
};
class GrantInstanceToCenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GrantInstanceToCenResponseBody> body{};

  GrantInstanceToCenResponse() {}

  explicit GrantInstanceToCenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GrantInstanceToCenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GrantInstanceToCenResponseBody>(model1);
      }
    }
  }


  virtual ~GrantInstanceToCenResponse() = default;
};
class GrantInstanceToVbrRequest : public Darabonba::Model {
public:
  shared_ptr<string> grantType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> vbrInstanceIds{};
  shared_ptr<long> vbrOwnerUid{};
  shared_ptr<string> vbrRegionNo{};

  GrantInstanceToVbrRequest() {}

  explicit GrantInstanceToVbrRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (grantType) {
      res["GrantType"] = boost::any(*grantType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vbrInstanceIds) {
      res["VbrInstanceIds"] = boost::any(*vbrInstanceIds);
    }
    if (vbrOwnerUid) {
      res["VbrOwnerUid"] = boost::any(*vbrOwnerUid);
    }
    if (vbrRegionNo) {
      res["VbrRegionNo"] = boost::any(*vbrRegionNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GrantType") != m.end() && !m["GrantType"].empty()) {
      grantType = make_shared<string>(boost::any_cast<string>(m["GrantType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VbrInstanceIds") != m.end() && !m["VbrInstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VbrInstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VbrInstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vbrInstanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VbrOwnerUid") != m.end() && !m["VbrOwnerUid"].empty()) {
      vbrOwnerUid = make_shared<long>(boost::any_cast<long>(m["VbrOwnerUid"]));
    }
    if (m.find("VbrRegionNo") != m.end() && !m["VbrRegionNo"].empty()) {
      vbrRegionNo = make_shared<string>(boost::any_cast<string>(m["VbrRegionNo"]));
    }
  }


  virtual ~GrantInstanceToVbrRequest() = default;
};
class GrantInstanceToVbrShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> grantType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vbrInstanceIdsShrink{};
  shared_ptr<long> vbrOwnerUid{};
  shared_ptr<string> vbrRegionNo{};

  GrantInstanceToVbrShrinkRequest() {}

  explicit GrantInstanceToVbrShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (grantType) {
      res["GrantType"] = boost::any(*grantType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vbrInstanceIdsShrink) {
      res["VbrInstanceIds"] = boost::any(*vbrInstanceIdsShrink);
    }
    if (vbrOwnerUid) {
      res["VbrOwnerUid"] = boost::any(*vbrOwnerUid);
    }
    if (vbrRegionNo) {
      res["VbrRegionNo"] = boost::any(*vbrRegionNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GrantType") != m.end() && !m["GrantType"].empty()) {
      grantType = make_shared<string>(boost::any_cast<string>(m["GrantType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VbrInstanceIds") != m.end() && !m["VbrInstanceIds"].empty()) {
      vbrInstanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["VbrInstanceIds"]));
    }
    if (m.find("VbrOwnerUid") != m.end() && !m["VbrOwnerUid"].empty()) {
      vbrOwnerUid = make_shared<long>(boost::any_cast<long>(m["VbrOwnerUid"]));
    }
    if (m.find("VbrRegionNo") != m.end() && !m["VbrRegionNo"].empty()) {
      vbrRegionNo = make_shared<string>(boost::any_cast<string>(m["VbrRegionNo"]));
    }
  }


  virtual ~GrantInstanceToVbrShrinkRequest() = default;
};
class GrantInstanceToVbrResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  GrantInstanceToVbrResponseBody() {}

  explicit GrantInstanceToVbrResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GrantInstanceToVbrResponseBody() = default;
};
class GrantInstanceToVbrResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GrantInstanceToVbrResponseBody> body{};

  GrantInstanceToVbrResponse() {}

  explicit GrantInstanceToVbrResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GrantInstanceToVbrResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GrantInstanceToVbrResponseBody>(model1);
      }
    }
  }


  virtual ~GrantInstanceToVbrResponse() = default;
};
class ListBusinessAccessPointsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  ListBusinessAccessPointsRequest() {}

  explicit ListBusinessAccessPointsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListBusinessAccessPointsRequest() = default;
};
class ListBusinessAccessPointsResponseBodyBusinessAccessPoints : public Darabonba::Model {
public:
  shared_ptr<string> accessPointId{};
  shared_ptr<string> accessPointName{};
  shared_ptr<string> cloudBoxInstanceIds{};
  shared_ptr<double> latitude{};
  shared_ptr<double> longitude{};
  shared_ptr<string> supportLineOperator{};
  shared_ptr<string> supportPortTypes{};

  ListBusinessAccessPointsResponseBodyBusinessAccessPoints() {}

  explicit ListBusinessAccessPointsResponseBodyBusinessAccessPoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (accessPointName) {
      res["AccessPointName"] = boost::any(*accessPointName);
    }
    if (cloudBoxInstanceIds) {
      res["CloudBoxInstanceIds"] = boost::any(*cloudBoxInstanceIds);
    }
    if (latitude) {
      res["Latitude"] = boost::any(*latitude);
    }
    if (longitude) {
      res["Longitude"] = boost::any(*longitude);
    }
    if (supportLineOperator) {
      res["SupportLineOperator"] = boost::any(*supportLineOperator);
    }
    if (supportPortTypes) {
      res["SupportPortTypes"] = boost::any(*supportPortTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<string>(boost::any_cast<string>(m["AccessPointId"]));
    }
    if (m.find("AccessPointName") != m.end() && !m["AccessPointName"].empty()) {
      accessPointName = make_shared<string>(boost::any_cast<string>(m["AccessPointName"]));
    }
    if (m.find("CloudBoxInstanceIds") != m.end() && !m["CloudBoxInstanceIds"].empty()) {
      cloudBoxInstanceIds = make_shared<string>(boost::any_cast<string>(m["CloudBoxInstanceIds"]));
    }
    if (m.find("Latitude") != m.end() && !m["Latitude"].empty()) {
      latitude = make_shared<double>(boost::any_cast<double>(m["Latitude"]));
    }
    if (m.find("Longitude") != m.end() && !m["Longitude"].empty()) {
      longitude = make_shared<double>(boost::any_cast<double>(m["Longitude"]));
    }
    if (m.find("SupportLineOperator") != m.end() && !m["SupportLineOperator"].empty()) {
      supportLineOperator = make_shared<string>(boost::any_cast<string>(m["SupportLineOperator"]));
    }
    if (m.find("SupportPortTypes") != m.end() && !m["SupportPortTypes"].empty()) {
      supportPortTypes = make_shared<string>(boost::any_cast<string>(m["SupportPortTypes"]));
    }
  }


  virtual ~ListBusinessAccessPointsResponseBodyBusinessAccessPoints() = default;
};
class ListBusinessAccessPointsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListBusinessAccessPointsResponseBodyBusinessAccessPoints>> businessAccessPoints{};
  shared_ptr<string> requestId{};

  ListBusinessAccessPointsResponseBody() {}

  explicit ListBusinessAccessPointsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessAccessPoints) {
      vector<boost::any> temp1;
      for(auto item1:*businessAccessPoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BusinessAccessPoints"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessAccessPoints") != m.end() && !m["BusinessAccessPoints"].empty()) {
      if (typeid(vector<boost::any>) == m["BusinessAccessPoints"].type()) {
        vector<ListBusinessAccessPointsResponseBodyBusinessAccessPoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BusinessAccessPoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBusinessAccessPointsResponseBodyBusinessAccessPoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        businessAccessPoints = make_shared<vector<ListBusinessAccessPointsResponseBodyBusinessAccessPoints>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListBusinessAccessPointsResponseBody() = default;
};
class ListBusinessAccessPointsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBusinessAccessPointsResponseBody> body{};

  ListBusinessAccessPointsResponse() {}

  explicit ListBusinessAccessPointsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBusinessAccessPointsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBusinessAccessPointsResponseBody>(model1);
      }
    }
  }


  virtual ~ListBusinessAccessPointsResponse() = default;
};
class ListDhcpOptionsSetsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListDhcpOptionsSetsRequestTags() {}

  explicit ListDhcpOptionsSetsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDhcpOptionsSetsRequestTags() = default;
};
class ListDhcpOptionsSetsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dhcpOptionsSetId{};
  shared_ptr<string> dhcpOptionsSetName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<ListDhcpOptionsSetsRequestTags>> tags{};

  ListDhcpOptionsSetsRequest() {}

  explicit ListDhcpOptionsSetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dhcpOptionsSetId) {
      res["DhcpOptionsSetId"] = boost::any(*dhcpOptionsSetId);
    }
    if (dhcpOptionsSetName) {
      res["DhcpOptionsSetName"] = boost::any(*dhcpOptionsSetName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DhcpOptionsSetId") != m.end() && !m["DhcpOptionsSetId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DhcpOptionsSetId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DhcpOptionsSetId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dhcpOptionsSetId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DhcpOptionsSetName") != m.end() && !m["DhcpOptionsSetName"].empty()) {
      dhcpOptionsSetName = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListDhcpOptionsSetsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDhcpOptionsSetsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListDhcpOptionsSetsRequestTags>>(expect1);
      }
    }
  }


  virtual ~ListDhcpOptionsSetsRequest() = default;
};
class ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> domainNameServers{};
  shared_ptr<string> ipv6LeaseTime{};
  shared_ptr<string> leaseTime{};

  ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions() {}

  explicit ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainNameServers) {
      res["DomainNameServers"] = boost::any(*domainNameServers);
    }
    if (ipv6LeaseTime) {
      res["Ipv6LeaseTime"] = boost::any(*ipv6LeaseTime);
    }
    if (leaseTime) {
      res["LeaseTime"] = boost::any(*leaseTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainNameServers") != m.end() && !m["DomainNameServers"].empty()) {
      domainNameServers = make_shared<string>(boost::any_cast<string>(m["DomainNameServers"]));
    }
    if (m.find("Ipv6LeaseTime") != m.end() && !m["Ipv6LeaseTime"].empty()) {
      ipv6LeaseTime = make_shared<string>(boost::any_cast<string>(m["Ipv6LeaseTime"]));
    }
    if (m.find("LeaseTime") != m.end() && !m["LeaseTime"].empty()) {
      leaseTime = make_shared<string>(boost::any_cast<string>(m["LeaseTime"]));
    }
  }


  virtual ~ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions() = default;
};
class ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsTags() {}

  explicit ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsTags() = default;
};
class ListDhcpOptionsSetsResponseBodyDhcpOptionsSets : public Darabonba::Model {
public:
  shared_ptr<long> associateVpcCount{};
  shared_ptr<ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions> dhcpOptions{};
  shared_ptr<string> dhcpOptionsSetDescription{};
  shared_ptr<string> dhcpOptionsSetId{};
  shared_ptr<string> dhcpOptionsSetName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> status{};
  shared_ptr<vector<ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsTags>> tags{};

  ListDhcpOptionsSetsResponseBodyDhcpOptionsSets() {}

  explicit ListDhcpOptionsSetsResponseBodyDhcpOptionsSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associateVpcCount) {
      res["AssociateVpcCount"] = boost::any(*associateVpcCount);
    }
    if (dhcpOptions) {
      res["DhcpOptions"] = dhcpOptions ? boost::any(dhcpOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dhcpOptionsSetDescription) {
      res["DhcpOptionsSetDescription"] = boost::any(*dhcpOptionsSetDescription);
    }
    if (dhcpOptionsSetId) {
      res["DhcpOptionsSetId"] = boost::any(*dhcpOptionsSetId);
    }
    if (dhcpOptionsSetName) {
      res["DhcpOptionsSetName"] = boost::any(*dhcpOptionsSetName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociateVpcCount") != m.end() && !m["AssociateVpcCount"].empty()) {
      associateVpcCount = make_shared<long>(boost::any_cast<long>(m["AssociateVpcCount"]));
    }
    if (m.find("DhcpOptions") != m.end() && !m["DhcpOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["DhcpOptions"].type()) {
        ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DhcpOptions"]));
        dhcpOptions = make_shared<ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsDhcpOptions>(model1);
      }
    }
    if (m.find("DhcpOptionsSetDescription") != m.end() && !m["DhcpOptionsSetDescription"].empty()) {
      dhcpOptionsSetDescription = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetDescription"]));
    }
    if (m.find("DhcpOptionsSetId") != m.end() && !m["DhcpOptionsSetId"].empty()) {
      dhcpOptionsSetId = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetId"]));
    }
    if (m.find("DhcpOptionsSetName") != m.end() && !m["DhcpOptionsSetName"].empty()) {
      dhcpOptionsSetName = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListDhcpOptionsSetsResponseBodyDhcpOptionsSetsTags>>(expect1);
      }
    }
  }


  virtual ~ListDhcpOptionsSetsResponseBodyDhcpOptionsSets() = default;
};
class ListDhcpOptionsSetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDhcpOptionsSetsResponseBodyDhcpOptionsSets>> dhcpOptionsSets{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};

  ListDhcpOptionsSetsResponseBody() {}

  explicit ListDhcpOptionsSetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dhcpOptionsSets) {
      vector<boost::any> temp1;
      for(auto item1:*dhcpOptionsSets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DhcpOptionsSets"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DhcpOptionsSets") != m.end() && !m["DhcpOptionsSets"].empty()) {
      if (typeid(vector<boost::any>) == m["DhcpOptionsSets"].type()) {
        vector<ListDhcpOptionsSetsResponseBodyDhcpOptionsSets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DhcpOptionsSets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDhcpOptionsSetsResponseBodyDhcpOptionsSets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dhcpOptionsSets = make_shared<vector<ListDhcpOptionsSetsResponseBodyDhcpOptionsSets>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListDhcpOptionsSetsResponseBody() = default;
};
class ListDhcpOptionsSetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDhcpOptionsSetsResponseBody> body{};

  ListDhcpOptionsSetsResponse() {}

  explicit ListDhcpOptionsSetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDhcpOptionsSetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDhcpOptionsSetsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDhcpOptionsSetsResponse() = default;
};
class ListEnhanhcedNatGatewayAvailableZonesRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListEnhanhcedNatGatewayAvailableZonesRequestFilter() {}

  explicit ListEnhanhcedNatGatewayAvailableZonesRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListEnhanhcedNatGatewayAvailableZonesRequestFilter() = default;
};
class ListEnhanhcedNatGatewayAvailableZonesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<vector<ListEnhanhcedNatGatewayAvailableZonesRequestFilter>> filter{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListEnhanhcedNatGatewayAvailableZonesRequest() {}

  explicit ListEnhanhcedNatGatewayAvailableZonesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<ListEnhanhcedNatGatewayAvailableZonesRequestFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEnhanhcedNatGatewayAvailableZonesRequestFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<ListEnhanhcedNatGatewayAvailableZonesRequestFilter>>(expect1);
      }
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListEnhanhcedNatGatewayAvailableZonesRequest() = default;
};
class ListEnhanhcedNatGatewayAvailableZonesResponseBodyZones : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> zoneId{};

  ListEnhanhcedNatGatewayAvailableZonesResponseBodyZones() {}

  explicit ListEnhanhcedNatGatewayAvailableZonesResponseBodyZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ListEnhanhcedNatGatewayAvailableZonesResponseBodyZones() = default;
};
class ListEnhanhcedNatGatewayAvailableZonesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListEnhanhcedNatGatewayAvailableZonesResponseBodyZones>> zones{};

  ListEnhanhcedNatGatewayAvailableZonesResponseBody() {}

  explicit ListEnhanhcedNatGatewayAvailableZonesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (zones) {
      vector<boost::any> temp1;
      for(auto item1:*zones){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Zones"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Zones") != m.end() && !m["Zones"].empty()) {
      if (typeid(vector<boost::any>) == m["Zones"].type()) {
        vector<ListEnhanhcedNatGatewayAvailableZonesResponseBodyZones> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Zones"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEnhanhcedNatGatewayAvailableZonesResponseBodyZones model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zones = make_shared<vector<ListEnhanhcedNatGatewayAvailableZonesResponseBodyZones>>(expect1);
      }
    }
  }


  virtual ~ListEnhanhcedNatGatewayAvailableZonesResponseBody() = default;
};
class ListEnhanhcedNatGatewayAvailableZonesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEnhanhcedNatGatewayAvailableZonesResponseBody> body{};

  ListEnhanhcedNatGatewayAvailableZonesResponse() {}

  explicit ListEnhanhcedNatGatewayAvailableZonesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEnhanhcedNatGatewayAvailableZonesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEnhanhcedNatGatewayAvailableZonesResponseBody>(model1);
      }
    }
  }


  virtual ~ListEnhanhcedNatGatewayAvailableZonesResponse() = default;
};
class ListFullNatEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> fullNatEntryId{};
  shared_ptr<vector<string>> fullNatEntryNames{};
  shared_ptr<string> fullNatTableId{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> natIp{};
  shared_ptr<string> natIpPort{};
  shared_ptr<vector<string>> networkInterfaceIds{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListFullNatEntriesRequest() {}

  explicit ListFullNatEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (fullNatEntryId) {
      res["FullNatEntryId"] = boost::any(*fullNatEntryId);
    }
    if (fullNatEntryNames) {
      res["FullNatEntryNames"] = boost::any(*fullNatEntryNames);
    }
    if (fullNatTableId) {
      res["FullNatTableId"] = boost::any(*fullNatTableId);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (natIp) {
      res["NatIp"] = boost::any(*natIp);
    }
    if (natIpPort) {
      res["NatIpPort"] = boost::any(*natIpPort);
    }
    if (networkInterfaceIds) {
      res["NetworkInterfaceIds"] = boost::any(*networkInterfaceIds);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("FullNatEntryId") != m.end() && !m["FullNatEntryId"].empty()) {
      fullNatEntryId = make_shared<string>(boost::any_cast<string>(m["FullNatEntryId"]));
    }
    if (m.find("FullNatEntryNames") != m.end() && !m["FullNatEntryNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FullNatEntryNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FullNatEntryNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fullNatEntryNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FullNatTableId") != m.end() && !m["FullNatTableId"].empty()) {
      fullNatTableId = make_shared<string>(boost::any_cast<string>(m["FullNatTableId"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("NatIp") != m.end() && !m["NatIp"].empty()) {
      natIp = make_shared<string>(boost::any_cast<string>(m["NatIp"]));
    }
    if (m.find("NatIpPort") != m.end() && !m["NatIpPort"].empty()) {
      natIpPort = make_shared<string>(boost::any_cast<string>(m["NatIpPort"]));
    }
    if (m.find("NetworkInterfaceIds") != m.end() && !m["NetworkInterfaceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NetworkInterfaceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NetworkInterfaceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      networkInterfaceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListFullNatEntriesRequest() = default;
};
class ListFullNatEntriesResponseBodyFullNatEntries : public Darabonba::Model {
public:
  shared_ptr<string> accessIp{};
  shared_ptr<string> accessPort{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> fullNatEntryDescription{};
  shared_ptr<string> fullNatEntryId{};
  shared_ptr<string> fullNatEntryName{};
  shared_ptr<string> fullNatEntryStatus{};
  shared_ptr<string> fullNatTableId{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> natIp{};
  shared_ptr<string> natIpPort{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> networkInterfaceType{};

  ListFullNatEntriesResponseBodyFullNatEntries() {}

  explicit ListFullNatEntriesResponseBodyFullNatEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessIp) {
      res["AccessIp"] = boost::any(*accessIp);
    }
    if (accessPort) {
      res["AccessPort"] = boost::any(*accessPort);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (fullNatEntryDescription) {
      res["FullNatEntryDescription"] = boost::any(*fullNatEntryDescription);
    }
    if (fullNatEntryId) {
      res["FullNatEntryId"] = boost::any(*fullNatEntryId);
    }
    if (fullNatEntryName) {
      res["FullNatEntryName"] = boost::any(*fullNatEntryName);
    }
    if (fullNatEntryStatus) {
      res["FullNatEntryStatus"] = boost::any(*fullNatEntryStatus);
    }
    if (fullNatTableId) {
      res["FullNatTableId"] = boost::any(*fullNatTableId);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (natIp) {
      res["NatIp"] = boost::any(*natIp);
    }
    if (natIpPort) {
      res["NatIpPort"] = boost::any(*natIpPort);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (networkInterfaceType) {
      res["NetworkInterfaceType"] = boost::any(*networkInterfaceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessIp") != m.end() && !m["AccessIp"].empty()) {
      accessIp = make_shared<string>(boost::any_cast<string>(m["AccessIp"]));
    }
    if (m.find("AccessPort") != m.end() && !m["AccessPort"].empty()) {
      accessPort = make_shared<string>(boost::any_cast<string>(m["AccessPort"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FullNatEntryDescription") != m.end() && !m["FullNatEntryDescription"].empty()) {
      fullNatEntryDescription = make_shared<string>(boost::any_cast<string>(m["FullNatEntryDescription"]));
    }
    if (m.find("FullNatEntryId") != m.end() && !m["FullNatEntryId"].empty()) {
      fullNatEntryId = make_shared<string>(boost::any_cast<string>(m["FullNatEntryId"]));
    }
    if (m.find("FullNatEntryName") != m.end() && !m["FullNatEntryName"].empty()) {
      fullNatEntryName = make_shared<string>(boost::any_cast<string>(m["FullNatEntryName"]));
    }
    if (m.find("FullNatEntryStatus") != m.end() && !m["FullNatEntryStatus"].empty()) {
      fullNatEntryStatus = make_shared<string>(boost::any_cast<string>(m["FullNatEntryStatus"]));
    }
    if (m.find("FullNatTableId") != m.end() && !m["FullNatTableId"].empty()) {
      fullNatTableId = make_shared<string>(boost::any_cast<string>(m["FullNatTableId"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("NatIp") != m.end() && !m["NatIp"].empty()) {
      natIp = make_shared<string>(boost::any_cast<string>(m["NatIp"]));
    }
    if (m.find("NatIpPort") != m.end() && !m["NatIpPort"].empty()) {
      natIpPort = make_shared<string>(boost::any_cast<string>(m["NatIpPort"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("NetworkInterfaceType") != m.end() && !m["NetworkInterfaceType"].empty()) {
      networkInterfaceType = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceType"]));
    }
  }


  virtual ~ListFullNatEntriesResponseBodyFullNatEntries() = default;
};
class ListFullNatEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListFullNatEntriesResponseBodyFullNatEntries>> fullNatEntries{};
  shared_ptr<string> fullNatTableId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListFullNatEntriesResponseBody() {}

  explicit ListFullNatEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fullNatEntries) {
      vector<boost::any> temp1;
      for(auto item1:*fullNatEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FullNatEntries"] = boost::any(temp1);
    }
    if (fullNatTableId) {
      res["FullNatTableId"] = boost::any(*fullNatTableId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FullNatEntries") != m.end() && !m["FullNatEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["FullNatEntries"].type()) {
        vector<ListFullNatEntriesResponseBodyFullNatEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FullNatEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFullNatEntriesResponseBodyFullNatEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fullNatEntries = make_shared<vector<ListFullNatEntriesResponseBodyFullNatEntries>>(expect1);
      }
    }
    if (m.find("FullNatTableId") != m.end() && !m["FullNatTableId"].empty()) {
      fullNatTableId = make_shared<string>(boost::any_cast<string>(m["FullNatTableId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListFullNatEntriesResponseBody() = default;
};
class ListFullNatEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFullNatEntriesResponseBody> body{};

  ListFullNatEntriesResponse() {}

  explicit ListFullNatEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFullNatEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFullNatEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~ListFullNatEntriesResponse() = default;
};
class ListGatewayRouteTableEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> gatewayRouteTableId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListGatewayRouteTableEntriesRequest() {}

  explicit ListGatewayRouteTableEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (gatewayRouteTableId) {
      res["GatewayRouteTableId"] = boost::any(*gatewayRouteTableId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("GatewayRouteTableId") != m.end() && !m["GatewayRouteTableId"].empty()) {
      gatewayRouteTableId = make_shared<string>(boost::any_cast<string>(m["GatewayRouteTableId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListGatewayRouteTableEntriesRequest() = default;
};
class ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops : public Darabonba::Model {
public:
  shared_ptr<string> enabled{};
  shared_ptr<string> nextHopId{};
  shared_ptr<string> nextHopType{};
  shared_ptr<string> weight{};

  ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops() {}

  explicit ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (nextHopId) {
      res["NextHopId"] = boost::any(*nextHopId);
    }
    if (nextHopType) {
      res["NextHopType"] = boost::any(*nextHopType);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<string>(boost::any_cast<string>(m["Enabled"]));
    }
    if (m.find("NextHopId") != m.end() && !m["NextHopId"].empty()) {
      nextHopId = make_shared<string>(boost::any_cast<string>(m["NextHopId"]));
    }
    if (m.find("NextHopType") != m.end() && !m["NextHopType"].empty()) {
      nextHopType = make_shared<string>(boost::any_cast<string>(m["NextHopType"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
  }


  virtual ~ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops() = default;
};
class ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> name{};
  shared_ptr<string> nextHopId{};
  shared_ptr<string> nextHopType{};
  shared_ptr<vector<ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops>> nextHops{};
  shared_ptr<string> status{};

  ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels() {}

  explicit ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nextHopId) {
      res["NextHopId"] = boost::any(*nextHopId);
    }
    if (nextHopType) {
      res["NextHopType"] = boost::any(*nextHopType);
    }
    if (nextHops) {
      vector<boost::any> temp1;
      for(auto item1:*nextHops){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NextHops"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NextHopId") != m.end() && !m["NextHopId"].empty()) {
      nextHopId = make_shared<string>(boost::any_cast<string>(m["NextHopId"]));
    }
    if (m.find("NextHopType") != m.end() && !m["NextHopType"].empty()) {
      nextHopType = make_shared<string>(boost::any_cast<string>(m["NextHopType"]));
    }
    if (m.find("NextHops") != m.end() && !m["NextHops"].empty()) {
      if (typeid(vector<boost::any>) == m["NextHops"].type()) {
        vector<ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NextHops"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nextHops = make_shared<vector<ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModelsNextHops>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels() = default;
};
class ListGatewayRouteTableEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels>> gatewayRouteEntryModels{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};

  ListGatewayRouteTableEntriesResponseBody() {}

  explicit ListGatewayRouteTableEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayRouteEntryModels) {
      vector<boost::any> temp1;
      for(auto item1:*gatewayRouteEntryModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GatewayRouteEntryModels"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayRouteEntryModels") != m.end() && !m["GatewayRouteEntryModels"].empty()) {
      if (typeid(vector<boost::any>) == m["GatewayRouteEntryModels"].type()) {
        vector<ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GatewayRouteEntryModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        gatewayRouteEntryModels = make_shared<vector<ListGatewayRouteTableEntriesResponseBodyGatewayRouteEntryModels>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListGatewayRouteTableEntriesResponseBody() = default;
};
class ListGatewayRouteTableEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGatewayRouteTableEntriesResponseBody> body{};

  ListGatewayRouteTableEntriesResponse() {}

  explicit ListGatewayRouteTableEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGatewayRouteTableEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGatewayRouteTableEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~ListGatewayRouteTableEntriesResponse() = default;
};
class ListGeographicSubRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<string>> geographicSubRegions{};
  shared_ptr<string> requestId{};

  ListGeographicSubRegionsResponseBody() {}

  explicit ListGeographicSubRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (geographicSubRegions) {
      res["GeographicSubRegions"] = boost::any(*geographicSubRegions);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("GeographicSubRegions") != m.end() && !m["GeographicSubRegions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GeographicSubRegions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GeographicSubRegions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      geographicSubRegions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListGeographicSubRegionsResponseBody() = default;
};
class ListGeographicSubRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGeographicSubRegionsResponseBody> body{};

  ListGeographicSubRegionsResponse() {}

  explicit ListGeographicSubRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGeographicSubRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGeographicSubRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListGeographicSubRegionsResponse() = default;
};
class ListIpsecServerLogsRequest : public Darabonba::Model {
public:
  shared_ptr<long> from{};
  shared_ptr<string> ipsecServerId{};
  shared_ptr<long> minutePeriod{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> to{};

  ListIpsecServerLogsRequest() {}

  explicit ListIpsecServerLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (ipsecServerId) {
      res["IpsecServerId"] = boost::any(*ipsecServerId);
    }
    if (minutePeriod) {
      res["MinutePeriod"] = boost::any(*minutePeriod);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<long>(boost::any_cast<long>(m["From"]));
    }
    if (m.find("IpsecServerId") != m.end() && !m["IpsecServerId"].empty()) {
      ipsecServerId = make_shared<string>(boost::any_cast<string>(m["IpsecServerId"]));
    }
    if (m.find("MinutePeriod") != m.end() && !m["MinutePeriod"].empty()) {
      minutePeriod = make_shared<long>(boost::any_cast<long>(m["MinutePeriod"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<long>(boost::any_cast<long>(m["To"]));
    }
  }


  virtual ~ListIpsecServerLogsRequest() = default;
};
class ListIpsecServerLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<string>> data{};
  shared_ptr<bool> isCompleted{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};

  ListIpsecServerLogsResponseBody() {}

  explicit ListIpsecServerLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (isCompleted) {
      res["IsCompleted"] = boost::any(*isCompleted);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IsCompleted") != m.end() && !m["IsCompleted"].empty()) {
      isCompleted = make_shared<bool>(boost::any_cast<bool>(m["IsCompleted"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListIpsecServerLogsResponseBody() = default;
};
class ListIpsecServerLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIpsecServerLogsResponseBody> body{};

  ListIpsecServerLogsResponse() {}

  explicit ListIpsecServerLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIpsecServerLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIpsecServerLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListIpsecServerLogsResponse() = default;
};
class ListIpsecServersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ipsecServerId{};
  shared_ptr<string> ipsecServerName{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> vpnGatewayId{};

  ListIpsecServersRequest() {}

  explicit ListIpsecServersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipsecServerId) {
      res["IpsecServerId"] = boost::any(*ipsecServerId);
    }
    if (ipsecServerName) {
      res["IpsecServerName"] = boost::any(*ipsecServerName);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpsecServerId") != m.end() && !m["IpsecServerId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpsecServerId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpsecServerId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipsecServerId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IpsecServerName") != m.end() && !m["IpsecServerName"].empty()) {
      ipsecServerName = make_shared<string>(boost::any_cast<string>(m["IpsecServerName"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~ListIpsecServersRequest() = default;
};
class ListIpsecServersResponseBodyIpsecServersIkeConfig : public Darabonba::Model {
public:
  shared_ptr<string> ikeAuthAlg{};
  shared_ptr<string> ikeEncAlg{};
  shared_ptr<long> ikeLifetime{};
  shared_ptr<string> ikeMode{};
  shared_ptr<string> ikePfs{};
  shared_ptr<string> ikeVersion{};
  shared_ptr<string> localId{};
  shared_ptr<string> remoteId{};

  ListIpsecServersResponseBodyIpsecServersIkeConfig() {}

  explicit ListIpsecServersResponseBodyIpsecServersIkeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ikeAuthAlg) {
      res["IkeAuthAlg"] = boost::any(*ikeAuthAlg);
    }
    if (ikeEncAlg) {
      res["IkeEncAlg"] = boost::any(*ikeEncAlg);
    }
    if (ikeLifetime) {
      res["IkeLifetime"] = boost::any(*ikeLifetime);
    }
    if (ikeMode) {
      res["IkeMode"] = boost::any(*ikeMode);
    }
    if (ikePfs) {
      res["IkePfs"] = boost::any(*ikePfs);
    }
    if (ikeVersion) {
      res["IkeVersion"] = boost::any(*ikeVersion);
    }
    if (localId) {
      res["LocalId"] = boost::any(*localId);
    }
    if (remoteId) {
      res["RemoteId"] = boost::any(*remoteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IkeAuthAlg") != m.end() && !m["IkeAuthAlg"].empty()) {
      ikeAuthAlg = make_shared<string>(boost::any_cast<string>(m["IkeAuthAlg"]));
    }
    if (m.find("IkeEncAlg") != m.end() && !m["IkeEncAlg"].empty()) {
      ikeEncAlg = make_shared<string>(boost::any_cast<string>(m["IkeEncAlg"]));
    }
    if (m.find("IkeLifetime") != m.end() && !m["IkeLifetime"].empty()) {
      ikeLifetime = make_shared<long>(boost::any_cast<long>(m["IkeLifetime"]));
    }
    if (m.find("IkeMode") != m.end() && !m["IkeMode"].empty()) {
      ikeMode = make_shared<string>(boost::any_cast<string>(m["IkeMode"]));
    }
    if (m.find("IkePfs") != m.end() && !m["IkePfs"].empty()) {
      ikePfs = make_shared<string>(boost::any_cast<string>(m["IkePfs"]));
    }
    if (m.find("IkeVersion") != m.end() && !m["IkeVersion"].empty()) {
      ikeVersion = make_shared<string>(boost::any_cast<string>(m["IkeVersion"]));
    }
    if (m.find("LocalId") != m.end() && !m["LocalId"].empty()) {
      localId = make_shared<string>(boost::any_cast<string>(m["LocalId"]));
    }
    if (m.find("RemoteId") != m.end() && !m["RemoteId"].empty()) {
      remoteId = make_shared<string>(boost::any_cast<string>(m["RemoteId"]));
    }
  }


  virtual ~ListIpsecServersResponseBodyIpsecServersIkeConfig() = default;
};
class ListIpsecServersResponseBodyIpsecServersIpsecConfig : public Darabonba::Model {
public:
  shared_ptr<string> ipsecAuthAlg{};
  shared_ptr<string> ipsecEncAlg{};
  shared_ptr<long> ipsecLifetime{};
  shared_ptr<string> ipsecPfs{};

  ListIpsecServersResponseBodyIpsecServersIpsecConfig() {}

  explicit ListIpsecServersResponseBodyIpsecServersIpsecConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipsecAuthAlg) {
      res["IpsecAuthAlg"] = boost::any(*ipsecAuthAlg);
    }
    if (ipsecEncAlg) {
      res["IpsecEncAlg"] = boost::any(*ipsecEncAlg);
    }
    if (ipsecLifetime) {
      res["IpsecLifetime"] = boost::any(*ipsecLifetime);
    }
    if (ipsecPfs) {
      res["IpsecPfs"] = boost::any(*ipsecPfs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpsecAuthAlg") != m.end() && !m["IpsecAuthAlg"].empty()) {
      ipsecAuthAlg = make_shared<string>(boost::any_cast<string>(m["IpsecAuthAlg"]));
    }
    if (m.find("IpsecEncAlg") != m.end() && !m["IpsecEncAlg"].empty()) {
      ipsecEncAlg = make_shared<string>(boost::any_cast<string>(m["IpsecEncAlg"]));
    }
    if (m.find("IpsecLifetime") != m.end() && !m["IpsecLifetime"].empty()) {
      ipsecLifetime = make_shared<long>(boost::any_cast<long>(m["IpsecLifetime"]));
    }
    if (m.find("IpsecPfs") != m.end() && !m["IpsecPfs"].empty()) {
      ipsecPfs = make_shared<string>(boost::any_cast<string>(m["IpsecPfs"]));
    }
  }


  virtual ~ListIpsecServersResponseBodyIpsecServersIpsecConfig() = default;
};
class ListIpsecServersResponseBodyIpsecServers : public Darabonba::Model {
public:
  shared_ptr<string> clientIpPool{};
  shared_ptr<string> creationTime{};
  shared_ptr<bool> effectImmediately{};
  shared_ptr<string> IDaaSInstanceId{};
  shared_ptr<ListIpsecServersResponseBodyIpsecServersIkeConfig> ikeConfig{};
  shared_ptr<string> internetIp{};
  shared_ptr<ListIpsecServersResponseBodyIpsecServersIpsecConfig> ipsecConfig{};
  shared_ptr<string> ipsecServerId{};
  shared_ptr<string> ipsecServerName{};
  shared_ptr<string> localSubnet{};
  shared_ptr<long> maxConnections{};
  shared_ptr<bool> multiFactorAuthEnabled{};
  shared_ptr<long> onlineClientCount{};
  shared_ptr<string> psk{};
  shared_ptr<bool> pskEnabled{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> vpnGatewayId{};

  ListIpsecServersResponseBodyIpsecServers() {}

  explicit ListIpsecServersResponseBodyIpsecServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientIpPool) {
      res["ClientIpPool"] = boost::any(*clientIpPool);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (effectImmediately) {
      res["EffectImmediately"] = boost::any(*effectImmediately);
    }
    if (IDaaSInstanceId) {
      res["IDaaSInstanceId"] = boost::any(*IDaaSInstanceId);
    }
    if (ikeConfig) {
      res["IkeConfig"] = ikeConfig ? boost::any(ikeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (ipsecConfig) {
      res["IpsecConfig"] = ipsecConfig ? boost::any(ipsecConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipsecServerId) {
      res["IpsecServerId"] = boost::any(*ipsecServerId);
    }
    if (ipsecServerName) {
      res["IpsecServerName"] = boost::any(*ipsecServerName);
    }
    if (localSubnet) {
      res["LocalSubnet"] = boost::any(*localSubnet);
    }
    if (maxConnections) {
      res["MaxConnections"] = boost::any(*maxConnections);
    }
    if (multiFactorAuthEnabled) {
      res["MultiFactorAuthEnabled"] = boost::any(*multiFactorAuthEnabled);
    }
    if (onlineClientCount) {
      res["OnlineClientCount"] = boost::any(*onlineClientCount);
    }
    if (psk) {
      res["Psk"] = boost::any(*psk);
    }
    if (pskEnabled) {
      res["PskEnabled"] = boost::any(*pskEnabled);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientIpPool") != m.end() && !m["ClientIpPool"].empty()) {
      clientIpPool = make_shared<string>(boost::any_cast<string>(m["ClientIpPool"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("EffectImmediately") != m.end() && !m["EffectImmediately"].empty()) {
      effectImmediately = make_shared<bool>(boost::any_cast<bool>(m["EffectImmediately"]));
    }
    if (m.find("IDaaSInstanceId") != m.end() && !m["IDaaSInstanceId"].empty()) {
      IDaaSInstanceId = make_shared<string>(boost::any_cast<string>(m["IDaaSInstanceId"]));
    }
    if (m.find("IkeConfig") != m.end() && !m["IkeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IkeConfig"].type()) {
        ListIpsecServersResponseBodyIpsecServersIkeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IkeConfig"]));
        ikeConfig = make_shared<ListIpsecServersResponseBodyIpsecServersIkeConfig>(model1);
      }
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IpsecConfig") != m.end() && !m["IpsecConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IpsecConfig"].type()) {
        ListIpsecServersResponseBodyIpsecServersIpsecConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IpsecConfig"]));
        ipsecConfig = make_shared<ListIpsecServersResponseBodyIpsecServersIpsecConfig>(model1);
      }
    }
    if (m.find("IpsecServerId") != m.end() && !m["IpsecServerId"].empty()) {
      ipsecServerId = make_shared<string>(boost::any_cast<string>(m["IpsecServerId"]));
    }
    if (m.find("IpsecServerName") != m.end() && !m["IpsecServerName"].empty()) {
      ipsecServerName = make_shared<string>(boost::any_cast<string>(m["IpsecServerName"]));
    }
    if (m.find("LocalSubnet") != m.end() && !m["LocalSubnet"].empty()) {
      localSubnet = make_shared<string>(boost::any_cast<string>(m["LocalSubnet"]));
    }
    if (m.find("MaxConnections") != m.end() && !m["MaxConnections"].empty()) {
      maxConnections = make_shared<long>(boost::any_cast<long>(m["MaxConnections"]));
    }
    if (m.find("MultiFactorAuthEnabled") != m.end() && !m["MultiFactorAuthEnabled"].empty()) {
      multiFactorAuthEnabled = make_shared<bool>(boost::any_cast<bool>(m["MultiFactorAuthEnabled"]));
    }
    if (m.find("OnlineClientCount") != m.end() && !m["OnlineClientCount"].empty()) {
      onlineClientCount = make_shared<long>(boost::any_cast<long>(m["OnlineClientCount"]));
    }
    if (m.find("Psk") != m.end() && !m["Psk"].empty()) {
      psk = make_shared<string>(boost::any_cast<string>(m["Psk"]));
    }
    if (m.find("PskEnabled") != m.end() && !m["PskEnabled"].empty()) {
      pskEnabled = make_shared<bool>(boost::any_cast<bool>(m["PskEnabled"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~ListIpsecServersResponseBodyIpsecServers() = default;
};
class ListIpsecServersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListIpsecServersResponseBodyIpsecServers>> ipsecServers{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListIpsecServersResponseBody() {}

  explicit ListIpsecServersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipsecServers) {
      vector<boost::any> temp1;
      for(auto item1:*ipsecServers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpsecServers"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpsecServers") != m.end() && !m["IpsecServers"].empty()) {
      if (typeid(vector<boost::any>) == m["IpsecServers"].type()) {
        vector<ListIpsecServersResponseBodyIpsecServers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpsecServers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIpsecServersResponseBodyIpsecServers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipsecServers = make_shared<vector<ListIpsecServersResponseBodyIpsecServers>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListIpsecServersResponseBody() = default;
};
class ListIpsecServersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIpsecServersResponseBody> body{};

  ListIpsecServersResponse() {}

  explicit ListIpsecServersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIpsecServersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIpsecServersResponseBody>(model1);
      }
    }
  }


  virtual ~ListIpsecServersResponse() = default;
};
class ListIpv4GatewaysRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListIpv4GatewaysRequestTags() {}

  explicit ListIpv4GatewaysRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListIpv4GatewaysRequestTags() = default;
};
class ListIpv4GatewaysRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipv4GatewayId{};
  shared_ptr<string> ipv4GatewayName{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<ListIpv4GatewaysRequestTags>> tags{};
  shared_ptr<string> vpcId{};

  ListIpv4GatewaysRequest() {}

  explicit ListIpv4GatewaysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv4GatewayId) {
      res["Ipv4GatewayId"] = boost::any(*ipv4GatewayId);
    }
    if (ipv4GatewayName) {
      res["Ipv4GatewayName"] = boost::any(*ipv4GatewayName);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv4GatewayId") != m.end() && !m["Ipv4GatewayId"].empty()) {
      ipv4GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayId"]));
    }
    if (m.find("Ipv4GatewayName") != m.end() && !m["Ipv4GatewayName"].empty()) {
      ipv4GatewayName = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayName"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListIpv4GatewaysRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIpv4GatewaysRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListIpv4GatewaysRequestTags>>(expect1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ListIpv4GatewaysRequest() = default;
};
class ListIpv4GatewaysResponseBodyIpv4GatewayModelsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListIpv4GatewaysResponseBodyIpv4GatewayModelsTags() {}

  explicit ListIpv4GatewaysResponseBodyIpv4GatewayModelsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListIpv4GatewaysResponseBodyIpv4GatewayModelsTags() = default;
};
class ListIpv4GatewaysResponseBodyIpv4GatewayModels : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> ipv4GatewayDescription{};
  shared_ptr<string> ipv4GatewayId{};
  shared_ptr<string> ipv4GatewayName{};
  shared_ptr<string> ipv4GatewayRouteTableId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> status{};
  shared_ptr<vector<ListIpv4GatewaysResponseBodyIpv4GatewayModelsTags>> tags{};
  shared_ptr<string> vpcId{};

  ListIpv4GatewaysResponseBodyIpv4GatewayModels() {}

  explicit ListIpv4GatewaysResponseBodyIpv4GatewayModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (ipv4GatewayDescription) {
      res["Ipv4GatewayDescription"] = boost::any(*ipv4GatewayDescription);
    }
    if (ipv4GatewayId) {
      res["Ipv4GatewayId"] = boost::any(*ipv4GatewayId);
    }
    if (ipv4GatewayName) {
      res["Ipv4GatewayName"] = boost::any(*ipv4GatewayName);
    }
    if (ipv4GatewayRouteTableId) {
      res["Ipv4GatewayRouteTableId"] = boost::any(*ipv4GatewayRouteTableId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("Ipv4GatewayDescription") != m.end() && !m["Ipv4GatewayDescription"].empty()) {
      ipv4GatewayDescription = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayDescription"]));
    }
    if (m.find("Ipv4GatewayId") != m.end() && !m["Ipv4GatewayId"].empty()) {
      ipv4GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayId"]));
    }
    if (m.find("Ipv4GatewayName") != m.end() && !m["Ipv4GatewayName"].empty()) {
      ipv4GatewayName = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayName"]));
    }
    if (m.find("Ipv4GatewayRouteTableId") != m.end() && !m["Ipv4GatewayRouteTableId"].empty()) {
      ipv4GatewayRouteTableId = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayRouteTableId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListIpv4GatewaysResponseBodyIpv4GatewayModelsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIpv4GatewaysResponseBodyIpv4GatewayModelsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListIpv4GatewaysResponseBodyIpv4GatewayModelsTags>>(expect1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ListIpv4GatewaysResponseBodyIpv4GatewayModels() = default;
};
class ListIpv4GatewaysResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListIpv4GatewaysResponseBodyIpv4GatewayModels>> ipv4GatewayModels{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};

  ListIpv4GatewaysResponseBody() {}

  explicit ListIpv4GatewaysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipv4GatewayModels) {
      vector<boost::any> temp1;
      for(auto item1:*ipv4GatewayModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ipv4GatewayModels"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ipv4GatewayModels") != m.end() && !m["Ipv4GatewayModels"].empty()) {
      if (typeid(vector<boost::any>) == m["Ipv4GatewayModels"].type()) {
        vector<ListIpv4GatewaysResponseBodyIpv4GatewayModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ipv4GatewayModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIpv4GatewaysResponseBodyIpv4GatewayModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipv4GatewayModels = make_shared<vector<ListIpv4GatewaysResponseBodyIpv4GatewayModels>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListIpv4GatewaysResponseBody() = default;
};
class ListIpv4GatewaysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIpv4GatewaysResponseBody> body{};

  ListIpv4GatewaysResponse() {}

  explicit ListIpv4GatewaysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIpv4GatewaysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIpv4GatewaysResponseBody>(model1);
      }
    }
  }


  virtual ~ListIpv4GatewaysResponse() = default;
};
class ListNatIpCidrsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> maxResults{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> natIpCidr{};
  shared_ptr<vector<string>> natIpCidrName{};
  shared_ptr<string> natIpCidrStatus{};
  shared_ptr<vector<string>> natIpCidrs{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListNatIpCidrsRequest() {}

  explicit ListNatIpCidrsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (natIpCidr) {
      res["NatIpCidr"] = boost::any(*natIpCidr);
    }
    if (natIpCidrName) {
      res["NatIpCidrName"] = boost::any(*natIpCidrName);
    }
    if (natIpCidrStatus) {
      res["NatIpCidrStatus"] = boost::any(*natIpCidrStatus);
    }
    if (natIpCidrs) {
      res["NatIpCidrs"] = boost::any(*natIpCidrs);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<string>(boost::any_cast<string>(m["MaxResults"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("NatIpCidr") != m.end() && !m["NatIpCidr"].empty()) {
      natIpCidr = make_shared<string>(boost::any_cast<string>(m["NatIpCidr"]));
    }
    if (m.find("NatIpCidrName") != m.end() && !m["NatIpCidrName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NatIpCidrName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NatIpCidrName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      natIpCidrName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NatIpCidrStatus") != m.end() && !m["NatIpCidrStatus"].empty()) {
      natIpCidrStatus = make_shared<string>(boost::any_cast<string>(m["NatIpCidrStatus"]));
    }
    if (m.find("NatIpCidrs") != m.end() && !m["NatIpCidrs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NatIpCidrs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NatIpCidrs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      natIpCidrs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListNatIpCidrsRequest() = default;
};
class ListNatIpCidrsResponseBodyNatIpCidrs : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> natIpCidr{};
  shared_ptr<string> natIpCidrDescription{};
  shared_ptr<string> natIpCidrId{};
  shared_ptr<string> natIpCidrName{};
  shared_ptr<string> natIpCidrStatus{};

  ListNatIpCidrsResponseBodyNatIpCidrs() {}

  explicit ListNatIpCidrsResponseBodyNatIpCidrs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (natIpCidr) {
      res["NatIpCidr"] = boost::any(*natIpCidr);
    }
    if (natIpCidrDescription) {
      res["NatIpCidrDescription"] = boost::any(*natIpCidrDescription);
    }
    if (natIpCidrId) {
      res["NatIpCidrId"] = boost::any(*natIpCidrId);
    }
    if (natIpCidrName) {
      res["NatIpCidrName"] = boost::any(*natIpCidrName);
    }
    if (natIpCidrStatus) {
      res["NatIpCidrStatus"] = boost::any(*natIpCidrStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("NatIpCidr") != m.end() && !m["NatIpCidr"].empty()) {
      natIpCidr = make_shared<string>(boost::any_cast<string>(m["NatIpCidr"]));
    }
    if (m.find("NatIpCidrDescription") != m.end() && !m["NatIpCidrDescription"].empty()) {
      natIpCidrDescription = make_shared<string>(boost::any_cast<string>(m["NatIpCidrDescription"]));
    }
    if (m.find("NatIpCidrId") != m.end() && !m["NatIpCidrId"].empty()) {
      natIpCidrId = make_shared<string>(boost::any_cast<string>(m["NatIpCidrId"]));
    }
    if (m.find("NatIpCidrName") != m.end() && !m["NatIpCidrName"].empty()) {
      natIpCidrName = make_shared<string>(boost::any_cast<string>(m["NatIpCidrName"]));
    }
    if (m.find("NatIpCidrStatus") != m.end() && !m["NatIpCidrStatus"].empty()) {
      natIpCidrStatus = make_shared<string>(boost::any_cast<string>(m["NatIpCidrStatus"]));
    }
  }


  virtual ~ListNatIpCidrsResponseBodyNatIpCidrs() = default;
};
class ListNatIpCidrsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListNatIpCidrsResponseBodyNatIpCidrs>> natIpCidrs{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};

  ListNatIpCidrsResponseBody() {}

  explicit ListNatIpCidrsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (natIpCidrs) {
      vector<boost::any> temp1;
      for(auto item1:*natIpCidrs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NatIpCidrs"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NatIpCidrs") != m.end() && !m["NatIpCidrs"].empty()) {
      if (typeid(vector<boost::any>) == m["NatIpCidrs"].type()) {
        vector<ListNatIpCidrsResponseBodyNatIpCidrs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NatIpCidrs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNatIpCidrsResponseBodyNatIpCidrs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        natIpCidrs = make_shared<vector<ListNatIpCidrsResponseBodyNatIpCidrs>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListNatIpCidrsResponseBody() = default;
};
class ListNatIpCidrsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNatIpCidrsResponseBody> body{};

  ListNatIpCidrsResponse() {}

  explicit ListNatIpCidrsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNatIpCidrsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNatIpCidrsResponseBody>(model1);
      }
    }
  }


  virtual ~ListNatIpCidrsResponse() = default;
};
class ListNatIpsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> maxResults{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> natIpCidr{};
  shared_ptr<vector<string>> natIpIds{};
  shared_ptr<vector<string>> natIpName{};
  shared_ptr<string> natIpStatus{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListNatIpsRequest() {}

  explicit ListNatIpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (natIpCidr) {
      res["NatIpCidr"] = boost::any(*natIpCidr);
    }
    if (natIpIds) {
      res["NatIpIds"] = boost::any(*natIpIds);
    }
    if (natIpName) {
      res["NatIpName"] = boost::any(*natIpName);
    }
    if (natIpStatus) {
      res["NatIpStatus"] = boost::any(*natIpStatus);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<string>(boost::any_cast<string>(m["MaxResults"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("NatIpCidr") != m.end() && !m["NatIpCidr"].empty()) {
      natIpCidr = make_shared<string>(boost::any_cast<string>(m["NatIpCidr"]));
    }
    if (m.find("NatIpIds") != m.end() && !m["NatIpIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NatIpIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NatIpIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      natIpIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NatIpName") != m.end() && !m["NatIpName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NatIpName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NatIpName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      natIpName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NatIpStatus") != m.end() && !m["NatIpStatus"].empty()) {
      natIpStatus = make_shared<string>(boost::any_cast<string>(m["NatIpStatus"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListNatIpsRequest() = default;
};
class ListNatIpsResponseBodyNatIps : public Darabonba::Model {
public:
  shared_ptr<bool> isDefault{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> natIp{};
  shared_ptr<string> natIpCidr{};
  shared_ptr<string> natIpDescription{};
  shared_ptr<string> natIpId{};
  shared_ptr<string> natIpName{};
  shared_ptr<string> natIpStatus{};

  ListNatIpsResponseBodyNatIps() {}

  explicit ListNatIpsResponseBodyNatIps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (natIp) {
      res["NatIp"] = boost::any(*natIp);
    }
    if (natIpCidr) {
      res["NatIpCidr"] = boost::any(*natIpCidr);
    }
    if (natIpDescription) {
      res["NatIpDescription"] = boost::any(*natIpDescription);
    }
    if (natIpId) {
      res["NatIpId"] = boost::any(*natIpId);
    }
    if (natIpName) {
      res["NatIpName"] = boost::any(*natIpName);
    }
    if (natIpStatus) {
      res["NatIpStatus"] = boost::any(*natIpStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("NatIp") != m.end() && !m["NatIp"].empty()) {
      natIp = make_shared<string>(boost::any_cast<string>(m["NatIp"]));
    }
    if (m.find("NatIpCidr") != m.end() && !m["NatIpCidr"].empty()) {
      natIpCidr = make_shared<string>(boost::any_cast<string>(m["NatIpCidr"]));
    }
    if (m.find("NatIpDescription") != m.end() && !m["NatIpDescription"].empty()) {
      natIpDescription = make_shared<string>(boost::any_cast<string>(m["NatIpDescription"]));
    }
    if (m.find("NatIpId") != m.end() && !m["NatIpId"].empty()) {
      natIpId = make_shared<string>(boost::any_cast<string>(m["NatIpId"]));
    }
    if (m.find("NatIpName") != m.end() && !m["NatIpName"].empty()) {
      natIpName = make_shared<string>(boost::any_cast<string>(m["NatIpName"]));
    }
    if (m.find("NatIpStatus") != m.end() && !m["NatIpStatus"].empty()) {
      natIpStatus = make_shared<string>(boost::any_cast<string>(m["NatIpStatus"]));
    }
  }


  virtual ~ListNatIpsResponseBodyNatIps() = default;
};
class ListNatIpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListNatIpsResponseBodyNatIps>> natIps{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};

  ListNatIpsResponseBody() {}

  explicit ListNatIpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (natIps) {
      vector<boost::any> temp1;
      for(auto item1:*natIps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NatIps"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NatIps") != m.end() && !m["NatIps"].empty()) {
      if (typeid(vector<boost::any>) == m["NatIps"].type()) {
        vector<ListNatIpsResponseBodyNatIps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NatIps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNatIpsResponseBodyNatIps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        natIps = make_shared<vector<ListNatIpsResponseBodyNatIps>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListNatIpsResponseBody() = default;
};
class ListNatIpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNatIpsResponseBody> body{};

  ListNatIpsResponse() {}

  explicit ListNatIpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNatIpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNatIpsResponseBody>(model1);
      }
    }
  }


  virtual ~ListNatIpsResponse() = default;
};
class ListPrefixListsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListPrefixListsRequestTags() {}

  explicit ListPrefixListsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListPrefixListsRequestTags() = default;
};
class ListPrefixListsRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<string>> prefixListIds{};
  shared_ptr<string> prefixListName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<ListPrefixListsRequestTags>> tags{};

  ListPrefixListsRequest() {}

  explicit ListPrefixListsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prefixListIds) {
      res["PrefixListIds"] = boost::any(*prefixListIds);
    }
    if (prefixListName) {
      res["PrefixListName"] = boost::any(*prefixListName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PrefixListIds") != m.end() && !m["PrefixListIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrefixListIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrefixListIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      prefixListIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PrefixListName") != m.end() && !m["PrefixListName"].empty()) {
      prefixListName = make_shared<string>(boost::any_cast<string>(m["PrefixListName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListPrefixListsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrefixListsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListPrefixListsRequestTags>>(expect1);
      }
    }
  }


  virtual ~ListPrefixListsRequest() = default;
};
class ListPrefixListsResponseBodyPrefixListsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListPrefixListsResponseBodyPrefixListsTags() {}

  explicit ListPrefixListsResponseBodyPrefixListsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListPrefixListsResponseBodyPrefixListsTags() = default;
};
class ListPrefixListsResponseBodyPrefixLists : public Darabonba::Model {
public:
  shared_ptr<vector<string>> cidrBlocks{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> ipVersion{};
  shared_ptr<long> maxEntries{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> prefixListDescription{};
  shared_ptr<string> prefixListId{};
  shared_ptr<string> prefixListName{};
  shared_ptr<string> prefixListStatus{};
  shared_ptr<string> prefixListType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> shareType{};
  shared_ptr<string> status{};
  shared_ptr<vector<ListPrefixListsResponseBodyPrefixListsTags>> tags{};

  ListPrefixListsResponseBodyPrefixLists() {}

  explicit ListPrefixListsResponseBodyPrefixLists(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlocks) {
      res["CidrBlocks"] = boost::any(*cidrBlocks);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (maxEntries) {
      res["MaxEntries"] = boost::any(*maxEntries);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prefixListDescription) {
      res["PrefixListDescription"] = boost::any(*prefixListDescription);
    }
    if (prefixListId) {
      res["PrefixListId"] = boost::any(*prefixListId);
    }
    if (prefixListName) {
      res["PrefixListName"] = boost::any(*prefixListName);
    }
    if (prefixListStatus) {
      res["PrefixListStatus"] = boost::any(*prefixListStatus);
    }
    if (prefixListType) {
      res["PrefixListType"] = boost::any(*prefixListType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (shareType) {
      res["ShareType"] = boost::any(*shareType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlocks") != m.end() && !m["CidrBlocks"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CidrBlocks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CidrBlocks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cidrBlocks = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("MaxEntries") != m.end() && !m["MaxEntries"].empty()) {
      maxEntries = make_shared<long>(boost::any_cast<long>(m["MaxEntries"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("PrefixListDescription") != m.end() && !m["PrefixListDescription"].empty()) {
      prefixListDescription = make_shared<string>(boost::any_cast<string>(m["PrefixListDescription"]));
    }
    if (m.find("PrefixListId") != m.end() && !m["PrefixListId"].empty()) {
      prefixListId = make_shared<string>(boost::any_cast<string>(m["PrefixListId"]));
    }
    if (m.find("PrefixListName") != m.end() && !m["PrefixListName"].empty()) {
      prefixListName = make_shared<string>(boost::any_cast<string>(m["PrefixListName"]));
    }
    if (m.find("PrefixListStatus") != m.end() && !m["PrefixListStatus"].empty()) {
      prefixListStatus = make_shared<string>(boost::any_cast<string>(m["PrefixListStatus"]));
    }
    if (m.find("PrefixListType") != m.end() && !m["PrefixListType"].empty()) {
      prefixListType = make_shared<string>(boost::any_cast<string>(m["PrefixListType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ShareType") != m.end() && !m["ShareType"].empty()) {
      shareType = make_shared<string>(boost::any_cast<string>(m["ShareType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListPrefixListsResponseBodyPrefixListsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrefixListsResponseBodyPrefixListsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListPrefixListsResponseBodyPrefixListsTags>>(expect1);
      }
    }
  }


  virtual ~ListPrefixListsResponseBodyPrefixLists() = default;
};
class ListPrefixListsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListPrefixListsResponseBodyPrefixLists>> prefixLists{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListPrefixListsResponseBody() {}

  explicit ListPrefixListsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (prefixLists) {
      vector<boost::any> temp1;
      for(auto item1:*prefixLists){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrefixLists"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PrefixLists") != m.end() && !m["PrefixLists"].empty()) {
      if (typeid(vector<boost::any>) == m["PrefixLists"].type()) {
        vector<ListPrefixListsResponseBodyPrefixLists> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrefixLists"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrefixListsResponseBodyPrefixLists model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        prefixLists = make_shared<vector<ListPrefixListsResponseBodyPrefixLists>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPrefixListsResponseBody() = default;
};
class ListPrefixListsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrefixListsResponseBody> body{};

  ListPrefixListsResponse() {}

  explicit ListPrefixListsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrefixListsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrefixListsResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrefixListsResponse() = default;
};
class ListPublicIpAddressPoolCidrBlocksRequest : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<bool> dryRun{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> publicIpAddressPoolId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListPublicIpAddressPoolCidrBlocksRequest() {}

  explicit ListPublicIpAddressPoolCidrBlocksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (publicIpAddressPoolId) {
      res["PublicIpAddressPoolId"] = boost::any(*publicIpAddressPoolId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PublicIpAddressPoolId") != m.end() && !m["PublicIpAddressPoolId"].empty()) {
      publicIpAddressPoolId = make_shared<string>(boost::any_cast<string>(m["PublicIpAddressPoolId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListPublicIpAddressPoolCidrBlocksRequest() = default;
};
class ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> publicIpAddressPoolId{};
  shared_ptr<string> status{};
  shared_ptr<long> totalIpNum{};
  shared_ptr<long> usedIpNum{};

  ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList() {}

  explicit ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (publicIpAddressPoolId) {
      res["PublicIpAddressPoolId"] = boost::any(*publicIpAddressPoolId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalIpNum) {
      res["TotalIpNum"] = boost::any(*totalIpNum);
    }
    if (usedIpNum) {
      res["UsedIpNum"] = boost::any(*usedIpNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("PublicIpAddressPoolId") != m.end() && !m["PublicIpAddressPoolId"].empty()) {
      publicIpAddressPoolId = make_shared<string>(boost::any_cast<string>(m["PublicIpAddressPoolId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalIpNum") != m.end() && !m["TotalIpNum"].empty()) {
      totalIpNum = make_shared<long>(boost::any_cast<long>(m["TotalIpNum"]));
    }
    if (m.find("UsedIpNum") != m.end() && !m["UsedIpNum"].empty()) {
      usedIpNum = make_shared<long>(boost::any_cast<long>(m["UsedIpNum"]));
    }
  }


  virtual ~ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList() = default;
};
class ListPublicIpAddressPoolCidrBlocksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList>> publicIpPoolCidrBlockList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListPublicIpAddressPoolCidrBlocksResponseBody() {}

  explicit ListPublicIpAddressPoolCidrBlocksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (publicIpPoolCidrBlockList) {
      vector<boost::any> temp1;
      for(auto item1:*publicIpPoolCidrBlockList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PublicIpPoolCidrBlockList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PublicIpPoolCidrBlockList") != m.end() && !m["PublicIpPoolCidrBlockList"].empty()) {
      if (typeid(vector<boost::any>) == m["PublicIpPoolCidrBlockList"].type()) {
        vector<ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PublicIpPoolCidrBlockList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        publicIpPoolCidrBlockList = make_shared<vector<ListPublicIpAddressPoolCidrBlocksResponseBodyPublicIpPoolCidrBlockList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPublicIpAddressPoolCidrBlocksResponseBody() = default;
};
class ListPublicIpAddressPoolCidrBlocksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPublicIpAddressPoolCidrBlocksResponseBody> body{};

  ListPublicIpAddressPoolCidrBlocksResponse() {}

  explicit ListPublicIpAddressPoolCidrBlocksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPublicIpAddressPoolCidrBlocksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPublicIpAddressPoolCidrBlocksResponseBody>(model1);
      }
    }
  }


  virtual ~ListPublicIpAddressPoolCidrBlocksResponse() = default;
};
class ListPublicIpAddressPoolsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListPublicIpAddressPoolsRequestTags() {}

  explicit ListPublicIpAddressPoolsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListPublicIpAddressPoolsRequestTags() = default;
};
class ListPublicIpAddressPoolsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<string> isp{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> name{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<string>> publicIpAddressPoolIds{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<bool> securityProtectionEnabled{};
  shared_ptr<string> status{};
  shared_ptr<vector<ListPublicIpAddressPoolsRequestTags>> tags{};

  ListPublicIpAddressPoolsRequest() {}

  explicit ListPublicIpAddressPoolsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (publicIpAddressPoolIds) {
      res["PublicIpAddressPoolIds"] = boost::any(*publicIpAddressPoolIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityProtectionEnabled) {
      res["SecurityProtectionEnabled"] = boost::any(*securityProtectionEnabled);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PublicIpAddressPoolIds") != m.end() && !m["PublicIpAddressPoolIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PublicIpAddressPoolIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PublicIpAddressPoolIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      publicIpAddressPoolIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityProtectionEnabled") != m.end() && !m["SecurityProtectionEnabled"].empty()) {
      securityProtectionEnabled = make_shared<bool>(boost::any_cast<bool>(m["SecurityProtectionEnabled"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListPublicIpAddressPoolsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPublicIpAddressPoolsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListPublicIpAddressPoolsRequestTags>>(expect1);
      }
    }
  }


  virtual ~ListPublicIpAddressPoolsRequest() = default;
};
class ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolListTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolListTags() {}

  explicit ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolListTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolListTags() = default;
};
class ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> ipAddressRemaining{};
  shared_ptr<string> isp{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> publicIpAddressPoolId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<string>> securityProtectionTypes{};
  shared_ptr<string> shareType{};
  shared_ptr<string> status{};
  shared_ptr<vector<ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolListTags>> tags{};
  shared_ptr<long> totalIpNum{};
  shared_ptr<long> usedIpNum{};
  shared_ptr<bool> userType{};
  shared_ptr<vector<string>> zones{};

  ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList() {}

  explicit ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipAddressRemaining) {
      res["IpAddressRemaining"] = boost::any(*ipAddressRemaining);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (publicIpAddressPoolId) {
      res["PublicIpAddressPoolId"] = boost::any(*publicIpAddressPoolId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityProtectionTypes) {
      res["SecurityProtectionTypes"] = boost::any(*securityProtectionTypes);
    }
    if (shareType) {
      res["ShareType"] = boost::any(*shareType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (totalIpNum) {
      res["TotalIpNum"] = boost::any(*totalIpNum);
    }
    if (usedIpNum) {
      res["UsedIpNum"] = boost::any(*usedIpNum);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    if (zones) {
      res["Zones"] = boost::any(*zones);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpAddressRemaining") != m.end() && !m["IpAddressRemaining"].empty()) {
      ipAddressRemaining = make_shared<bool>(boost::any_cast<bool>(m["IpAddressRemaining"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PublicIpAddressPoolId") != m.end() && !m["PublicIpAddressPoolId"].empty()) {
      publicIpAddressPoolId = make_shared<string>(boost::any_cast<string>(m["PublicIpAddressPoolId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityProtectionTypes") != m.end() && !m["SecurityProtectionTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityProtectionTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityProtectionTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityProtectionTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ShareType") != m.end() && !m["ShareType"].empty()) {
      shareType = make_shared<string>(boost::any_cast<string>(m["ShareType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolListTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolListTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolListTags>>(expect1);
      }
    }
    if (m.find("TotalIpNum") != m.end() && !m["TotalIpNum"].empty()) {
      totalIpNum = make_shared<long>(boost::any_cast<long>(m["TotalIpNum"]));
    }
    if (m.find("UsedIpNum") != m.end() && !m["UsedIpNum"].empty()) {
      usedIpNum = make_shared<long>(boost::any_cast<long>(m["UsedIpNum"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<bool>(boost::any_cast<bool>(m["UserType"]));
    }
    if (m.find("Zones") != m.end() && !m["Zones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Zones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Zones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      zones = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList() = default;
};
class ListPublicIpAddressPoolsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList>> publicIpAddressPoolList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListPublicIpAddressPoolsResponseBody() {}

  explicit ListPublicIpAddressPoolsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (publicIpAddressPoolList) {
      vector<boost::any> temp1;
      for(auto item1:*publicIpAddressPoolList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PublicIpAddressPoolList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PublicIpAddressPoolList") != m.end() && !m["PublicIpAddressPoolList"].empty()) {
      if (typeid(vector<boost::any>) == m["PublicIpAddressPoolList"].type()) {
        vector<ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PublicIpAddressPoolList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        publicIpAddressPoolList = make_shared<vector<ListPublicIpAddressPoolsResponseBodyPublicIpAddressPoolList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPublicIpAddressPoolsResponseBody() = default;
};
class ListPublicIpAddressPoolsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPublicIpAddressPoolsResponseBody> body{};

  ListPublicIpAddressPoolsResponse() {}

  explicit ListPublicIpAddressPoolsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPublicIpAddressPoolsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPublicIpAddressPoolsResponseBody>(model1);
      }
    }
  }


  virtual ~ListPublicIpAddressPoolsResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResourcesTagResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResourcesTagResource() {}

  explicit ListTagResourcesResponseBodyTagResourcesTagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResourcesTagResource() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<vector<ListTagResourcesResponseBodyTagResourcesTagResource>> tagResource{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResource) {
      vector<boost::any> temp1;
      for(auto item1:*tagResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagResource") != m.end() && !m["TagResource"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResource"].type()) {
        vector<ListTagResourcesResponseBodyTagResourcesTagResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResourcesTagResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResource = make_shared<vector<ListTagResourcesResponseBodyTagResourcesTagResource>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<ListTagResourcesResponseBodyTagResources> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      res["TagResources"] = tagResources ? boost::any(tagResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagResources"].type()) {
        ListTagResourcesResponseBodyTagResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagResources"]));
        tagResources = make_shared<ListTagResourcesResponseBodyTagResources>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ListTagResourcesForExpressConnectRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesForExpressConnectRequestTag() {}

  explicit ListTagResourcesForExpressConnectRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesForExpressConnectRequestTag() = default;
};
class ListTagResourcesForExpressConnectRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ListTagResourcesForExpressConnectRequestTag>> tag{};

  ListTagResourcesForExpressConnectRequest() {}

  explicit ListTagResourcesForExpressConnectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesForExpressConnectRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesForExpressConnectRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesForExpressConnectRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesForExpressConnectRequest() = default;
};
class ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource() {}

  explicit ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource() = default;
};
class ListTagResourcesForExpressConnectResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<vector<ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource>> tagResource{};

  ListTagResourcesForExpressConnectResponseBodyTagResources() {}

  explicit ListTagResourcesForExpressConnectResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResource) {
      vector<boost::any> temp1;
      for(auto item1:*tagResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagResource") != m.end() && !m["TagResource"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResource"].type()) {
        vector<ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResource = make_shared<vector<ListTagResourcesForExpressConnectResponseBodyTagResourcesTagResource>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesForExpressConnectResponseBodyTagResources() = default;
};
class ListTagResourcesForExpressConnectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<ListTagResourcesForExpressConnectResponseBodyTagResources> tagResources{};

  ListTagResourcesForExpressConnectResponseBody() {}

  explicit ListTagResourcesForExpressConnectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      res["TagResources"] = tagResources ? boost::any(tagResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagResources"].type()) {
        ListTagResourcesForExpressConnectResponseBodyTagResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagResources"]));
        tagResources = make_shared<ListTagResourcesForExpressConnectResponseBodyTagResources>(model1);
      }
    }
  }


  virtual ~ListTagResourcesForExpressConnectResponseBody() = default;
};
class ListTagResourcesForExpressConnectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesForExpressConnectResponseBody> body{};

  ListTagResourcesForExpressConnectResponse() {}

  explicit ListTagResourcesForExpressConnectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesForExpressConnectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesForExpressConnectResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesForExpressConnectResponse() = default;
};
class ListTrafficMirrorFiltersRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTrafficMirrorFiltersRequestTags() {}

  explicit ListTrafficMirrorFiltersRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTrafficMirrorFiltersRequestTags() = default;
};
class ListTrafficMirrorFiltersRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<ListTrafficMirrorFiltersRequestTags>> tags{};
  shared_ptr<vector<string>> trafficMirrorFilterIds{};
  shared_ptr<string> trafficMirrorFilterName{};

  ListTrafficMirrorFiltersRequest() {}

  explicit ListTrafficMirrorFiltersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (trafficMirrorFilterIds) {
      res["TrafficMirrorFilterIds"] = boost::any(*trafficMirrorFilterIds);
    }
    if (trafficMirrorFilterName) {
      res["TrafficMirrorFilterName"] = boost::any(*trafficMirrorFilterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListTrafficMirrorFiltersRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTrafficMirrorFiltersRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListTrafficMirrorFiltersRequestTags>>(expect1);
      }
    }
    if (m.find("TrafficMirrorFilterIds") != m.end() && !m["TrafficMirrorFilterIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TrafficMirrorFilterIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TrafficMirrorFilterIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      trafficMirrorFilterIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TrafficMirrorFilterName") != m.end() && !m["TrafficMirrorFilterName"].empty()) {
      trafficMirrorFilterName = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterName"]));
    }
  }


  virtual ~ListTrafficMirrorFiltersRequest() = default;
};
class ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> destinationPortRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> protocol{};
  shared_ptr<string> sourceCidrBlock{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> trafficDirection{};
  shared_ptr<string> trafficMirrorFilterId{};
  shared_ptr<string> trafficMirrorFilterRuleId{};
  shared_ptr<string> trafficMirrorFilterRuleStatus{};

  ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules() {}

  explicit ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (destinationPortRange) {
      res["DestinationPortRange"] = boost::any(*destinationPortRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (sourceCidrBlock) {
      res["SourceCidrBlock"] = boost::any(*sourceCidrBlock);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (trafficDirection) {
      res["TrafficDirection"] = boost::any(*trafficDirection);
    }
    if (trafficMirrorFilterId) {
      res["TrafficMirrorFilterId"] = boost::any(*trafficMirrorFilterId);
    }
    if (trafficMirrorFilterRuleId) {
      res["TrafficMirrorFilterRuleId"] = boost::any(*trafficMirrorFilterRuleId);
    }
    if (trafficMirrorFilterRuleStatus) {
      res["TrafficMirrorFilterRuleStatus"] = boost::any(*trafficMirrorFilterRuleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("DestinationPortRange") != m.end() && !m["DestinationPortRange"].empty()) {
      destinationPortRange = make_shared<string>(boost::any_cast<string>(m["DestinationPortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SourceCidrBlock") != m.end() && !m["SourceCidrBlock"].empty()) {
      sourceCidrBlock = make_shared<string>(boost::any_cast<string>(m["SourceCidrBlock"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("TrafficDirection") != m.end() && !m["TrafficDirection"].empty()) {
      trafficDirection = make_shared<string>(boost::any_cast<string>(m["TrafficDirection"]));
    }
    if (m.find("TrafficMirrorFilterId") != m.end() && !m["TrafficMirrorFilterId"].empty()) {
      trafficMirrorFilterId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterId"]));
    }
    if (m.find("TrafficMirrorFilterRuleId") != m.end() && !m["TrafficMirrorFilterRuleId"].empty()) {
      trafficMirrorFilterRuleId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterRuleId"]));
    }
    if (m.find("TrafficMirrorFilterRuleStatus") != m.end() && !m["TrafficMirrorFilterRuleStatus"].empty()) {
      trafficMirrorFilterRuleStatus = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterRuleStatus"]));
    }
  }


  virtual ~ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules() = default;
};
class ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> destinationPortRange{};
  shared_ptr<long> priority{};
  shared_ptr<string> protocol{};
  shared_ptr<string> sourceCidrBlock{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> trafficDirection{};
  shared_ptr<string> trafficMirrorFilterId{};
  shared_ptr<string> trafficMirrorFilterRuleId{};
  shared_ptr<string> trafficMirrorFilterRuleStatus{};

  ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules() {}

  explicit ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (destinationPortRange) {
      res["DestinationPortRange"] = boost::any(*destinationPortRange);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (sourceCidrBlock) {
      res["SourceCidrBlock"] = boost::any(*sourceCidrBlock);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (trafficDirection) {
      res["TrafficDirection"] = boost::any(*trafficDirection);
    }
    if (trafficMirrorFilterId) {
      res["TrafficMirrorFilterId"] = boost::any(*trafficMirrorFilterId);
    }
    if (trafficMirrorFilterRuleId) {
      res["TrafficMirrorFilterRuleId"] = boost::any(*trafficMirrorFilterRuleId);
    }
    if (trafficMirrorFilterRuleStatus) {
      res["TrafficMirrorFilterRuleStatus"] = boost::any(*trafficMirrorFilterRuleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("DestinationPortRange") != m.end() && !m["DestinationPortRange"].empty()) {
      destinationPortRange = make_shared<string>(boost::any_cast<string>(m["DestinationPortRange"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SourceCidrBlock") != m.end() && !m["SourceCidrBlock"].empty()) {
      sourceCidrBlock = make_shared<string>(boost::any_cast<string>(m["SourceCidrBlock"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("TrafficDirection") != m.end() && !m["TrafficDirection"].empty()) {
      trafficDirection = make_shared<string>(boost::any_cast<string>(m["TrafficDirection"]));
    }
    if (m.find("TrafficMirrorFilterId") != m.end() && !m["TrafficMirrorFilterId"].empty()) {
      trafficMirrorFilterId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterId"]));
    }
    if (m.find("TrafficMirrorFilterRuleId") != m.end() && !m["TrafficMirrorFilterRuleId"].empty()) {
      trafficMirrorFilterRuleId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterRuleId"]));
    }
    if (m.find("TrafficMirrorFilterRuleStatus") != m.end() && !m["TrafficMirrorFilterRuleStatus"].empty()) {
      trafficMirrorFilterRuleStatus = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterRuleStatus"]));
    }
  }


  virtual ~ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules() = default;
};
class ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersTags() {}

  explicit ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersTags() = default;
};
class ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<vector<ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules>> egressRules{};
  shared_ptr<vector<ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules>> ingressRules{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersTags>> tags{};
  shared_ptr<string> trafficMirrorFilterDescription{};
  shared_ptr<string> trafficMirrorFilterId{};
  shared_ptr<string> trafficMirrorFilterName{};
  shared_ptr<string> trafficMirrorFilterStatus{};

  ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters() {}

  explicit ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (egressRules) {
      vector<boost::any> temp1;
      for(auto item1:*egressRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EgressRules"] = boost::any(temp1);
    }
    if (ingressRules) {
      vector<boost::any> temp1;
      for(auto item1:*ingressRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IngressRules"] = boost::any(temp1);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (trafficMirrorFilterDescription) {
      res["TrafficMirrorFilterDescription"] = boost::any(*trafficMirrorFilterDescription);
    }
    if (trafficMirrorFilterId) {
      res["TrafficMirrorFilterId"] = boost::any(*trafficMirrorFilterId);
    }
    if (trafficMirrorFilterName) {
      res["TrafficMirrorFilterName"] = boost::any(*trafficMirrorFilterName);
    }
    if (trafficMirrorFilterStatus) {
      res["TrafficMirrorFilterStatus"] = boost::any(*trafficMirrorFilterStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("EgressRules") != m.end() && !m["EgressRules"].empty()) {
      if (typeid(vector<boost::any>) == m["EgressRules"].type()) {
        vector<ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EgressRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        egressRules = make_shared<vector<ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersEgressRules>>(expect1);
      }
    }
    if (m.find("IngressRules") != m.end() && !m["IngressRules"].empty()) {
      if (typeid(vector<boost::any>) == m["IngressRules"].type()) {
        vector<ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IngressRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ingressRules = make_shared<vector<ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersIngressRules>>(expect1);
      }
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListTrafficMirrorFiltersResponseBodyTrafficMirrorFiltersTags>>(expect1);
      }
    }
    if (m.find("TrafficMirrorFilterDescription") != m.end() && !m["TrafficMirrorFilterDescription"].empty()) {
      trafficMirrorFilterDescription = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterDescription"]));
    }
    if (m.find("TrafficMirrorFilterId") != m.end() && !m["TrafficMirrorFilterId"].empty()) {
      trafficMirrorFilterId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterId"]));
    }
    if (m.find("TrafficMirrorFilterName") != m.end() && !m["TrafficMirrorFilterName"].empty()) {
      trafficMirrorFilterName = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterName"]));
    }
    if (m.find("TrafficMirrorFilterStatus") != m.end() && !m["TrafficMirrorFilterStatus"].empty()) {
      trafficMirrorFilterStatus = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterStatus"]));
    }
  }


  virtual ~ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters() = default;
};
class ListTrafficMirrorFiltersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};
  shared_ptr<vector<ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters>> trafficMirrorFilters{};

  ListTrafficMirrorFiltersResponseBody() {}

  explicit ListTrafficMirrorFiltersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (trafficMirrorFilters) {
      vector<boost::any> temp1;
      for(auto item1:*trafficMirrorFilters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TrafficMirrorFilters"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
    if (m.find("TrafficMirrorFilters") != m.end() && !m["TrafficMirrorFilters"].empty()) {
      if (typeid(vector<boost::any>) == m["TrafficMirrorFilters"].type()) {
        vector<ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TrafficMirrorFilters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trafficMirrorFilters = make_shared<vector<ListTrafficMirrorFiltersResponseBodyTrafficMirrorFilters>>(expect1);
      }
    }
  }


  virtual ~ListTrafficMirrorFiltersResponseBody() = default;
};
class ListTrafficMirrorFiltersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTrafficMirrorFiltersResponseBody> body{};

  ListTrafficMirrorFiltersResponse() {}

  explicit ListTrafficMirrorFiltersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTrafficMirrorFiltersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTrafficMirrorFiltersResponseBody>(model1);
      }
    }
  }


  virtual ~ListTrafficMirrorFiltersResponse() = default;
};
class ListTrafficMirrorSessionsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTrafficMirrorSessionsRequestTags() {}

  explicit ListTrafficMirrorSessionsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTrafficMirrorSessionsRequestTags() = default;
};
class ListTrafficMirrorSessionsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> priority{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<ListTrafficMirrorSessionsRequestTags>> tags{};
  shared_ptr<string> trafficMirrorFilterId{};
  shared_ptr<vector<string>> trafficMirrorSessionIds{};
  shared_ptr<string> trafficMirrorSessionName{};
  shared_ptr<string> trafficMirrorSourceId{};
  shared_ptr<string> trafficMirrorTargetId{};
  shared_ptr<long> virtualNetworkId{};

  ListTrafficMirrorSessionsRequest() {}

  explicit ListTrafficMirrorSessionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (trafficMirrorFilterId) {
      res["TrafficMirrorFilterId"] = boost::any(*trafficMirrorFilterId);
    }
    if (trafficMirrorSessionIds) {
      res["TrafficMirrorSessionIds"] = boost::any(*trafficMirrorSessionIds);
    }
    if (trafficMirrorSessionName) {
      res["TrafficMirrorSessionName"] = boost::any(*trafficMirrorSessionName);
    }
    if (trafficMirrorSourceId) {
      res["TrafficMirrorSourceId"] = boost::any(*trafficMirrorSourceId);
    }
    if (trafficMirrorTargetId) {
      res["TrafficMirrorTargetId"] = boost::any(*trafficMirrorTargetId);
    }
    if (virtualNetworkId) {
      res["VirtualNetworkId"] = boost::any(*virtualNetworkId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListTrafficMirrorSessionsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTrafficMirrorSessionsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListTrafficMirrorSessionsRequestTags>>(expect1);
      }
    }
    if (m.find("TrafficMirrorFilterId") != m.end() && !m["TrafficMirrorFilterId"].empty()) {
      trafficMirrorFilterId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterId"]));
    }
    if (m.find("TrafficMirrorSessionIds") != m.end() && !m["TrafficMirrorSessionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TrafficMirrorSessionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TrafficMirrorSessionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      trafficMirrorSessionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TrafficMirrorSessionName") != m.end() && !m["TrafficMirrorSessionName"].empty()) {
      trafficMirrorSessionName = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorSessionName"]));
    }
    if (m.find("TrafficMirrorSourceId") != m.end() && !m["TrafficMirrorSourceId"].empty()) {
      trafficMirrorSourceId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorSourceId"]));
    }
    if (m.find("TrafficMirrorTargetId") != m.end() && !m["TrafficMirrorTargetId"].empty()) {
      trafficMirrorTargetId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorTargetId"]));
    }
    if (m.find("VirtualNetworkId") != m.end() && !m["VirtualNetworkId"].empty()) {
      virtualNetworkId = make_shared<long>(boost::any_cast<long>(m["VirtualNetworkId"]));
    }
  }


  virtual ~ListTrafficMirrorSessionsRequest() = default;
};
class ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessionsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessionsTags() {}

  explicit ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessionsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessionsTags() = default;
};
class ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<bool> enabled{};
  shared_ptr<long> packetLength{};
  shared_ptr<long> priority{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessionsTags>> tags{};
  shared_ptr<string> trafficMirrorFilterId{};
  shared_ptr<string> trafficMirrorSessionBusinessStatus{};
  shared_ptr<string> trafficMirrorSessionDescription{};
  shared_ptr<string> trafficMirrorSessionId{};
  shared_ptr<string> trafficMirrorSessionName{};
  shared_ptr<string> trafficMirrorSessionStatus{};
  shared_ptr<vector<string>> trafficMirrorSourceIds{};
  shared_ptr<string> trafficMirrorTargetId{};
  shared_ptr<string> trafficMirrorTargetType{};
  shared_ptr<long> virtualNetworkId{};

  ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions() {}

  explicit ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (packetLength) {
      res["PacketLength"] = boost::any(*packetLength);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (trafficMirrorFilterId) {
      res["TrafficMirrorFilterId"] = boost::any(*trafficMirrorFilterId);
    }
    if (trafficMirrorSessionBusinessStatus) {
      res["TrafficMirrorSessionBusinessStatus"] = boost::any(*trafficMirrorSessionBusinessStatus);
    }
    if (trafficMirrorSessionDescription) {
      res["TrafficMirrorSessionDescription"] = boost::any(*trafficMirrorSessionDescription);
    }
    if (trafficMirrorSessionId) {
      res["TrafficMirrorSessionId"] = boost::any(*trafficMirrorSessionId);
    }
    if (trafficMirrorSessionName) {
      res["TrafficMirrorSessionName"] = boost::any(*trafficMirrorSessionName);
    }
    if (trafficMirrorSessionStatus) {
      res["TrafficMirrorSessionStatus"] = boost::any(*trafficMirrorSessionStatus);
    }
    if (trafficMirrorSourceIds) {
      res["TrafficMirrorSourceIds"] = boost::any(*trafficMirrorSourceIds);
    }
    if (trafficMirrorTargetId) {
      res["TrafficMirrorTargetId"] = boost::any(*trafficMirrorTargetId);
    }
    if (trafficMirrorTargetType) {
      res["TrafficMirrorTargetType"] = boost::any(*trafficMirrorTargetType);
    }
    if (virtualNetworkId) {
      res["VirtualNetworkId"] = boost::any(*virtualNetworkId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("PacketLength") != m.end() && !m["PacketLength"].empty()) {
      packetLength = make_shared<long>(boost::any_cast<long>(m["PacketLength"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessionsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessionsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessionsTags>>(expect1);
      }
    }
    if (m.find("TrafficMirrorFilterId") != m.end() && !m["TrafficMirrorFilterId"].empty()) {
      trafficMirrorFilterId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterId"]));
    }
    if (m.find("TrafficMirrorSessionBusinessStatus") != m.end() && !m["TrafficMirrorSessionBusinessStatus"].empty()) {
      trafficMirrorSessionBusinessStatus = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorSessionBusinessStatus"]));
    }
    if (m.find("TrafficMirrorSessionDescription") != m.end() && !m["TrafficMirrorSessionDescription"].empty()) {
      trafficMirrorSessionDescription = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorSessionDescription"]));
    }
    if (m.find("TrafficMirrorSessionId") != m.end() && !m["TrafficMirrorSessionId"].empty()) {
      trafficMirrorSessionId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorSessionId"]));
    }
    if (m.find("TrafficMirrorSessionName") != m.end() && !m["TrafficMirrorSessionName"].empty()) {
      trafficMirrorSessionName = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorSessionName"]));
    }
    if (m.find("TrafficMirrorSessionStatus") != m.end() && !m["TrafficMirrorSessionStatus"].empty()) {
      trafficMirrorSessionStatus = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorSessionStatus"]));
    }
    if (m.find("TrafficMirrorSourceIds") != m.end() && !m["TrafficMirrorSourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TrafficMirrorSourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TrafficMirrorSourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      trafficMirrorSourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TrafficMirrorTargetId") != m.end() && !m["TrafficMirrorTargetId"].empty()) {
      trafficMirrorTargetId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorTargetId"]));
    }
    if (m.find("TrafficMirrorTargetType") != m.end() && !m["TrafficMirrorTargetType"].empty()) {
      trafficMirrorTargetType = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorTargetType"]));
    }
    if (m.find("VirtualNetworkId") != m.end() && !m["VirtualNetworkId"].empty()) {
      virtualNetworkId = make_shared<long>(boost::any_cast<long>(m["VirtualNetworkId"]));
    }
  }


  virtual ~ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions() = default;
};
class ListTrafficMirrorSessionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};
  shared_ptr<vector<ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions>> trafficMirrorSessions{};

  ListTrafficMirrorSessionsResponseBody() {}

  explicit ListTrafficMirrorSessionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (trafficMirrorSessions) {
      vector<boost::any> temp1;
      for(auto item1:*trafficMirrorSessions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TrafficMirrorSessions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
    if (m.find("TrafficMirrorSessions") != m.end() && !m["TrafficMirrorSessions"].empty()) {
      if (typeid(vector<boost::any>) == m["TrafficMirrorSessions"].type()) {
        vector<ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TrafficMirrorSessions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trafficMirrorSessions = make_shared<vector<ListTrafficMirrorSessionsResponseBodyTrafficMirrorSessions>>(expect1);
      }
    }
  }


  virtual ~ListTrafficMirrorSessionsResponseBody() = default;
};
class ListTrafficMirrorSessionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTrafficMirrorSessionsResponseBody> body{};

  ListTrafficMirrorSessionsResponse() {}

  explicit ListTrafficMirrorSessionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTrafficMirrorSessionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTrafficMirrorSessionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListTrafficMirrorSessionsResponse() = default;
};
class ListVSwitchCidrReservationsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListVSwitchCidrReservationsRequestTags() {}

  explicit ListVSwitchCidrReservationsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListVSwitchCidrReservationsRequestTags() = default;
};
class ListVSwitchCidrReservationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipVersion{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<ListVSwitchCidrReservationsRequestTags>> tags{};
  shared_ptr<vector<string>> vSwitchCidrReservationIds{};
  shared_ptr<string> vSwitchCidrReservationType{};
  shared_ptr<string> vSwitchId{};

  ListVSwitchCidrReservationsRequest() {}

  explicit ListVSwitchCidrReservationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (vSwitchCidrReservationIds) {
      res["VSwitchCidrReservationIds"] = boost::any(*vSwitchCidrReservationIds);
    }
    if (vSwitchCidrReservationType) {
      res["VSwitchCidrReservationType"] = boost::any(*vSwitchCidrReservationType);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListVSwitchCidrReservationsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVSwitchCidrReservationsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListVSwitchCidrReservationsRequestTags>>(expect1);
      }
    }
    if (m.find("VSwitchCidrReservationIds") != m.end() && !m["VSwitchCidrReservationIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchCidrReservationIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchCidrReservationIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchCidrReservationIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VSwitchCidrReservationType") != m.end() && !m["VSwitchCidrReservationType"].empty()) {
      vSwitchCidrReservationType = make_shared<string>(boost::any_cast<string>(m["VSwitchCidrReservationType"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~ListVSwitchCidrReservationsRequest() = default;
};
class ListVSwitchCidrReservationsResponseBodyVSwitchCidrReservationsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListVSwitchCidrReservationsResponseBodyVSwitchCidrReservationsTags() {}

  explicit ListVSwitchCidrReservationsResponseBodyVSwitchCidrReservationsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListVSwitchCidrReservationsResponseBodyVSwitchCidrReservationsTags() = default;
};
class ListVSwitchCidrReservationsResponseBodyVSwitchCidrReservations : public Darabonba::Model {
public:
  shared_ptr<long> assignedCidrCount{};
  shared_ptr<long> availableCidrCount{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> status{};
  shared_ptr<vector<ListVSwitchCidrReservationsResponseBodyVSwitchCidrReservationsTags>> tags{};
  shared_ptr<string> type{};
  shared_ptr<string> vSwitchCidrReservationCidr{};
  shared_ptr<string> vSwitchCidrReservationDescription{};
  shared_ptr<string> vSwitchCidrReservationId{};
  shared_ptr<string> vSwitchCidrReservationName{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  ListVSwitchCidrReservationsResponseBodyVSwitchCidrReservations() {}

  explicit ListVSwitchCidrReservationsResponseBodyVSwitchCidrReservations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignedCidrCount) {
      res["AssignedCidrCount"] = boost::any(*assignedCidrCount);
    }
    if (availableCidrCount) {
      res["AvailableCidrCount"] = boost::any(*availableCidrCount);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (vSwitchCidrReservationCidr) {
      res["VSwitchCidrReservationCidr"] = boost::any(*vSwitchCidrReservationCidr);
    }
    if (vSwitchCidrReservationDescription) {
      res["VSwitchCidrReservationDescription"] = boost::any(*vSwitchCidrReservationDescription);
    }
    if (vSwitchCidrReservationId) {
      res["VSwitchCidrReservationId"] = boost::any(*vSwitchCidrReservationId);
    }
    if (vSwitchCidrReservationName) {
      res["VSwitchCidrReservationName"] = boost::any(*vSwitchCidrReservationName);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssignedCidrCount") != m.end() && !m["AssignedCidrCount"].empty()) {
      assignedCidrCount = make_shared<long>(boost::any_cast<long>(m["AssignedCidrCount"]));
    }
    if (m.find("AvailableCidrCount") != m.end() && !m["AvailableCidrCount"].empty()) {
      availableCidrCount = make_shared<long>(boost::any_cast<long>(m["AvailableCidrCount"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListVSwitchCidrReservationsResponseBodyVSwitchCidrReservationsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVSwitchCidrReservationsResponseBodyVSwitchCidrReservationsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListVSwitchCidrReservationsResponseBodyVSwitchCidrReservationsTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VSwitchCidrReservationCidr") != m.end() && !m["VSwitchCidrReservationCidr"].empty()) {
      vSwitchCidrReservationCidr = make_shared<string>(boost::any_cast<string>(m["VSwitchCidrReservationCidr"]));
    }
    if (m.find("VSwitchCidrReservationDescription") != m.end() && !m["VSwitchCidrReservationDescription"].empty()) {
      vSwitchCidrReservationDescription = make_shared<string>(boost::any_cast<string>(m["VSwitchCidrReservationDescription"]));
    }
    if (m.find("VSwitchCidrReservationId") != m.end() && !m["VSwitchCidrReservationId"].empty()) {
      vSwitchCidrReservationId = make_shared<string>(boost::any_cast<string>(m["VSwitchCidrReservationId"]));
    }
    if (m.find("VSwitchCidrReservationName") != m.end() && !m["VSwitchCidrReservationName"].empty()) {
      vSwitchCidrReservationName = make_shared<string>(boost::any_cast<string>(m["VSwitchCidrReservationName"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ListVSwitchCidrReservationsResponseBodyVSwitchCidrReservations() = default;
};
class ListVSwitchCidrReservationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListVSwitchCidrReservationsResponseBodyVSwitchCidrReservations>> vSwitchCidrReservations{};

  ListVSwitchCidrReservationsResponseBody() {}

  explicit ListVSwitchCidrReservationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vSwitchCidrReservations) {
      vector<boost::any> temp1;
      for(auto item1:*vSwitchCidrReservations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VSwitchCidrReservations"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VSwitchCidrReservations") != m.end() && !m["VSwitchCidrReservations"].empty()) {
      if (typeid(vector<boost::any>) == m["VSwitchCidrReservations"].type()) {
        vector<ListVSwitchCidrReservationsResponseBodyVSwitchCidrReservations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VSwitchCidrReservations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVSwitchCidrReservationsResponseBodyVSwitchCidrReservations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vSwitchCidrReservations = make_shared<vector<ListVSwitchCidrReservationsResponseBodyVSwitchCidrReservations>>(expect1);
      }
    }
  }


  virtual ~ListVSwitchCidrReservationsResponseBody() = default;
};
class ListVSwitchCidrReservationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListVSwitchCidrReservationsResponseBody> body{};

  ListVSwitchCidrReservationsResponse() {}

  explicit ListVSwitchCidrReservationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVSwitchCidrReservationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVSwitchCidrReservationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListVSwitchCidrReservationsResponse() = default;
};
class ListVirtualPhysicalConnectionsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListVirtualPhysicalConnectionsRequestTags() {}

  explicit ListVirtualPhysicalConnectionsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListVirtualPhysicalConnectionsRequestTags() = default;
};
class ListVirtualPhysicalConnectionsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> isConfirmed{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ListVirtualPhysicalConnectionsRequestTags>> tags{};
  shared_ptr<vector<string>> virtualPhysicalConnectionAliUids{};
  shared_ptr<string> virtualPhysicalConnectionBusinessStatus{};
  shared_ptr<vector<string>> virtualPhysicalConnectionIds{};
  shared_ptr<vector<string>> virtualPhysicalConnectionStatuses{};
  shared_ptr<vector<string>> vlanIds{};

  ListVirtualPhysicalConnectionsRequest() {}

  explicit ListVirtualPhysicalConnectionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isConfirmed) {
      res["IsConfirmed"] = boost::any(*isConfirmed);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (virtualPhysicalConnectionAliUids) {
      res["VirtualPhysicalConnectionAliUids"] = boost::any(*virtualPhysicalConnectionAliUids);
    }
    if (virtualPhysicalConnectionBusinessStatus) {
      res["VirtualPhysicalConnectionBusinessStatus"] = boost::any(*virtualPhysicalConnectionBusinessStatus);
    }
    if (virtualPhysicalConnectionIds) {
      res["VirtualPhysicalConnectionIds"] = boost::any(*virtualPhysicalConnectionIds);
    }
    if (virtualPhysicalConnectionStatuses) {
      res["VirtualPhysicalConnectionStatuses"] = boost::any(*virtualPhysicalConnectionStatuses);
    }
    if (vlanIds) {
      res["VlanIds"] = boost::any(*vlanIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsConfirmed") != m.end() && !m["IsConfirmed"].empty()) {
      isConfirmed = make_shared<bool>(boost::any_cast<bool>(m["IsConfirmed"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListVirtualPhysicalConnectionsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVirtualPhysicalConnectionsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListVirtualPhysicalConnectionsRequestTags>>(expect1);
      }
    }
    if (m.find("VirtualPhysicalConnectionAliUids") != m.end() && !m["VirtualPhysicalConnectionAliUids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VirtualPhysicalConnectionAliUids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VirtualPhysicalConnectionAliUids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      virtualPhysicalConnectionAliUids = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VirtualPhysicalConnectionBusinessStatus") != m.end() && !m["VirtualPhysicalConnectionBusinessStatus"].empty()) {
      virtualPhysicalConnectionBusinessStatus = make_shared<string>(boost::any_cast<string>(m["VirtualPhysicalConnectionBusinessStatus"]));
    }
    if (m.find("VirtualPhysicalConnectionIds") != m.end() && !m["VirtualPhysicalConnectionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VirtualPhysicalConnectionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VirtualPhysicalConnectionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      virtualPhysicalConnectionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VirtualPhysicalConnectionStatuses") != m.end() && !m["VirtualPhysicalConnectionStatuses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VirtualPhysicalConnectionStatuses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VirtualPhysicalConnectionStatuses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      virtualPhysicalConnectionStatuses = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VlanIds") != m.end() && !m["VlanIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VlanIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VlanIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vlanIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListVirtualPhysicalConnectionsRequest() = default;
};
class ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnectionsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnectionsTags() {}

  explicit ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnectionsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnectionsTags() = default;
};
class ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections : public Darabonba::Model {
public:
  shared_ptr<string> accessPointId{};
  shared_ptr<string> adLocation{};
  shared_ptr<string> aliUid{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> circuitCode{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> enabledTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> expectSpec{};
  shared_ptr<string> lineOperator{};
  shared_ptr<string> loaStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> orderMode{};
  shared_ptr<string> parentPhysicalConnectionAliUid{};
  shared_ptr<string> parentPhysicalConnectionId{};
  shared_ptr<string> peerLocation{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> portNumber{};
  shared_ptr<string> portType{};
  shared_ptr<string> productType{};
  shared_ptr<string> redundantPhysicalConnectionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> spec{};
  shared_ptr<string> status{};
  shared_ptr<vector<ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnectionsTags>> tags{};
  shared_ptr<string> type{};
  shared_ptr<string> virtualPhysicalConnectionStatus{};
  shared_ptr<string> vlanId{};

  ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections() {}

  explicit ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (adLocation) {
      res["AdLocation"] = boost::any(*adLocation);
    }
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (circuitCode) {
      res["CircuitCode"] = boost::any(*circuitCode);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabledTime) {
      res["EnabledTime"] = boost::any(*enabledTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (expectSpec) {
      res["ExpectSpec"] = boost::any(*expectSpec);
    }
    if (lineOperator) {
      res["LineOperator"] = boost::any(*lineOperator);
    }
    if (loaStatus) {
      res["LoaStatus"] = boost::any(*loaStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (orderMode) {
      res["OrderMode"] = boost::any(*orderMode);
    }
    if (parentPhysicalConnectionAliUid) {
      res["ParentPhysicalConnectionAliUid"] = boost::any(*parentPhysicalConnectionAliUid);
    }
    if (parentPhysicalConnectionId) {
      res["ParentPhysicalConnectionId"] = boost::any(*parentPhysicalConnectionId);
    }
    if (peerLocation) {
      res["PeerLocation"] = boost::any(*peerLocation);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (portNumber) {
      res["PortNumber"] = boost::any(*portNumber);
    }
    if (portType) {
      res["PortType"] = boost::any(*portType);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (redundantPhysicalConnectionId) {
      res["RedundantPhysicalConnectionId"] = boost::any(*redundantPhysicalConnectionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (virtualPhysicalConnectionStatus) {
      res["VirtualPhysicalConnectionStatus"] = boost::any(*virtualPhysicalConnectionStatus);
    }
    if (vlanId) {
      res["VlanId"] = boost::any(*vlanId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<string>(boost::any_cast<string>(m["AccessPointId"]));
    }
    if (m.find("AdLocation") != m.end() && !m["AdLocation"].empty()) {
      adLocation = make_shared<string>(boost::any_cast<string>(m["AdLocation"]));
    }
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<string>(boost::any_cast<string>(m["AliUid"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CircuitCode") != m.end() && !m["CircuitCode"].empty()) {
      circuitCode = make_shared<string>(boost::any_cast<string>(m["CircuitCode"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnabledTime") != m.end() && !m["EnabledTime"].empty()) {
      enabledTime = make_shared<string>(boost::any_cast<string>(m["EnabledTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ExpectSpec") != m.end() && !m["ExpectSpec"].empty()) {
      expectSpec = make_shared<string>(boost::any_cast<string>(m["ExpectSpec"]));
    }
    if (m.find("LineOperator") != m.end() && !m["LineOperator"].empty()) {
      lineOperator = make_shared<string>(boost::any_cast<string>(m["LineOperator"]));
    }
    if (m.find("LoaStatus") != m.end() && !m["LoaStatus"].empty()) {
      loaStatus = make_shared<string>(boost::any_cast<string>(m["LoaStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrderMode") != m.end() && !m["OrderMode"].empty()) {
      orderMode = make_shared<string>(boost::any_cast<string>(m["OrderMode"]));
    }
    if (m.find("ParentPhysicalConnectionAliUid") != m.end() && !m["ParentPhysicalConnectionAliUid"].empty()) {
      parentPhysicalConnectionAliUid = make_shared<string>(boost::any_cast<string>(m["ParentPhysicalConnectionAliUid"]));
    }
    if (m.find("ParentPhysicalConnectionId") != m.end() && !m["ParentPhysicalConnectionId"].empty()) {
      parentPhysicalConnectionId = make_shared<string>(boost::any_cast<string>(m["ParentPhysicalConnectionId"]));
    }
    if (m.find("PeerLocation") != m.end() && !m["PeerLocation"].empty()) {
      peerLocation = make_shared<string>(boost::any_cast<string>(m["PeerLocation"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("PortNumber") != m.end() && !m["PortNumber"].empty()) {
      portNumber = make_shared<string>(boost::any_cast<string>(m["PortNumber"]));
    }
    if (m.find("PortType") != m.end() && !m["PortType"].empty()) {
      portType = make_shared<string>(boost::any_cast<string>(m["PortType"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("RedundantPhysicalConnectionId") != m.end() && !m["RedundantPhysicalConnectionId"].empty()) {
      redundantPhysicalConnectionId = make_shared<string>(boost::any_cast<string>(m["RedundantPhysicalConnectionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnectionsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnectionsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnectionsTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VirtualPhysicalConnectionStatus") != m.end() && !m["VirtualPhysicalConnectionStatus"].empty()) {
      virtualPhysicalConnectionStatus = make_shared<string>(boost::any_cast<string>(m["VirtualPhysicalConnectionStatus"]));
    }
    if (m.find("VlanId") != m.end() && !m["VlanId"].empty()) {
      vlanId = make_shared<string>(boost::any_cast<string>(m["VlanId"]));
    }
  }


  virtual ~ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections() = default;
};
class ListVirtualPhysicalConnectionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections>> virtualPhysicalConnections{};

  ListVirtualPhysicalConnectionsResponseBody() {}

  explicit ListVirtualPhysicalConnectionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (virtualPhysicalConnections) {
      vector<boost::any> temp1;
      for(auto item1:*virtualPhysicalConnections){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VirtualPhysicalConnections"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VirtualPhysicalConnections") != m.end() && !m["VirtualPhysicalConnections"].empty()) {
      if (typeid(vector<boost::any>) == m["VirtualPhysicalConnections"].type()) {
        vector<ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VirtualPhysicalConnections"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        virtualPhysicalConnections = make_shared<vector<ListVirtualPhysicalConnectionsResponseBodyVirtualPhysicalConnections>>(expect1);
      }
    }
  }


  virtual ~ListVirtualPhysicalConnectionsResponseBody() = default;
};
class ListVirtualPhysicalConnectionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListVirtualPhysicalConnectionsResponseBody> body{};

  ListVirtualPhysicalConnectionsResponse() {}

  explicit ListVirtualPhysicalConnectionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVirtualPhysicalConnectionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVirtualPhysicalConnectionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListVirtualPhysicalConnectionsResponse() = default;
};
class ListVpcEndpointServicesByEndUserRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serviceName{};

  ListVpcEndpointServicesByEndUserRequest() {}

  explicit ListVpcEndpointServicesByEndUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ListVpcEndpointServicesByEndUserRequest() = default;
};
class ListVpcEndpointServicesByEndUserResponseBodyServices : public Darabonba::Model {
public:
  shared_ptr<string> defaultPolicyDocument{};
  shared_ptr<string> serviceDomain{};
  shared_ptr<string> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<bool> supportPolicy{};

  ListVpcEndpointServicesByEndUserResponseBodyServices() {}

  explicit ListVpcEndpointServicesByEndUserResponseBodyServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultPolicyDocument) {
      res["DefaultPolicyDocument"] = boost::any(*defaultPolicyDocument);
    }
    if (serviceDomain) {
      res["ServiceDomain"] = boost::any(*serviceDomain);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (supportPolicy) {
      res["SupportPolicy"] = boost::any(*supportPolicy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultPolicyDocument") != m.end() && !m["DefaultPolicyDocument"].empty()) {
      defaultPolicyDocument = make_shared<string>(boost::any_cast<string>(m["DefaultPolicyDocument"]));
    }
    if (m.find("ServiceDomain") != m.end() && !m["ServiceDomain"].empty()) {
      serviceDomain = make_shared<string>(boost::any_cast<string>(m["ServiceDomain"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["ServiceId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("SupportPolicy") != m.end() && !m["SupportPolicy"].empty()) {
      supportPolicy = make_shared<bool>(boost::any_cast<bool>(m["SupportPolicy"]));
    }
  }


  virtual ~ListVpcEndpointServicesByEndUserResponseBodyServices() = default;
};
class ListVpcEndpointServicesByEndUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListVpcEndpointServicesByEndUserResponseBodyServices>> services{};
  shared_ptr<string> totalCount{};

  ListVpcEndpointServicesByEndUserResponseBody() {}

  explicit ListVpcEndpointServicesByEndUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (services) {
      vector<boost::any> temp1;
      for(auto item1:*services){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Services"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Services") != m.end() && !m["Services"].empty()) {
      if (typeid(vector<boost::any>) == m["Services"].type()) {
        vector<ListVpcEndpointServicesByEndUserResponseBodyServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Services"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVpcEndpointServicesByEndUserResponseBodyServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        services = make_shared<vector<ListVpcEndpointServicesByEndUserResponseBodyServices>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListVpcEndpointServicesByEndUserResponseBody() = default;
};
class ListVpcEndpointServicesByEndUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListVpcEndpointServicesByEndUserResponseBody> body{};

  ListVpcEndpointServicesByEndUserResponse() {}

  explicit ListVpcEndpointServicesByEndUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVpcEndpointServicesByEndUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVpcEndpointServicesByEndUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListVpcEndpointServicesByEndUserResponse() = default;
};
class ListVpcGatewayEndpointsRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListVpcGatewayEndpointsRequestTags() {}

  explicit ListVpcGatewayEndpointsRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListVpcGatewayEndpointsRequestTags() = default;
};
class ListVpcGatewayEndpointsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endpointId{};
  shared_ptr<string> endpointName{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serviceName{};
  shared_ptr<vector<ListVpcGatewayEndpointsRequestTags>> tags{};

  ListVpcGatewayEndpointsRequest() {}

  explicit ListVpcGatewayEndpointsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListVpcGatewayEndpointsRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVpcGatewayEndpointsRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListVpcGatewayEndpointsRequestTags>>(expect1);
      }
    }
  }


  virtual ~ListVpcGatewayEndpointsRequest() = default;
};
class ListVpcGatewayEndpointsResponseBodyEndpointsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListVpcGatewayEndpointsResponseBodyEndpointsTags() {}

  explicit ListVpcGatewayEndpointsResponseBodyEndpointsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListVpcGatewayEndpointsResponseBodyEndpointsTags() = default;
};
class ListVpcGatewayEndpointsResponseBodyEndpoints : public Darabonba::Model {
public:
  shared_ptr<vector<string>> associatedRouteTables{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> endpointDescription{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> endpointStatus{};
  shared_ptr<string> policyDocument{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> serviceName{};
  shared_ptr<vector<ListVpcGatewayEndpointsResponseBodyEndpointsTags>> tags{};
  shared_ptr<string> vpcId{};

  ListVpcGatewayEndpointsResponseBodyEndpoints() {}

  explicit ListVpcGatewayEndpointsResponseBodyEndpoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associatedRouteTables) {
      res["AssociatedRouteTables"] = boost::any(*associatedRouteTables);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (endpointDescription) {
      res["EndpointDescription"] = boost::any(*endpointDescription);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (endpointStatus) {
      res["EndpointStatus"] = boost::any(*endpointStatus);
    }
    if (policyDocument) {
      res["PolicyDocument"] = boost::any(*policyDocument);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociatedRouteTables") != m.end() && !m["AssociatedRouteTables"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AssociatedRouteTables"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AssociatedRouteTables"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      associatedRouteTables = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("EndpointDescription") != m.end() && !m["EndpointDescription"].empty()) {
      endpointDescription = make_shared<string>(boost::any_cast<string>(m["EndpointDescription"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("EndpointStatus") != m.end() && !m["EndpointStatus"].empty()) {
      endpointStatus = make_shared<string>(boost::any_cast<string>(m["EndpointStatus"]));
    }
    if (m.find("PolicyDocument") != m.end() && !m["PolicyDocument"].empty()) {
      policyDocument = make_shared<string>(boost::any_cast<string>(m["PolicyDocument"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListVpcGatewayEndpointsResponseBodyEndpointsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVpcGatewayEndpointsResponseBodyEndpointsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListVpcGatewayEndpointsResponseBodyEndpointsTags>>(expect1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ListVpcGatewayEndpointsResponseBodyEndpoints() = default;
};
class ListVpcGatewayEndpointsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListVpcGatewayEndpointsResponseBodyEndpoints>> endpoints{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListVpcGatewayEndpointsResponseBody() {}

  explicit ListVpcGatewayEndpointsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpoints) {
      vector<boost::any> temp1;
      for(auto item1:*endpoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Endpoints"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Endpoints") != m.end() && !m["Endpoints"].empty()) {
      if (typeid(vector<boost::any>) == m["Endpoints"].type()) {
        vector<ListVpcGatewayEndpointsResponseBodyEndpoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Endpoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVpcGatewayEndpointsResponseBodyEndpoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpoints = make_shared<vector<ListVpcGatewayEndpointsResponseBodyEndpoints>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListVpcGatewayEndpointsResponseBody() = default;
};
class ListVpcGatewayEndpointsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListVpcGatewayEndpointsResponseBody> body{};

  ListVpcGatewayEndpointsResponse() {}

  explicit ListVpcGatewayEndpointsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVpcGatewayEndpointsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVpcGatewayEndpointsResponseBody>(model1);
      }
    }
  }


  virtual ~ListVpcGatewayEndpointsResponse() = default;
};
class ListVpnCertificateAssociationsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> certificateId{};
  shared_ptr<string> certificateType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> vpnGatewayId{};

  ListVpnCertificateAssociationsRequest() {}

  explicit ListVpnCertificateAssociationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    if (certificateType) {
      res["CertificateType"] = boost::any(*certificateType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CertificateId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CertificateId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      certificateId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CertificateType") != m.end() && !m["CertificateType"].empty()) {
      certificateType = make_shared<string>(boost::any_cast<string>(m["CertificateType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VpnGatewayId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VpnGatewayId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vpnGatewayId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListVpnCertificateAssociationsRequest() = default;
};
class ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations : public Darabonba::Model {
public:
  shared_ptr<string> associationTime{};
  shared_ptr<string> certificateId{};
  shared_ptr<string> certificateType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vpnGatewayId{};

  ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations() {}

  explicit ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associationTime) {
      res["AssociationTime"] = boost::any(*associationTime);
    }
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    if (certificateType) {
      res["CertificateType"] = boost::any(*certificateType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociationTime") != m.end() && !m["AssociationTime"].empty()) {
      associationTime = make_shared<string>(boost::any_cast<string>(m["AssociationTime"]));
    }
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
    if (m.find("CertificateType") != m.end() && !m["CertificateType"].empty()) {
      certificateType = make_shared<string>(boost::any_cast<string>(m["CertificateType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations() = default;
};
class ListVpnCertificateAssociationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations>> vpnCertificateRelations{};

  ListVpnCertificateAssociationsResponseBody() {}

  explicit ListVpnCertificateAssociationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vpnCertificateRelations) {
      vector<boost::any> temp1;
      for(auto item1:*vpnCertificateRelations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpnCertificateRelations"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VpnCertificateRelations") != m.end() && !m["VpnCertificateRelations"].empty()) {
      if (typeid(vector<boost::any>) == m["VpnCertificateRelations"].type()) {
        vector<ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpnCertificateRelations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpnCertificateRelations = make_shared<vector<ListVpnCertificateAssociationsResponseBodyVpnCertificateRelations>>(expect1);
      }
    }
  }


  virtual ~ListVpnCertificateAssociationsResponseBody() = default;
};
class ListVpnCertificateAssociationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListVpnCertificateAssociationsResponseBody> body{};

  ListVpnCertificateAssociationsResponse() {}

  explicit ListVpnCertificateAssociationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVpnCertificateAssociationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVpnCertificateAssociationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListVpnCertificateAssociationsResponse() = default;
};
class ModifyBgpGroupAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> authKey{};
  shared_ptr<string> bgpGroupId{};
  shared_ptr<bool> clearAuthKey{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<bool> isFakeAsn{};
  shared_ptr<long> localAsn{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> peerAsn{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> routeQuota{};

  ModifyBgpGroupAttributeRequest() {}

  explicit ModifyBgpGroupAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (bgpGroupId) {
      res["BgpGroupId"] = boost::any(*bgpGroupId);
    }
    if (clearAuthKey) {
      res["ClearAuthKey"] = boost::any(*clearAuthKey);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (isFakeAsn) {
      res["IsFakeAsn"] = boost::any(*isFakeAsn);
    }
    if (localAsn) {
      res["LocalAsn"] = boost::any(*localAsn);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (peerAsn) {
      res["PeerAsn"] = boost::any(*peerAsn);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeQuota) {
      res["RouteQuota"] = boost::any(*routeQuota);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("BgpGroupId") != m.end() && !m["BgpGroupId"].empty()) {
      bgpGroupId = make_shared<string>(boost::any_cast<string>(m["BgpGroupId"]));
    }
    if (m.find("ClearAuthKey") != m.end() && !m["ClearAuthKey"].empty()) {
      clearAuthKey = make_shared<bool>(boost::any_cast<bool>(m["ClearAuthKey"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IsFakeAsn") != m.end() && !m["IsFakeAsn"].empty()) {
      isFakeAsn = make_shared<bool>(boost::any_cast<bool>(m["IsFakeAsn"]));
    }
    if (m.find("LocalAsn") != m.end() && !m["LocalAsn"].empty()) {
      localAsn = make_shared<long>(boost::any_cast<long>(m["LocalAsn"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PeerAsn") != m.end() && !m["PeerAsn"].empty()) {
      peerAsn = make_shared<long>(boost::any_cast<long>(m["PeerAsn"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteQuota") != m.end() && !m["RouteQuota"].empty()) {
      routeQuota = make_shared<long>(boost::any_cast<long>(m["RouteQuota"]));
    }
  }


  virtual ~ModifyBgpGroupAttributeRequest() = default;
};
class ModifyBgpGroupAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyBgpGroupAttributeResponseBody() {}

  explicit ModifyBgpGroupAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyBgpGroupAttributeResponseBody() = default;
};
class ModifyBgpGroupAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyBgpGroupAttributeResponseBody> body{};

  ModifyBgpGroupAttributeResponse() {}

  explicit ModifyBgpGroupAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBgpGroupAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBgpGroupAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBgpGroupAttributeResponse() = default;
};
class ModifyBgpPeerAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> bfdMultiHop{};
  shared_ptr<string> bgpGroupId{};
  shared_ptr<string> bgpPeerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> enableBfd{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> peerIpAddress{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyBgpPeerAttributeRequest() {}

  explicit ModifyBgpPeerAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bfdMultiHop) {
      res["BfdMultiHop"] = boost::any(*bfdMultiHop);
    }
    if (bgpGroupId) {
      res["BgpGroupId"] = boost::any(*bgpGroupId);
    }
    if (bgpPeerId) {
      res["BgpPeerId"] = boost::any(*bgpPeerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (enableBfd) {
      res["EnableBfd"] = boost::any(*enableBfd);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (peerIpAddress) {
      res["PeerIpAddress"] = boost::any(*peerIpAddress);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BfdMultiHop") != m.end() && !m["BfdMultiHop"].empty()) {
      bfdMultiHop = make_shared<long>(boost::any_cast<long>(m["BfdMultiHop"]));
    }
    if (m.find("BgpGroupId") != m.end() && !m["BgpGroupId"].empty()) {
      bgpGroupId = make_shared<string>(boost::any_cast<string>(m["BgpGroupId"]));
    }
    if (m.find("BgpPeerId") != m.end() && !m["BgpPeerId"].empty()) {
      bgpPeerId = make_shared<string>(boost::any_cast<string>(m["BgpPeerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EnableBfd") != m.end() && !m["EnableBfd"].empty()) {
      enableBfd = make_shared<bool>(boost::any_cast<bool>(m["EnableBfd"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PeerIpAddress") != m.end() && !m["PeerIpAddress"].empty()) {
      peerIpAddress = make_shared<string>(boost::any_cast<string>(m["PeerIpAddress"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyBgpPeerAttributeRequest() = default;
};
class ModifyBgpPeerAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyBgpPeerAttributeResponseBody() {}

  explicit ModifyBgpPeerAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyBgpPeerAttributeResponseBody() = default;
};
class ModifyBgpPeerAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyBgpPeerAttributeResponseBody> body{};

  ModifyBgpPeerAttributeResponse() {}

  explicit ModifyBgpPeerAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBgpPeerAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBgpPeerAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBgpPeerAttributeResponse() = default;
};
class ModifyCommonBandwidthPackageAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyCommonBandwidthPackageAttributeRequest() {}

  explicit ModifyCommonBandwidthPackageAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyCommonBandwidthPackageAttributeRequest() = default;
};
class ModifyCommonBandwidthPackageAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyCommonBandwidthPackageAttributeResponseBody() {}

  explicit ModifyCommonBandwidthPackageAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCommonBandwidthPackageAttributeResponseBody() = default;
};
class ModifyCommonBandwidthPackageAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCommonBandwidthPackageAttributeResponseBody> body{};

  ModifyCommonBandwidthPackageAttributeResponse() {}

  explicit ModifyCommonBandwidthPackageAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCommonBandwidthPackageAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCommonBandwidthPackageAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCommonBandwidthPackageAttributeResponse() = default;
};
class ModifyCommonBandwidthPackageIpBandwidthRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidth{};
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> eipId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyCommonBandwidthPackageIpBandwidthRequest() {}

  explicit ModifyCommonBandwidthPackageIpBandwidthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (eipId) {
      res["EipId"] = boost::any(*eipId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("EipId") != m.end() && !m["EipId"].empty()) {
      eipId = make_shared<string>(boost::any_cast<string>(m["EipId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyCommonBandwidthPackageIpBandwidthRequest() = default;
};
class ModifyCommonBandwidthPackageIpBandwidthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyCommonBandwidthPackageIpBandwidthResponseBody() {}

  explicit ModifyCommonBandwidthPackageIpBandwidthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCommonBandwidthPackageIpBandwidthResponseBody() = default;
};
class ModifyCommonBandwidthPackageIpBandwidthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCommonBandwidthPackageIpBandwidthResponseBody> body{};

  ModifyCommonBandwidthPackageIpBandwidthResponse() {}

  explicit ModifyCommonBandwidthPackageIpBandwidthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCommonBandwidthPackageIpBandwidthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCommonBandwidthPackageIpBandwidthResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCommonBandwidthPackageIpBandwidthResponse() = default;
};
class ModifyCommonBandwidthPackageSpecRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidth{};
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyCommonBandwidthPackageSpecRequest() {}

  explicit ModifyCommonBandwidthPackageSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyCommonBandwidthPackageSpecRequest() = default;
};
class ModifyCommonBandwidthPackageSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyCommonBandwidthPackageSpecResponseBody() {}

  explicit ModifyCommonBandwidthPackageSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCommonBandwidthPackageSpecResponseBody() = default;
};
class ModifyCommonBandwidthPackageSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCommonBandwidthPackageSpecResponseBody> body{};

  ModifyCommonBandwidthPackageSpecResponse() {}

  explicit ModifyCommonBandwidthPackageSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCommonBandwidthPackageSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCommonBandwidthPackageSpecResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCommonBandwidthPackageSpecResponse() = default;
};
class ModifyCustomerGatewayAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> authKey{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> customerGatewayId{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyCustomerGatewayAttributeRequest() {}

  explicit ModifyCustomerGatewayAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyCustomerGatewayAttributeRequest() = default;
};
class ModifyCustomerGatewayAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> customerGatewayId{};
  shared_ptr<string> description{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};

  ModifyCustomerGatewayAttributeResponseBody() {}

  explicit ModifyCustomerGatewayAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ModifyCustomerGatewayAttributeResponseBody() = default;
};
class ModifyCustomerGatewayAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCustomerGatewayAttributeResponseBody> body{};

  ModifyCustomerGatewayAttributeResponse() {}

  explicit ModifyCustomerGatewayAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCustomerGatewayAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCustomerGatewayAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCustomerGatewayAttributeResponse() = default;
};
class ModifyEipAddressAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> bandwidth{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyEipAddressAttributeRequest() {}

  explicit ModifyEipAddressAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyEipAddressAttributeRequest() = default;
};
class ModifyEipAddressAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyEipAddressAttributeResponseBody() {}

  explicit ModifyEipAddressAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyEipAddressAttributeResponseBody() = default;
};
class ModifyEipAddressAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyEipAddressAttributeResponseBody> body{};

  ModifyEipAddressAttributeResponse() {}

  explicit ModifyEipAddressAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyEipAddressAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyEipAddressAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyEipAddressAttributeResponse() = default;
};
class ModifyExpressCloudConnectionAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> bgpAs{};
  shared_ptr<string> ceIp{};
  shared_ptr<string> description{};
  shared_ptr<string> eccId{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> peIp{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyExpressCloudConnectionAttributeRequest() {}

  explicit ModifyExpressCloudConnectionAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgpAs) {
      res["BgpAs"] = boost::any(*bgpAs);
    }
    if (ceIp) {
      res["CeIp"] = boost::any(*ceIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eccId) {
      res["EccId"] = boost::any(*eccId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (peIp) {
      res["PeIp"] = boost::any(*peIp);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgpAs") != m.end() && !m["BgpAs"].empty()) {
      bgpAs = make_shared<string>(boost::any_cast<string>(m["BgpAs"]));
    }
    if (m.find("CeIp") != m.end() && !m["CeIp"].empty()) {
      ceIp = make_shared<string>(boost::any_cast<string>(m["CeIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EccId") != m.end() && !m["EccId"].empty()) {
      eccId = make_shared<string>(boost::any_cast<string>(m["EccId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PeIp") != m.end() && !m["PeIp"].empty()) {
      peIp = make_shared<string>(boost::any_cast<string>(m["PeIp"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyExpressCloudConnectionAttributeRequest() = default;
};
class ModifyExpressCloudConnectionAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyExpressCloudConnectionAttributeResponseBody() {}

  explicit ModifyExpressCloudConnectionAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyExpressCloudConnectionAttributeResponseBody() = default;
};
class ModifyExpressCloudConnectionAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyExpressCloudConnectionAttributeResponseBody> body{};

  ModifyExpressCloudConnectionAttributeResponse() {}

  explicit ModifyExpressCloudConnectionAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyExpressCloudConnectionAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyExpressCloudConnectionAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyExpressCloudConnectionAttributeResponse() = default;
};
class ModifyExpressCloudConnectionBandwidthRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidth{};
  shared_ptr<string> eccId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyExpressCloudConnectionBandwidthRequest() {}

  explicit ModifyExpressCloudConnectionBandwidthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (eccId) {
      res["EccId"] = boost::any(*eccId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("EccId") != m.end() && !m["EccId"].empty()) {
      eccId = make_shared<string>(boost::any_cast<string>(m["EccId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyExpressCloudConnectionBandwidthRequest() = default;
};
class ModifyExpressCloudConnectionBandwidthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyExpressCloudConnectionBandwidthResponseBody() {}

  explicit ModifyExpressCloudConnectionBandwidthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyExpressCloudConnectionBandwidthResponseBody() = default;
};
class ModifyExpressCloudConnectionBandwidthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyExpressCloudConnectionBandwidthResponseBody> body{};

  ModifyExpressCloudConnectionBandwidthResponse() {}

  explicit ModifyExpressCloudConnectionBandwidthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyExpressCloudConnectionBandwidthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyExpressCloudConnectionBandwidthResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyExpressCloudConnectionBandwidthResponse() = default;
};
class ModifyExpressConnectTrafficQosRequestAddInstanceList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};

  ModifyExpressConnectTrafficQosRequestAddInstanceList() {}

  explicit ModifyExpressConnectTrafficQosRequestAddInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~ModifyExpressConnectTrafficQosRequestAddInstanceList() = default;
};
class ModifyExpressConnectTrafficQosRequestRemoveInstanceList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};

  ModifyExpressConnectTrafficQosRequestRemoveInstanceList() {}

  explicit ModifyExpressConnectTrafficQosRequestRemoveInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~ModifyExpressConnectTrafficQosRequestRemoveInstanceList() = default;
};
class ModifyExpressConnectTrafficQosRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyExpressConnectTrafficQosRequestAddInstanceList>> addInstanceList{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> qosDescription{};
  shared_ptr<string> qosId{};
  shared_ptr<string> qosName{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<ModifyExpressConnectTrafficQosRequestRemoveInstanceList>> removeInstanceList{};
  shared_ptr<string> resourceOwnerAccount{};

  ModifyExpressConnectTrafficQosRequest() {}

  explicit ModifyExpressConnectTrafficQosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addInstanceList) {
      vector<boost::any> temp1;
      for(auto item1:*addInstanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddInstanceList"] = boost::any(temp1);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (qosDescription) {
      res["QosDescription"] = boost::any(*qosDescription);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (qosName) {
      res["QosName"] = boost::any(*qosName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (removeInstanceList) {
      vector<boost::any> temp1;
      for(auto item1:*removeInstanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RemoveInstanceList"] = boost::any(temp1);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddInstanceList") != m.end() && !m["AddInstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["AddInstanceList"].type()) {
        vector<ModifyExpressConnectTrafficQosRequestAddInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddInstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyExpressConnectTrafficQosRequestAddInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addInstanceList = make_shared<vector<ModifyExpressConnectTrafficQosRequestAddInstanceList>>(expect1);
      }
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QosDescription") != m.end() && !m["QosDescription"].empty()) {
      qosDescription = make_shared<string>(boost::any_cast<string>(m["QosDescription"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QosName") != m.end() && !m["QosName"].empty()) {
      qosName = make_shared<string>(boost::any_cast<string>(m["QosName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemoveInstanceList") != m.end() && !m["RemoveInstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["RemoveInstanceList"].type()) {
        vector<ModifyExpressConnectTrafficQosRequestRemoveInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RemoveInstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyExpressConnectTrafficQosRequestRemoveInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        removeInstanceList = make_shared<vector<ModifyExpressConnectTrafficQosRequestRemoveInstanceList>>(expect1);
      }
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~ModifyExpressConnectTrafficQosRequest() = default;
};
class ModifyExpressConnectTrafficQosResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyExpressConnectTrafficQosResponseBody() {}

  explicit ModifyExpressConnectTrafficQosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyExpressConnectTrafficQosResponseBody() = default;
};
class ModifyExpressConnectTrafficQosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyExpressConnectTrafficQosResponseBody> body{};

  ModifyExpressConnectTrafficQosResponse() {}

  explicit ModifyExpressConnectTrafficQosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyExpressConnectTrafficQosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyExpressConnectTrafficQosResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyExpressConnectTrafficQosResponse() = default;
};
class ModifyExpressConnectTrafficQosQueueRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthPercent{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> qosId{};
  shared_ptr<string> queueDescription{};
  shared_ptr<string> queueId{};
  shared_ptr<string> queueName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};

  ModifyExpressConnectTrafficQosQueueRequest() {}

  explicit ModifyExpressConnectTrafficQosQueueRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPercent) {
      res["BandwidthPercent"] = boost::any(*bandwidthPercent);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (queueDescription) {
      res["QueueDescription"] = boost::any(*queueDescription);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPercent") != m.end() && !m["BandwidthPercent"].empty()) {
      bandwidthPercent = make_shared<string>(boost::any_cast<string>(m["BandwidthPercent"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QueueDescription") != m.end() && !m["QueueDescription"].empty()) {
      queueDescription = make_shared<string>(boost::any_cast<string>(m["QueueDescription"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~ModifyExpressConnectTrafficQosQueueRequest() = default;
};
class ModifyExpressConnectTrafficQosQueueResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyExpressConnectTrafficQosQueueResponseBody() {}

  explicit ModifyExpressConnectTrafficQosQueueResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyExpressConnectTrafficQosQueueResponseBody() = default;
};
class ModifyExpressConnectTrafficQosQueueResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyExpressConnectTrafficQosQueueResponseBody> body{};

  ModifyExpressConnectTrafficQosQueueResponse() {}

  explicit ModifyExpressConnectTrafficQosQueueResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyExpressConnectTrafficQosQueueResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyExpressConnectTrafficQosQueueResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyExpressConnectTrafficQosQueueResponse() = default;
};
class ModifyExpressConnectTrafficQosRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> dstCidr{};
  shared_ptr<string> dstIPv6Cidr{};
  shared_ptr<string> dstPortRange{};
  shared_ptr<long> matchDscp{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> priority{};
  shared_ptr<string> protocol{};
  shared_ptr<string> qosId{};
  shared_ptr<string> queueId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> remarkingDscp{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> ruleDescription{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> srcCidr{};
  shared_ptr<string> srcIPv6Cidr{};
  shared_ptr<string> srcPortRange{};

  ModifyExpressConnectTrafficQosRuleRequest() {}

  explicit ModifyExpressConnectTrafficQosRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dstCidr) {
      res["DstCidr"] = boost::any(*dstCidr);
    }
    if (dstIPv6Cidr) {
      res["DstIPv6Cidr"] = boost::any(*dstIPv6Cidr);
    }
    if (dstPortRange) {
      res["DstPortRange"] = boost::any(*dstPortRange);
    }
    if (matchDscp) {
      res["MatchDscp"] = boost::any(*matchDscp);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (remarkingDscp) {
      res["RemarkingDscp"] = boost::any(*remarkingDscp);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (ruleDescription) {
      res["RuleDescription"] = boost::any(*ruleDescription);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (srcCidr) {
      res["SrcCidr"] = boost::any(*srcCidr);
    }
    if (srcIPv6Cidr) {
      res["SrcIPv6Cidr"] = boost::any(*srcIPv6Cidr);
    }
    if (srcPortRange) {
      res["SrcPortRange"] = boost::any(*srcPortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DstCidr") != m.end() && !m["DstCidr"].empty()) {
      dstCidr = make_shared<string>(boost::any_cast<string>(m["DstCidr"]));
    }
    if (m.find("DstIPv6Cidr") != m.end() && !m["DstIPv6Cidr"].empty()) {
      dstIPv6Cidr = make_shared<string>(boost::any_cast<string>(m["DstIPv6Cidr"]));
    }
    if (m.find("DstPortRange") != m.end() && !m["DstPortRange"].empty()) {
      dstPortRange = make_shared<string>(boost::any_cast<string>(m["DstPortRange"]));
    }
    if (m.find("MatchDscp") != m.end() && !m["MatchDscp"].empty()) {
      matchDscp = make_shared<long>(boost::any_cast<long>(m["MatchDscp"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemarkingDscp") != m.end() && !m["RemarkingDscp"].empty()) {
      remarkingDscp = make_shared<long>(boost::any_cast<long>(m["RemarkingDscp"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("RuleDescription") != m.end() && !m["RuleDescription"].empty()) {
      ruleDescription = make_shared<string>(boost::any_cast<string>(m["RuleDescription"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SrcCidr") != m.end() && !m["SrcCidr"].empty()) {
      srcCidr = make_shared<string>(boost::any_cast<string>(m["SrcCidr"]));
    }
    if (m.find("SrcIPv6Cidr") != m.end() && !m["SrcIPv6Cidr"].empty()) {
      srcIPv6Cidr = make_shared<string>(boost::any_cast<string>(m["SrcIPv6Cidr"]));
    }
    if (m.find("SrcPortRange") != m.end() && !m["SrcPortRange"].empty()) {
      srcPortRange = make_shared<string>(boost::any_cast<string>(m["SrcPortRange"]));
    }
  }


  virtual ~ModifyExpressConnectTrafficQosRuleRequest() = default;
};
class ModifyExpressConnectTrafficQosRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyExpressConnectTrafficQosRuleResponseBody() {}

  explicit ModifyExpressConnectTrafficQosRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyExpressConnectTrafficQosRuleResponseBody() = default;
};
class ModifyExpressConnectTrafficQosRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyExpressConnectTrafficQosRuleResponseBody> body{};

  ModifyExpressConnectTrafficQosRuleResponse() {}

  explicit ModifyExpressConnectTrafficQosRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyExpressConnectTrafficQosRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyExpressConnectTrafficQosRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyExpressConnectTrafficQosRuleResponse() = default;
};
class ModifyFlowLogAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<long> aggregationInterval{};
  shared_ptr<string> description{};
  shared_ptr<string> flowLogId{};
  shared_ptr<string> flowLogName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyFlowLogAttributeRequest() {}

  explicit ModifyFlowLogAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregationInterval) {
      res["AggregationInterval"] = boost::any(*aggregationInterval);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (flowLogId) {
      res["FlowLogId"] = boost::any(*flowLogId);
    }
    if (flowLogName) {
      res["FlowLogName"] = boost::any(*flowLogName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregationInterval") != m.end() && !m["AggregationInterval"].empty()) {
      aggregationInterval = make_shared<long>(boost::any_cast<long>(m["AggregationInterval"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FlowLogId") != m.end() && !m["FlowLogId"].empty()) {
      flowLogId = make_shared<string>(boost::any_cast<string>(m["FlowLogId"]));
    }
    if (m.find("FlowLogName") != m.end() && !m["FlowLogName"].empty()) {
      flowLogName = make_shared<string>(boost::any_cast<string>(m["FlowLogName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyFlowLogAttributeRequest() = default;
};
class ModifyFlowLogAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ModifyFlowLogAttributeResponseBody() {}

  explicit ModifyFlowLogAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ModifyFlowLogAttributeResponseBody() = default;
};
class ModifyFlowLogAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyFlowLogAttributeResponseBody> body{};

  ModifyFlowLogAttributeResponse() {}

  explicit ModifyFlowLogAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyFlowLogAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyFlowLogAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyFlowLogAttributeResponse() = default;
};
class ModifyForwardEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> externalIp{};
  shared_ptr<string> externalPort{};
  shared_ptr<string> forwardEntryId{};
  shared_ptr<string> forwardEntryName{};
  shared_ptr<string> forwardTableId{};
  shared_ptr<string> internalIp{};
  shared_ptr<string> internalPort{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<bool> portBreak{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyForwardEntryRequest() {}

  explicit ModifyForwardEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (externalIp) {
      res["ExternalIp"] = boost::any(*externalIp);
    }
    if (externalPort) {
      res["ExternalPort"] = boost::any(*externalPort);
    }
    if (forwardEntryId) {
      res["ForwardEntryId"] = boost::any(*forwardEntryId);
    }
    if (forwardEntryName) {
      res["ForwardEntryName"] = boost::any(*forwardEntryName);
    }
    if (forwardTableId) {
      res["ForwardTableId"] = boost::any(*forwardTableId);
    }
    if (internalIp) {
      res["InternalIp"] = boost::any(*internalIp);
    }
    if (internalPort) {
      res["InternalPort"] = boost::any(*internalPort);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (portBreak) {
      res["PortBreak"] = boost::any(*portBreak);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ExternalIp") != m.end() && !m["ExternalIp"].empty()) {
      externalIp = make_shared<string>(boost::any_cast<string>(m["ExternalIp"]));
    }
    if (m.find("ExternalPort") != m.end() && !m["ExternalPort"].empty()) {
      externalPort = make_shared<string>(boost::any_cast<string>(m["ExternalPort"]));
    }
    if (m.find("ForwardEntryId") != m.end() && !m["ForwardEntryId"].empty()) {
      forwardEntryId = make_shared<string>(boost::any_cast<string>(m["ForwardEntryId"]));
    }
    if (m.find("ForwardEntryName") != m.end() && !m["ForwardEntryName"].empty()) {
      forwardEntryName = make_shared<string>(boost::any_cast<string>(m["ForwardEntryName"]));
    }
    if (m.find("ForwardTableId") != m.end() && !m["ForwardTableId"].empty()) {
      forwardTableId = make_shared<string>(boost::any_cast<string>(m["ForwardTableId"]));
    }
    if (m.find("InternalIp") != m.end() && !m["InternalIp"].empty()) {
      internalIp = make_shared<string>(boost::any_cast<string>(m["InternalIp"]));
    }
    if (m.find("InternalPort") != m.end() && !m["InternalPort"].empty()) {
      internalPort = make_shared<string>(boost::any_cast<string>(m["InternalPort"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PortBreak") != m.end() && !m["PortBreak"].empty()) {
      portBreak = make_shared<bool>(boost::any_cast<bool>(m["PortBreak"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyForwardEntryRequest() = default;
};
class ModifyForwardEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyForwardEntryResponseBody() {}

  explicit ModifyForwardEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyForwardEntryResponseBody() = default;
};
class ModifyForwardEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyForwardEntryResponseBody> body{};

  ModifyForwardEntryResponse() {}

  explicit ModifyForwardEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyForwardEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyForwardEntryResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyForwardEntryResponse() = default;
};
class ModifyFullNatEntryAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessIp{};
  shared_ptr<string> accessPort{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> fullNatEntryDescription{};
  shared_ptr<string> fullNatEntryId{};
  shared_ptr<string> fullNatEntryName{};
  shared_ptr<string> fullNatTableId{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> natIp{};
  shared_ptr<string> natIpPort{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyFullNatEntryAttributeRequest() {}

  explicit ModifyFullNatEntryAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessIp) {
      res["AccessIp"] = boost::any(*accessIp);
    }
    if (accessPort) {
      res["AccessPort"] = boost::any(*accessPort);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (fullNatEntryDescription) {
      res["FullNatEntryDescription"] = boost::any(*fullNatEntryDescription);
    }
    if (fullNatEntryId) {
      res["FullNatEntryId"] = boost::any(*fullNatEntryId);
    }
    if (fullNatEntryName) {
      res["FullNatEntryName"] = boost::any(*fullNatEntryName);
    }
    if (fullNatTableId) {
      res["FullNatTableId"] = boost::any(*fullNatTableId);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (natIp) {
      res["NatIp"] = boost::any(*natIp);
    }
    if (natIpPort) {
      res["NatIpPort"] = boost::any(*natIpPort);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessIp") != m.end() && !m["AccessIp"].empty()) {
      accessIp = make_shared<string>(boost::any_cast<string>(m["AccessIp"]));
    }
    if (m.find("AccessPort") != m.end() && !m["AccessPort"].empty()) {
      accessPort = make_shared<string>(boost::any_cast<string>(m["AccessPort"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("FullNatEntryDescription") != m.end() && !m["FullNatEntryDescription"].empty()) {
      fullNatEntryDescription = make_shared<string>(boost::any_cast<string>(m["FullNatEntryDescription"]));
    }
    if (m.find("FullNatEntryId") != m.end() && !m["FullNatEntryId"].empty()) {
      fullNatEntryId = make_shared<string>(boost::any_cast<string>(m["FullNatEntryId"]));
    }
    if (m.find("FullNatEntryName") != m.end() && !m["FullNatEntryName"].empty()) {
      fullNatEntryName = make_shared<string>(boost::any_cast<string>(m["FullNatEntryName"]));
    }
    if (m.find("FullNatTableId") != m.end() && !m["FullNatTableId"].empty()) {
      fullNatTableId = make_shared<string>(boost::any_cast<string>(m["FullNatTableId"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("NatIp") != m.end() && !m["NatIp"].empty()) {
      natIp = make_shared<string>(boost::any_cast<string>(m["NatIp"]));
    }
    if (m.find("NatIpPort") != m.end() && !m["NatIpPort"].empty()) {
      natIpPort = make_shared<string>(boost::any_cast<string>(m["NatIpPort"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyFullNatEntryAttributeRequest() = default;
};
class ModifyFullNatEntryAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyFullNatEntryAttributeResponseBody() {}

  explicit ModifyFullNatEntryAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyFullNatEntryAttributeResponseBody() = default;
};
class ModifyFullNatEntryAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyFullNatEntryAttributeResponseBody> body{};

  ModifyFullNatEntryAttributeResponse() {}

  explicit ModifyFullNatEntryAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyFullNatEntryAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyFullNatEntryAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyFullNatEntryAttributeResponse() = default;
};
class ModifyGlobalAccelerationInstanceAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> globalAccelerationInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyGlobalAccelerationInstanceAttributesRequest() {}

  explicit ModifyGlobalAccelerationInstanceAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (globalAccelerationInstanceId) {
      res["GlobalAccelerationInstanceId"] = boost::any(*globalAccelerationInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GlobalAccelerationInstanceId") != m.end() && !m["GlobalAccelerationInstanceId"].empty()) {
      globalAccelerationInstanceId = make_shared<string>(boost::any_cast<string>(m["GlobalAccelerationInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyGlobalAccelerationInstanceAttributesRequest() = default;
};
class ModifyGlobalAccelerationInstanceAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyGlobalAccelerationInstanceAttributesResponseBody() {}

  explicit ModifyGlobalAccelerationInstanceAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyGlobalAccelerationInstanceAttributesResponseBody() = default;
};
class ModifyGlobalAccelerationInstanceAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyGlobalAccelerationInstanceAttributesResponseBody> body{};

  ModifyGlobalAccelerationInstanceAttributesResponse() {}

  explicit ModifyGlobalAccelerationInstanceAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyGlobalAccelerationInstanceAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyGlobalAccelerationInstanceAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyGlobalAccelerationInstanceAttributesResponse() = default;
};
class ModifyGlobalAccelerationInstanceSpecRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidth{};
  shared_ptr<string> globalAccelerationInstanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyGlobalAccelerationInstanceSpecRequest() {}

  explicit ModifyGlobalAccelerationInstanceSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (globalAccelerationInstanceId) {
      res["GlobalAccelerationInstanceId"] = boost::any(*globalAccelerationInstanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("GlobalAccelerationInstanceId") != m.end() && !m["GlobalAccelerationInstanceId"].empty()) {
      globalAccelerationInstanceId = make_shared<string>(boost::any_cast<string>(m["GlobalAccelerationInstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyGlobalAccelerationInstanceSpecRequest() = default;
};
class ModifyGlobalAccelerationInstanceSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyGlobalAccelerationInstanceSpecResponseBody() {}

  explicit ModifyGlobalAccelerationInstanceSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyGlobalAccelerationInstanceSpecResponseBody() = default;
};
class ModifyGlobalAccelerationInstanceSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyGlobalAccelerationInstanceSpecResponseBody> body{};

  ModifyGlobalAccelerationInstanceSpecResponse() {}

  explicit ModifyGlobalAccelerationInstanceSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyGlobalAccelerationInstanceSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyGlobalAccelerationInstanceSpecResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyGlobalAccelerationInstanceSpecResponse() = default;
};
class ModifyHaVipAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> haVipId{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyHaVipAttributeRequest() {}

  explicit ModifyHaVipAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (haVipId) {
      res["HaVipId"] = boost::any(*haVipId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HaVipId") != m.end() && !m["HaVipId"].empty()) {
      haVipId = make_shared<string>(boost::any_cast<string>(m["HaVipId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyHaVipAttributeRequest() = default;
};
class ModifyHaVipAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHaVipAttributeResponseBody() {}

  explicit ModifyHaVipAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHaVipAttributeResponseBody() = default;
};
class ModifyHaVipAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHaVipAttributeResponseBody> body{};

  ModifyHaVipAttributeResponse() {}

  explicit ModifyHaVipAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHaVipAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHaVipAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHaVipAttributeResponse() = default;
};
class ModifyIPv6TranslatorAclAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> aclName{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyIPv6TranslatorAclAttributeRequest() {}

  explicit ModifyIPv6TranslatorAclAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (aclName) {
      res["AclName"] = boost::any(*aclName);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AclName") != m.end() && !m["AclName"].empty()) {
      aclName = make_shared<string>(boost::any_cast<string>(m["AclName"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyIPv6TranslatorAclAttributeRequest() = default;
};
class ModifyIPv6TranslatorAclAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyIPv6TranslatorAclAttributeResponseBody() {}

  explicit ModifyIPv6TranslatorAclAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyIPv6TranslatorAclAttributeResponseBody() = default;
};
class ModifyIPv6TranslatorAclAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyIPv6TranslatorAclAttributeResponseBody> body{};

  ModifyIPv6TranslatorAclAttributeResponse() {}

  explicit ModifyIPv6TranslatorAclAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyIPv6TranslatorAclAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyIPv6TranslatorAclAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyIPv6TranslatorAclAttributeResponse() = default;
};
class ModifyIPv6TranslatorAclListEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclEntryComment{};
  shared_ptr<string> aclEntryId{};
  shared_ptr<string> aclId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyIPv6TranslatorAclListEntryRequest() {}

  explicit ModifyIPv6TranslatorAclListEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntryComment) {
      res["AclEntryComment"] = boost::any(*aclEntryComment);
    }
    if (aclEntryId) {
      res["AclEntryId"] = boost::any(*aclEntryId);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclEntryComment") != m.end() && !m["AclEntryComment"].empty()) {
      aclEntryComment = make_shared<string>(boost::any_cast<string>(m["AclEntryComment"]));
    }
    if (m.find("AclEntryId") != m.end() && !m["AclEntryId"].empty()) {
      aclEntryId = make_shared<string>(boost::any_cast<string>(m["AclEntryId"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyIPv6TranslatorAclListEntryRequest() = default;
};
class ModifyIPv6TranslatorAclListEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyIPv6TranslatorAclListEntryResponseBody() {}

  explicit ModifyIPv6TranslatorAclListEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyIPv6TranslatorAclListEntryResponseBody() = default;
};
class ModifyIPv6TranslatorAclListEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyIPv6TranslatorAclListEntryResponseBody> body{};

  ModifyIPv6TranslatorAclListEntryResponse() {}

  explicit ModifyIPv6TranslatorAclListEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyIPv6TranslatorAclListEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyIPv6TranslatorAclListEntryResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyIPv6TranslatorAclListEntryResponse() = default;
};
class ModifyIPv6TranslatorAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> ipv6TranslatorId{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyIPv6TranslatorAttributeRequest() {}

  explicit ModifyIPv6TranslatorAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipv6TranslatorId) {
      res["Ipv6TranslatorId"] = boost::any(*ipv6TranslatorId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Ipv6TranslatorId") != m.end() && !m["Ipv6TranslatorId"].empty()) {
      ipv6TranslatorId = make_shared<string>(boost::any_cast<string>(m["Ipv6TranslatorId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyIPv6TranslatorAttributeRequest() = default;
};
class ModifyIPv6TranslatorAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyIPv6TranslatorAttributeResponseBody() {}

  explicit ModifyIPv6TranslatorAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyIPv6TranslatorAttributeResponseBody() = default;
};
class ModifyIPv6TranslatorAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyIPv6TranslatorAttributeResponseBody> body{};

  ModifyIPv6TranslatorAttributeResponse() {}

  explicit ModifyIPv6TranslatorAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyIPv6TranslatorAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyIPv6TranslatorAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyIPv6TranslatorAttributeResponse() = default;
};
class ModifyIPv6TranslatorBandwidthRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ipv6TranslatorId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyIPv6TranslatorBandwidthRequest() {}

  explicit ModifyIPv6TranslatorBandwidthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ipv6TranslatorId) {
      res["Ipv6TranslatorId"] = boost::any(*ipv6TranslatorId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Ipv6TranslatorId") != m.end() && !m["Ipv6TranslatorId"].empty()) {
      ipv6TranslatorId = make_shared<string>(boost::any_cast<string>(m["Ipv6TranslatorId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyIPv6TranslatorBandwidthRequest() = default;
};
class ModifyIPv6TranslatorBandwidthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  ModifyIPv6TranslatorBandwidthResponseBody() {}

  explicit ModifyIPv6TranslatorBandwidthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyIPv6TranslatorBandwidthResponseBody() = default;
};
class ModifyIPv6TranslatorBandwidthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyIPv6TranslatorBandwidthResponseBody> body{};

  ModifyIPv6TranslatorBandwidthResponse() {}

  explicit ModifyIPv6TranslatorBandwidthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyIPv6TranslatorBandwidthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyIPv6TranslatorBandwidthResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyIPv6TranslatorBandwidthResponse() = default;
};
class ModifyIPv6TranslatorEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> aclStatus{};
  shared_ptr<string> aclType{};
  shared_ptr<long> allocateIpv6Port{};
  shared_ptr<string> backendIpv4Addr{};
  shared_ptr<long> backendIpv4Port{};
  shared_ptr<long> entryBandwidth{};
  shared_ptr<string> entryDescription{};
  shared_ptr<string> entryName{};
  shared_ptr<string> ipv6TranslatorEntryId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> transProtocol{};

  ModifyIPv6TranslatorEntryRequest() {}

  explicit ModifyIPv6TranslatorEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (aclStatus) {
      res["AclStatus"] = boost::any(*aclStatus);
    }
    if (aclType) {
      res["AclType"] = boost::any(*aclType);
    }
    if (allocateIpv6Port) {
      res["AllocateIpv6Port"] = boost::any(*allocateIpv6Port);
    }
    if (backendIpv4Addr) {
      res["BackendIpv4Addr"] = boost::any(*backendIpv4Addr);
    }
    if (backendIpv4Port) {
      res["BackendIpv4Port"] = boost::any(*backendIpv4Port);
    }
    if (entryBandwidth) {
      res["EntryBandwidth"] = boost::any(*entryBandwidth);
    }
    if (entryDescription) {
      res["EntryDescription"] = boost::any(*entryDescription);
    }
    if (entryName) {
      res["EntryName"] = boost::any(*entryName);
    }
    if (ipv6TranslatorEntryId) {
      res["Ipv6TranslatorEntryId"] = boost::any(*ipv6TranslatorEntryId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (transProtocol) {
      res["TransProtocol"] = boost::any(*transProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AclStatus") != m.end() && !m["AclStatus"].empty()) {
      aclStatus = make_shared<string>(boost::any_cast<string>(m["AclStatus"]));
    }
    if (m.find("AclType") != m.end() && !m["AclType"].empty()) {
      aclType = make_shared<string>(boost::any_cast<string>(m["AclType"]));
    }
    if (m.find("AllocateIpv6Port") != m.end() && !m["AllocateIpv6Port"].empty()) {
      allocateIpv6Port = make_shared<long>(boost::any_cast<long>(m["AllocateIpv6Port"]));
    }
    if (m.find("BackendIpv4Addr") != m.end() && !m["BackendIpv4Addr"].empty()) {
      backendIpv4Addr = make_shared<string>(boost::any_cast<string>(m["BackendIpv4Addr"]));
    }
    if (m.find("BackendIpv4Port") != m.end() && !m["BackendIpv4Port"].empty()) {
      backendIpv4Port = make_shared<long>(boost::any_cast<long>(m["BackendIpv4Port"]));
    }
    if (m.find("EntryBandwidth") != m.end() && !m["EntryBandwidth"].empty()) {
      entryBandwidth = make_shared<long>(boost::any_cast<long>(m["EntryBandwidth"]));
    }
    if (m.find("EntryDescription") != m.end() && !m["EntryDescription"].empty()) {
      entryDescription = make_shared<string>(boost::any_cast<string>(m["EntryDescription"]));
    }
    if (m.find("EntryName") != m.end() && !m["EntryName"].empty()) {
      entryName = make_shared<string>(boost::any_cast<string>(m["EntryName"]));
    }
    if (m.find("Ipv6TranslatorEntryId") != m.end() && !m["Ipv6TranslatorEntryId"].empty()) {
      ipv6TranslatorEntryId = make_shared<string>(boost::any_cast<string>(m["Ipv6TranslatorEntryId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TransProtocol") != m.end() && !m["TransProtocol"].empty()) {
      transProtocol = make_shared<string>(boost::any_cast<string>(m["TransProtocol"]));
    }
  }


  virtual ~ModifyIPv6TranslatorEntryRequest() = default;
};
class ModifyIPv6TranslatorEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyIPv6TranslatorEntryResponseBody() {}

  explicit ModifyIPv6TranslatorEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyIPv6TranslatorEntryResponseBody() = default;
};
class ModifyIPv6TranslatorEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyIPv6TranslatorEntryResponseBody> body{};

  ModifyIPv6TranslatorEntryResponse() {}

  explicit ModifyIPv6TranslatorEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyIPv6TranslatorEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyIPv6TranslatorEntryResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyIPv6TranslatorEntryResponse() = default;
};
class ModifyIpv6AddressAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> ipv6AddressId{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyIpv6AddressAttributeRequest() {}

  explicit ModifyIpv6AddressAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipv6AddressId) {
      res["Ipv6AddressId"] = boost::any(*ipv6AddressId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Ipv6AddressId") != m.end() && !m["Ipv6AddressId"].empty()) {
      ipv6AddressId = make_shared<string>(boost::any_cast<string>(m["Ipv6AddressId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyIpv6AddressAttributeRequest() = default;
};
class ModifyIpv6AddressAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyIpv6AddressAttributeResponseBody() {}

  explicit ModifyIpv6AddressAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyIpv6AddressAttributeResponseBody() = default;
};
class ModifyIpv6AddressAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyIpv6AddressAttributeResponseBody> body{};

  ModifyIpv6AddressAttributeResponse() {}

  explicit ModifyIpv6AddressAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyIpv6AddressAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyIpv6AddressAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyIpv6AddressAttributeResponse() = default;
};
class ModifyIpv6GatewayAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> ipv6GatewayId{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyIpv6GatewayAttributeRequest() {}

  explicit ModifyIpv6GatewayAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipv6GatewayId) {
      res["Ipv6GatewayId"] = boost::any(*ipv6GatewayId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Ipv6GatewayId") != m.end() && !m["Ipv6GatewayId"].empty()) {
      ipv6GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv6GatewayId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyIpv6GatewayAttributeRequest() = default;
};
class ModifyIpv6GatewayAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyIpv6GatewayAttributeResponseBody() {}

  explicit ModifyIpv6GatewayAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyIpv6GatewayAttributeResponseBody() = default;
};
class ModifyIpv6GatewayAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyIpv6GatewayAttributeResponseBody> body{};

  ModifyIpv6GatewayAttributeResponse() {}

  explicit ModifyIpv6GatewayAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyIpv6GatewayAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyIpv6GatewayAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyIpv6GatewayAttributeResponse() = default;
};
class ModifyIpv6InternetBandwidthRequest : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ipv6AddressId{};
  shared_ptr<string> ipv6InternetBandwidthId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyIpv6InternetBandwidthRequest() {}

  explicit ModifyIpv6InternetBandwidthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ipv6AddressId) {
      res["Ipv6AddressId"] = boost::any(*ipv6AddressId);
    }
    if (ipv6InternetBandwidthId) {
      res["Ipv6InternetBandwidthId"] = boost::any(*ipv6InternetBandwidthId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Ipv6AddressId") != m.end() && !m["Ipv6AddressId"].empty()) {
      ipv6AddressId = make_shared<string>(boost::any_cast<string>(m["Ipv6AddressId"]));
    }
    if (m.find("Ipv6InternetBandwidthId") != m.end() && !m["Ipv6InternetBandwidthId"].empty()) {
      ipv6InternetBandwidthId = make_shared<string>(boost::any_cast<string>(m["Ipv6InternetBandwidthId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyIpv6InternetBandwidthRequest() = default;
};
class ModifyIpv6InternetBandwidthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyIpv6InternetBandwidthResponseBody() {}

  explicit ModifyIpv6InternetBandwidthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyIpv6InternetBandwidthResponseBody() = default;
};
class ModifyIpv6InternetBandwidthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyIpv6InternetBandwidthResponseBody> body{};

  ModifyIpv6InternetBandwidthResponse() {}

  explicit ModifyIpv6InternetBandwidthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyIpv6InternetBandwidthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyIpv6InternetBandwidthResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyIpv6InternetBandwidthResponse() = default;
};
class ModifyNatGatewayAttributeRequestLogDelivery : public Darabonba::Model {
public:
  shared_ptr<string> logDeliveryType{};
  shared_ptr<string> logDestination{};

  ModifyNatGatewayAttributeRequestLogDelivery() {}

  explicit ModifyNatGatewayAttributeRequestLogDelivery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logDeliveryType) {
      res["LogDeliveryType"] = boost::any(*logDeliveryType);
    }
    if (logDestination) {
      res["LogDestination"] = boost::any(*logDestination);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogDeliveryType") != m.end() && !m["LogDeliveryType"].empty()) {
      logDeliveryType = make_shared<string>(boost::any_cast<string>(m["LogDeliveryType"]));
    }
    if (m.find("LogDestination") != m.end() && !m["LogDestination"].empty()) {
      logDestination = make_shared<string>(boost::any_cast<string>(m["LogDestination"]));
    }
  }


  virtual ~ModifyNatGatewayAttributeRequestLogDelivery() = default;
};
class ModifyNatGatewayAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> eipBindMode{};
  shared_ptr<bool> enableSessionLog{};
  shared_ptr<bool> icmpReplyEnabled{};
  shared_ptr<ModifyNatGatewayAttributeRequestLogDelivery> logDelivery{};
  shared_ptr<string> name{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyNatGatewayAttributeRequest() {}

  explicit ModifyNatGatewayAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eipBindMode) {
      res["EipBindMode"] = boost::any(*eipBindMode);
    }
    if (enableSessionLog) {
      res["EnableSessionLog"] = boost::any(*enableSessionLog);
    }
    if (icmpReplyEnabled) {
      res["IcmpReplyEnabled"] = boost::any(*icmpReplyEnabled);
    }
    if (logDelivery) {
      res["LogDelivery"] = logDelivery ? boost::any(logDelivery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EipBindMode") != m.end() && !m["EipBindMode"].empty()) {
      eipBindMode = make_shared<string>(boost::any_cast<string>(m["EipBindMode"]));
    }
    if (m.find("EnableSessionLog") != m.end() && !m["EnableSessionLog"].empty()) {
      enableSessionLog = make_shared<bool>(boost::any_cast<bool>(m["EnableSessionLog"]));
    }
    if (m.find("IcmpReplyEnabled") != m.end() && !m["IcmpReplyEnabled"].empty()) {
      icmpReplyEnabled = make_shared<bool>(boost::any_cast<bool>(m["IcmpReplyEnabled"]));
    }
    if (m.find("LogDelivery") != m.end() && !m["LogDelivery"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogDelivery"].type()) {
        ModifyNatGatewayAttributeRequestLogDelivery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogDelivery"]));
        logDelivery = make_shared<ModifyNatGatewayAttributeRequestLogDelivery>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyNatGatewayAttributeRequest() = default;
};
class ModifyNatGatewayAttributeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> eipBindMode{};
  shared_ptr<bool> enableSessionLog{};
  shared_ptr<bool> icmpReplyEnabled{};
  shared_ptr<string> logDeliveryShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyNatGatewayAttributeShrinkRequest() {}

  explicit ModifyNatGatewayAttributeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eipBindMode) {
      res["EipBindMode"] = boost::any(*eipBindMode);
    }
    if (enableSessionLog) {
      res["EnableSessionLog"] = boost::any(*enableSessionLog);
    }
    if (icmpReplyEnabled) {
      res["IcmpReplyEnabled"] = boost::any(*icmpReplyEnabled);
    }
    if (logDeliveryShrink) {
      res["LogDelivery"] = boost::any(*logDeliveryShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EipBindMode") != m.end() && !m["EipBindMode"].empty()) {
      eipBindMode = make_shared<string>(boost::any_cast<string>(m["EipBindMode"]));
    }
    if (m.find("EnableSessionLog") != m.end() && !m["EnableSessionLog"].empty()) {
      enableSessionLog = make_shared<bool>(boost::any_cast<bool>(m["EnableSessionLog"]));
    }
    if (m.find("IcmpReplyEnabled") != m.end() && !m["IcmpReplyEnabled"].empty()) {
      icmpReplyEnabled = make_shared<bool>(boost::any_cast<bool>(m["IcmpReplyEnabled"]));
    }
    if (m.find("LogDelivery") != m.end() && !m["LogDelivery"].empty()) {
      logDeliveryShrink = make_shared<string>(boost::any_cast<string>(m["LogDelivery"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyNatGatewayAttributeShrinkRequest() = default;
};
class ModifyNatGatewayAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyNatGatewayAttributeResponseBody() {}

  explicit ModifyNatGatewayAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyNatGatewayAttributeResponseBody() = default;
};
class ModifyNatGatewayAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyNatGatewayAttributeResponseBody> body{};

  ModifyNatGatewayAttributeResponse() {}

  explicit ModifyNatGatewayAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyNatGatewayAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyNatGatewayAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyNatGatewayAttributeResponse() = default;
};
class ModifyNatGatewaySpecRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> spec{};

  ModifyNatGatewaySpecRequest() {}

  explicit ModifyNatGatewaySpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~ModifyNatGatewaySpecRequest() = default;
};
class ModifyNatGatewaySpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyNatGatewaySpecResponseBody() {}

  explicit ModifyNatGatewaySpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyNatGatewaySpecResponseBody() = default;
};
class ModifyNatGatewaySpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyNatGatewaySpecResponseBody> body{};

  ModifyNatGatewaySpecResponse() {}

  explicit ModifyNatGatewaySpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyNatGatewaySpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyNatGatewaySpecResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyNatGatewaySpecResponse() = default;
};
class ModifyNatIpAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> natIpDescription{};
  shared_ptr<string> natIpId{};
  shared_ptr<string> natIpName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyNatIpAttributeRequest() {}

  explicit ModifyNatIpAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (natIpDescription) {
      res["NatIpDescription"] = boost::any(*natIpDescription);
    }
    if (natIpId) {
      res["NatIpId"] = boost::any(*natIpId);
    }
    if (natIpName) {
      res["NatIpName"] = boost::any(*natIpName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NatIpDescription") != m.end() && !m["NatIpDescription"].empty()) {
      natIpDescription = make_shared<string>(boost::any_cast<string>(m["NatIpDescription"]));
    }
    if (m.find("NatIpId") != m.end() && !m["NatIpId"].empty()) {
      natIpId = make_shared<string>(boost::any_cast<string>(m["NatIpId"]));
    }
    if (m.find("NatIpName") != m.end() && !m["NatIpName"].empty()) {
      natIpName = make_shared<string>(boost::any_cast<string>(m["NatIpName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyNatIpAttributeRequest() = default;
};
class ModifyNatIpAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyNatIpAttributeResponseBody() {}

  explicit ModifyNatIpAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyNatIpAttributeResponseBody() = default;
};
class ModifyNatIpAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyNatIpAttributeResponseBody> body{};

  ModifyNatIpAttributeResponse() {}

  explicit ModifyNatIpAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyNatIpAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyNatIpAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyNatIpAttributeResponse() = default;
};
class ModifyNatIpCidrAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> natIpCidr{};
  shared_ptr<string> natIpCidrDescription{};
  shared_ptr<string> natIpCidrName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyNatIpCidrAttributeRequest() {}

  explicit ModifyNatIpCidrAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (natIpCidr) {
      res["NatIpCidr"] = boost::any(*natIpCidr);
    }
    if (natIpCidrDescription) {
      res["NatIpCidrDescription"] = boost::any(*natIpCidrDescription);
    }
    if (natIpCidrName) {
      res["NatIpCidrName"] = boost::any(*natIpCidrName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("NatIpCidr") != m.end() && !m["NatIpCidr"].empty()) {
      natIpCidr = make_shared<string>(boost::any_cast<string>(m["NatIpCidr"]));
    }
    if (m.find("NatIpCidrDescription") != m.end() && !m["NatIpCidrDescription"].empty()) {
      natIpCidrDescription = make_shared<string>(boost::any_cast<string>(m["NatIpCidrDescription"]));
    }
    if (m.find("NatIpCidrName") != m.end() && !m["NatIpCidrName"].empty()) {
      natIpCidrName = make_shared<string>(boost::any_cast<string>(m["NatIpCidrName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyNatIpCidrAttributeRequest() = default;
};
class ModifyNatIpCidrAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyNatIpCidrAttributeResponseBody() {}

  explicit ModifyNatIpCidrAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyNatIpCidrAttributeResponseBody() = default;
};
class ModifyNatIpCidrAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyNatIpCidrAttributeResponseBody> body{};

  ModifyNatIpCidrAttributeResponse() {}

  explicit ModifyNatIpCidrAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyNatIpCidrAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyNatIpCidrAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyNatIpCidrAttributeResponse() = default;
};
class ModifyNetworkAclAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> networkAclId{};
  shared_ptr<string> networkAclName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyNetworkAclAttributesRequest() {}

  explicit ModifyNetworkAclAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (networkAclName) {
      res["NetworkAclName"] = boost::any(*networkAclName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("NetworkAclName") != m.end() && !m["NetworkAclName"].empty()) {
      networkAclName = make_shared<string>(boost::any_cast<string>(m["NetworkAclName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyNetworkAclAttributesRequest() = default;
};
class ModifyNetworkAclAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyNetworkAclAttributesResponseBody() {}

  explicit ModifyNetworkAclAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyNetworkAclAttributesResponseBody() = default;
};
class ModifyNetworkAclAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyNetworkAclAttributesResponseBody> body{};

  ModifyNetworkAclAttributesResponse() {}

  explicit ModifyNetworkAclAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyNetworkAclAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyNetworkAclAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyNetworkAclAttributesResponse() = default;
};
class ModifyPhysicalConnectionAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> circuitCode{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> lineOperator{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> peerLocation{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> portType{};
  shared_ptr<string> redundantPhysicalConnectionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> bandwidth{};

  ModifyPhysicalConnectionAttributeRequest() {}

  explicit ModifyPhysicalConnectionAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (circuitCode) {
      res["CircuitCode"] = boost::any(*circuitCode);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (lineOperator) {
      res["LineOperator"] = boost::any(*lineOperator);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (peerLocation) {
      res["PeerLocation"] = boost::any(*peerLocation);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (portType) {
      res["PortType"] = boost::any(*portType);
    }
    if (redundantPhysicalConnectionId) {
      res["RedundantPhysicalConnectionId"] = boost::any(*redundantPhysicalConnectionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (bandwidth) {
      res["bandwidth"] = boost::any(*bandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CircuitCode") != m.end() && !m["CircuitCode"].empty()) {
      circuitCode = make_shared<string>(boost::any_cast<string>(m["CircuitCode"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("LineOperator") != m.end() && !m["LineOperator"].empty()) {
      lineOperator = make_shared<string>(boost::any_cast<string>(m["LineOperator"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PeerLocation") != m.end() && !m["PeerLocation"].empty()) {
      peerLocation = make_shared<string>(boost::any_cast<string>(m["PeerLocation"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("PortType") != m.end() && !m["PortType"].empty()) {
      portType = make_shared<string>(boost::any_cast<string>(m["PortType"]));
    }
    if (m.find("RedundantPhysicalConnectionId") != m.end() && !m["RedundantPhysicalConnectionId"].empty()) {
      redundantPhysicalConnectionId = make_shared<string>(boost::any_cast<string>(m["RedundantPhysicalConnectionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("bandwidth") != m.end() && !m["bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["bandwidth"]));
    }
  }


  virtual ~ModifyPhysicalConnectionAttributeRequest() = default;
};
class ModifyPhysicalConnectionAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyPhysicalConnectionAttributeResponseBody() {}

  explicit ModifyPhysicalConnectionAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyPhysicalConnectionAttributeResponseBody() = default;
};
class ModifyPhysicalConnectionAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyPhysicalConnectionAttributeResponseBody> body{};

  ModifyPhysicalConnectionAttributeResponse() {}

  explicit ModifyPhysicalConnectionAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPhysicalConnectionAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPhysicalConnectionAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPhysicalConnectionAttributeResponse() = default;
};
class ModifyRouteEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> newNextHopId{};
  shared_ptr<string> newNextHopType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeEntryId{};
  shared_ptr<string> routeEntryName{};

  ModifyRouteEntryRequest() {}

  explicit ModifyRouteEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (newNextHopId) {
      res["NewNextHopId"] = boost::any(*newNextHopId);
    }
    if (newNextHopType) {
      res["NewNextHopType"] = boost::any(*newNextHopType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeEntryId) {
      res["RouteEntryId"] = boost::any(*routeEntryId);
    }
    if (routeEntryName) {
      res["RouteEntryName"] = boost::any(*routeEntryName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NewNextHopId") != m.end() && !m["NewNextHopId"].empty()) {
      newNextHopId = make_shared<string>(boost::any_cast<string>(m["NewNextHopId"]));
    }
    if (m.find("NewNextHopType") != m.end() && !m["NewNextHopType"].empty()) {
      newNextHopType = make_shared<string>(boost::any_cast<string>(m["NewNextHopType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteEntryId") != m.end() && !m["RouteEntryId"].empty()) {
      routeEntryId = make_shared<string>(boost::any_cast<string>(m["RouteEntryId"]));
    }
    if (m.find("RouteEntryName") != m.end() && !m["RouteEntryName"].empty()) {
      routeEntryName = make_shared<string>(boost::any_cast<string>(m["RouteEntryName"]));
    }
  }


  virtual ~ModifyRouteEntryRequest() = default;
};
class ModifyRouteEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyRouteEntryResponseBody() {}

  explicit ModifyRouteEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyRouteEntryResponseBody() = default;
};
class ModifyRouteEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyRouteEntryResponseBody> body{};

  ModifyRouteEntryResponse() {}

  explicit ModifyRouteEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyRouteEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyRouteEntryResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyRouteEntryResponse() = default;
};
class ModifyRouteTableAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> routeTableName{};

  ModifyRouteTableAttributesRequest() {}

  explicit ModifyRouteTableAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (routeTableName) {
      res["RouteTableName"] = boost::any(*routeTableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("RouteTableName") != m.end() && !m["RouteTableName"].empty()) {
      routeTableName = make_shared<string>(boost::any_cast<string>(m["RouteTableName"]));
    }
  }


  virtual ~ModifyRouteTableAttributesRequest() = default;
};
class ModifyRouteTableAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyRouteTableAttributesResponseBody() {}

  explicit ModifyRouteTableAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyRouteTableAttributesResponseBody() = default;
};
class ModifyRouteTableAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyRouteTableAttributesResponseBody> body{};

  ModifyRouteTableAttributesResponse() {}

  explicit ModifyRouteTableAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyRouteTableAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyRouteTableAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyRouteTableAttributesResponse() = default;
};
class ModifyRouterInterfaceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<bool> deleteHealthCheckIp{};
  shared_ptr<string> description{};
  shared_ptr<long> hcRate{};
  shared_ptr<long> hcThreshold{};
  shared_ptr<string> healthCheckSourceIp{};
  shared_ptr<string> healthCheckTargetIp{};
  shared_ptr<string> name{};
  shared_ptr<string> oppositeInterfaceId{};
  shared_ptr<long> oppositeInterfaceOwnerId{};
  shared_ptr<string> oppositeRouterId{};
  shared_ptr<string> oppositeRouterType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routerInterfaceId{};

  ModifyRouterInterfaceAttributeRequest() {}

  explicit ModifyRouterInterfaceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteHealthCheckIp) {
      res["DeleteHealthCheckIp"] = boost::any(*deleteHealthCheckIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hcRate) {
      res["HcRate"] = boost::any(*hcRate);
    }
    if (hcThreshold) {
      res["HcThreshold"] = boost::any(*hcThreshold);
    }
    if (healthCheckSourceIp) {
      res["HealthCheckSourceIp"] = boost::any(*healthCheckSourceIp);
    }
    if (healthCheckTargetIp) {
      res["HealthCheckTargetIp"] = boost::any(*healthCheckTargetIp);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (oppositeInterfaceId) {
      res["OppositeInterfaceId"] = boost::any(*oppositeInterfaceId);
    }
    if (oppositeInterfaceOwnerId) {
      res["OppositeInterfaceOwnerId"] = boost::any(*oppositeInterfaceOwnerId);
    }
    if (oppositeRouterId) {
      res["OppositeRouterId"] = boost::any(*oppositeRouterId);
    }
    if (oppositeRouterType) {
      res["OppositeRouterType"] = boost::any(*oppositeRouterType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routerInterfaceId) {
      res["RouterInterfaceId"] = boost::any(*routerInterfaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteHealthCheckIp") != m.end() && !m["DeleteHealthCheckIp"].empty()) {
      deleteHealthCheckIp = make_shared<bool>(boost::any_cast<bool>(m["DeleteHealthCheckIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HcRate") != m.end() && !m["HcRate"].empty()) {
      hcRate = make_shared<long>(boost::any_cast<long>(m["HcRate"]));
    }
    if (m.find("HcThreshold") != m.end() && !m["HcThreshold"].empty()) {
      hcThreshold = make_shared<long>(boost::any_cast<long>(m["HcThreshold"]));
    }
    if (m.find("HealthCheckSourceIp") != m.end() && !m["HealthCheckSourceIp"].empty()) {
      healthCheckSourceIp = make_shared<string>(boost::any_cast<string>(m["HealthCheckSourceIp"]));
    }
    if (m.find("HealthCheckTargetIp") != m.end() && !m["HealthCheckTargetIp"].empty()) {
      healthCheckTargetIp = make_shared<string>(boost::any_cast<string>(m["HealthCheckTargetIp"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OppositeInterfaceId") != m.end() && !m["OppositeInterfaceId"].empty()) {
      oppositeInterfaceId = make_shared<string>(boost::any_cast<string>(m["OppositeInterfaceId"]));
    }
    if (m.find("OppositeInterfaceOwnerId") != m.end() && !m["OppositeInterfaceOwnerId"].empty()) {
      oppositeInterfaceOwnerId = make_shared<long>(boost::any_cast<long>(m["OppositeInterfaceOwnerId"]));
    }
    if (m.find("OppositeRouterId") != m.end() && !m["OppositeRouterId"].empty()) {
      oppositeRouterId = make_shared<string>(boost::any_cast<string>(m["OppositeRouterId"]));
    }
    if (m.find("OppositeRouterType") != m.end() && !m["OppositeRouterType"].empty()) {
      oppositeRouterType = make_shared<string>(boost::any_cast<string>(m["OppositeRouterType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouterInterfaceId") != m.end() && !m["RouterInterfaceId"].empty()) {
      routerInterfaceId = make_shared<string>(boost::any_cast<string>(m["RouterInterfaceId"]));
    }
  }


  virtual ~ModifyRouterInterfaceAttributeRequest() = default;
};
class ModifyRouterInterfaceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyRouterInterfaceAttributeResponseBody() {}

  explicit ModifyRouterInterfaceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyRouterInterfaceAttributeResponseBody() = default;
};
class ModifyRouterInterfaceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyRouterInterfaceAttributeResponseBody> body{};

  ModifyRouterInterfaceAttributeResponse() {}

  explicit ModifyRouterInterfaceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyRouterInterfaceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyRouterInterfaceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyRouterInterfaceAttributeResponse() = default;
};
class ModifyRouterInterfaceSpecRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routerInterfaceId{};
  shared_ptr<string> spec{};

  ModifyRouterInterfaceSpecRequest() {}

  explicit ModifyRouterInterfaceSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routerInterfaceId) {
      res["RouterInterfaceId"] = boost::any(*routerInterfaceId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouterInterfaceId") != m.end() && !m["RouterInterfaceId"].empty()) {
      routerInterfaceId = make_shared<string>(boost::any_cast<string>(m["RouterInterfaceId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~ModifyRouterInterfaceSpecRequest() = default;
};
class ModifyRouterInterfaceSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> spec{};

  ModifyRouterInterfaceSpecResponseBody() {}

  explicit ModifyRouterInterfaceSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~ModifyRouterInterfaceSpecResponseBody() = default;
};
class ModifyRouterInterfaceSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyRouterInterfaceSpecResponseBody> body{};

  ModifyRouterInterfaceSpecResponse() {}

  explicit ModifyRouterInterfaceSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyRouterInterfaceSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyRouterInterfaceSpecResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyRouterInterfaceSpecResponse() = default;
};
class ModifySnatEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> eipAffinity{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> snatEntryId{};
  shared_ptr<string> snatEntryName{};
  shared_ptr<string> snatIp{};
  shared_ptr<string> snatTableId{};

  ModifySnatEntryRequest() {}

  explicit ModifySnatEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (eipAffinity) {
      res["EipAffinity"] = boost::any(*eipAffinity);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (snatEntryId) {
      res["SnatEntryId"] = boost::any(*snatEntryId);
    }
    if (snatEntryName) {
      res["SnatEntryName"] = boost::any(*snatEntryName);
    }
    if (snatIp) {
      res["SnatIp"] = boost::any(*snatIp);
    }
    if (snatTableId) {
      res["SnatTableId"] = boost::any(*snatTableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EipAffinity") != m.end() && !m["EipAffinity"].empty()) {
      eipAffinity = make_shared<long>(boost::any_cast<long>(m["EipAffinity"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SnatEntryId") != m.end() && !m["SnatEntryId"].empty()) {
      snatEntryId = make_shared<string>(boost::any_cast<string>(m["SnatEntryId"]));
    }
    if (m.find("SnatEntryName") != m.end() && !m["SnatEntryName"].empty()) {
      snatEntryName = make_shared<string>(boost::any_cast<string>(m["SnatEntryName"]));
    }
    if (m.find("SnatIp") != m.end() && !m["SnatIp"].empty()) {
      snatIp = make_shared<string>(boost::any_cast<string>(m["SnatIp"]));
    }
    if (m.find("SnatTableId") != m.end() && !m["SnatTableId"].empty()) {
      snatTableId = make_shared<string>(boost::any_cast<string>(m["SnatTableId"]));
    }
  }


  virtual ~ModifySnatEntryRequest() = default;
};
class ModifySnatEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySnatEntryResponseBody() {}

  explicit ModifySnatEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySnatEntryResponseBody() = default;
};
class ModifySnatEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySnatEntryResponseBody> body{};

  ModifySnatEntryResponse() {}

  explicit ModifySnatEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySnatEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySnatEntryResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySnatEntryResponse() = default;
};
class ModifySslVpnClientCertRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sslVpnClientCertId{};

  ModifySslVpnClientCertRequest() {}

  explicit ModifySslVpnClientCertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sslVpnClientCertId) {
      res["SslVpnClientCertId"] = boost::any(*sslVpnClientCertId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SslVpnClientCertId") != m.end() && !m["SslVpnClientCertId"].empty()) {
      sslVpnClientCertId = make_shared<string>(boost::any_cast<string>(m["SslVpnClientCertId"]));
    }
  }


  virtual ~ModifySslVpnClientCertRequest() = default;
};
class ModifySslVpnClientCertResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sslVpnClientCertId{};

  ModifySslVpnClientCertResponseBody() {}

  explicit ModifySslVpnClientCertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sslVpnClientCertId) {
      res["SslVpnClientCertId"] = boost::any(*sslVpnClientCertId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SslVpnClientCertId") != m.end() && !m["SslVpnClientCertId"].empty()) {
      sslVpnClientCertId = make_shared<string>(boost::any_cast<string>(m["SslVpnClientCertId"]));
    }
  }


  virtual ~ModifySslVpnClientCertResponseBody() = default;
};
class ModifySslVpnClientCertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySslVpnClientCertResponseBody> body{};

  ModifySslVpnClientCertResponse() {}

  explicit ModifySslVpnClientCertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySslVpnClientCertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySslVpnClientCertResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySslVpnClientCertResponse() = default;
};
class ModifySslVpnServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> cipher{};
  shared_ptr<string> clientIpPool{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> compress{};
  shared_ptr<bool> enableMultiFactorAuth{};
  shared_ptr<string> IDaaSApplicationId{};
  shared_ptr<string> IDaaSInstanceId{};
  shared_ptr<string> IDaaSRegionId{};
  shared_ptr<string> localSubnet{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> port{};
  shared_ptr<string> proto{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sslVpnServerId{};

  ModifySslVpnServerRequest() {}

  explicit ModifySslVpnServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cipher) {
      res["Cipher"] = boost::any(*cipher);
    }
    if (clientIpPool) {
      res["ClientIpPool"] = boost::any(*clientIpPool);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (compress) {
      res["Compress"] = boost::any(*compress);
    }
    if (enableMultiFactorAuth) {
      res["EnableMultiFactorAuth"] = boost::any(*enableMultiFactorAuth);
    }
    if (IDaaSApplicationId) {
      res["IDaaSApplicationId"] = boost::any(*IDaaSApplicationId);
    }
    if (IDaaSInstanceId) {
      res["IDaaSInstanceId"] = boost::any(*IDaaSInstanceId);
    }
    if (IDaaSRegionId) {
      res["IDaaSRegionId"] = boost::any(*IDaaSRegionId);
    }
    if (localSubnet) {
      res["LocalSubnet"] = boost::any(*localSubnet);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (proto) {
      res["Proto"] = boost::any(*proto);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sslVpnServerId) {
      res["SslVpnServerId"] = boost::any(*sslVpnServerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cipher") != m.end() && !m["Cipher"].empty()) {
      cipher = make_shared<string>(boost::any_cast<string>(m["Cipher"]));
    }
    if (m.find("ClientIpPool") != m.end() && !m["ClientIpPool"].empty()) {
      clientIpPool = make_shared<string>(boost::any_cast<string>(m["ClientIpPool"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Compress") != m.end() && !m["Compress"].empty()) {
      compress = make_shared<bool>(boost::any_cast<bool>(m["Compress"]));
    }
    if (m.find("EnableMultiFactorAuth") != m.end() && !m["EnableMultiFactorAuth"].empty()) {
      enableMultiFactorAuth = make_shared<bool>(boost::any_cast<bool>(m["EnableMultiFactorAuth"]));
    }
    if (m.find("IDaaSApplicationId") != m.end() && !m["IDaaSApplicationId"].empty()) {
      IDaaSApplicationId = make_shared<string>(boost::any_cast<string>(m["IDaaSApplicationId"]));
    }
    if (m.find("IDaaSInstanceId") != m.end() && !m["IDaaSInstanceId"].empty()) {
      IDaaSInstanceId = make_shared<string>(boost::any_cast<string>(m["IDaaSInstanceId"]));
    }
    if (m.find("IDaaSRegionId") != m.end() && !m["IDaaSRegionId"].empty()) {
      IDaaSRegionId = make_shared<string>(boost::any_cast<string>(m["IDaaSRegionId"]));
    }
    if (m.find("LocalSubnet") != m.end() && !m["LocalSubnet"].empty()) {
      localSubnet = make_shared<string>(boost::any_cast<string>(m["LocalSubnet"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Proto") != m.end() && !m["Proto"].empty()) {
      proto = make_shared<string>(boost::any_cast<string>(m["Proto"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SslVpnServerId") != m.end() && !m["SslVpnServerId"].empty()) {
      sslVpnServerId = make_shared<string>(boost::any_cast<string>(m["SslVpnServerId"]));
    }
  }


  virtual ~ModifySslVpnServerRequest() = default;
};
class ModifySslVpnServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cipher{};
  shared_ptr<string> clientIpPool{};
  shared_ptr<bool> compress{};
  shared_ptr<long> connections{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> enableMultiFactorAuth{};
  shared_ptr<string> IDaaSApplicationId{};
  shared_ptr<string> IDaaSInstanceId{};
  shared_ptr<string> IDaaSInstanceVersion{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> localSubnet{};
  shared_ptr<long> maxConnections{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> proto{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sslVpnServerId{};
  shared_ptr<string> vpnGatewayId{};

  ModifySslVpnServerResponseBody() {}

  explicit ModifySslVpnServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cipher) {
      res["Cipher"] = boost::any(*cipher);
    }
    if (clientIpPool) {
      res["ClientIpPool"] = boost::any(*clientIpPool);
    }
    if (compress) {
      res["Compress"] = boost::any(*compress);
    }
    if (connections) {
      res["Connections"] = boost::any(*connections);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (enableMultiFactorAuth) {
      res["EnableMultiFactorAuth"] = boost::any(*enableMultiFactorAuth);
    }
    if (IDaaSApplicationId) {
      res["IDaaSApplicationId"] = boost::any(*IDaaSApplicationId);
    }
    if (IDaaSInstanceId) {
      res["IDaaSInstanceId"] = boost::any(*IDaaSInstanceId);
    }
    if (IDaaSInstanceVersion) {
      res["IDaaSInstanceVersion"] = boost::any(*IDaaSInstanceVersion);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (localSubnet) {
      res["LocalSubnet"] = boost::any(*localSubnet);
    }
    if (maxConnections) {
      res["MaxConnections"] = boost::any(*maxConnections);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (proto) {
      res["Proto"] = boost::any(*proto);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sslVpnServerId) {
      res["SslVpnServerId"] = boost::any(*sslVpnServerId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cipher") != m.end() && !m["Cipher"].empty()) {
      cipher = make_shared<string>(boost::any_cast<string>(m["Cipher"]));
    }
    if (m.find("ClientIpPool") != m.end() && !m["ClientIpPool"].empty()) {
      clientIpPool = make_shared<string>(boost::any_cast<string>(m["ClientIpPool"]));
    }
    if (m.find("Compress") != m.end() && !m["Compress"].empty()) {
      compress = make_shared<bool>(boost::any_cast<bool>(m["Compress"]));
    }
    if (m.find("Connections") != m.end() && !m["Connections"].empty()) {
      connections = make_shared<long>(boost::any_cast<long>(m["Connections"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("EnableMultiFactorAuth") != m.end() && !m["EnableMultiFactorAuth"].empty()) {
      enableMultiFactorAuth = make_shared<bool>(boost::any_cast<bool>(m["EnableMultiFactorAuth"]));
    }
    if (m.find("IDaaSApplicationId") != m.end() && !m["IDaaSApplicationId"].empty()) {
      IDaaSApplicationId = make_shared<string>(boost::any_cast<string>(m["IDaaSApplicationId"]));
    }
    if (m.find("IDaaSInstanceId") != m.end() && !m["IDaaSInstanceId"].empty()) {
      IDaaSInstanceId = make_shared<string>(boost::any_cast<string>(m["IDaaSInstanceId"]));
    }
    if (m.find("IDaaSInstanceVersion") != m.end() && !m["IDaaSInstanceVersion"].empty()) {
      IDaaSInstanceVersion = make_shared<string>(boost::any_cast<string>(m["IDaaSInstanceVersion"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("LocalSubnet") != m.end() && !m["LocalSubnet"].empty()) {
      localSubnet = make_shared<string>(boost::any_cast<string>(m["LocalSubnet"]));
    }
    if (m.find("MaxConnections") != m.end() && !m["MaxConnections"].empty()) {
      maxConnections = make_shared<long>(boost::any_cast<long>(m["MaxConnections"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Proto") != m.end() && !m["Proto"].empty()) {
      proto = make_shared<string>(boost::any_cast<string>(m["Proto"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SslVpnServerId") != m.end() && !m["SslVpnServerId"].empty()) {
      sslVpnServerId = make_shared<string>(boost::any_cast<string>(m["SslVpnServerId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~ModifySslVpnServerResponseBody() = default;
};
class ModifySslVpnServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySslVpnServerResponseBody> body{};

  ModifySslVpnServerResponse() {}

  explicit ModifySslVpnServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySslVpnServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySslVpnServerResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySslVpnServerResponse() = default;
};
class ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig : public Darabonba::Model {
public:
  shared_ptr<long> localAsn{};
  shared_ptr<string> localBgpIp{};
  shared_ptr<string> tunnelCidr{};

  ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig() {}

  explicit ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localAsn) {
      res["LocalAsn"] = boost::any(*localAsn);
    }
    if (localBgpIp) {
      res["LocalBgpIp"] = boost::any(*localBgpIp);
    }
    if (tunnelCidr) {
      res["TunnelCidr"] = boost::any(*tunnelCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalAsn") != m.end() && !m["LocalAsn"].empty()) {
      localAsn = make_shared<long>(boost::any_cast<long>(m["LocalAsn"]));
    }
    if (m.find("LocalBgpIp") != m.end() && !m["LocalBgpIp"].empty()) {
      localBgpIp = make_shared<string>(boost::any_cast<string>(m["LocalBgpIp"]));
    }
    if (m.find("TunnelCidr") != m.end() && !m["TunnelCidr"].empty()) {
      tunnelCidr = make_shared<string>(boost::any_cast<string>(m["TunnelCidr"]));
    }
  }


  virtual ~ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig() = default;
};
class ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig : public Darabonba::Model {
public:
  shared_ptr<string> ikeAuthAlg{};
  shared_ptr<string> ikeEncAlg{};
  shared_ptr<long> ikeLifetime{};
  shared_ptr<string> ikeMode{};
  shared_ptr<string> ikePfs{};
  shared_ptr<string> ikeVersion{};
  shared_ptr<string> localId{};
  shared_ptr<string> psk{};
  shared_ptr<string> remoteId{};

  ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig() {}

  explicit ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ikeAuthAlg) {
      res["IkeAuthAlg"] = boost::any(*ikeAuthAlg);
    }
    if (ikeEncAlg) {
      res["IkeEncAlg"] = boost::any(*ikeEncAlg);
    }
    if (ikeLifetime) {
      res["IkeLifetime"] = boost::any(*ikeLifetime);
    }
    if (ikeMode) {
      res["IkeMode"] = boost::any(*ikeMode);
    }
    if (ikePfs) {
      res["IkePfs"] = boost::any(*ikePfs);
    }
    if (ikeVersion) {
      res["IkeVersion"] = boost::any(*ikeVersion);
    }
    if (localId) {
      res["LocalId"] = boost::any(*localId);
    }
    if (psk) {
      res["Psk"] = boost::any(*psk);
    }
    if (remoteId) {
      res["RemoteId"] = boost::any(*remoteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IkeAuthAlg") != m.end() && !m["IkeAuthAlg"].empty()) {
      ikeAuthAlg = make_shared<string>(boost::any_cast<string>(m["IkeAuthAlg"]));
    }
    if (m.find("IkeEncAlg") != m.end() && !m["IkeEncAlg"].empty()) {
      ikeEncAlg = make_shared<string>(boost::any_cast<string>(m["IkeEncAlg"]));
    }
    if (m.find("IkeLifetime") != m.end() && !m["IkeLifetime"].empty()) {
      ikeLifetime = make_shared<long>(boost::any_cast<long>(m["IkeLifetime"]));
    }
    if (m.find("IkeMode") != m.end() && !m["IkeMode"].empty()) {
      ikeMode = make_shared<string>(boost::any_cast<string>(m["IkeMode"]));
    }
    if (m.find("IkePfs") != m.end() && !m["IkePfs"].empty()) {
      ikePfs = make_shared<string>(boost::any_cast<string>(m["IkePfs"]));
    }
    if (m.find("IkeVersion") != m.end() && !m["IkeVersion"].empty()) {
      ikeVersion = make_shared<string>(boost::any_cast<string>(m["IkeVersion"]));
    }
    if (m.find("LocalId") != m.end() && !m["LocalId"].empty()) {
      localId = make_shared<string>(boost::any_cast<string>(m["LocalId"]));
    }
    if (m.find("Psk") != m.end() && !m["Psk"].empty()) {
      psk = make_shared<string>(boost::any_cast<string>(m["Psk"]));
    }
    if (m.find("RemoteId") != m.end() && !m["RemoteId"].empty()) {
      remoteId = make_shared<string>(boost::any_cast<string>(m["RemoteId"]));
    }
  }


  virtual ~ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig() = default;
};
class ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig : public Darabonba::Model {
public:
  shared_ptr<string> ipsecAuthAlg{};
  shared_ptr<string> ipsecEncAlg{};
  shared_ptr<long> ipsecLifetime{};
  shared_ptr<string> ipsecPfs{};

  ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig() {}

  explicit ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipsecAuthAlg) {
      res["IpsecAuthAlg"] = boost::any(*ipsecAuthAlg);
    }
    if (ipsecEncAlg) {
      res["IpsecEncAlg"] = boost::any(*ipsecEncAlg);
    }
    if (ipsecLifetime) {
      res["IpsecLifetime"] = boost::any(*ipsecLifetime);
    }
    if (ipsecPfs) {
      res["IpsecPfs"] = boost::any(*ipsecPfs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpsecAuthAlg") != m.end() && !m["IpsecAuthAlg"].empty()) {
      ipsecAuthAlg = make_shared<string>(boost::any_cast<string>(m["IpsecAuthAlg"]));
    }
    if (m.find("IpsecEncAlg") != m.end() && !m["IpsecEncAlg"].empty()) {
      ipsecEncAlg = make_shared<string>(boost::any_cast<string>(m["IpsecEncAlg"]));
    }
    if (m.find("IpsecLifetime") != m.end() && !m["IpsecLifetime"].empty()) {
      ipsecLifetime = make_shared<long>(boost::any_cast<long>(m["IpsecLifetime"]));
    }
    if (m.find("IpsecPfs") != m.end() && !m["IpsecPfs"].empty()) {
      ipsecPfs = make_shared<string>(boost::any_cast<string>(m["IpsecPfs"]));
    }
  }


  virtual ~ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig() = default;
};
class ModifyTunnelAttributeRequestTunnelOptionsSpecification : public Darabonba::Model {
public:
  shared_ptr<bool> enableDpd{};
  shared_ptr<bool> enableNatTraversal{};
  shared_ptr<string> remoteCaCertificate{};
  shared_ptr<ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig> tunnelBgpConfig{};
  shared_ptr<ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig> tunnelIkeConfig{};
  shared_ptr<ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig> tunnelIpsecConfig{};

  ModifyTunnelAttributeRequestTunnelOptionsSpecification() {}

  explicit ModifyTunnelAttributeRequestTunnelOptionsSpecification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableDpd) {
      res["EnableDpd"] = boost::any(*enableDpd);
    }
    if (enableNatTraversal) {
      res["EnableNatTraversal"] = boost::any(*enableNatTraversal);
    }
    if (remoteCaCertificate) {
      res["RemoteCaCertificate"] = boost::any(*remoteCaCertificate);
    }
    if (tunnelBgpConfig) {
      res["TunnelBgpConfig"] = tunnelBgpConfig ? boost::any(tunnelBgpConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tunnelIkeConfig) {
      res["TunnelIkeConfig"] = tunnelIkeConfig ? boost::any(tunnelIkeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tunnelIpsecConfig) {
      res["TunnelIpsecConfig"] = tunnelIpsecConfig ? boost::any(tunnelIpsecConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableDpd") != m.end() && !m["EnableDpd"].empty()) {
      enableDpd = make_shared<bool>(boost::any_cast<bool>(m["EnableDpd"]));
    }
    if (m.find("EnableNatTraversal") != m.end() && !m["EnableNatTraversal"].empty()) {
      enableNatTraversal = make_shared<bool>(boost::any_cast<bool>(m["EnableNatTraversal"]));
    }
    if (m.find("RemoteCaCertificate") != m.end() && !m["RemoteCaCertificate"].empty()) {
      remoteCaCertificate = make_shared<string>(boost::any_cast<string>(m["RemoteCaCertificate"]));
    }
    if (m.find("TunnelBgpConfig") != m.end() && !m["TunnelBgpConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelBgpConfig"].type()) {
        ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelBgpConfig"]));
        tunnelBgpConfig = make_shared<ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig>(model1);
      }
    }
    if (m.find("TunnelIkeConfig") != m.end() && !m["TunnelIkeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelIkeConfig"].type()) {
        ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelIkeConfig"]));
        tunnelIkeConfig = make_shared<ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig>(model1);
      }
    }
    if (m.find("TunnelIpsecConfig") != m.end() && !m["TunnelIpsecConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelIpsecConfig"].type()) {
        ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelIpsecConfig"]));
        tunnelIpsecConfig = make_shared<ModifyTunnelAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig>(model1);
      }
    }
  }


  virtual ~ModifyTunnelAttributeRequestTunnelOptionsSpecification() = default;
};
class ModifyTunnelAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> tunnelId{};
  shared_ptr<ModifyTunnelAttributeRequestTunnelOptionsSpecification> tunnelOptionsSpecification{};
  shared_ptr<string> vpnConnectionId{};

  ModifyTunnelAttributeRequest() {}

  explicit ModifyTunnelAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tunnelId) {
      res["TunnelId"] = boost::any(*tunnelId);
    }
    if (tunnelOptionsSpecification) {
      res["TunnelOptionsSpecification"] = tunnelOptionsSpecification ? boost::any(tunnelOptionsSpecification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TunnelId") != m.end() && !m["TunnelId"].empty()) {
      tunnelId = make_shared<string>(boost::any_cast<string>(m["TunnelId"]));
    }
    if (m.find("TunnelOptionsSpecification") != m.end() && !m["TunnelOptionsSpecification"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelOptionsSpecification"].type()) {
        ModifyTunnelAttributeRequestTunnelOptionsSpecification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelOptionsSpecification"]));
        tunnelOptionsSpecification = make_shared<ModifyTunnelAttributeRequestTunnelOptionsSpecification>(model1);
      }
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
  }


  virtual ~ModifyTunnelAttributeRequest() = default;
};
class ModifyTunnelAttributeResponseBodyTunnelBgpConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enableBgp{};
  shared_ptr<long> localAsn{};
  shared_ptr<string> localBgpIp{};
  shared_ptr<long> peerAsn{};
  shared_ptr<string> peerBgpIp{};
  shared_ptr<string> tunnelCidr{};

  ModifyTunnelAttributeResponseBodyTunnelBgpConfig() {}

  explicit ModifyTunnelAttributeResponseBodyTunnelBgpConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableBgp) {
      res["EnableBgp"] = boost::any(*enableBgp);
    }
    if (localAsn) {
      res["LocalAsn"] = boost::any(*localAsn);
    }
    if (localBgpIp) {
      res["LocalBgpIp"] = boost::any(*localBgpIp);
    }
    if (peerAsn) {
      res["PeerAsn"] = boost::any(*peerAsn);
    }
    if (peerBgpIp) {
      res["PeerBgpIp"] = boost::any(*peerBgpIp);
    }
    if (tunnelCidr) {
      res["TunnelCidr"] = boost::any(*tunnelCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableBgp") != m.end() && !m["EnableBgp"].empty()) {
      enableBgp = make_shared<bool>(boost::any_cast<bool>(m["EnableBgp"]));
    }
    if (m.find("LocalAsn") != m.end() && !m["LocalAsn"].empty()) {
      localAsn = make_shared<long>(boost::any_cast<long>(m["LocalAsn"]));
    }
    if (m.find("LocalBgpIp") != m.end() && !m["LocalBgpIp"].empty()) {
      localBgpIp = make_shared<string>(boost::any_cast<string>(m["LocalBgpIp"]));
    }
    if (m.find("PeerAsn") != m.end() && !m["PeerAsn"].empty()) {
      peerAsn = make_shared<long>(boost::any_cast<long>(m["PeerAsn"]));
    }
    if (m.find("PeerBgpIp") != m.end() && !m["PeerBgpIp"].empty()) {
      peerBgpIp = make_shared<string>(boost::any_cast<string>(m["PeerBgpIp"]));
    }
    if (m.find("TunnelCidr") != m.end() && !m["TunnelCidr"].empty()) {
      tunnelCidr = make_shared<string>(boost::any_cast<string>(m["TunnelCidr"]));
    }
  }


  virtual ~ModifyTunnelAttributeResponseBodyTunnelBgpConfig() = default;
};
class ModifyTunnelAttributeResponseBodyTunnelIkeConfig : public Darabonba::Model {
public:
  shared_ptr<string> ikeAuthAlg{};
  shared_ptr<string> ikeEncAlg{};
  shared_ptr<long> ikeLifetime{};
  shared_ptr<string> ikeMode{};
  shared_ptr<string> ikePfs{};
  shared_ptr<string> ikeVersion{};
  shared_ptr<string> localId{};
  shared_ptr<string> psk{};
  shared_ptr<string> remoteId{};

  ModifyTunnelAttributeResponseBodyTunnelIkeConfig() {}

  explicit ModifyTunnelAttributeResponseBodyTunnelIkeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ikeAuthAlg) {
      res["IkeAuthAlg"] = boost::any(*ikeAuthAlg);
    }
    if (ikeEncAlg) {
      res["IkeEncAlg"] = boost::any(*ikeEncAlg);
    }
    if (ikeLifetime) {
      res["IkeLifetime"] = boost::any(*ikeLifetime);
    }
    if (ikeMode) {
      res["IkeMode"] = boost::any(*ikeMode);
    }
    if (ikePfs) {
      res["IkePfs"] = boost::any(*ikePfs);
    }
    if (ikeVersion) {
      res["IkeVersion"] = boost::any(*ikeVersion);
    }
    if (localId) {
      res["LocalId"] = boost::any(*localId);
    }
    if (psk) {
      res["Psk"] = boost::any(*psk);
    }
    if (remoteId) {
      res["RemoteId"] = boost::any(*remoteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IkeAuthAlg") != m.end() && !m["IkeAuthAlg"].empty()) {
      ikeAuthAlg = make_shared<string>(boost::any_cast<string>(m["IkeAuthAlg"]));
    }
    if (m.find("IkeEncAlg") != m.end() && !m["IkeEncAlg"].empty()) {
      ikeEncAlg = make_shared<string>(boost::any_cast<string>(m["IkeEncAlg"]));
    }
    if (m.find("IkeLifetime") != m.end() && !m["IkeLifetime"].empty()) {
      ikeLifetime = make_shared<long>(boost::any_cast<long>(m["IkeLifetime"]));
    }
    if (m.find("IkeMode") != m.end() && !m["IkeMode"].empty()) {
      ikeMode = make_shared<string>(boost::any_cast<string>(m["IkeMode"]));
    }
    if (m.find("IkePfs") != m.end() && !m["IkePfs"].empty()) {
      ikePfs = make_shared<string>(boost::any_cast<string>(m["IkePfs"]));
    }
    if (m.find("IkeVersion") != m.end() && !m["IkeVersion"].empty()) {
      ikeVersion = make_shared<string>(boost::any_cast<string>(m["IkeVersion"]));
    }
    if (m.find("LocalId") != m.end() && !m["LocalId"].empty()) {
      localId = make_shared<string>(boost::any_cast<string>(m["LocalId"]));
    }
    if (m.find("Psk") != m.end() && !m["Psk"].empty()) {
      psk = make_shared<string>(boost::any_cast<string>(m["Psk"]));
    }
    if (m.find("RemoteId") != m.end() && !m["RemoteId"].empty()) {
      remoteId = make_shared<string>(boost::any_cast<string>(m["RemoteId"]));
    }
  }


  virtual ~ModifyTunnelAttributeResponseBodyTunnelIkeConfig() = default;
};
class ModifyTunnelAttributeResponseBodyTunnelIpsecConfig : public Darabonba::Model {
public:
  shared_ptr<string> ipsecAuthAlg{};
  shared_ptr<string> ipsecEncAlg{};
  shared_ptr<long> ipsecLifetime{};
  shared_ptr<string> ipsecPfs{};

  ModifyTunnelAttributeResponseBodyTunnelIpsecConfig() {}

  explicit ModifyTunnelAttributeResponseBodyTunnelIpsecConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipsecAuthAlg) {
      res["IpsecAuthAlg"] = boost::any(*ipsecAuthAlg);
    }
    if (ipsecEncAlg) {
      res["IpsecEncAlg"] = boost::any(*ipsecEncAlg);
    }
    if (ipsecLifetime) {
      res["IpsecLifetime"] = boost::any(*ipsecLifetime);
    }
    if (ipsecPfs) {
      res["IpsecPfs"] = boost::any(*ipsecPfs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpsecAuthAlg") != m.end() && !m["IpsecAuthAlg"].empty()) {
      ipsecAuthAlg = make_shared<string>(boost::any_cast<string>(m["IpsecAuthAlg"]));
    }
    if (m.find("IpsecEncAlg") != m.end() && !m["IpsecEncAlg"].empty()) {
      ipsecEncAlg = make_shared<string>(boost::any_cast<string>(m["IpsecEncAlg"]));
    }
    if (m.find("IpsecLifetime") != m.end() && !m["IpsecLifetime"].empty()) {
      ipsecLifetime = make_shared<long>(boost::any_cast<long>(m["IpsecLifetime"]));
    }
    if (m.find("IpsecPfs") != m.end() && !m["IpsecPfs"].empty()) {
      ipsecPfs = make_shared<string>(boost::any_cast<string>(m["IpsecPfs"]));
    }
  }


  virtual ~ModifyTunnelAttributeResponseBodyTunnelIpsecConfig() = default;
};
class ModifyTunnelAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> customerGatewayId{};
  shared_ptr<bool> enableDpd{};
  shared_ptr<bool> enableNatTraversal{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> remoteCaCertificate{};
  shared_ptr<string> requestId{};
  shared_ptr<string> role{};
  shared_ptr<string> state{};
  shared_ptr<ModifyTunnelAttributeResponseBodyTunnelBgpConfig> tunnelBgpConfig{};
  shared_ptr<string> tunnelId{};
  shared_ptr<ModifyTunnelAttributeResponseBodyTunnelIkeConfig> tunnelIkeConfig{};
  shared_ptr<ModifyTunnelAttributeResponseBodyTunnelIpsecConfig> tunnelIpsecConfig{};
  shared_ptr<string> zoneNo{};

  ModifyTunnelAttributeResponseBody() {}

  explicit ModifyTunnelAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (enableDpd) {
      res["EnableDpd"] = boost::any(*enableDpd);
    }
    if (enableNatTraversal) {
      res["EnableNatTraversal"] = boost::any(*enableNatTraversal);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (remoteCaCertificate) {
      res["RemoteCaCertificate"] = boost::any(*remoteCaCertificate);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tunnelBgpConfig) {
      res["TunnelBgpConfig"] = tunnelBgpConfig ? boost::any(tunnelBgpConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tunnelId) {
      res["TunnelId"] = boost::any(*tunnelId);
    }
    if (tunnelIkeConfig) {
      res["TunnelIkeConfig"] = tunnelIkeConfig ? boost::any(tunnelIkeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tunnelIpsecConfig) {
      res["TunnelIpsecConfig"] = tunnelIpsecConfig ? boost::any(tunnelIpsecConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (zoneNo) {
      res["ZoneNo"] = boost::any(*zoneNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("EnableDpd") != m.end() && !m["EnableDpd"].empty()) {
      enableDpd = make_shared<bool>(boost::any_cast<bool>(m["EnableDpd"]));
    }
    if (m.find("EnableNatTraversal") != m.end() && !m["EnableNatTraversal"].empty()) {
      enableNatTraversal = make_shared<bool>(boost::any_cast<bool>(m["EnableNatTraversal"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("RemoteCaCertificate") != m.end() && !m["RemoteCaCertificate"].empty()) {
      remoteCaCertificate = make_shared<string>(boost::any_cast<string>(m["RemoteCaCertificate"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TunnelBgpConfig") != m.end() && !m["TunnelBgpConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelBgpConfig"].type()) {
        ModifyTunnelAttributeResponseBodyTunnelBgpConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelBgpConfig"]));
        tunnelBgpConfig = make_shared<ModifyTunnelAttributeResponseBodyTunnelBgpConfig>(model1);
      }
    }
    if (m.find("TunnelId") != m.end() && !m["TunnelId"].empty()) {
      tunnelId = make_shared<string>(boost::any_cast<string>(m["TunnelId"]));
    }
    if (m.find("TunnelIkeConfig") != m.end() && !m["TunnelIkeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelIkeConfig"].type()) {
        ModifyTunnelAttributeResponseBodyTunnelIkeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelIkeConfig"]));
        tunnelIkeConfig = make_shared<ModifyTunnelAttributeResponseBodyTunnelIkeConfig>(model1);
      }
    }
    if (m.find("TunnelIpsecConfig") != m.end() && !m["TunnelIpsecConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelIpsecConfig"].type()) {
        ModifyTunnelAttributeResponseBodyTunnelIpsecConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelIpsecConfig"]));
        tunnelIpsecConfig = make_shared<ModifyTunnelAttributeResponseBodyTunnelIpsecConfig>(model1);
      }
    }
    if (m.find("ZoneNo") != m.end() && !m["ZoneNo"].empty()) {
      zoneNo = make_shared<string>(boost::any_cast<string>(m["ZoneNo"]));
    }
  }


  virtual ~ModifyTunnelAttributeResponseBody() = default;
};
class ModifyTunnelAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTunnelAttributeResponseBody> body{};

  ModifyTunnelAttributeResponse() {}

  explicit ModifyTunnelAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTunnelAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTunnelAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTunnelAttributeResponse() = default;
};
class ModifyVRouterAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> VRouterId{};
  shared_ptr<string> VRouterName{};

  ModifyVRouterAttributeRequest() {}

  explicit ModifyVRouterAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (VRouterId) {
      res["VRouterId"] = boost::any(*VRouterId);
    }
    if (VRouterName) {
      res["VRouterName"] = boost::any(*VRouterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VRouterId") != m.end() && !m["VRouterId"].empty()) {
      VRouterId = make_shared<string>(boost::any_cast<string>(m["VRouterId"]));
    }
    if (m.find("VRouterName") != m.end() && !m["VRouterName"].empty()) {
      VRouterName = make_shared<string>(boost::any_cast<string>(m["VRouterName"]));
    }
  }


  virtual ~ModifyVRouterAttributeRequest() = default;
};
class ModifyVRouterAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVRouterAttributeResponseBody() {}

  explicit ModifyVRouterAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVRouterAttributeResponseBody() = default;
};
class ModifyVRouterAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVRouterAttributeResponseBody> body{};

  ModifyVRouterAttributeResponse() {}

  explicit ModifyVRouterAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVRouterAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVRouterAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVRouterAttributeResponse() = default;
};
class ModifyVSwitchAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<bool> enableIPv6{};
  shared_ptr<long> ipv6CidrBlock{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vSwitchName{};
  shared_ptr<string> vpcIpv6CidrBlock{};

  ModifyVSwitchAttributeRequest() {}

  explicit ModifyVSwitchAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enableIPv6) {
      res["EnableIPv6"] = boost::any(*enableIPv6);
    }
    if (ipv6CidrBlock) {
      res["Ipv6CidrBlock"] = boost::any(*ipv6CidrBlock);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchName) {
      res["VSwitchName"] = boost::any(*vSwitchName);
    }
    if (vpcIpv6CidrBlock) {
      res["VpcIpv6CidrBlock"] = boost::any(*vpcIpv6CidrBlock);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnableIPv6") != m.end() && !m["EnableIPv6"].empty()) {
      enableIPv6 = make_shared<bool>(boost::any_cast<bool>(m["EnableIPv6"]));
    }
    if (m.find("Ipv6CidrBlock") != m.end() && !m["Ipv6CidrBlock"].empty()) {
      ipv6CidrBlock = make_shared<long>(boost::any_cast<long>(m["Ipv6CidrBlock"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchName") != m.end() && !m["VSwitchName"].empty()) {
      vSwitchName = make_shared<string>(boost::any_cast<string>(m["VSwitchName"]));
    }
    if (m.find("VpcIpv6CidrBlock") != m.end() && !m["VpcIpv6CidrBlock"].empty()) {
      vpcIpv6CidrBlock = make_shared<string>(boost::any_cast<string>(m["VpcIpv6CidrBlock"]));
    }
  }


  virtual ~ModifyVSwitchAttributeRequest() = default;
};
class ModifyVSwitchAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVSwitchAttributeResponseBody() {}

  explicit ModifyVSwitchAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVSwitchAttributeResponseBody() = default;
};
class ModifyVSwitchAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVSwitchAttributeResponseBody> body{};

  ModifyVSwitchAttributeResponse() {}

  explicit ModifyVSwitchAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVSwitchAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVSwitchAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVSwitchAttributeResponse() = default;
};
class ModifyVSwitchCidrReservationAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vSwitchCidrReservationDescription{};
  shared_ptr<string> vSwitchCidrReservationId{};
  shared_ptr<string> vSwitchCidrReservationName{};

  ModifyVSwitchCidrReservationAttributeRequest() {}

  explicit ModifyVSwitchCidrReservationAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vSwitchCidrReservationDescription) {
      res["VSwitchCidrReservationDescription"] = boost::any(*vSwitchCidrReservationDescription);
    }
    if (vSwitchCidrReservationId) {
      res["VSwitchCidrReservationId"] = boost::any(*vSwitchCidrReservationId);
    }
    if (vSwitchCidrReservationName) {
      res["VSwitchCidrReservationName"] = boost::any(*vSwitchCidrReservationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VSwitchCidrReservationDescription") != m.end() && !m["VSwitchCidrReservationDescription"].empty()) {
      vSwitchCidrReservationDescription = make_shared<string>(boost::any_cast<string>(m["VSwitchCidrReservationDescription"]));
    }
    if (m.find("VSwitchCidrReservationId") != m.end() && !m["VSwitchCidrReservationId"].empty()) {
      vSwitchCidrReservationId = make_shared<string>(boost::any_cast<string>(m["VSwitchCidrReservationId"]));
    }
    if (m.find("VSwitchCidrReservationName") != m.end() && !m["VSwitchCidrReservationName"].empty()) {
      vSwitchCidrReservationName = make_shared<string>(boost::any_cast<string>(m["VSwitchCidrReservationName"]));
    }
  }


  virtual ~ModifyVSwitchCidrReservationAttributeRequest() = default;
};
class ModifyVSwitchCidrReservationAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVSwitchCidrReservationAttributeResponseBody() {}

  explicit ModifyVSwitchCidrReservationAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVSwitchCidrReservationAttributeResponseBody() = default;
};
class ModifyVSwitchCidrReservationAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVSwitchCidrReservationAttributeResponseBody> body{};

  ModifyVSwitchCidrReservationAttributeResponse() {}

  explicit ModifyVSwitchCidrReservationAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVSwitchCidrReservationAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVSwitchCidrReservationAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVSwitchCidrReservationAttributeResponse() = default;
};
class ModifyVcoRouteEntryWeightRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> newWeight{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> overlayMode{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeDest{};
  shared_ptr<string> vpnConnectionId{};
  shared_ptr<long> weight{};

  ModifyVcoRouteEntryWeightRequest() {}

  explicit ModifyVcoRouteEntryWeightRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (newWeight) {
      res["NewWeight"] = boost::any(*newWeight);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (overlayMode) {
      res["OverlayMode"] = boost::any(*overlayMode);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeDest) {
      res["RouteDest"] = boost::any(*routeDest);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("NewWeight") != m.end() && !m["NewWeight"].empty()) {
      newWeight = make_shared<long>(boost::any_cast<long>(m["NewWeight"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("OverlayMode") != m.end() && !m["OverlayMode"].empty()) {
      overlayMode = make_shared<string>(boost::any_cast<string>(m["OverlayMode"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteDest") != m.end() && !m["RouteDest"].empty()) {
      routeDest = make_shared<string>(boost::any_cast<string>(m["RouteDest"]));
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~ModifyVcoRouteEntryWeightRequest() = default;
};
class ModifyVcoRouteEntryWeightResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVcoRouteEntryWeightResponseBody() {}

  explicit ModifyVcoRouteEntryWeightResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVcoRouteEntryWeightResponseBody() = default;
};
class ModifyVcoRouteEntryWeightResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVcoRouteEntryWeightResponseBody> body{};

  ModifyVcoRouteEntryWeightResponse() {}

  explicit ModifyVcoRouteEntryWeightResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVcoRouteEntryWeightResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVcoRouteEntryWeightResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVcoRouteEntryWeightResponse() = default;
};
class ModifyVirtualBorderRouterAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> associatedPhysicalConnections{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> circuitCode{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<long> detectMultiplier{};
  shared_ptr<bool> enableIpv6{};
  shared_ptr<string> localGatewayIp{};
  shared_ptr<string> localIpv6GatewayIp{};
  shared_ptr<long> minRxInterval{};
  shared_ptr<long> minTxInterval{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> peerGatewayIp{};
  shared_ptr<string> peerIpv6GatewayIp{};
  shared_ptr<string> peeringIpv6SubnetMask{};
  shared_ptr<string> peeringSubnetMask{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<bool> sitelinkEnable{};
  shared_ptr<string> vbrId{};
  shared_ptr<long> vlanId{};

  ModifyVirtualBorderRouterAttributeRequest() {}

  explicit ModifyVirtualBorderRouterAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associatedPhysicalConnections) {
      res["AssociatedPhysicalConnections"] = boost::any(*associatedPhysicalConnections);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (circuitCode) {
      res["CircuitCode"] = boost::any(*circuitCode);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (detectMultiplier) {
      res["DetectMultiplier"] = boost::any(*detectMultiplier);
    }
    if (enableIpv6) {
      res["EnableIpv6"] = boost::any(*enableIpv6);
    }
    if (localGatewayIp) {
      res["LocalGatewayIp"] = boost::any(*localGatewayIp);
    }
    if (localIpv6GatewayIp) {
      res["LocalIpv6GatewayIp"] = boost::any(*localIpv6GatewayIp);
    }
    if (minRxInterval) {
      res["MinRxInterval"] = boost::any(*minRxInterval);
    }
    if (minTxInterval) {
      res["MinTxInterval"] = boost::any(*minTxInterval);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (peerGatewayIp) {
      res["PeerGatewayIp"] = boost::any(*peerGatewayIp);
    }
    if (peerIpv6GatewayIp) {
      res["PeerIpv6GatewayIp"] = boost::any(*peerIpv6GatewayIp);
    }
    if (peeringIpv6SubnetMask) {
      res["PeeringIpv6SubnetMask"] = boost::any(*peeringIpv6SubnetMask);
    }
    if (peeringSubnetMask) {
      res["PeeringSubnetMask"] = boost::any(*peeringSubnetMask);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sitelinkEnable) {
      res["SitelinkEnable"] = boost::any(*sitelinkEnable);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    if (vlanId) {
      res["VlanId"] = boost::any(*vlanId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssociatedPhysicalConnections") != m.end() && !m["AssociatedPhysicalConnections"].empty()) {
      associatedPhysicalConnections = make_shared<string>(boost::any_cast<string>(m["AssociatedPhysicalConnections"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("CircuitCode") != m.end() && !m["CircuitCode"].empty()) {
      circuitCode = make_shared<string>(boost::any_cast<string>(m["CircuitCode"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DetectMultiplier") != m.end() && !m["DetectMultiplier"].empty()) {
      detectMultiplier = make_shared<long>(boost::any_cast<long>(m["DetectMultiplier"]));
    }
    if (m.find("EnableIpv6") != m.end() && !m["EnableIpv6"].empty()) {
      enableIpv6 = make_shared<bool>(boost::any_cast<bool>(m["EnableIpv6"]));
    }
    if (m.find("LocalGatewayIp") != m.end() && !m["LocalGatewayIp"].empty()) {
      localGatewayIp = make_shared<string>(boost::any_cast<string>(m["LocalGatewayIp"]));
    }
    if (m.find("LocalIpv6GatewayIp") != m.end() && !m["LocalIpv6GatewayIp"].empty()) {
      localIpv6GatewayIp = make_shared<string>(boost::any_cast<string>(m["LocalIpv6GatewayIp"]));
    }
    if (m.find("MinRxInterval") != m.end() && !m["MinRxInterval"].empty()) {
      minRxInterval = make_shared<long>(boost::any_cast<long>(m["MinRxInterval"]));
    }
    if (m.find("MinTxInterval") != m.end() && !m["MinTxInterval"].empty()) {
      minTxInterval = make_shared<long>(boost::any_cast<long>(m["MinTxInterval"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PeerGatewayIp") != m.end() && !m["PeerGatewayIp"].empty()) {
      peerGatewayIp = make_shared<string>(boost::any_cast<string>(m["PeerGatewayIp"]));
    }
    if (m.find("PeerIpv6GatewayIp") != m.end() && !m["PeerIpv6GatewayIp"].empty()) {
      peerIpv6GatewayIp = make_shared<string>(boost::any_cast<string>(m["PeerIpv6GatewayIp"]));
    }
    if (m.find("PeeringIpv6SubnetMask") != m.end() && !m["PeeringIpv6SubnetMask"].empty()) {
      peeringIpv6SubnetMask = make_shared<string>(boost::any_cast<string>(m["PeeringIpv6SubnetMask"]));
    }
    if (m.find("PeeringSubnetMask") != m.end() && !m["PeeringSubnetMask"].empty()) {
      peeringSubnetMask = make_shared<string>(boost::any_cast<string>(m["PeeringSubnetMask"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SitelinkEnable") != m.end() && !m["SitelinkEnable"].empty()) {
      sitelinkEnable = make_shared<bool>(boost::any_cast<bool>(m["SitelinkEnable"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
    if (m.find("VlanId") != m.end() && !m["VlanId"].empty()) {
      vlanId = make_shared<long>(boost::any_cast<long>(m["VlanId"]));
    }
  }


  virtual ~ModifyVirtualBorderRouterAttributeRequest() = default;
};
class ModifyVirtualBorderRouterAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVirtualBorderRouterAttributeResponseBody() {}

  explicit ModifyVirtualBorderRouterAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVirtualBorderRouterAttributeResponseBody() = default;
};
class ModifyVirtualBorderRouterAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVirtualBorderRouterAttributeResponseBody> body{};

  ModifyVirtualBorderRouterAttributeResponse() {}

  explicit ModifyVirtualBorderRouterAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVirtualBorderRouterAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVirtualBorderRouterAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVirtualBorderRouterAttributeResponse() = default;
};
class ModifyVpcAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> description{};
  shared_ptr<bool> enableIPv6{};
  shared_ptr<string> ipv6CidrBlock{};
  shared_ptr<string> ipv6Isp{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcName{};

  ModifyVpcAttributeRequest() {}

  explicit ModifyVpcAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enableIPv6) {
      res["EnableIPv6"] = boost::any(*enableIPv6);
    }
    if (ipv6CidrBlock) {
      res["Ipv6CidrBlock"] = boost::any(*ipv6CidrBlock);
    }
    if (ipv6Isp) {
      res["Ipv6Isp"] = boost::any(*ipv6Isp);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnableIPv6") != m.end() && !m["EnableIPv6"].empty()) {
      enableIPv6 = make_shared<bool>(boost::any_cast<bool>(m["EnableIPv6"]));
    }
    if (m.find("Ipv6CidrBlock") != m.end() && !m["Ipv6CidrBlock"].empty()) {
      ipv6CidrBlock = make_shared<string>(boost::any_cast<string>(m["Ipv6CidrBlock"]));
    }
    if (m.find("Ipv6Isp") != m.end() && !m["Ipv6Isp"].empty()) {
      ipv6Isp = make_shared<string>(boost::any_cast<string>(m["Ipv6Isp"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
  }


  virtual ~ModifyVpcAttributeRequest() = default;
};
class ModifyVpcAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVpcAttributeResponseBody() {}

  explicit ModifyVpcAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVpcAttributeResponseBody() = default;
};
class ModifyVpcAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVpcAttributeResponseBody> body{};

  ModifyVpcAttributeResponse() {}

  explicit ModifyVpcAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVpcAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVpcAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVpcAttributeResponse() = default;
};
class ModifyVpcPrefixListRequestAddPrefixListEntry : public Darabonba::Model {
public:
  shared_ptr<string> cidr{};
  shared_ptr<string> description{};

  ModifyVpcPrefixListRequestAddPrefixListEntry() {}

  explicit ModifyVpcPrefixListRequestAddPrefixListEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidr) {
      res["Cidr"] = boost::any(*cidr);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cidr") != m.end() && !m["Cidr"].empty()) {
      cidr = make_shared<string>(boost::any_cast<string>(m["Cidr"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ModifyVpcPrefixListRequestAddPrefixListEntry() = default;
};
class ModifyVpcPrefixListRequestRemovePrefixListEntry : public Darabonba::Model {
public:
  shared_ptr<string> cidr{};
  shared_ptr<string> description{};

  ModifyVpcPrefixListRequestRemovePrefixListEntry() {}

  explicit ModifyVpcPrefixListRequestRemovePrefixListEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidr) {
      res["Cidr"] = boost::any(*cidr);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cidr") != m.end() && !m["Cidr"].empty()) {
      cidr = make_shared<string>(boost::any_cast<string>(m["Cidr"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~ModifyVpcPrefixListRequestRemovePrefixListEntry() = default;
};
class ModifyVpcPrefixListRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyVpcPrefixListRequestAddPrefixListEntry>> addPrefixListEntry{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<long> maxEntries{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prefixListDescription{};
  shared_ptr<string> prefixListId{};
  shared_ptr<string> prefixListName{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<ModifyVpcPrefixListRequestRemovePrefixListEntry>> removePrefixListEntry{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ModifyVpcPrefixListRequest() {}

  explicit ModifyVpcPrefixListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addPrefixListEntry) {
      vector<boost::any> temp1;
      for(auto item1:*addPrefixListEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddPrefixListEntry"] = boost::any(temp1);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (maxEntries) {
      res["MaxEntries"] = boost::any(*maxEntries);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prefixListDescription) {
      res["PrefixListDescription"] = boost::any(*prefixListDescription);
    }
    if (prefixListId) {
      res["PrefixListId"] = boost::any(*prefixListId);
    }
    if (prefixListName) {
      res["PrefixListName"] = boost::any(*prefixListName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (removePrefixListEntry) {
      vector<boost::any> temp1;
      for(auto item1:*removePrefixListEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RemovePrefixListEntry"] = boost::any(temp1);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddPrefixListEntry") != m.end() && !m["AddPrefixListEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["AddPrefixListEntry"].type()) {
        vector<ModifyVpcPrefixListRequestAddPrefixListEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddPrefixListEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyVpcPrefixListRequestAddPrefixListEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addPrefixListEntry = make_shared<vector<ModifyVpcPrefixListRequestAddPrefixListEntry>>(expect1);
      }
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("MaxEntries") != m.end() && !m["MaxEntries"].empty()) {
      maxEntries = make_shared<long>(boost::any_cast<long>(m["MaxEntries"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PrefixListDescription") != m.end() && !m["PrefixListDescription"].empty()) {
      prefixListDescription = make_shared<string>(boost::any_cast<string>(m["PrefixListDescription"]));
    }
    if (m.find("PrefixListId") != m.end() && !m["PrefixListId"].empty()) {
      prefixListId = make_shared<string>(boost::any_cast<string>(m["PrefixListId"]));
    }
    if (m.find("PrefixListName") != m.end() && !m["PrefixListName"].empty()) {
      prefixListName = make_shared<string>(boost::any_cast<string>(m["PrefixListName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemovePrefixListEntry") != m.end() && !m["RemovePrefixListEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["RemovePrefixListEntry"].type()) {
        vector<ModifyVpcPrefixListRequestRemovePrefixListEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RemovePrefixListEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyVpcPrefixListRequestRemovePrefixListEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        removePrefixListEntry = make_shared<vector<ModifyVpcPrefixListRequestRemovePrefixListEntry>>(expect1);
      }
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyVpcPrefixListRequest() = default;
};
class ModifyVpcPrefixListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> prefixListId{};
  shared_ptr<string> requestId{};

  ModifyVpcPrefixListResponseBody() {}

  explicit ModifyVpcPrefixListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prefixListId) {
      res["PrefixListId"] = boost::any(*prefixListId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrefixListId") != m.end() && !m["PrefixListId"].empty()) {
      prefixListId = make_shared<string>(boost::any_cast<string>(m["PrefixListId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVpcPrefixListResponseBody() = default;
};
class ModifyVpcPrefixListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVpcPrefixListResponseBody> body{};

  ModifyVpcPrefixListResponse() {}

  explicit ModifyVpcPrefixListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVpcPrefixListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVpcPrefixListResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVpcPrefixListResponse() = default;
};
class ModifyVpnAttachmentAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoConfigRoute{};
  shared_ptr<string> bgpConfig{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> customerGatewayId{};
  shared_ptr<bool> effectImmediately{};
  shared_ptr<bool> enableDpd{};
  shared_ptr<bool> enableNatTraversal{};
  shared_ptr<string> healthCheckConfig{};
  shared_ptr<string> ikeConfig{};
  shared_ptr<string> ipsecConfig{};
  shared_ptr<string> localSubnet{};
  shared_ptr<string> name{};
  shared_ptr<string> networkType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> remoteCaCert{};
  shared_ptr<string> remoteSubnet{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpnConnectionId{};

  ModifyVpnAttachmentAttributeRequest() {}

  explicit ModifyVpnAttachmentAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoConfigRoute) {
      res["AutoConfigRoute"] = boost::any(*autoConfigRoute);
    }
    if (bgpConfig) {
      res["BgpConfig"] = boost::any(*bgpConfig);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (effectImmediately) {
      res["EffectImmediately"] = boost::any(*effectImmediately);
    }
    if (enableDpd) {
      res["EnableDpd"] = boost::any(*enableDpd);
    }
    if (enableNatTraversal) {
      res["EnableNatTraversal"] = boost::any(*enableNatTraversal);
    }
    if (healthCheckConfig) {
      res["HealthCheckConfig"] = boost::any(*healthCheckConfig);
    }
    if (ikeConfig) {
      res["IkeConfig"] = boost::any(*ikeConfig);
    }
    if (ipsecConfig) {
      res["IpsecConfig"] = boost::any(*ipsecConfig);
    }
    if (localSubnet) {
      res["LocalSubnet"] = boost::any(*localSubnet);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (remoteCaCert) {
      res["RemoteCaCert"] = boost::any(*remoteCaCert);
    }
    if (remoteSubnet) {
      res["RemoteSubnet"] = boost::any(*remoteSubnet);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoConfigRoute") != m.end() && !m["AutoConfigRoute"].empty()) {
      autoConfigRoute = make_shared<bool>(boost::any_cast<bool>(m["AutoConfigRoute"]));
    }
    if (m.find("BgpConfig") != m.end() && !m["BgpConfig"].empty()) {
      bgpConfig = make_shared<string>(boost::any_cast<string>(m["BgpConfig"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("EffectImmediately") != m.end() && !m["EffectImmediately"].empty()) {
      effectImmediately = make_shared<bool>(boost::any_cast<bool>(m["EffectImmediately"]));
    }
    if (m.find("EnableDpd") != m.end() && !m["EnableDpd"].empty()) {
      enableDpd = make_shared<bool>(boost::any_cast<bool>(m["EnableDpd"]));
    }
    if (m.find("EnableNatTraversal") != m.end() && !m["EnableNatTraversal"].empty()) {
      enableNatTraversal = make_shared<bool>(boost::any_cast<bool>(m["EnableNatTraversal"]));
    }
    if (m.find("HealthCheckConfig") != m.end() && !m["HealthCheckConfig"].empty()) {
      healthCheckConfig = make_shared<string>(boost::any_cast<string>(m["HealthCheckConfig"]));
    }
    if (m.find("IkeConfig") != m.end() && !m["IkeConfig"].empty()) {
      ikeConfig = make_shared<string>(boost::any_cast<string>(m["IkeConfig"]));
    }
    if (m.find("IpsecConfig") != m.end() && !m["IpsecConfig"].empty()) {
      ipsecConfig = make_shared<string>(boost::any_cast<string>(m["IpsecConfig"]));
    }
    if (m.find("LocalSubnet") != m.end() && !m["LocalSubnet"].empty()) {
      localSubnet = make_shared<string>(boost::any_cast<string>(m["LocalSubnet"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemoteCaCert") != m.end() && !m["RemoteCaCert"].empty()) {
      remoteCaCert = make_shared<string>(boost::any_cast<string>(m["RemoteCaCert"]));
    }
    if (m.find("RemoteSubnet") != m.end() && !m["RemoteSubnet"].empty()) {
      remoteSubnet = make_shared<string>(boost::any_cast<string>(m["RemoteSubnet"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
  }


  virtual ~ModifyVpnAttachmentAttributeRequest() = default;
};
class ModifyVpnAttachmentAttributeResponseBodyIkeConfig : public Darabonba::Model {
public:
  shared_ptr<string> ikeAuthAlg{};
  shared_ptr<string> ikeEncAlg{};
  shared_ptr<long> ikeLifetime{};
  shared_ptr<string> ikeMode{};
  shared_ptr<string> ikePfs{};
  shared_ptr<string> ikeVersion{};
  shared_ptr<string> localId{};
  shared_ptr<string> psk{};
  shared_ptr<string> remoteId{};

  ModifyVpnAttachmentAttributeResponseBodyIkeConfig() {}

  explicit ModifyVpnAttachmentAttributeResponseBodyIkeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ikeAuthAlg) {
      res["IkeAuthAlg"] = boost::any(*ikeAuthAlg);
    }
    if (ikeEncAlg) {
      res["IkeEncAlg"] = boost::any(*ikeEncAlg);
    }
    if (ikeLifetime) {
      res["IkeLifetime"] = boost::any(*ikeLifetime);
    }
    if (ikeMode) {
      res["IkeMode"] = boost::any(*ikeMode);
    }
    if (ikePfs) {
      res["IkePfs"] = boost::any(*ikePfs);
    }
    if (ikeVersion) {
      res["IkeVersion"] = boost::any(*ikeVersion);
    }
    if (localId) {
      res["LocalId"] = boost::any(*localId);
    }
    if (psk) {
      res["Psk"] = boost::any(*psk);
    }
    if (remoteId) {
      res["RemoteId"] = boost::any(*remoteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IkeAuthAlg") != m.end() && !m["IkeAuthAlg"].empty()) {
      ikeAuthAlg = make_shared<string>(boost::any_cast<string>(m["IkeAuthAlg"]));
    }
    if (m.find("IkeEncAlg") != m.end() && !m["IkeEncAlg"].empty()) {
      ikeEncAlg = make_shared<string>(boost::any_cast<string>(m["IkeEncAlg"]));
    }
    if (m.find("IkeLifetime") != m.end() && !m["IkeLifetime"].empty()) {
      ikeLifetime = make_shared<long>(boost::any_cast<long>(m["IkeLifetime"]));
    }
    if (m.find("IkeMode") != m.end() && !m["IkeMode"].empty()) {
      ikeMode = make_shared<string>(boost::any_cast<string>(m["IkeMode"]));
    }
    if (m.find("IkePfs") != m.end() && !m["IkePfs"].empty()) {
      ikePfs = make_shared<string>(boost::any_cast<string>(m["IkePfs"]));
    }
    if (m.find("IkeVersion") != m.end() && !m["IkeVersion"].empty()) {
      ikeVersion = make_shared<string>(boost::any_cast<string>(m["IkeVersion"]));
    }
    if (m.find("LocalId") != m.end() && !m["LocalId"].empty()) {
      localId = make_shared<string>(boost::any_cast<string>(m["LocalId"]));
    }
    if (m.find("Psk") != m.end() && !m["Psk"].empty()) {
      psk = make_shared<string>(boost::any_cast<string>(m["Psk"]));
    }
    if (m.find("RemoteId") != m.end() && !m["RemoteId"].empty()) {
      remoteId = make_shared<string>(boost::any_cast<string>(m["RemoteId"]));
    }
  }


  virtual ~ModifyVpnAttachmentAttributeResponseBodyIkeConfig() = default;
};
class ModifyVpnAttachmentAttributeResponseBodyIpsecConfig : public Darabonba::Model {
public:
  shared_ptr<string> ipsecAuthAlg{};
  shared_ptr<string> ipsecEncAlg{};
  shared_ptr<long> ipsecLifetime{};
  shared_ptr<string> ipsecPfs{};

  ModifyVpnAttachmentAttributeResponseBodyIpsecConfig() {}

  explicit ModifyVpnAttachmentAttributeResponseBodyIpsecConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipsecAuthAlg) {
      res["IpsecAuthAlg"] = boost::any(*ipsecAuthAlg);
    }
    if (ipsecEncAlg) {
      res["IpsecEncAlg"] = boost::any(*ipsecEncAlg);
    }
    if (ipsecLifetime) {
      res["IpsecLifetime"] = boost::any(*ipsecLifetime);
    }
    if (ipsecPfs) {
      res["IpsecPfs"] = boost::any(*ipsecPfs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpsecAuthAlg") != m.end() && !m["IpsecAuthAlg"].empty()) {
      ipsecAuthAlg = make_shared<string>(boost::any_cast<string>(m["IpsecAuthAlg"]));
    }
    if (m.find("IpsecEncAlg") != m.end() && !m["IpsecEncAlg"].empty()) {
      ipsecEncAlg = make_shared<string>(boost::any_cast<string>(m["IpsecEncAlg"]));
    }
    if (m.find("IpsecLifetime") != m.end() && !m["IpsecLifetime"].empty()) {
      ipsecLifetime = make_shared<long>(boost::any_cast<long>(m["IpsecLifetime"]));
    }
    if (m.find("IpsecPfs") != m.end() && !m["IpsecPfs"].empty()) {
      ipsecPfs = make_shared<string>(boost::any_cast<string>(m["IpsecPfs"]));
    }
  }


  virtual ~ModifyVpnAttachmentAttributeResponseBodyIpsecConfig() = default;
};
class ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck : public Darabonba::Model {
public:
  shared_ptr<string> dip{};
  shared_ptr<string> enable{};
  shared_ptr<long> interval{};
  shared_ptr<string> policy{};
  shared_ptr<long> retry{};
  shared_ptr<string> sip{};

  ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck() {}

  explicit ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dip) {
      res["Dip"] = boost::any(*dip);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (retry) {
      res["Retry"] = boost::any(*retry);
    }
    if (sip) {
      res["Sip"] = boost::any(*sip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dip") != m.end() && !m["Dip"].empty()) {
      dip = make_shared<string>(boost::any_cast<string>(m["Dip"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Retry") != m.end() && !m["Retry"].empty()) {
      retry = make_shared<long>(boost::any_cast<long>(m["Retry"]));
    }
    if (m.find("Sip") != m.end() && !m["Sip"].empty()) {
      sip = make_shared<string>(boost::any_cast<string>(m["Sip"]));
    }
  }


  virtual ~ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck() = default;
};
class ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig : public Darabonba::Model {
public:
  shared_ptr<string> enableBgp{};
  shared_ptr<long> localAsn{};
  shared_ptr<string> localBgpIp{};
  shared_ptr<long> peerAsn{};
  shared_ptr<string> peerBgpIp{};
  shared_ptr<string> status{};
  shared_ptr<string> tunnelCidr{};

  ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig() {}

  explicit ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableBgp) {
      res["EnableBgp"] = boost::any(*enableBgp);
    }
    if (localAsn) {
      res["LocalAsn"] = boost::any(*localAsn);
    }
    if (localBgpIp) {
      res["LocalBgpIp"] = boost::any(*localBgpIp);
    }
    if (peerAsn) {
      res["PeerAsn"] = boost::any(*peerAsn);
    }
    if (peerBgpIp) {
      res["PeerBgpIp"] = boost::any(*peerBgpIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tunnelCidr) {
      res["TunnelCidr"] = boost::any(*tunnelCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableBgp") != m.end() && !m["EnableBgp"].empty()) {
      enableBgp = make_shared<string>(boost::any_cast<string>(m["EnableBgp"]));
    }
    if (m.find("LocalAsn") != m.end() && !m["LocalAsn"].empty()) {
      localAsn = make_shared<long>(boost::any_cast<long>(m["LocalAsn"]));
    }
    if (m.find("LocalBgpIp") != m.end() && !m["LocalBgpIp"].empty()) {
      localBgpIp = make_shared<string>(boost::any_cast<string>(m["LocalBgpIp"]));
    }
    if (m.find("PeerAsn") != m.end() && !m["PeerAsn"].empty()) {
      peerAsn = make_shared<long>(boost::any_cast<long>(m["PeerAsn"]));
    }
    if (m.find("PeerBgpIp") != m.end() && !m["PeerBgpIp"].empty()) {
      peerBgpIp = make_shared<string>(boost::any_cast<string>(m["PeerBgpIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TunnelCidr") != m.end() && !m["TunnelCidr"].empty()) {
      tunnelCidr = make_shared<string>(boost::any_cast<string>(m["TunnelCidr"]));
    }
  }


  virtual ~ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig() = default;
};
class ModifyVpnAttachmentAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> attachInstanceId{};
  shared_ptr<string> attachType{};
  shared_ptr<long> createTime{};
  shared_ptr<string> customerGatewayId{};
  shared_ptr<string> description{};
  shared_ptr<bool> effectImmediately{};
  shared_ptr<bool> enableDpd{};
  shared_ptr<bool> enableNatTraversal{};
  shared_ptr<ModifyVpnAttachmentAttributeResponseBodyIkeConfig> ikeConfig{};
  shared_ptr<ModifyVpnAttachmentAttributeResponseBodyIpsecConfig> ipsecConfig{};
  shared_ptr<string> localSubnet{};
  shared_ptr<string> name{};
  shared_ptr<string> networkType{};
  shared_ptr<string> remoteSubnet{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> spec{};
  shared_ptr<string> status{};
  shared_ptr<ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck> vcoHealthCheck{};
  shared_ptr<ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig> vpnBgpConfig{};
  shared_ptr<string> vpnConnectionId{};
  shared_ptr<string> vpnGatewayId{};

  ModifyVpnAttachmentAttributeResponseBody() {}

  explicit ModifyVpnAttachmentAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachInstanceId) {
      res["AttachInstanceId"] = boost::any(*attachInstanceId);
    }
    if (attachType) {
      res["AttachType"] = boost::any(*attachType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (effectImmediately) {
      res["EffectImmediately"] = boost::any(*effectImmediately);
    }
    if (enableDpd) {
      res["EnableDpd"] = boost::any(*enableDpd);
    }
    if (enableNatTraversal) {
      res["EnableNatTraversal"] = boost::any(*enableNatTraversal);
    }
    if (ikeConfig) {
      res["IkeConfig"] = ikeConfig ? boost::any(ikeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipsecConfig) {
      res["IpsecConfig"] = ipsecConfig ? boost::any(ipsecConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (localSubnet) {
      res["LocalSubnet"] = boost::any(*localSubnet);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (remoteSubnet) {
      res["RemoteSubnet"] = boost::any(*remoteSubnet);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vcoHealthCheck) {
      res["VcoHealthCheck"] = vcoHealthCheck ? boost::any(vcoHealthCheck->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpnBgpConfig) {
      res["VpnBgpConfig"] = vpnBgpConfig ? boost::any(vpnBgpConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachInstanceId") != m.end() && !m["AttachInstanceId"].empty()) {
      attachInstanceId = make_shared<string>(boost::any_cast<string>(m["AttachInstanceId"]));
    }
    if (m.find("AttachType") != m.end() && !m["AttachType"].empty()) {
      attachType = make_shared<string>(boost::any_cast<string>(m["AttachType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EffectImmediately") != m.end() && !m["EffectImmediately"].empty()) {
      effectImmediately = make_shared<bool>(boost::any_cast<bool>(m["EffectImmediately"]));
    }
    if (m.find("EnableDpd") != m.end() && !m["EnableDpd"].empty()) {
      enableDpd = make_shared<bool>(boost::any_cast<bool>(m["EnableDpd"]));
    }
    if (m.find("EnableNatTraversal") != m.end() && !m["EnableNatTraversal"].empty()) {
      enableNatTraversal = make_shared<bool>(boost::any_cast<bool>(m["EnableNatTraversal"]));
    }
    if (m.find("IkeConfig") != m.end() && !m["IkeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IkeConfig"].type()) {
        ModifyVpnAttachmentAttributeResponseBodyIkeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IkeConfig"]));
        ikeConfig = make_shared<ModifyVpnAttachmentAttributeResponseBodyIkeConfig>(model1);
      }
    }
    if (m.find("IpsecConfig") != m.end() && !m["IpsecConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IpsecConfig"].type()) {
        ModifyVpnAttachmentAttributeResponseBodyIpsecConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IpsecConfig"]));
        ipsecConfig = make_shared<ModifyVpnAttachmentAttributeResponseBodyIpsecConfig>(model1);
      }
    }
    if (m.find("LocalSubnet") != m.end() && !m["LocalSubnet"].empty()) {
      localSubnet = make_shared<string>(boost::any_cast<string>(m["LocalSubnet"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("RemoteSubnet") != m.end() && !m["RemoteSubnet"].empty()) {
      remoteSubnet = make_shared<string>(boost::any_cast<string>(m["RemoteSubnet"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VcoHealthCheck") != m.end() && !m["VcoHealthCheck"].empty()) {
      if (typeid(map<string, boost::any>) == m["VcoHealthCheck"].type()) {
        ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VcoHealthCheck"]));
        vcoHealthCheck = make_shared<ModifyVpnAttachmentAttributeResponseBodyVcoHealthCheck>(model1);
      }
    }
    if (m.find("VpnBgpConfig") != m.end() && !m["VpnBgpConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpnBgpConfig"].type()) {
        ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpnBgpConfig"]));
        vpnBgpConfig = make_shared<ModifyVpnAttachmentAttributeResponseBodyVpnBgpConfig>(model1);
      }
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~ModifyVpnAttachmentAttributeResponseBody() = default;
};
class ModifyVpnAttachmentAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVpnAttachmentAttributeResponseBody> body{};

  ModifyVpnAttachmentAttributeResponse() {}

  explicit ModifyVpnAttachmentAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVpnAttachmentAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVpnAttachmentAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVpnAttachmentAttributeResponse() = default;
};
class ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig : public Darabonba::Model {
public:
  shared_ptr<long> localAsn{};
  shared_ptr<string> localBgpIp{};
  shared_ptr<string> tunnelCidr{};

  ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig() {}

  explicit ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localAsn) {
      res["LocalAsn"] = boost::any(*localAsn);
    }
    if (localBgpIp) {
      res["LocalBgpIp"] = boost::any(*localBgpIp);
    }
    if (tunnelCidr) {
      res["TunnelCidr"] = boost::any(*tunnelCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalAsn") != m.end() && !m["LocalAsn"].empty()) {
      localAsn = make_shared<long>(boost::any_cast<long>(m["LocalAsn"]));
    }
    if (m.find("LocalBgpIp") != m.end() && !m["LocalBgpIp"].empty()) {
      localBgpIp = make_shared<string>(boost::any_cast<string>(m["LocalBgpIp"]));
    }
    if (m.find("TunnelCidr") != m.end() && !m["TunnelCidr"].empty()) {
      tunnelCidr = make_shared<string>(boost::any_cast<string>(m["TunnelCidr"]));
    }
  }


  virtual ~ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig() = default;
};
class ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig : public Darabonba::Model {
public:
  shared_ptr<string> ikeAuthAlg{};
  shared_ptr<string> ikeEncAlg{};
  shared_ptr<long> ikeLifetime{};
  shared_ptr<string> ikeMode{};
  shared_ptr<string> ikePfs{};
  shared_ptr<string> ikeVersion{};
  shared_ptr<string> localId{};
  shared_ptr<string> psk{};
  shared_ptr<string> remoteId{};

  ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig() {}

  explicit ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ikeAuthAlg) {
      res["IkeAuthAlg"] = boost::any(*ikeAuthAlg);
    }
    if (ikeEncAlg) {
      res["IkeEncAlg"] = boost::any(*ikeEncAlg);
    }
    if (ikeLifetime) {
      res["IkeLifetime"] = boost::any(*ikeLifetime);
    }
    if (ikeMode) {
      res["IkeMode"] = boost::any(*ikeMode);
    }
    if (ikePfs) {
      res["IkePfs"] = boost::any(*ikePfs);
    }
    if (ikeVersion) {
      res["IkeVersion"] = boost::any(*ikeVersion);
    }
    if (localId) {
      res["LocalId"] = boost::any(*localId);
    }
    if (psk) {
      res["Psk"] = boost::any(*psk);
    }
    if (remoteId) {
      res["RemoteId"] = boost::any(*remoteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IkeAuthAlg") != m.end() && !m["IkeAuthAlg"].empty()) {
      ikeAuthAlg = make_shared<string>(boost::any_cast<string>(m["IkeAuthAlg"]));
    }
    if (m.find("IkeEncAlg") != m.end() && !m["IkeEncAlg"].empty()) {
      ikeEncAlg = make_shared<string>(boost::any_cast<string>(m["IkeEncAlg"]));
    }
    if (m.find("IkeLifetime") != m.end() && !m["IkeLifetime"].empty()) {
      ikeLifetime = make_shared<long>(boost::any_cast<long>(m["IkeLifetime"]));
    }
    if (m.find("IkeMode") != m.end() && !m["IkeMode"].empty()) {
      ikeMode = make_shared<string>(boost::any_cast<string>(m["IkeMode"]));
    }
    if (m.find("IkePfs") != m.end() && !m["IkePfs"].empty()) {
      ikePfs = make_shared<string>(boost::any_cast<string>(m["IkePfs"]));
    }
    if (m.find("IkeVersion") != m.end() && !m["IkeVersion"].empty()) {
      ikeVersion = make_shared<string>(boost::any_cast<string>(m["IkeVersion"]));
    }
    if (m.find("LocalId") != m.end() && !m["LocalId"].empty()) {
      localId = make_shared<string>(boost::any_cast<string>(m["LocalId"]));
    }
    if (m.find("Psk") != m.end() && !m["Psk"].empty()) {
      psk = make_shared<string>(boost::any_cast<string>(m["Psk"]));
    }
    if (m.find("RemoteId") != m.end() && !m["RemoteId"].empty()) {
      remoteId = make_shared<string>(boost::any_cast<string>(m["RemoteId"]));
    }
  }


  virtual ~ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig() = default;
};
class ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig : public Darabonba::Model {
public:
  shared_ptr<string> ipsecAuthAlg{};
  shared_ptr<string> ipsecEncAlg{};
  shared_ptr<long> ipsecLifetime{};
  shared_ptr<string> ipsecPfs{};

  ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig() {}

  explicit ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipsecAuthAlg) {
      res["IpsecAuthAlg"] = boost::any(*ipsecAuthAlg);
    }
    if (ipsecEncAlg) {
      res["IpsecEncAlg"] = boost::any(*ipsecEncAlg);
    }
    if (ipsecLifetime) {
      res["IpsecLifetime"] = boost::any(*ipsecLifetime);
    }
    if (ipsecPfs) {
      res["IpsecPfs"] = boost::any(*ipsecPfs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpsecAuthAlg") != m.end() && !m["IpsecAuthAlg"].empty()) {
      ipsecAuthAlg = make_shared<string>(boost::any_cast<string>(m["IpsecAuthAlg"]));
    }
    if (m.find("IpsecEncAlg") != m.end() && !m["IpsecEncAlg"].empty()) {
      ipsecEncAlg = make_shared<string>(boost::any_cast<string>(m["IpsecEncAlg"]));
    }
    if (m.find("IpsecLifetime") != m.end() && !m["IpsecLifetime"].empty()) {
      ipsecLifetime = make_shared<long>(boost::any_cast<long>(m["IpsecLifetime"]));
    }
    if (m.find("IpsecPfs") != m.end() && !m["IpsecPfs"].empty()) {
      ipsecPfs = make_shared<string>(boost::any_cast<string>(m["IpsecPfs"]));
    }
  }


  virtual ~ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig() = default;
};
class ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification : public Darabonba::Model {
public:
  shared_ptr<bool> enableDpd{};
  shared_ptr<bool> enableNatTraversal{};
  shared_ptr<string> remoteCaCertificate{};
  shared_ptr<string> role{};
  shared_ptr<ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig> tunnelBgpConfig{};
  shared_ptr<string> tunnelId{};
  shared_ptr<ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig> tunnelIkeConfig{};
  shared_ptr<ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig> tunnelIpsecConfig{};

  ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification() {}

  explicit ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableDpd) {
      res["EnableDpd"] = boost::any(*enableDpd);
    }
    if (enableNatTraversal) {
      res["EnableNatTraversal"] = boost::any(*enableNatTraversal);
    }
    if (remoteCaCertificate) {
      res["RemoteCaCertificate"] = boost::any(*remoteCaCertificate);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (tunnelBgpConfig) {
      res["TunnelBgpConfig"] = tunnelBgpConfig ? boost::any(tunnelBgpConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tunnelId) {
      res["TunnelId"] = boost::any(*tunnelId);
    }
    if (tunnelIkeConfig) {
      res["TunnelIkeConfig"] = tunnelIkeConfig ? boost::any(tunnelIkeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tunnelIpsecConfig) {
      res["TunnelIpsecConfig"] = tunnelIpsecConfig ? boost::any(tunnelIpsecConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableDpd") != m.end() && !m["EnableDpd"].empty()) {
      enableDpd = make_shared<bool>(boost::any_cast<bool>(m["EnableDpd"]));
    }
    if (m.find("EnableNatTraversal") != m.end() && !m["EnableNatTraversal"].empty()) {
      enableNatTraversal = make_shared<bool>(boost::any_cast<bool>(m["EnableNatTraversal"]));
    }
    if (m.find("RemoteCaCertificate") != m.end() && !m["RemoteCaCertificate"].empty()) {
      remoteCaCertificate = make_shared<string>(boost::any_cast<string>(m["RemoteCaCertificate"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("TunnelBgpConfig") != m.end() && !m["TunnelBgpConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelBgpConfig"].type()) {
        ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelBgpConfig"]));
        tunnelBgpConfig = make_shared<ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelBgpConfig>(model1);
      }
    }
    if (m.find("TunnelId") != m.end() && !m["TunnelId"].empty()) {
      tunnelId = make_shared<string>(boost::any_cast<string>(m["TunnelId"]));
    }
    if (m.find("TunnelIkeConfig") != m.end() && !m["TunnelIkeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelIkeConfig"].type()) {
        ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelIkeConfig"]));
        tunnelIkeConfig = make_shared<ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIkeConfig>(model1);
      }
    }
    if (m.find("TunnelIpsecConfig") != m.end() && !m["TunnelIpsecConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelIpsecConfig"].type()) {
        ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelIpsecConfig"]));
        tunnelIpsecConfig = make_shared<ModifyVpnConnectionAttributeRequestTunnelOptionsSpecificationTunnelIpsecConfig>(model1);
      }
    }
  }


  virtual ~ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification() = default;
};
class ModifyVpnConnectionAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoConfigRoute{};
  shared_ptr<string> bgpConfig{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> effectImmediately{};
  shared_ptr<bool> enableDpd{};
  shared_ptr<bool> enableNatTraversal{};
  shared_ptr<bool> enableTunnelsBgp{};
  shared_ptr<string> healthCheckConfig{};
  shared_ptr<string> ikeConfig{};
  shared_ptr<string> ipsecConfig{};
  shared_ptr<string> localSubnet{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> remoteCaCertificate{};
  shared_ptr<string> remoteSubnet{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification>> tunnelOptionsSpecification{};
  shared_ptr<string> vpnConnectionId{};

  ModifyVpnConnectionAttributeRequest() {}

  explicit ModifyVpnConnectionAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoConfigRoute) {
      res["AutoConfigRoute"] = boost::any(*autoConfigRoute);
    }
    if (bgpConfig) {
      res["BgpConfig"] = boost::any(*bgpConfig);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (effectImmediately) {
      res["EffectImmediately"] = boost::any(*effectImmediately);
    }
    if (enableDpd) {
      res["EnableDpd"] = boost::any(*enableDpd);
    }
    if (enableNatTraversal) {
      res["EnableNatTraversal"] = boost::any(*enableNatTraversal);
    }
    if (enableTunnelsBgp) {
      res["EnableTunnelsBgp"] = boost::any(*enableTunnelsBgp);
    }
    if (healthCheckConfig) {
      res["HealthCheckConfig"] = boost::any(*healthCheckConfig);
    }
    if (ikeConfig) {
      res["IkeConfig"] = boost::any(*ikeConfig);
    }
    if (ipsecConfig) {
      res["IpsecConfig"] = boost::any(*ipsecConfig);
    }
    if (localSubnet) {
      res["LocalSubnet"] = boost::any(*localSubnet);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (remoteCaCertificate) {
      res["RemoteCaCertificate"] = boost::any(*remoteCaCertificate);
    }
    if (remoteSubnet) {
      res["RemoteSubnet"] = boost::any(*remoteSubnet);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tunnelOptionsSpecification) {
      vector<boost::any> temp1;
      for(auto item1:*tunnelOptionsSpecification){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TunnelOptionsSpecification"] = boost::any(temp1);
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoConfigRoute") != m.end() && !m["AutoConfigRoute"].empty()) {
      autoConfigRoute = make_shared<bool>(boost::any_cast<bool>(m["AutoConfigRoute"]));
    }
    if (m.find("BgpConfig") != m.end() && !m["BgpConfig"].empty()) {
      bgpConfig = make_shared<string>(boost::any_cast<string>(m["BgpConfig"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EffectImmediately") != m.end() && !m["EffectImmediately"].empty()) {
      effectImmediately = make_shared<bool>(boost::any_cast<bool>(m["EffectImmediately"]));
    }
    if (m.find("EnableDpd") != m.end() && !m["EnableDpd"].empty()) {
      enableDpd = make_shared<bool>(boost::any_cast<bool>(m["EnableDpd"]));
    }
    if (m.find("EnableNatTraversal") != m.end() && !m["EnableNatTraversal"].empty()) {
      enableNatTraversal = make_shared<bool>(boost::any_cast<bool>(m["EnableNatTraversal"]));
    }
    if (m.find("EnableTunnelsBgp") != m.end() && !m["EnableTunnelsBgp"].empty()) {
      enableTunnelsBgp = make_shared<bool>(boost::any_cast<bool>(m["EnableTunnelsBgp"]));
    }
    if (m.find("HealthCheckConfig") != m.end() && !m["HealthCheckConfig"].empty()) {
      healthCheckConfig = make_shared<string>(boost::any_cast<string>(m["HealthCheckConfig"]));
    }
    if (m.find("IkeConfig") != m.end() && !m["IkeConfig"].empty()) {
      ikeConfig = make_shared<string>(boost::any_cast<string>(m["IkeConfig"]));
    }
    if (m.find("IpsecConfig") != m.end() && !m["IpsecConfig"].empty()) {
      ipsecConfig = make_shared<string>(boost::any_cast<string>(m["IpsecConfig"]));
    }
    if (m.find("LocalSubnet") != m.end() && !m["LocalSubnet"].empty()) {
      localSubnet = make_shared<string>(boost::any_cast<string>(m["LocalSubnet"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemoteCaCertificate") != m.end() && !m["RemoteCaCertificate"].empty()) {
      remoteCaCertificate = make_shared<string>(boost::any_cast<string>(m["RemoteCaCertificate"]));
    }
    if (m.find("RemoteSubnet") != m.end() && !m["RemoteSubnet"].empty()) {
      remoteSubnet = make_shared<string>(boost::any_cast<string>(m["RemoteSubnet"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TunnelOptionsSpecification") != m.end() && !m["TunnelOptionsSpecification"].empty()) {
      if (typeid(vector<boost::any>) == m["TunnelOptionsSpecification"].type()) {
        vector<ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TunnelOptionsSpecification"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tunnelOptionsSpecification = make_shared<vector<ModifyVpnConnectionAttributeRequestTunnelOptionsSpecification>>(expect1);
      }
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
  }


  virtual ~ModifyVpnConnectionAttributeRequest() = default;
};
class ModifyVpnConnectionAttributeResponseBodyIkeConfig : public Darabonba::Model {
public:
  shared_ptr<string> ikeAuthAlg{};
  shared_ptr<string> ikeEncAlg{};
  shared_ptr<long> ikeLifetime{};
  shared_ptr<string> ikeMode{};
  shared_ptr<string> ikePfs{};
  shared_ptr<string> ikeVersion{};
  shared_ptr<string> localId{};
  shared_ptr<string> psk{};
  shared_ptr<string> remoteId{};

  ModifyVpnConnectionAttributeResponseBodyIkeConfig() {}

  explicit ModifyVpnConnectionAttributeResponseBodyIkeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ikeAuthAlg) {
      res["IkeAuthAlg"] = boost::any(*ikeAuthAlg);
    }
    if (ikeEncAlg) {
      res["IkeEncAlg"] = boost::any(*ikeEncAlg);
    }
    if (ikeLifetime) {
      res["IkeLifetime"] = boost::any(*ikeLifetime);
    }
    if (ikeMode) {
      res["IkeMode"] = boost::any(*ikeMode);
    }
    if (ikePfs) {
      res["IkePfs"] = boost::any(*ikePfs);
    }
    if (ikeVersion) {
      res["IkeVersion"] = boost::any(*ikeVersion);
    }
    if (localId) {
      res["LocalId"] = boost::any(*localId);
    }
    if (psk) {
      res["Psk"] = boost::any(*psk);
    }
    if (remoteId) {
      res["RemoteId"] = boost::any(*remoteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IkeAuthAlg") != m.end() && !m["IkeAuthAlg"].empty()) {
      ikeAuthAlg = make_shared<string>(boost::any_cast<string>(m["IkeAuthAlg"]));
    }
    if (m.find("IkeEncAlg") != m.end() && !m["IkeEncAlg"].empty()) {
      ikeEncAlg = make_shared<string>(boost::any_cast<string>(m["IkeEncAlg"]));
    }
    if (m.find("IkeLifetime") != m.end() && !m["IkeLifetime"].empty()) {
      ikeLifetime = make_shared<long>(boost::any_cast<long>(m["IkeLifetime"]));
    }
    if (m.find("IkeMode") != m.end() && !m["IkeMode"].empty()) {
      ikeMode = make_shared<string>(boost::any_cast<string>(m["IkeMode"]));
    }
    if (m.find("IkePfs") != m.end() && !m["IkePfs"].empty()) {
      ikePfs = make_shared<string>(boost::any_cast<string>(m["IkePfs"]));
    }
    if (m.find("IkeVersion") != m.end() && !m["IkeVersion"].empty()) {
      ikeVersion = make_shared<string>(boost::any_cast<string>(m["IkeVersion"]));
    }
    if (m.find("LocalId") != m.end() && !m["LocalId"].empty()) {
      localId = make_shared<string>(boost::any_cast<string>(m["LocalId"]));
    }
    if (m.find("Psk") != m.end() && !m["Psk"].empty()) {
      psk = make_shared<string>(boost::any_cast<string>(m["Psk"]));
    }
    if (m.find("RemoteId") != m.end() && !m["RemoteId"].empty()) {
      remoteId = make_shared<string>(boost::any_cast<string>(m["RemoteId"]));
    }
  }


  virtual ~ModifyVpnConnectionAttributeResponseBodyIkeConfig() = default;
};
class ModifyVpnConnectionAttributeResponseBodyIpsecConfig : public Darabonba::Model {
public:
  shared_ptr<string> ipsecAuthAlg{};
  shared_ptr<string> ipsecEncAlg{};
  shared_ptr<long> ipsecLifetime{};
  shared_ptr<string> ipsecPfs{};

  ModifyVpnConnectionAttributeResponseBodyIpsecConfig() {}

  explicit ModifyVpnConnectionAttributeResponseBodyIpsecConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipsecAuthAlg) {
      res["IpsecAuthAlg"] = boost::any(*ipsecAuthAlg);
    }
    if (ipsecEncAlg) {
      res["IpsecEncAlg"] = boost::any(*ipsecEncAlg);
    }
    if (ipsecLifetime) {
      res["IpsecLifetime"] = boost::any(*ipsecLifetime);
    }
    if (ipsecPfs) {
      res["IpsecPfs"] = boost::any(*ipsecPfs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpsecAuthAlg") != m.end() && !m["IpsecAuthAlg"].empty()) {
      ipsecAuthAlg = make_shared<string>(boost::any_cast<string>(m["IpsecAuthAlg"]));
    }
    if (m.find("IpsecEncAlg") != m.end() && !m["IpsecEncAlg"].empty()) {
      ipsecEncAlg = make_shared<string>(boost::any_cast<string>(m["IpsecEncAlg"]));
    }
    if (m.find("IpsecLifetime") != m.end() && !m["IpsecLifetime"].empty()) {
      ipsecLifetime = make_shared<long>(boost::any_cast<long>(m["IpsecLifetime"]));
    }
    if (m.find("IpsecPfs") != m.end() && !m["IpsecPfs"].empty()) {
      ipsecPfs = make_shared<string>(boost::any_cast<string>(m["IpsecPfs"]));
    }
  }


  virtual ~ModifyVpnConnectionAttributeResponseBodyIpsecConfig() = default;
};
class ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig : public Darabonba::Model {
public:
  shared_ptr<long> localAsn{};
  shared_ptr<string> localBgpIp{};
  shared_ptr<long> peerAsn{};
  shared_ptr<string> peerBgpIp{};
  shared_ptr<string> tunnelCidr{};

  ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig() {}

  explicit ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localAsn) {
      res["LocalAsn"] = boost::any(*localAsn);
    }
    if (localBgpIp) {
      res["LocalBgpIp"] = boost::any(*localBgpIp);
    }
    if (peerAsn) {
      res["PeerAsn"] = boost::any(*peerAsn);
    }
    if (peerBgpIp) {
      res["PeerBgpIp"] = boost::any(*peerBgpIp);
    }
    if (tunnelCidr) {
      res["TunnelCidr"] = boost::any(*tunnelCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalAsn") != m.end() && !m["LocalAsn"].empty()) {
      localAsn = make_shared<long>(boost::any_cast<long>(m["LocalAsn"]));
    }
    if (m.find("LocalBgpIp") != m.end() && !m["LocalBgpIp"].empty()) {
      localBgpIp = make_shared<string>(boost::any_cast<string>(m["LocalBgpIp"]));
    }
    if (m.find("PeerAsn") != m.end() && !m["PeerAsn"].empty()) {
      peerAsn = make_shared<long>(boost::any_cast<long>(m["PeerAsn"]));
    }
    if (m.find("PeerBgpIp") != m.end() && !m["PeerBgpIp"].empty()) {
      peerBgpIp = make_shared<string>(boost::any_cast<string>(m["PeerBgpIp"]));
    }
    if (m.find("TunnelCidr") != m.end() && !m["TunnelCidr"].empty()) {
      tunnelCidr = make_shared<string>(boost::any_cast<string>(m["TunnelCidr"]));
    }
  }


  virtual ~ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig() = default;
};
class ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig : public Darabonba::Model {
public:
  shared_ptr<string> ikeAuthAlg{};
  shared_ptr<string> ikeEncAlg{};
  shared_ptr<long> ikeLifetime{};
  shared_ptr<string> ikeMode{};
  shared_ptr<string> ikePfs{};
  shared_ptr<string> ikeVersion{};
  shared_ptr<string> localId{};
  shared_ptr<string> psk{};
  shared_ptr<string> remoteId{};

  ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig() {}

  explicit ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ikeAuthAlg) {
      res["IkeAuthAlg"] = boost::any(*ikeAuthAlg);
    }
    if (ikeEncAlg) {
      res["IkeEncAlg"] = boost::any(*ikeEncAlg);
    }
    if (ikeLifetime) {
      res["IkeLifetime"] = boost::any(*ikeLifetime);
    }
    if (ikeMode) {
      res["IkeMode"] = boost::any(*ikeMode);
    }
    if (ikePfs) {
      res["IkePfs"] = boost::any(*ikePfs);
    }
    if (ikeVersion) {
      res["IkeVersion"] = boost::any(*ikeVersion);
    }
    if (localId) {
      res["LocalId"] = boost::any(*localId);
    }
    if (psk) {
      res["Psk"] = boost::any(*psk);
    }
    if (remoteId) {
      res["RemoteId"] = boost::any(*remoteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IkeAuthAlg") != m.end() && !m["IkeAuthAlg"].empty()) {
      ikeAuthAlg = make_shared<string>(boost::any_cast<string>(m["IkeAuthAlg"]));
    }
    if (m.find("IkeEncAlg") != m.end() && !m["IkeEncAlg"].empty()) {
      ikeEncAlg = make_shared<string>(boost::any_cast<string>(m["IkeEncAlg"]));
    }
    if (m.find("IkeLifetime") != m.end() && !m["IkeLifetime"].empty()) {
      ikeLifetime = make_shared<long>(boost::any_cast<long>(m["IkeLifetime"]));
    }
    if (m.find("IkeMode") != m.end() && !m["IkeMode"].empty()) {
      ikeMode = make_shared<string>(boost::any_cast<string>(m["IkeMode"]));
    }
    if (m.find("IkePfs") != m.end() && !m["IkePfs"].empty()) {
      ikePfs = make_shared<string>(boost::any_cast<string>(m["IkePfs"]));
    }
    if (m.find("IkeVersion") != m.end() && !m["IkeVersion"].empty()) {
      ikeVersion = make_shared<string>(boost::any_cast<string>(m["IkeVersion"]));
    }
    if (m.find("LocalId") != m.end() && !m["LocalId"].empty()) {
      localId = make_shared<string>(boost::any_cast<string>(m["LocalId"]));
    }
    if (m.find("Psk") != m.end() && !m["Psk"].empty()) {
      psk = make_shared<string>(boost::any_cast<string>(m["Psk"]));
    }
    if (m.find("RemoteId") != m.end() && !m["RemoteId"].empty()) {
      remoteId = make_shared<string>(boost::any_cast<string>(m["RemoteId"]));
    }
  }


  virtual ~ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig() = default;
};
class ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig : public Darabonba::Model {
public:
  shared_ptr<string> ipsecAuthAlg{};
  shared_ptr<string> ipsecEncAlg{};
  shared_ptr<long> ipsecLifetime{};
  shared_ptr<string> ipsecPfs{};

  ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig() {}

  explicit ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipsecAuthAlg) {
      res["IpsecAuthAlg"] = boost::any(*ipsecAuthAlg);
    }
    if (ipsecEncAlg) {
      res["IpsecEncAlg"] = boost::any(*ipsecEncAlg);
    }
    if (ipsecLifetime) {
      res["IpsecLifetime"] = boost::any(*ipsecLifetime);
    }
    if (ipsecPfs) {
      res["IpsecPfs"] = boost::any(*ipsecPfs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpsecAuthAlg") != m.end() && !m["IpsecAuthAlg"].empty()) {
      ipsecAuthAlg = make_shared<string>(boost::any_cast<string>(m["IpsecAuthAlg"]));
    }
    if (m.find("IpsecEncAlg") != m.end() && !m["IpsecEncAlg"].empty()) {
      ipsecEncAlg = make_shared<string>(boost::any_cast<string>(m["IpsecEncAlg"]));
    }
    if (m.find("IpsecLifetime") != m.end() && !m["IpsecLifetime"].empty()) {
      ipsecLifetime = make_shared<long>(boost::any_cast<long>(m["IpsecLifetime"]));
    }
    if (m.find("IpsecPfs") != m.end() && !m["IpsecPfs"].empty()) {
      ipsecPfs = make_shared<string>(boost::any_cast<string>(m["IpsecPfs"]));
    }
  }


  virtual ~ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig() = default;
};
class ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions : public Darabonba::Model {
public:
  shared_ptr<string> customerGatewayId{};
  shared_ptr<bool> enableDpd{};
  shared_ptr<bool> enableNatTraversal{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> remoteCaCertificate{};
  shared_ptr<string> role{};
  shared_ptr<string> state{};
  shared_ptr<ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig> tunnelBgpConfig{};
  shared_ptr<string> tunnelId{};
  shared_ptr<ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig> tunnelIkeConfig{};
  shared_ptr<ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig> tunnelIpsecConfig{};
  shared_ptr<string> zoneNo{};

  ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions() {}

  explicit ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (enableDpd) {
      res["EnableDpd"] = boost::any(*enableDpd);
    }
    if (enableNatTraversal) {
      res["EnableNatTraversal"] = boost::any(*enableNatTraversal);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (remoteCaCertificate) {
      res["RemoteCaCertificate"] = boost::any(*remoteCaCertificate);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tunnelBgpConfig) {
      res["TunnelBgpConfig"] = tunnelBgpConfig ? boost::any(tunnelBgpConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tunnelId) {
      res["TunnelId"] = boost::any(*tunnelId);
    }
    if (tunnelIkeConfig) {
      res["TunnelIkeConfig"] = tunnelIkeConfig ? boost::any(tunnelIkeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tunnelIpsecConfig) {
      res["TunnelIpsecConfig"] = tunnelIpsecConfig ? boost::any(tunnelIpsecConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (zoneNo) {
      res["ZoneNo"] = boost::any(*zoneNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("EnableDpd") != m.end() && !m["EnableDpd"].empty()) {
      enableDpd = make_shared<bool>(boost::any_cast<bool>(m["EnableDpd"]));
    }
    if (m.find("EnableNatTraversal") != m.end() && !m["EnableNatTraversal"].empty()) {
      enableNatTraversal = make_shared<bool>(boost::any_cast<bool>(m["EnableNatTraversal"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("RemoteCaCertificate") != m.end() && !m["RemoteCaCertificate"].empty()) {
      remoteCaCertificate = make_shared<string>(boost::any_cast<string>(m["RemoteCaCertificate"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TunnelBgpConfig") != m.end() && !m["TunnelBgpConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelBgpConfig"].type()) {
        ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelBgpConfig"]));
        tunnelBgpConfig = make_shared<ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelBgpConfig>(model1);
      }
    }
    if (m.find("TunnelId") != m.end() && !m["TunnelId"].empty()) {
      tunnelId = make_shared<string>(boost::any_cast<string>(m["TunnelId"]));
    }
    if (m.find("TunnelIkeConfig") != m.end() && !m["TunnelIkeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelIkeConfig"].type()) {
        ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelIkeConfig"]));
        tunnelIkeConfig = make_shared<ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIkeConfig>(model1);
      }
    }
    if (m.find("TunnelIpsecConfig") != m.end() && !m["TunnelIpsecConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelIpsecConfig"].type()) {
        ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelIpsecConfig"]));
        tunnelIpsecConfig = make_shared<ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptionsTunnelIpsecConfig>(model1);
      }
    }
    if (m.find("ZoneNo") != m.end() && !m["ZoneNo"].empty()) {
      zoneNo = make_shared<string>(boost::any_cast<string>(m["ZoneNo"]));
    }
  }


  virtual ~ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions() = default;
};
class ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecification : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions>> tunnelOptions{};

  ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecification() {}

  explicit ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tunnelOptions) {
      vector<boost::any> temp1;
      for(auto item1:*tunnelOptions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TunnelOptions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TunnelOptions") != m.end() && !m["TunnelOptions"].empty()) {
      if (typeid(vector<boost::any>) == m["TunnelOptions"].type()) {
        vector<ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TunnelOptions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tunnelOptions = make_shared<vector<ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecificationTunnelOptions>>(expect1);
      }
    }
  }


  virtual ~ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecification() = default;
};
class ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck : public Darabonba::Model {
public:
  shared_ptr<string> dip{};
  shared_ptr<string> enable{};
  shared_ptr<long> interval{};
  shared_ptr<long> retry{};
  shared_ptr<string> sip{};

  ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck() {}

  explicit ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dip) {
      res["Dip"] = boost::any(*dip);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (retry) {
      res["Retry"] = boost::any(*retry);
    }
    if (sip) {
      res["Sip"] = boost::any(*sip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dip") != m.end() && !m["Dip"].empty()) {
      dip = make_shared<string>(boost::any_cast<string>(m["Dip"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Retry") != m.end() && !m["Retry"].empty()) {
      retry = make_shared<long>(boost::any_cast<long>(m["Retry"]));
    }
    if (m.find("Sip") != m.end() && !m["Sip"].empty()) {
      sip = make_shared<string>(boost::any_cast<string>(m["Sip"]));
    }
  }


  virtual ~ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck() = default;
};
class ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig : public Darabonba::Model {
public:
  shared_ptr<string> enableBgp{};
  shared_ptr<long> localAsn{};
  shared_ptr<string> localBgpIp{};
  shared_ptr<long> peerAsn{};
  shared_ptr<string> peerBgpIp{};
  shared_ptr<string> status{};
  shared_ptr<string> tunnelCidr{};

  ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig() {}

  explicit ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableBgp) {
      res["EnableBgp"] = boost::any(*enableBgp);
    }
    if (localAsn) {
      res["LocalAsn"] = boost::any(*localAsn);
    }
    if (localBgpIp) {
      res["LocalBgpIp"] = boost::any(*localBgpIp);
    }
    if (peerAsn) {
      res["PeerAsn"] = boost::any(*peerAsn);
    }
    if (peerBgpIp) {
      res["PeerBgpIp"] = boost::any(*peerBgpIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tunnelCidr) {
      res["TunnelCidr"] = boost::any(*tunnelCidr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableBgp") != m.end() && !m["EnableBgp"].empty()) {
      enableBgp = make_shared<string>(boost::any_cast<string>(m["EnableBgp"]));
    }
    if (m.find("LocalAsn") != m.end() && !m["LocalAsn"].empty()) {
      localAsn = make_shared<long>(boost::any_cast<long>(m["LocalAsn"]));
    }
    if (m.find("LocalBgpIp") != m.end() && !m["LocalBgpIp"].empty()) {
      localBgpIp = make_shared<string>(boost::any_cast<string>(m["LocalBgpIp"]));
    }
    if (m.find("PeerAsn") != m.end() && !m["PeerAsn"].empty()) {
      peerAsn = make_shared<long>(boost::any_cast<long>(m["PeerAsn"]));
    }
    if (m.find("PeerBgpIp") != m.end() && !m["PeerBgpIp"].empty()) {
      peerBgpIp = make_shared<string>(boost::any_cast<string>(m["PeerBgpIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TunnelCidr") != m.end() && !m["TunnelCidr"].empty()) {
      tunnelCidr = make_shared<string>(boost::any_cast<string>(m["TunnelCidr"]));
    }
  }


  virtual ~ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig() = default;
};
class ModifyVpnConnectionAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> customerGatewayId{};
  shared_ptr<string> description{};
  shared_ptr<bool> effectImmediately{};
  shared_ptr<bool> enableDpd{};
  shared_ptr<bool> enableNatTraversal{};
  shared_ptr<bool> enableTunnelsBgp{};
  shared_ptr<ModifyVpnConnectionAttributeResponseBodyIkeConfig> ikeConfig{};
  shared_ptr<ModifyVpnConnectionAttributeResponseBodyIpsecConfig> ipsecConfig{};
  shared_ptr<string> localSubnet{};
  shared_ptr<string> name{};
  shared_ptr<string> remoteSubnet{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecification> tunnelOptionsSpecification{};
  shared_ptr<ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck> vcoHealthCheck{};
  shared_ptr<ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig> vpnBgpConfig{};
  shared_ptr<string> vpnConnectionId{};
  shared_ptr<string> vpnGatewayId{};

  ModifyVpnConnectionAttributeResponseBody() {}

  explicit ModifyVpnConnectionAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (customerGatewayId) {
      res["CustomerGatewayId"] = boost::any(*customerGatewayId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (effectImmediately) {
      res["EffectImmediately"] = boost::any(*effectImmediately);
    }
    if (enableDpd) {
      res["EnableDpd"] = boost::any(*enableDpd);
    }
    if (enableNatTraversal) {
      res["EnableNatTraversal"] = boost::any(*enableNatTraversal);
    }
    if (enableTunnelsBgp) {
      res["EnableTunnelsBgp"] = boost::any(*enableTunnelsBgp);
    }
    if (ikeConfig) {
      res["IkeConfig"] = ikeConfig ? boost::any(ikeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipsecConfig) {
      res["IpsecConfig"] = ipsecConfig ? boost::any(ipsecConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (localSubnet) {
      res["LocalSubnet"] = boost::any(*localSubnet);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remoteSubnet) {
      res["RemoteSubnet"] = boost::any(*remoteSubnet);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tunnelOptionsSpecification) {
      res["TunnelOptionsSpecification"] = tunnelOptionsSpecification ? boost::any(tunnelOptionsSpecification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vcoHealthCheck) {
      res["VcoHealthCheck"] = vcoHealthCheck ? boost::any(vcoHealthCheck->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpnBgpConfig) {
      res["VpnBgpConfig"] = vpnBgpConfig ? boost::any(vpnBgpConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpnConnectionId) {
      res["VpnConnectionId"] = boost::any(*vpnConnectionId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CustomerGatewayId") != m.end() && !m["CustomerGatewayId"].empty()) {
      customerGatewayId = make_shared<string>(boost::any_cast<string>(m["CustomerGatewayId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EffectImmediately") != m.end() && !m["EffectImmediately"].empty()) {
      effectImmediately = make_shared<bool>(boost::any_cast<bool>(m["EffectImmediately"]));
    }
    if (m.find("EnableDpd") != m.end() && !m["EnableDpd"].empty()) {
      enableDpd = make_shared<bool>(boost::any_cast<bool>(m["EnableDpd"]));
    }
    if (m.find("EnableNatTraversal") != m.end() && !m["EnableNatTraversal"].empty()) {
      enableNatTraversal = make_shared<bool>(boost::any_cast<bool>(m["EnableNatTraversal"]));
    }
    if (m.find("EnableTunnelsBgp") != m.end() && !m["EnableTunnelsBgp"].empty()) {
      enableTunnelsBgp = make_shared<bool>(boost::any_cast<bool>(m["EnableTunnelsBgp"]));
    }
    if (m.find("IkeConfig") != m.end() && !m["IkeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IkeConfig"].type()) {
        ModifyVpnConnectionAttributeResponseBodyIkeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IkeConfig"]));
        ikeConfig = make_shared<ModifyVpnConnectionAttributeResponseBodyIkeConfig>(model1);
      }
    }
    if (m.find("IpsecConfig") != m.end() && !m["IpsecConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IpsecConfig"].type()) {
        ModifyVpnConnectionAttributeResponseBodyIpsecConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IpsecConfig"]));
        ipsecConfig = make_shared<ModifyVpnConnectionAttributeResponseBodyIpsecConfig>(model1);
      }
    }
    if (m.find("LocalSubnet") != m.end() && !m["LocalSubnet"].empty()) {
      localSubnet = make_shared<string>(boost::any_cast<string>(m["LocalSubnet"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RemoteSubnet") != m.end() && !m["RemoteSubnet"].empty()) {
      remoteSubnet = make_shared<string>(boost::any_cast<string>(m["RemoteSubnet"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("TunnelOptionsSpecification") != m.end() && !m["TunnelOptionsSpecification"].empty()) {
      if (typeid(map<string, boost::any>) == m["TunnelOptionsSpecification"].type()) {
        ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TunnelOptionsSpecification"]));
        tunnelOptionsSpecification = make_shared<ModifyVpnConnectionAttributeResponseBodyTunnelOptionsSpecification>(model1);
      }
    }
    if (m.find("VcoHealthCheck") != m.end() && !m["VcoHealthCheck"].empty()) {
      if (typeid(map<string, boost::any>) == m["VcoHealthCheck"].type()) {
        ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VcoHealthCheck"]));
        vcoHealthCheck = make_shared<ModifyVpnConnectionAttributeResponseBodyVcoHealthCheck>(model1);
      }
    }
    if (m.find("VpnBgpConfig") != m.end() && !m["VpnBgpConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpnBgpConfig"].type()) {
        ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpnBgpConfig"]));
        vpnBgpConfig = make_shared<ModifyVpnConnectionAttributeResponseBodyVpnBgpConfig>(model1);
      }
    }
    if (m.find("VpnConnectionId") != m.end() && !m["VpnConnectionId"].empty()) {
      vpnConnectionId = make_shared<string>(boost::any_cast<string>(m["VpnConnectionId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~ModifyVpnConnectionAttributeResponseBody() = default;
};
class ModifyVpnConnectionAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVpnConnectionAttributeResponseBody> body{};

  ModifyVpnConnectionAttributeResponse() {}

  explicit ModifyVpnConnectionAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVpnConnectionAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVpnConnectionAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVpnConnectionAttributeResponse() = default;
};
class ModifyVpnGatewayAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPropagate{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpnGatewayId{};

  ModifyVpnGatewayAttributeRequest() {}

  explicit ModifyVpnGatewayAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPropagate) {
      res["AutoPropagate"] = boost::any(*autoPropagate);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPropagate") != m.end() && !m["AutoPropagate"].empty()) {
      autoPropagate = make_shared<bool>(boost::any_cast<bool>(m["AutoPropagate"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~ModifyVpnGatewayAttributeRequest() = default;
};
class ModifyVpnGatewayAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> autoPropagate{};
  shared_ptr<string> businessStatus{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> disasterRecoveryInternetIp{};
  shared_ptr<string> disasterRecoveryVSwitchId{};
  shared_ptr<bool> enableBgp{};
  shared_ptr<long> endTime{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> spec{};
  shared_ptr<string> sslVpnInternetIp{};
  shared_ptr<string> status{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpnGatewayId{};

  ModifyVpnGatewayAttributeResponseBody() {}

  explicit ModifyVpnGatewayAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPropagate) {
      res["AutoPropagate"] = boost::any(*autoPropagate);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disasterRecoveryInternetIp) {
      res["DisasterRecoveryInternetIp"] = boost::any(*disasterRecoveryInternetIp);
    }
    if (disasterRecoveryVSwitchId) {
      res["DisasterRecoveryVSwitchId"] = boost::any(*disasterRecoveryVSwitchId);
    }
    if (enableBgp) {
      res["EnableBgp"] = boost::any(*enableBgp);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (sslVpnInternetIp) {
      res["SslVpnInternetIp"] = boost::any(*sslVpnInternetIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPropagate") != m.end() && !m["AutoPropagate"].empty()) {
      autoPropagate = make_shared<bool>(boost::any_cast<bool>(m["AutoPropagate"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisasterRecoveryInternetIp") != m.end() && !m["DisasterRecoveryInternetIp"].empty()) {
      disasterRecoveryInternetIp = make_shared<string>(boost::any_cast<string>(m["DisasterRecoveryInternetIp"]));
    }
    if (m.find("DisasterRecoveryVSwitchId") != m.end() && !m["DisasterRecoveryVSwitchId"].empty()) {
      disasterRecoveryVSwitchId = make_shared<string>(boost::any_cast<string>(m["DisasterRecoveryVSwitchId"]));
    }
    if (m.find("EnableBgp") != m.end() && !m["EnableBgp"].empty()) {
      enableBgp = make_shared<bool>(boost::any_cast<bool>(m["EnableBgp"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("SslVpnInternetIp") != m.end() && !m["SslVpnInternetIp"].empty()) {
      sslVpnInternetIp = make_shared<string>(boost::any_cast<string>(m["SslVpnInternetIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~ModifyVpnGatewayAttributeResponseBody() = default;
};
class ModifyVpnGatewayAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVpnGatewayAttributeResponseBody> body{};

  ModifyVpnGatewayAttributeResponse() {}

  explicit ModifyVpnGatewayAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVpnGatewayAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVpnGatewayAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVpnGatewayAttributeResponse() = default;
};
class ModifyVpnPbrRouteEntryAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> newPriority{};
  shared_ptr<long> newWeight{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> priority{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeDest{};
  shared_ptr<string> routeSource{};
  shared_ptr<string> vpnGatewayId{};
  shared_ptr<long> weight{};

  ModifyVpnPbrRouteEntryAttributeRequest() {}

  explicit ModifyVpnPbrRouteEntryAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (newPriority) {
      res["NewPriority"] = boost::any(*newPriority);
    }
    if (newWeight) {
      res["NewWeight"] = boost::any(*newWeight);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeDest) {
      res["RouteDest"] = boost::any(*routeDest);
    }
    if (routeSource) {
      res["RouteSource"] = boost::any(*routeSource);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("NewPriority") != m.end() && !m["NewPriority"].empty()) {
      newPriority = make_shared<long>(boost::any_cast<long>(m["NewPriority"]));
    }
    if (m.find("NewWeight") != m.end() && !m["NewWeight"].empty()) {
      newWeight = make_shared<long>(boost::any_cast<long>(m["NewWeight"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteDest") != m.end() && !m["RouteDest"].empty()) {
      routeDest = make_shared<string>(boost::any_cast<string>(m["RouteDest"]));
    }
    if (m.find("RouteSource") != m.end() && !m["RouteSource"].empty()) {
      routeSource = make_shared<string>(boost::any_cast<string>(m["RouteSource"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~ModifyVpnPbrRouteEntryAttributeRequest() = default;
};
class ModifyVpnPbrRouteEntryAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVpnPbrRouteEntryAttributeResponseBody() {}

  explicit ModifyVpnPbrRouteEntryAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVpnPbrRouteEntryAttributeResponseBody() = default;
};
class ModifyVpnPbrRouteEntryAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVpnPbrRouteEntryAttributeResponseBody> body{};

  ModifyVpnPbrRouteEntryAttributeResponse() {}

  explicit ModifyVpnPbrRouteEntryAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVpnPbrRouteEntryAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVpnPbrRouteEntryAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVpnPbrRouteEntryAttributeResponse() = default;
};
class ModifyVpnPbrRouteEntryPriorityRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> newPriority{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> priority{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeDest{};
  shared_ptr<string> routeSource{};
  shared_ptr<string> vpnGatewayId{};
  shared_ptr<long> weight{};

  ModifyVpnPbrRouteEntryPriorityRequest() {}

  explicit ModifyVpnPbrRouteEntryPriorityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (newPriority) {
      res["NewPriority"] = boost::any(*newPriority);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeDest) {
      res["RouteDest"] = boost::any(*routeDest);
    }
    if (routeSource) {
      res["RouteSource"] = boost::any(*routeSource);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("NewPriority") != m.end() && !m["NewPriority"].empty()) {
      newPriority = make_shared<long>(boost::any_cast<long>(m["NewPriority"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteDest") != m.end() && !m["RouteDest"].empty()) {
      routeDest = make_shared<string>(boost::any_cast<string>(m["RouteDest"]));
    }
    if (m.find("RouteSource") != m.end() && !m["RouteSource"].empty()) {
      routeSource = make_shared<string>(boost::any_cast<string>(m["RouteSource"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~ModifyVpnPbrRouteEntryPriorityRequest() = default;
};
class ModifyVpnPbrRouteEntryPriorityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVpnPbrRouteEntryPriorityResponseBody() {}

  explicit ModifyVpnPbrRouteEntryPriorityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVpnPbrRouteEntryPriorityResponseBody() = default;
};
class ModifyVpnPbrRouteEntryPriorityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVpnPbrRouteEntryPriorityResponseBody> body{};

  ModifyVpnPbrRouteEntryPriorityResponse() {}

  explicit ModifyVpnPbrRouteEntryPriorityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVpnPbrRouteEntryPriorityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVpnPbrRouteEntryPriorityResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVpnPbrRouteEntryPriorityResponse() = default;
};
class ModifyVpnPbrRouteEntryWeightRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> newWeight{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> overlayMode{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> priority{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeDest{};
  shared_ptr<string> routeSource{};
  shared_ptr<string> vpnGatewayId{};
  shared_ptr<long> weight{};

  ModifyVpnPbrRouteEntryWeightRequest() {}

  explicit ModifyVpnPbrRouteEntryWeightRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (newWeight) {
      res["NewWeight"] = boost::any(*newWeight);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (overlayMode) {
      res["OverlayMode"] = boost::any(*overlayMode);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeDest) {
      res["RouteDest"] = boost::any(*routeDest);
    }
    if (routeSource) {
      res["RouteSource"] = boost::any(*routeSource);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("NewWeight") != m.end() && !m["NewWeight"].empty()) {
      newWeight = make_shared<long>(boost::any_cast<long>(m["NewWeight"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("OverlayMode") != m.end() && !m["OverlayMode"].empty()) {
      overlayMode = make_shared<string>(boost::any_cast<string>(m["OverlayMode"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteDest") != m.end() && !m["RouteDest"].empty()) {
      routeDest = make_shared<string>(boost::any_cast<string>(m["RouteDest"]));
    }
    if (m.find("RouteSource") != m.end() && !m["RouteSource"].empty()) {
      routeSource = make_shared<string>(boost::any_cast<string>(m["RouteSource"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~ModifyVpnPbrRouteEntryWeightRequest() = default;
};
class ModifyVpnPbrRouteEntryWeightResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVpnPbrRouteEntryWeightResponseBody() {}

  explicit ModifyVpnPbrRouteEntryWeightResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVpnPbrRouteEntryWeightResponseBody() = default;
};
class ModifyVpnPbrRouteEntryWeightResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVpnPbrRouteEntryWeightResponseBody> body{};

  ModifyVpnPbrRouteEntryWeightResponse() {}

  explicit ModifyVpnPbrRouteEntryWeightResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVpnPbrRouteEntryWeightResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVpnPbrRouteEntryWeightResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVpnPbrRouteEntryWeightResponse() = default;
};
class ModifyVpnRouteEntryWeightRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> newWeight{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> overlayMode{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeDest{};
  shared_ptr<string> vpnGatewayId{};
  shared_ptr<long> weight{};

  ModifyVpnRouteEntryWeightRequest() {}

  explicit ModifyVpnRouteEntryWeightRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (newWeight) {
      res["NewWeight"] = boost::any(*newWeight);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (overlayMode) {
      res["OverlayMode"] = boost::any(*overlayMode);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeDest) {
      res["RouteDest"] = boost::any(*routeDest);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("NewWeight") != m.end() && !m["NewWeight"].empty()) {
      newWeight = make_shared<long>(boost::any_cast<long>(m["NewWeight"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("OverlayMode") != m.end() && !m["OverlayMode"].empty()) {
      overlayMode = make_shared<string>(boost::any_cast<string>(m["OverlayMode"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteDest") != m.end() && !m["RouteDest"].empty()) {
      routeDest = make_shared<string>(boost::any_cast<string>(m["RouteDest"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~ModifyVpnRouteEntryWeightRequest() = default;
};
class ModifyVpnRouteEntryWeightResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVpnRouteEntryWeightResponseBody() {}

  explicit ModifyVpnRouteEntryWeightResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVpnRouteEntryWeightResponseBody() = default;
};
class ModifyVpnRouteEntryWeightResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVpnRouteEntryWeightResponseBody> body{};

  ModifyVpnRouteEntryWeightResponse() {}

  explicit ModifyVpnRouteEntryWeightResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVpnRouteEntryWeightResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVpnRouteEntryWeightResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVpnRouteEntryWeightResponse() = default;
};
class MoveResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> newResourceGroupId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};

  MoveResourceGroupRequest() {}

  explicit MoveResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (newResourceGroupId) {
      res["NewResourceGroupId"] = boost::any(*newResourceGroupId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NewResourceGroupId") != m.end() && !m["NewResourceGroupId"].empty()) {
      newResourceGroupId = make_shared<string>(boost::any_cast<string>(m["NewResourceGroupId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~MoveResourceGroupRequest() = default;
};
class MoveResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  MoveResourceGroupResponseBody() {}

  explicit MoveResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MoveResourceGroupResponseBody() = default;
};
class MoveResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MoveResourceGroupResponseBody> body{};

  MoveResourceGroupResponse() {}

  explicit MoveResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~MoveResourceGroupResponse() = default;
};
class MoveVpnResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> newResourceGroupId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};

  MoveVpnResourceGroupRequest() {}

  explicit MoveVpnResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (newResourceGroupId) {
      res["NewResourceGroupId"] = boost::any(*newResourceGroupId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NewResourceGroupId") != m.end() && !m["NewResourceGroupId"].empty()) {
      newResourceGroupId = make_shared<string>(boost::any_cast<string>(m["NewResourceGroupId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~MoveVpnResourceGroupRequest() = default;
};
class MoveVpnResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  MoveVpnResourceGroupResponseBody() {}

  explicit MoveVpnResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MoveVpnResourceGroupResponseBody() = default;
};
class MoveVpnResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MoveVpnResourceGroupResponseBody> body{};

  MoveVpnResourceGroupResponse() {}

  explicit MoveVpnResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveVpnResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveVpnResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~MoveVpnResourceGroupResponse() = default;
};
class OpenFlowLogServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  OpenFlowLogServiceRequest() {}

  explicit OpenFlowLogServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~OpenFlowLogServiceRequest() = default;
};
class OpenFlowLogServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  OpenFlowLogServiceResponseBody() {}

  explicit OpenFlowLogServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenFlowLogServiceResponseBody() = default;
};
class OpenFlowLogServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenFlowLogServiceResponseBody> body{};

  OpenFlowLogServiceResponse() {}

  explicit OpenFlowLogServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenFlowLogServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenFlowLogServiceResponseBody>(model1);
      }
    }
  }


  virtual ~OpenFlowLogServiceResponse() = default;
};
class OpenPhysicalConnectionServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  OpenPhysicalConnectionServiceRequest() {}

  explicit OpenPhysicalConnectionServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~OpenPhysicalConnectionServiceRequest() = default;
};
class OpenPhysicalConnectionServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  OpenPhysicalConnectionServiceResponseBody() {}

  explicit OpenPhysicalConnectionServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenPhysicalConnectionServiceResponseBody() = default;
};
class OpenPhysicalConnectionServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenPhysicalConnectionServiceResponseBody> body{};

  OpenPhysicalConnectionServiceResponse() {}

  explicit OpenPhysicalConnectionServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenPhysicalConnectionServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenPhysicalConnectionServiceResponseBody>(model1);
      }
    }
  }


  virtual ~OpenPhysicalConnectionServiceResponse() = default;
};
class OpenTrafficMirrorServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  OpenTrafficMirrorServiceRequest() {}

  explicit OpenTrafficMirrorServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~OpenTrafficMirrorServiceRequest() = default;
};
class OpenTrafficMirrorServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  OpenTrafficMirrorServiceResponseBody() {}

  explicit OpenTrafficMirrorServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenTrafficMirrorServiceResponseBody() = default;
};
class OpenTrafficMirrorServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenTrafficMirrorServiceResponseBody> body{};

  OpenTrafficMirrorServiceResponse() {}

  explicit OpenTrafficMirrorServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenTrafficMirrorServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenTrafficMirrorServiceResponseBody>(model1);
      }
    }
  }


  virtual ~OpenTrafficMirrorServiceResponse() = default;
};
class PublishVpnRouteEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<bool> publishVpc{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeDest{};
  shared_ptr<string> routeType{};
  shared_ptr<string> vpnGatewayId{};

  PublishVpnRouteEntryRequest() {}

  explicit PublishVpnRouteEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (publishVpc) {
      res["PublishVpc"] = boost::any(*publishVpc);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeDest) {
      res["RouteDest"] = boost::any(*routeDest);
    }
    if (routeType) {
      res["RouteType"] = boost::any(*routeType);
    }
    if (vpnGatewayId) {
      res["VpnGatewayId"] = boost::any(*vpnGatewayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PublishVpc") != m.end() && !m["PublishVpc"].empty()) {
      publishVpc = make_shared<bool>(boost::any_cast<bool>(m["PublishVpc"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteDest") != m.end() && !m["RouteDest"].empty()) {
      routeDest = make_shared<string>(boost::any_cast<string>(m["RouteDest"]));
    }
    if (m.find("RouteType") != m.end() && !m["RouteType"].empty()) {
      routeType = make_shared<string>(boost::any_cast<string>(m["RouteType"]));
    }
    if (m.find("VpnGatewayId") != m.end() && !m["VpnGatewayId"].empty()) {
      vpnGatewayId = make_shared<string>(boost::any_cast<string>(m["VpnGatewayId"]));
    }
  }


  virtual ~PublishVpnRouteEntryRequest() = default;
};
class PublishVpnRouteEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  PublishVpnRouteEntryResponseBody() {}

  explicit PublishVpnRouteEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PublishVpnRouteEntryResponseBody() = default;
};
class PublishVpnRouteEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PublishVpnRouteEntryResponseBody> body{};

  PublishVpnRouteEntryResponse() {}

  explicit PublishVpnRouteEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishVpnRouteEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishVpnRouteEntryResponseBody>(model1);
      }
    }
  }


  virtual ~PublishVpnRouteEntryResponse() = default;
};
class RecoverPhysicalConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> token{};

  RecoverPhysicalConnectionRequest() {}

  explicit RecoverPhysicalConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~RecoverPhysicalConnectionRequest() = default;
};
class RecoverPhysicalConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RecoverPhysicalConnectionResponseBody() {}

  explicit RecoverPhysicalConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RecoverPhysicalConnectionResponseBody() = default;
};
class RecoverPhysicalConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RecoverPhysicalConnectionResponseBody> body{};

  RecoverPhysicalConnectionResponse() {}

  explicit RecoverPhysicalConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RecoverPhysicalConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RecoverPhysicalConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~RecoverPhysicalConnectionResponse() = default;
};
class RecoverVirtualBorderRouterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vbrId{};

  RecoverVirtualBorderRouterRequest() {}

  explicit RecoverVirtualBorderRouterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
  }


  virtual ~RecoverVirtualBorderRouterRequest() = default;
};
class RecoverVirtualBorderRouterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RecoverVirtualBorderRouterResponseBody() {}

  explicit RecoverVirtualBorderRouterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RecoverVirtualBorderRouterResponseBody() = default;
};
class RecoverVirtualBorderRouterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RecoverVirtualBorderRouterResponseBody> body{};

  RecoverVirtualBorderRouterResponse() {}

  explicit RecoverVirtualBorderRouterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RecoverVirtualBorderRouterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RecoverVirtualBorderRouterResponseBody>(model1);
      }
    }
  }


  virtual ~RecoverVirtualBorderRouterResponse() = default;
};
class ReleaseEipAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ReleaseEipAddressRequest() {}

  explicit ReleaseEipAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ReleaseEipAddressRequest() = default;
};
class ReleaseEipAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseEipAddressResponseBody() {}

  explicit ReleaseEipAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseEipAddressResponseBody() = default;
};
class ReleaseEipAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseEipAddressResponseBody> body{};

  ReleaseEipAddressResponse() {}

  explicit ReleaseEipAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseEipAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseEipAddressResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseEipAddressResponse() = default;
};
class ReleaseEipSegmentAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> segmentInstanceId{};

  ReleaseEipSegmentAddressRequest() {}

  explicit ReleaseEipSegmentAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (segmentInstanceId) {
      res["SegmentInstanceId"] = boost::any(*segmentInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SegmentInstanceId") != m.end() && !m["SegmentInstanceId"].empty()) {
      segmentInstanceId = make_shared<string>(boost::any_cast<string>(m["SegmentInstanceId"]));
    }
  }


  virtual ~ReleaseEipSegmentAddressRequest() = default;
};
class ReleaseEipSegmentAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseEipSegmentAddressResponseBody() {}

  explicit ReleaseEipSegmentAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseEipSegmentAddressResponseBody() = default;
};
class ReleaseEipSegmentAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseEipSegmentAddressResponseBody> body{};

  ReleaseEipSegmentAddressResponse() {}

  explicit ReleaseEipSegmentAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseEipSegmentAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseEipSegmentAddressResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseEipSegmentAddressResponse() = default;
};
class ReleaseIpv6AddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ipv6AddressId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ReleaseIpv6AddressRequest() {}

  explicit ReleaseIpv6AddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ipv6AddressId) {
      res["Ipv6AddressId"] = boost::any(*ipv6AddressId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("Ipv6AddressId") != m.end() && !m["Ipv6AddressId"].empty()) {
      ipv6AddressId = make_shared<string>(boost::any_cast<string>(m["Ipv6AddressId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ReleaseIpv6AddressRequest() = default;
};
class ReleaseIpv6AddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseIpv6AddressResponseBody() {}

  explicit ReleaseIpv6AddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseIpv6AddressResponseBody() = default;
};
class ReleaseIpv6AddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseIpv6AddressResponseBody> body{};

  ReleaseIpv6AddressResponse() {}

  explicit ReleaseIpv6AddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseIpv6AddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseIpv6AddressResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseIpv6AddressResponse() = default;
};
class RemoveCommonBandwidthPackageIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ipInstanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  RemoveCommonBandwidthPackageIpRequest() {}

  explicit RemoveCommonBandwidthPackageIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ipInstanceId) {
      res["IpInstanceId"] = boost::any(*ipInstanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("IpInstanceId") != m.end() && !m["IpInstanceId"].empty()) {
      ipInstanceId = make_shared<string>(boost::any_cast<string>(m["IpInstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~RemoveCommonBandwidthPackageIpRequest() = default;
};
class RemoveCommonBandwidthPackageIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveCommonBandwidthPackageIpResponseBody() {}

  explicit RemoveCommonBandwidthPackageIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveCommonBandwidthPackageIpResponseBody() = default;
};
class RemoveCommonBandwidthPackageIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveCommonBandwidthPackageIpResponseBody> body{};

  RemoveCommonBandwidthPackageIpResponse() {}

  explicit RemoveCommonBandwidthPackageIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveCommonBandwidthPackageIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveCommonBandwidthPackageIpResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveCommonBandwidthPackageIpResponse() = default;
};
class RemoveGlobalAccelerationInstanceIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> globalAccelerationInstanceId{};
  shared_ptr<string> ipInstanceId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  RemoveGlobalAccelerationInstanceIpRequest() {}

  explicit RemoveGlobalAccelerationInstanceIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalAccelerationInstanceId) {
      res["GlobalAccelerationInstanceId"] = boost::any(*globalAccelerationInstanceId);
    }
    if (ipInstanceId) {
      res["IpInstanceId"] = boost::any(*ipInstanceId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalAccelerationInstanceId") != m.end() && !m["GlobalAccelerationInstanceId"].empty()) {
      globalAccelerationInstanceId = make_shared<string>(boost::any_cast<string>(m["GlobalAccelerationInstanceId"]));
    }
    if (m.find("IpInstanceId") != m.end() && !m["IpInstanceId"].empty()) {
      ipInstanceId = make_shared<string>(boost::any_cast<string>(m["IpInstanceId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~RemoveGlobalAccelerationInstanceIpRequest() = default;
};
class RemoveGlobalAccelerationInstanceIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveGlobalAccelerationInstanceIpResponseBody() {}

  explicit RemoveGlobalAccelerationInstanceIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveGlobalAccelerationInstanceIpResponseBody() = default;
};
class RemoveGlobalAccelerationInstanceIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveGlobalAccelerationInstanceIpResponseBody> body{};

  RemoveGlobalAccelerationInstanceIpResponse() {}

  explicit RemoveGlobalAccelerationInstanceIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveGlobalAccelerationInstanceIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveGlobalAccelerationInstanceIpResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveGlobalAccelerationInstanceIpResponse() = default;
};
class RemoveIPv6TranslatorAclListEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclEntryId{};
  shared_ptr<string> aclId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  RemoveIPv6TranslatorAclListEntryRequest() {}

  explicit RemoveIPv6TranslatorAclListEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntryId) {
      res["AclEntryId"] = boost::any(*aclEntryId);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclEntryId") != m.end() && !m["AclEntryId"].empty()) {
      aclEntryId = make_shared<string>(boost::any_cast<string>(m["AclEntryId"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~RemoveIPv6TranslatorAclListEntryRequest() = default;
};
class RemoveIPv6TranslatorAclListEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveIPv6TranslatorAclListEntryResponseBody() {}

  explicit RemoveIPv6TranslatorAclListEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveIPv6TranslatorAclListEntryResponseBody() = default;
};
class RemoveIPv6TranslatorAclListEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveIPv6TranslatorAclListEntryResponseBody> body{};

  RemoveIPv6TranslatorAclListEntryResponse() {}

  explicit RemoveIPv6TranslatorAclListEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveIPv6TranslatorAclListEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveIPv6TranslatorAclListEntryResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveIPv6TranslatorAclListEntryResponse() = default;
};
class RemoveSourcesFromTrafficMirrorSessionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> trafficMirrorSessionId{};
  shared_ptr<vector<string>> trafficMirrorSourceIds{};

  RemoveSourcesFromTrafficMirrorSessionRequest() {}

  explicit RemoveSourcesFromTrafficMirrorSessionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (trafficMirrorSessionId) {
      res["TrafficMirrorSessionId"] = boost::any(*trafficMirrorSessionId);
    }
    if (trafficMirrorSourceIds) {
      res["TrafficMirrorSourceIds"] = boost::any(*trafficMirrorSourceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TrafficMirrorSessionId") != m.end() && !m["TrafficMirrorSessionId"].empty()) {
      trafficMirrorSessionId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorSessionId"]));
    }
    if (m.find("TrafficMirrorSourceIds") != m.end() && !m["TrafficMirrorSourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TrafficMirrorSourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TrafficMirrorSourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      trafficMirrorSourceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RemoveSourcesFromTrafficMirrorSessionRequest() = default;
};
class RemoveSourcesFromTrafficMirrorSessionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveSourcesFromTrafficMirrorSessionResponseBody() {}

  explicit RemoveSourcesFromTrafficMirrorSessionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveSourcesFromTrafficMirrorSessionResponseBody() = default;
};
class RemoveSourcesFromTrafficMirrorSessionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveSourcesFromTrafficMirrorSessionResponseBody> body{};

  RemoveSourcesFromTrafficMirrorSessionResponse() {}

  explicit RemoveSourcesFromTrafficMirrorSessionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveSourcesFromTrafficMirrorSessionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveSourcesFromTrafficMirrorSessionResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveSourcesFromTrafficMirrorSessionResponse() = default;
};
class ReplaceVpcDhcpOptionsSetRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> dhcpOptionsSetId{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vpcId{};

  ReplaceVpcDhcpOptionsSetRequest() {}

  explicit ReplaceVpcDhcpOptionsSetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dhcpOptionsSetId) {
      res["DhcpOptionsSetId"] = boost::any(*dhcpOptionsSetId);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DhcpOptionsSetId") != m.end() && !m["DhcpOptionsSetId"].empty()) {
      dhcpOptionsSetId = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetId"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ReplaceVpcDhcpOptionsSetRequest() = default;
};
class ReplaceVpcDhcpOptionsSetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReplaceVpcDhcpOptionsSetResponseBody() {}

  explicit ReplaceVpcDhcpOptionsSetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReplaceVpcDhcpOptionsSetResponseBody() = default;
};
class ReplaceVpcDhcpOptionsSetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReplaceVpcDhcpOptionsSetResponseBody> body{};

  ReplaceVpcDhcpOptionsSetResponse() {}

  explicit ReplaceVpcDhcpOptionsSetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReplaceVpcDhcpOptionsSetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReplaceVpcDhcpOptionsSetResponseBody>(model1);
      }
    }
  }


  virtual ~ReplaceVpcDhcpOptionsSetResponse() = default;
};
class RetryVpcPrefixListAssociationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> prefixListId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};

  RetryVpcPrefixListAssociationRequest() {}

  explicit RetryVpcPrefixListAssociationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (prefixListId) {
      res["PrefixListId"] = boost::any(*prefixListId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PrefixListId") != m.end() && !m["PrefixListId"].empty()) {
      prefixListId = make_shared<string>(boost::any_cast<string>(m["PrefixListId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~RetryVpcPrefixListAssociationRequest() = default;
};
class RetryVpcPrefixListAssociationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RetryVpcPrefixListAssociationResponseBody() {}

  explicit RetryVpcPrefixListAssociationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RetryVpcPrefixListAssociationResponseBody() = default;
};
class RetryVpcPrefixListAssociationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RetryVpcPrefixListAssociationResponseBody> body{};

  RetryVpcPrefixListAssociationResponse() {}

  explicit RetryVpcPrefixListAssociationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RetryVpcPrefixListAssociationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RetryVpcPrefixListAssociationResponseBody>(model1);
      }
    }
  }


  virtual ~RetryVpcPrefixListAssociationResponse() = default;
};
class RevokeInstanceFromCenRequest : public Darabonba::Model {
public:
  shared_ptr<string> cenId{};
  shared_ptr<long> cenOwnerId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  RevokeInstanceFromCenRequest() {}

  explicit RevokeInstanceFromCenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cenId) {
      res["CenId"] = boost::any(*cenId);
    }
    if (cenOwnerId) {
      res["CenOwnerId"] = boost::any(*cenOwnerId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CenId") != m.end() && !m["CenId"].empty()) {
      cenId = make_shared<string>(boost::any_cast<string>(m["CenId"]));
    }
    if (m.find("CenOwnerId") != m.end() && !m["CenOwnerId"].empty()) {
      cenOwnerId = make_shared<long>(boost::any_cast<long>(m["CenOwnerId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~RevokeInstanceFromCenRequest() = default;
};
class RevokeInstanceFromCenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeInstanceFromCenResponseBody() {}

  explicit RevokeInstanceFromCenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeInstanceFromCenResponseBody() = default;
};
class RevokeInstanceFromCenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevokeInstanceFromCenResponseBody> body{};

  RevokeInstanceFromCenResponse() {}

  explicit RevokeInstanceFromCenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeInstanceFromCenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeInstanceFromCenResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeInstanceFromCenResponse() = default;
};
class RevokeInstanceFromVbrRequest : public Darabonba::Model {
public:
  shared_ptr<string> grantType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> vbrInstanceIds{};
  shared_ptr<string> vbrOwnerUid{};
  shared_ptr<string> vbrRegionNo{};

  RevokeInstanceFromVbrRequest() {}

  explicit RevokeInstanceFromVbrRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (grantType) {
      res["GrantType"] = boost::any(*grantType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vbrInstanceIds) {
      res["VbrInstanceIds"] = boost::any(*vbrInstanceIds);
    }
    if (vbrOwnerUid) {
      res["VbrOwnerUid"] = boost::any(*vbrOwnerUid);
    }
    if (vbrRegionNo) {
      res["VbrRegionNo"] = boost::any(*vbrRegionNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GrantType") != m.end() && !m["GrantType"].empty()) {
      grantType = make_shared<string>(boost::any_cast<string>(m["GrantType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VbrInstanceIds") != m.end() && !m["VbrInstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VbrInstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VbrInstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vbrInstanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VbrOwnerUid") != m.end() && !m["VbrOwnerUid"].empty()) {
      vbrOwnerUid = make_shared<string>(boost::any_cast<string>(m["VbrOwnerUid"]));
    }
    if (m.find("VbrRegionNo") != m.end() && !m["VbrRegionNo"].empty()) {
      vbrRegionNo = make_shared<string>(boost::any_cast<string>(m["VbrRegionNo"]));
    }
  }


  virtual ~RevokeInstanceFromVbrRequest() = default;
};
class RevokeInstanceFromVbrShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> grantType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vbrInstanceIdsShrink{};
  shared_ptr<string> vbrOwnerUid{};
  shared_ptr<string> vbrRegionNo{};

  RevokeInstanceFromVbrShrinkRequest() {}

  explicit RevokeInstanceFromVbrShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (grantType) {
      res["GrantType"] = boost::any(*grantType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vbrInstanceIdsShrink) {
      res["VbrInstanceIds"] = boost::any(*vbrInstanceIdsShrink);
    }
    if (vbrOwnerUid) {
      res["VbrOwnerUid"] = boost::any(*vbrOwnerUid);
    }
    if (vbrRegionNo) {
      res["VbrRegionNo"] = boost::any(*vbrRegionNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GrantType") != m.end() && !m["GrantType"].empty()) {
      grantType = make_shared<string>(boost::any_cast<string>(m["GrantType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VbrInstanceIds") != m.end() && !m["VbrInstanceIds"].empty()) {
      vbrInstanceIdsShrink = make_shared<string>(boost::any_cast<string>(m["VbrInstanceIds"]));
    }
    if (m.find("VbrOwnerUid") != m.end() && !m["VbrOwnerUid"].empty()) {
      vbrOwnerUid = make_shared<string>(boost::any_cast<string>(m["VbrOwnerUid"]));
    }
    if (m.find("VbrRegionNo") != m.end() && !m["VbrRegionNo"].empty()) {
      vbrRegionNo = make_shared<string>(boost::any_cast<string>(m["VbrRegionNo"]));
    }
  }


  virtual ~RevokeInstanceFromVbrShrinkRequest() = default;
};
class RevokeInstanceFromVbrResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeInstanceFromVbrResponseBody() {}

  explicit RevokeInstanceFromVbrResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeInstanceFromVbrResponseBody() = default;
};
class RevokeInstanceFromVbrResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevokeInstanceFromVbrResponseBody> body{};

  RevokeInstanceFromVbrResponse() {}

  explicit RevokeInstanceFromVbrResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeInstanceFromVbrResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeInstanceFromVbrResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeInstanceFromVbrResponse() = default;
};
class SecondApplyPhysicalConnectionLOARequestPMInfo : public Darabonba::Model {
public:
  shared_ptr<string> PMCertificateNo{};
  shared_ptr<string> PMCertificateType{};
  shared_ptr<string> PMContactInfo{};
  shared_ptr<string> PMGender{};
  shared_ptr<string> PMName{};

  SecondApplyPhysicalConnectionLOARequestPMInfo() {}

  explicit SecondApplyPhysicalConnectionLOARequestPMInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (PMCertificateNo) {
      res["PMCertificateNo"] = boost::any(*PMCertificateNo);
    }
    if (PMCertificateType) {
      res["PMCertificateType"] = boost::any(*PMCertificateType);
    }
    if (PMContactInfo) {
      res["PMContactInfo"] = boost::any(*PMContactInfo);
    }
    if (PMGender) {
      res["PMGender"] = boost::any(*PMGender);
    }
    if (PMName) {
      res["PMName"] = boost::any(*PMName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PMCertificateNo") != m.end() && !m["PMCertificateNo"].empty()) {
      PMCertificateNo = make_shared<string>(boost::any_cast<string>(m["PMCertificateNo"]));
    }
    if (m.find("PMCertificateType") != m.end() && !m["PMCertificateType"].empty()) {
      PMCertificateType = make_shared<string>(boost::any_cast<string>(m["PMCertificateType"]));
    }
    if (m.find("PMContactInfo") != m.end() && !m["PMContactInfo"].empty()) {
      PMContactInfo = make_shared<string>(boost::any_cast<string>(m["PMContactInfo"]));
    }
    if (m.find("PMGender") != m.end() && !m["PMGender"].empty()) {
      PMGender = make_shared<string>(boost::any_cast<string>(m["PMGender"]));
    }
    if (m.find("PMName") != m.end() && !m["PMName"].empty()) {
      PMName = make_shared<string>(boost::any_cast<string>(m["PMName"]));
    }
  }


  virtual ~SecondApplyPhysicalConnectionLOARequestPMInfo() = default;
};
class SecondApplyPhysicalConnectionLOARequest : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> companyName{};
  shared_ptr<string> constructionTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lineType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<SecondApplyPhysicalConnectionLOARequestPMInfo>> PMInfo{};
  shared_ptr<string> peerLocation{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> si{};

  SecondApplyPhysicalConnectionLOARequest() {}

  explicit SecondApplyPhysicalConnectionLOARequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (companyName) {
      res["CompanyName"] = boost::any(*companyName);
    }
    if (constructionTime) {
      res["ConstructionTime"] = boost::any(*constructionTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lineType) {
      res["LineType"] = boost::any(*lineType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (PMInfo) {
      vector<boost::any> temp1;
      for(auto item1:*PMInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PMInfo"] = boost::any(temp1);
    }
    if (peerLocation) {
      res["PeerLocation"] = boost::any(*peerLocation);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (si) {
      res["Si"] = boost::any(*si);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CompanyName") != m.end() && !m["CompanyName"].empty()) {
      companyName = make_shared<string>(boost::any_cast<string>(m["CompanyName"]));
    }
    if (m.find("ConstructionTime") != m.end() && !m["ConstructionTime"].empty()) {
      constructionTime = make_shared<string>(boost::any_cast<string>(m["ConstructionTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LineType") != m.end() && !m["LineType"].empty()) {
      lineType = make_shared<string>(boost::any_cast<string>(m["LineType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PMInfo") != m.end() && !m["PMInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PMInfo"].type()) {
        vector<SecondApplyPhysicalConnectionLOARequestPMInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PMInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SecondApplyPhysicalConnectionLOARequestPMInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        PMInfo = make_shared<vector<SecondApplyPhysicalConnectionLOARequestPMInfo>>(expect1);
      }
    }
    if (m.find("PeerLocation") != m.end() && !m["PeerLocation"].empty()) {
      peerLocation = make_shared<string>(boost::any_cast<string>(m["PeerLocation"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Si") != m.end() && !m["Si"].empty()) {
      si = make_shared<string>(boost::any_cast<string>(m["Si"]));
    }
  }


  virtual ~SecondApplyPhysicalConnectionLOARequest() = default;
};
class SecondApplyPhysicalConnectionLOAResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SecondApplyPhysicalConnectionLOAResponseBody() {}

  explicit SecondApplyPhysicalConnectionLOAResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SecondApplyPhysicalConnectionLOAResponseBody() = default;
};
class SecondApplyPhysicalConnectionLOAResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SecondApplyPhysicalConnectionLOAResponseBody> body{};

  SecondApplyPhysicalConnectionLOAResponse() {}

  explicit SecondApplyPhysicalConnectionLOAResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SecondApplyPhysicalConnectionLOAResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SecondApplyPhysicalConnectionLOAResponseBody>(model1);
      }
    }
  }


  virtual ~SecondApplyPhysicalConnectionLOAResponse() = default;
};
class SetHighDefinitionMonitorLogStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> logProject{};
  shared_ptr<string> logStore{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};

  SetHighDefinitionMonitorLogStatusRequest() {}

  explicit SetHighDefinitionMonitorLogStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (logProject) {
      res["LogProject"] = boost::any(*logProject);
    }
    if (logStore) {
      res["LogStore"] = boost::any(*logStore);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("LogProject") != m.end() && !m["LogProject"].empty()) {
      logProject = make_shared<string>(boost::any_cast<string>(m["LogProject"]));
    }
    if (m.find("LogStore") != m.end() && !m["LogStore"].empty()) {
      logStore = make_shared<string>(boost::any_cast<string>(m["LogStore"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~SetHighDefinitionMonitorLogStatusRequest() = default;
};
class SetHighDefinitionMonitorLogStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  SetHighDefinitionMonitorLogStatusResponseBody() {}

  explicit SetHighDefinitionMonitorLogStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~SetHighDefinitionMonitorLogStatusResponseBody() = default;
};
class SetHighDefinitionMonitorLogStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetHighDefinitionMonitorLogStatusResponseBody> body{};

  SetHighDefinitionMonitorLogStatusResponse() {}

  explicit SetHighDefinitionMonitorLogStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetHighDefinitionMonitorLogStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetHighDefinitionMonitorLogStatusResponseBody>(model1);
      }
    }
  }


  virtual ~SetHighDefinitionMonitorLogStatusResponse() = default;
};
class StartFailoverTestJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> jobId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};

  StartFailoverTestJobRequest() {}

  explicit StartFailoverTestJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~StartFailoverTestJobRequest() = default;
};
class StartFailoverTestJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartFailoverTestJobResponseBody() {}

  explicit StartFailoverTestJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartFailoverTestJobResponseBody() = default;
};
class StartFailoverTestJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartFailoverTestJobResponseBody> body{};

  StartFailoverTestJobResponse() {}

  explicit StartFailoverTestJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartFailoverTestJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartFailoverTestJobResponseBody>(model1);
      }
    }
  }


  virtual ~StartFailoverTestJobResponse() = default;
};
class StopFailoverTestJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> jobId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};

  StopFailoverTestJobRequest() {}

  explicit StopFailoverTestJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~StopFailoverTestJobRequest() = default;
};
class StopFailoverTestJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopFailoverTestJobResponseBody() {}

  explicit StopFailoverTestJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopFailoverTestJobResponseBody() = default;
};
class StopFailoverTestJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopFailoverTestJobResponseBody> body{};

  StopFailoverTestJobResponse() {}

  explicit StopFailoverTestJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopFailoverTestJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopFailoverTestJobResponseBody>(model1);
      }
    }
  }


  virtual ~StopFailoverTestJobResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class TagResourcesForExpressConnectRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesForExpressConnectRequestTag() {}

  explicit TagResourcesForExpressConnectRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesForExpressConnectRequestTag() = default;
};
class TagResourcesForExpressConnectRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesForExpressConnectRequestTag>> tag{};

  TagResourcesForExpressConnectRequest() {}

  explicit TagResourcesForExpressConnectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesForExpressConnectRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesForExpressConnectRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesForExpressConnectRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesForExpressConnectRequest() = default;
};
class TagResourcesForExpressConnectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagResourcesForExpressConnectResponseBody() {}

  explicit TagResourcesForExpressConnectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesForExpressConnectResponseBody() = default;
};
class TagResourcesForExpressConnectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesForExpressConnectResponseBody> body{};

  TagResourcesForExpressConnectResponse() {}

  explicit TagResourcesForExpressConnectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesForExpressConnectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesForExpressConnectResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesForExpressConnectResponse() = default;
};
class TerminatePhysicalConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  TerminatePhysicalConnectionRequest() {}

  explicit TerminatePhysicalConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~TerminatePhysicalConnectionRequest() = default;
};
class TerminatePhysicalConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TerminatePhysicalConnectionResponseBody() {}

  explicit TerminatePhysicalConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TerminatePhysicalConnectionResponseBody() = default;
};
class TerminatePhysicalConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TerminatePhysicalConnectionResponseBody> body{};

  TerminatePhysicalConnectionResponse() {}

  explicit TerminatePhysicalConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TerminatePhysicalConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TerminatePhysicalConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~TerminatePhysicalConnectionResponse() = default;
};
class TerminateVirtualBorderRouterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vbrId{};

  TerminateVirtualBorderRouterRequest() {}

  explicit TerminateVirtualBorderRouterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
  }


  virtual ~TerminateVirtualBorderRouterRequest() = default;
};
class TerminateVirtualBorderRouterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TerminateVirtualBorderRouterResponseBody() {}

  explicit TerminateVirtualBorderRouterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TerminateVirtualBorderRouterResponseBody() = default;
};
class TerminateVirtualBorderRouterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TerminateVirtualBorderRouterResponseBody> body{};

  TerminateVirtualBorderRouterResponse() {}

  explicit TerminateVirtualBorderRouterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TerminateVirtualBorderRouterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TerminateVirtualBorderRouterResponseBody>(model1);
      }
    }
  }


  virtual ~TerminateVirtualBorderRouterResponse() = default;
};
class UnTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  UnTagResourcesRequest() {}

  explicit UnTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UnTagResourcesRequest() = default;
};
class UnTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnTagResourcesResponseBody() {}

  explicit UnTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnTagResourcesResponseBody() = default;
};
class UnTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnTagResourcesResponseBody> body{};

  UnTagResourcesResponse() {}

  explicit UnTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UnTagResourcesResponse() = default;
};
class UnassociateEipAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> allocationId{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> force{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UnassociateEipAddressRequest() {}

  explicit UnassociateEipAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allocationId) {
      res["AllocationId"] = boost::any(*allocationId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllocationId") != m.end() && !m["AllocationId"].empty()) {
      allocationId = make_shared<string>(boost::any_cast<string>(m["AllocationId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UnassociateEipAddressRequest() = default;
};
class UnassociateEipAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnassociateEipAddressResponseBody() {}

  explicit UnassociateEipAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnassociateEipAddressResponseBody() = default;
};
class UnassociateEipAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnassociateEipAddressResponseBody> body{};

  UnassociateEipAddressResponse() {}

  explicit UnassociateEipAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnassociateEipAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnassociateEipAddressResponseBody>(model1);
      }
    }
  }


  virtual ~UnassociateEipAddressResponse() = default;
};
class UnassociateGlobalAccelerationInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> globalAccelerationInstanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UnassociateGlobalAccelerationInstanceRequest() {}

  explicit UnassociateGlobalAccelerationInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalAccelerationInstanceId) {
      res["GlobalAccelerationInstanceId"] = boost::any(*globalAccelerationInstanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalAccelerationInstanceId") != m.end() && !m["GlobalAccelerationInstanceId"].empty()) {
      globalAccelerationInstanceId = make_shared<string>(boost::any_cast<string>(m["GlobalAccelerationInstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UnassociateGlobalAccelerationInstanceRequest() = default;
};
class UnassociateGlobalAccelerationInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnassociateGlobalAccelerationInstanceResponseBody() {}

  explicit UnassociateGlobalAccelerationInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnassociateGlobalAccelerationInstanceResponseBody() = default;
};
class UnassociateGlobalAccelerationInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnassociateGlobalAccelerationInstanceResponseBody> body{};

  UnassociateGlobalAccelerationInstanceResponse() {}

  explicit UnassociateGlobalAccelerationInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnassociateGlobalAccelerationInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnassociateGlobalAccelerationInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UnassociateGlobalAccelerationInstanceResponse() = default;
};
class UnassociateHaVipRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> force{};
  shared_ptr<string> haVipId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UnassociateHaVipRequest() {}

  explicit UnassociateHaVipRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (haVipId) {
      res["HaVipId"] = boost::any(*haVipId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<string>(boost::any_cast<string>(m["Force"]));
    }
    if (m.find("HaVipId") != m.end() && !m["HaVipId"].empty()) {
      haVipId = make_shared<string>(boost::any_cast<string>(m["HaVipId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UnassociateHaVipRequest() = default;
};
class UnassociateHaVipResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnassociateHaVipResponseBody() {}

  explicit UnassociateHaVipResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnassociateHaVipResponseBody() = default;
};
class UnassociateHaVipResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnassociateHaVipResponseBody> body{};

  UnassociateHaVipResponse() {}

  explicit UnassociateHaVipResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnassociateHaVipResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnassociateHaVipResponseBody>(model1);
      }
    }
  }


  virtual ~UnassociateHaVipResponse() = default;
};
class UnassociateNetworkAclRequestResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  UnassociateNetworkAclRequestResource() {}

  explicit UnassociateNetworkAclRequestResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~UnassociateNetworkAclRequestResource() = default;
};
class UnassociateNetworkAclRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> networkAclId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<UnassociateNetworkAclRequestResource>> resource{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UnassociateNetworkAclRequest() {}

  explicit UnassociateNetworkAclRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<UnassociateNetworkAclRequestResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UnassociateNetworkAclRequestResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<UnassociateNetworkAclRequestResource>>(expect1);
      }
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UnassociateNetworkAclRequest() = default;
};
class UnassociateNetworkAclResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnassociateNetworkAclResponseBody() {}

  explicit UnassociateNetworkAclResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnassociateNetworkAclResponseBody() = default;
};
class UnassociateNetworkAclResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnassociateNetworkAclResponseBody> body{};

  UnassociateNetworkAclResponse() {}

  explicit UnassociateNetworkAclResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnassociateNetworkAclResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnassociateNetworkAclResponseBody>(model1);
      }
    }
  }


  virtual ~UnassociateNetworkAclResponse() = default;
};
class UnassociatePhysicalConnectionFromVirtualBorderRouterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> physicalConnectionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vbrId{};

  UnassociatePhysicalConnectionFromVirtualBorderRouterRequest() {}

  explicit UnassociatePhysicalConnectionFromVirtualBorderRouterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (physicalConnectionId) {
      res["PhysicalConnectionId"] = boost::any(*physicalConnectionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PhysicalConnectionId") != m.end() && !m["PhysicalConnectionId"].empty()) {
      physicalConnectionId = make_shared<string>(boost::any_cast<string>(m["PhysicalConnectionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
  }


  virtual ~UnassociatePhysicalConnectionFromVirtualBorderRouterRequest() = default;
};
class UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody() {}

  explicit UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody() = default;
};
class UnassociatePhysicalConnectionFromVirtualBorderRouterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody> body{};

  UnassociatePhysicalConnectionFromVirtualBorderRouterResponse() {}

  explicit UnassociatePhysicalConnectionFromVirtualBorderRouterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody>(model1);
      }
    }
  }


  virtual ~UnassociatePhysicalConnectionFromVirtualBorderRouterResponse() = default;
};
class UnassociateRouteTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> routeTableId{};
  shared_ptr<string> vSwitchId{};

  UnassociateRouteTableRequest() {}

  explicit UnassociateRouteTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (routeTableId) {
      res["RouteTableId"] = boost::any(*routeTableId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RouteTableId") != m.end() && !m["RouteTableId"].empty()) {
      routeTableId = make_shared<string>(boost::any_cast<string>(m["RouteTableId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~UnassociateRouteTableRequest() = default;
};
class UnassociateRouteTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnassociateRouteTableResponseBody() {}

  explicit UnassociateRouteTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnassociateRouteTableResponseBody() = default;
};
class UnassociateRouteTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnassociateRouteTableResponseBody> body{};

  UnassociateRouteTableResponse() {}

  explicit UnassociateRouteTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnassociateRouteTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnassociateRouteTableResponseBody>(model1);
      }
    }
  }


  virtual ~UnassociateRouteTableResponse() = default;
};
class UnassociateVpcCidrBlockRequest : public Darabonba::Model {
public:
  shared_ptr<string> IPv6CidrBlock{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> secondaryCidrBlock{};
  shared_ptr<string> vpcId{};

  UnassociateVpcCidrBlockRequest() {}

  explicit UnassociateVpcCidrBlockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IPv6CidrBlock) {
      res["IPv6CidrBlock"] = boost::any(*IPv6CidrBlock);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (secondaryCidrBlock) {
      res["SecondaryCidrBlock"] = boost::any(*secondaryCidrBlock);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IPv6CidrBlock") != m.end() && !m["IPv6CidrBlock"].empty()) {
      IPv6CidrBlock = make_shared<string>(boost::any_cast<string>(m["IPv6CidrBlock"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecondaryCidrBlock") != m.end() && !m["SecondaryCidrBlock"].empty()) {
      secondaryCidrBlock = make_shared<string>(boost::any_cast<string>(m["SecondaryCidrBlock"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~UnassociateVpcCidrBlockRequest() = default;
};
class UnassociateVpcCidrBlockResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnassociateVpcCidrBlockResponseBody() {}

  explicit UnassociateVpcCidrBlockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnassociateVpcCidrBlockResponseBody() = default;
};
class UnassociateVpcCidrBlockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnassociateVpcCidrBlockResponseBody> body{};

  UnassociateVpcCidrBlockResponse() {}

  explicit UnassociateVpcCidrBlockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnassociateVpcCidrBlockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnassociateVpcCidrBlockResponseBody>(model1);
      }
    }
  }


  virtual ~UnassociateVpcCidrBlockResponse() = default;
};
class UntagResourcesForExpressConnectRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  UntagResourcesForExpressConnectRequest() {}

  explicit UntagResourcesForExpressConnectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesForExpressConnectRequest() = default;
};
class UntagResourcesForExpressConnectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagResourcesForExpressConnectResponseBody() {}

  explicit UntagResourcesForExpressConnectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesForExpressConnectResponseBody() = default;
};
class UntagResourcesForExpressConnectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesForExpressConnectResponseBody> body{};

  UntagResourcesForExpressConnectResponse() {}

  explicit UntagResourcesForExpressConnectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesForExpressConnectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesForExpressConnectResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesForExpressConnectResponse() = default;
};
class UpdateDhcpOptionsSetAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> dhcpOptionsSetDescription{};
  shared_ptr<string> dhcpOptionsSetId{};
  shared_ptr<string> dhcpOptionsSetName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainNameServers{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ipv6LeaseTime{};
  shared_ptr<string> leaseTime{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UpdateDhcpOptionsSetAttributeRequest() {}

  explicit UpdateDhcpOptionsSetAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dhcpOptionsSetDescription) {
      res["DhcpOptionsSetDescription"] = boost::any(*dhcpOptionsSetDescription);
    }
    if (dhcpOptionsSetId) {
      res["DhcpOptionsSetId"] = boost::any(*dhcpOptionsSetId);
    }
    if (dhcpOptionsSetName) {
      res["DhcpOptionsSetName"] = boost::any(*dhcpOptionsSetName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainNameServers) {
      res["DomainNameServers"] = boost::any(*domainNameServers);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ipv6LeaseTime) {
      res["Ipv6LeaseTime"] = boost::any(*ipv6LeaseTime);
    }
    if (leaseTime) {
      res["LeaseTime"] = boost::any(*leaseTime);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DhcpOptionsSetDescription") != m.end() && !m["DhcpOptionsSetDescription"].empty()) {
      dhcpOptionsSetDescription = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetDescription"]));
    }
    if (m.find("DhcpOptionsSetId") != m.end() && !m["DhcpOptionsSetId"].empty()) {
      dhcpOptionsSetId = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetId"]));
    }
    if (m.find("DhcpOptionsSetName") != m.end() && !m["DhcpOptionsSetName"].empty()) {
      dhcpOptionsSetName = make_shared<string>(boost::any_cast<string>(m["DhcpOptionsSetName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainNameServers") != m.end() && !m["DomainNameServers"].empty()) {
      domainNameServers = make_shared<string>(boost::any_cast<string>(m["DomainNameServers"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("Ipv6LeaseTime") != m.end() && !m["Ipv6LeaseTime"].empty()) {
      ipv6LeaseTime = make_shared<string>(boost::any_cast<string>(m["Ipv6LeaseTime"]));
    }
    if (m.find("LeaseTime") != m.end() && !m["LeaseTime"].empty()) {
      leaseTime = make_shared<string>(boost::any_cast<string>(m["LeaseTime"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UpdateDhcpOptionsSetAttributeRequest() = default;
};
class UpdateDhcpOptionsSetAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDhcpOptionsSetAttributeResponseBody() {}

  explicit UpdateDhcpOptionsSetAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDhcpOptionsSetAttributeResponseBody() = default;
};
class UpdateDhcpOptionsSetAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDhcpOptionsSetAttributeResponseBody> body{};

  UpdateDhcpOptionsSetAttributeResponse() {}

  explicit UpdateDhcpOptionsSetAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDhcpOptionsSetAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDhcpOptionsSetAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDhcpOptionsSetAttributeResponse() = default;
};
class UpdateFailoverTestJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<long> jobDuration{};
  shared_ptr<string> jobId{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceOwnerAccount{};

  UpdateFailoverTestJobRequest() {}

  explicit UpdateFailoverTestJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (jobDuration) {
      res["JobDuration"] = boost::any(*jobDuration);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("JobDuration") != m.end() && !m["JobDuration"].empty()) {
      jobDuration = make_shared<long>(boost::any_cast<long>(m["JobDuration"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
  }


  virtual ~UpdateFailoverTestJobRequest() = default;
};
class UpdateFailoverTestJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateFailoverTestJobResponseBody() {}

  explicit UpdateFailoverTestJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateFailoverTestJobResponseBody() = default;
};
class UpdateFailoverTestJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateFailoverTestJobResponseBody> body{};

  UpdateFailoverTestJobResponse() {}

  explicit UpdateFailoverTestJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFailoverTestJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFailoverTestJobResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFailoverTestJobResponse() = default;
};
class UpdateGatewayRouteTableEntryAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> gatewayRouteTableId{};
  shared_ptr<string> IPv4GatewayRouteTableId{};
  shared_ptr<string> name{};
  shared_ptr<string> nextHopId{};
  shared_ptr<string> nextHopType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UpdateGatewayRouteTableEntryAttributeRequest() {}

  explicit UpdateGatewayRouteTableEntryAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (gatewayRouteTableId) {
      res["GatewayRouteTableId"] = boost::any(*gatewayRouteTableId);
    }
    if (IPv4GatewayRouteTableId) {
      res["IPv4GatewayRouteTableId"] = boost::any(*IPv4GatewayRouteTableId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nextHopId) {
      res["NextHopId"] = boost::any(*nextHopId);
    }
    if (nextHopType) {
      res["NextHopType"] = boost::any(*nextHopType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("GatewayRouteTableId") != m.end() && !m["GatewayRouteTableId"].empty()) {
      gatewayRouteTableId = make_shared<string>(boost::any_cast<string>(m["GatewayRouteTableId"]));
    }
    if (m.find("IPv4GatewayRouteTableId") != m.end() && !m["IPv4GatewayRouteTableId"].empty()) {
      IPv4GatewayRouteTableId = make_shared<string>(boost::any_cast<string>(m["IPv4GatewayRouteTableId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NextHopId") != m.end() && !m["NextHopId"].empty()) {
      nextHopId = make_shared<string>(boost::any_cast<string>(m["NextHopId"]));
    }
    if (m.find("NextHopType") != m.end() && !m["NextHopType"].empty()) {
      nextHopType = make_shared<string>(boost::any_cast<string>(m["NextHopType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UpdateGatewayRouteTableEntryAttributeRequest() = default;
};
class UpdateGatewayRouteTableEntryAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateGatewayRouteTableEntryAttributeResponseBody() {}

  explicit UpdateGatewayRouteTableEntryAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateGatewayRouteTableEntryAttributeResponseBody() = default;
};
class UpdateGatewayRouteTableEntryAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewayRouteTableEntryAttributeResponseBody> body{};

  UpdateGatewayRouteTableEntryAttributeResponse() {}

  explicit UpdateGatewayRouteTableEntryAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewayRouteTableEntryAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewayRouteTableEntryAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewayRouteTableEntryAttributeResponse() = default;
};
class UpdateIpsecServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientIpPool{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> dryRun{};
  shared_ptr<bool> effectImmediately{};
  shared_ptr<string> ikeConfig{};
  shared_ptr<string> ipsecConfig{};
  shared_ptr<string> ipsecServerId{};
  shared_ptr<string> ipsecServerName{};
  shared_ptr<string> localSubnet{};
  shared_ptr<string> psk{};
  shared_ptr<bool> pskEnabled{};
  shared_ptr<string> regionId{};

  UpdateIpsecServerRequest() {}

  explicit UpdateIpsecServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientIpPool) {
      res["ClientIpPool"] = boost::any(*clientIpPool);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (effectImmediately) {
      res["EffectImmediately"] = boost::any(*effectImmediately);
    }
    if (ikeConfig) {
      res["IkeConfig"] = boost::any(*ikeConfig);
    }
    if (ipsecConfig) {
      res["IpsecConfig"] = boost::any(*ipsecConfig);
    }
    if (ipsecServerId) {
      res["IpsecServerId"] = boost::any(*ipsecServerId);
    }
    if (ipsecServerName) {
      res["IpsecServerName"] = boost::any(*ipsecServerName);
    }
    if (localSubnet) {
      res["LocalSubnet"] = boost::any(*localSubnet);
    }
    if (psk) {
      res["Psk"] = boost::any(*psk);
    }
    if (pskEnabled) {
      res["PskEnabled"] = boost::any(*pskEnabled);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientIpPool") != m.end() && !m["ClientIpPool"].empty()) {
      clientIpPool = make_shared<string>(boost::any_cast<string>(m["ClientIpPool"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<string>(boost::any_cast<string>(m["DryRun"]));
    }
    if (m.find("EffectImmediately") != m.end() && !m["EffectImmediately"].empty()) {
      effectImmediately = make_shared<bool>(boost::any_cast<bool>(m["EffectImmediately"]));
    }
    if (m.find("IkeConfig") != m.end() && !m["IkeConfig"].empty()) {
      ikeConfig = make_shared<string>(boost::any_cast<string>(m["IkeConfig"]));
    }
    if (m.find("IpsecConfig") != m.end() && !m["IpsecConfig"].empty()) {
      ipsecConfig = make_shared<string>(boost::any_cast<string>(m["IpsecConfig"]));
    }
    if (m.find("IpsecServerId") != m.end() && !m["IpsecServerId"].empty()) {
      ipsecServerId = make_shared<string>(boost::any_cast<string>(m["IpsecServerId"]));
    }
    if (m.find("IpsecServerName") != m.end() && !m["IpsecServerName"].empty()) {
      ipsecServerName = make_shared<string>(boost::any_cast<string>(m["IpsecServerName"]));
    }
    if (m.find("LocalSubnet") != m.end() && !m["LocalSubnet"].empty()) {
      localSubnet = make_shared<string>(boost::any_cast<string>(m["LocalSubnet"]));
    }
    if (m.find("Psk") != m.end() && !m["Psk"].empty()) {
      psk = make_shared<string>(boost::any_cast<string>(m["Psk"]));
    }
    if (m.find("PskEnabled") != m.end() && !m["PskEnabled"].empty()) {
      pskEnabled = make_shared<bool>(boost::any_cast<bool>(m["PskEnabled"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateIpsecServerRequest() = default;
};
class UpdateIpsecServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateIpsecServerResponseBody() {}

  explicit UpdateIpsecServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateIpsecServerResponseBody() = default;
};
class UpdateIpsecServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateIpsecServerResponseBody> body{};

  UpdateIpsecServerResponse() {}

  explicit UpdateIpsecServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateIpsecServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateIpsecServerResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateIpsecServerResponse() = default;
};
class UpdateIpv4GatewayAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ipv4GatewayDescription{};
  shared_ptr<string> ipv4GatewayId{};
  shared_ptr<string> ipv4GatewayName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UpdateIpv4GatewayAttributeRequest() {}

  explicit UpdateIpv4GatewayAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ipv4GatewayDescription) {
      res["Ipv4GatewayDescription"] = boost::any(*ipv4GatewayDescription);
    }
    if (ipv4GatewayId) {
      res["Ipv4GatewayId"] = boost::any(*ipv4GatewayId);
    }
    if (ipv4GatewayName) {
      res["Ipv4GatewayName"] = boost::any(*ipv4GatewayName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("Ipv4GatewayDescription") != m.end() && !m["Ipv4GatewayDescription"].empty()) {
      ipv4GatewayDescription = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayDescription"]));
    }
    if (m.find("Ipv4GatewayId") != m.end() && !m["Ipv4GatewayId"].empty()) {
      ipv4GatewayId = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayId"]));
    }
    if (m.find("Ipv4GatewayName") != m.end() && !m["Ipv4GatewayName"].empty()) {
      ipv4GatewayName = make_shared<string>(boost::any_cast<string>(m["Ipv4GatewayName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UpdateIpv4GatewayAttributeRequest() = default;
};
class UpdateIpv4GatewayAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateIpv4GatewayAttributeResponseBody() {}

  explicit UpdateIpv4GatewayAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateIpv4GatewayAttributeResponseBody() = default;
};
class UpdateIpv4GatewayAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateIpv4GatewayAttributeResponseBody> body{};

  UpdateIpv4GatewayAttributeResponse() {}

  explicit UpdateIpv4GatewayAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateIpv4GatewayAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateIpv4GatewayAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateIpv4GatewayAttributeResponse() = default;
};
class UpdateNatGatewayNatTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> natType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> vSwitchId{};

  UpdateNatGatewayNatTypeRequest() {}

  explicit UpdateNatGatewayNatTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (natType) {
      res["NatType"] = boost::any(*natType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("NatType") != m.end() && !m["NatType"].empty()) {
      natType = make_shared<string>(boost::any_cast<string>(m["NatType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~UpdateNatGatewayNatTypeRequest() = default;
};
class UpdateNatGatewayNatTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateNatGatewayNatTypeResponseBody() {}

  explicit UpdateNatGatewayNatTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateNatGatewayNatTypeResponseBody() = default;
};
class UpdateNatGatewayNatTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateNatGatewayNatTypeResponseBody> body{};

  UpdateNatGatewayNatTypeResponse() {}

  explicit UpdateNatGatewayNatTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateNatGatewayNatTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateNatGatewayNatTypeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateNatGatewayNatTypeResponse() = default;
};
class UpdateNetworkAclEntriesRequestEgressAclEntries : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> destinationCidrIp{};
  shared_ptr<string> entryType{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> networkAclEntryId{};
  shared_ptr<string> networkAclEntryName{};
  shared_ptr<string> policy{};
  shared_ptr<string> port{};
  shared_ptr<string> protocol{};

  UpdateNetworkAclEntriesRequestEgressAclEntries() {}

  explicit UpdateNetworkAclEntriesRequestEgressAclEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationCidrIp) {
      res["DestinationCidrIp"] = boost::any(*destinationCidrIp);
    }
    if (entryType) {
      res["EntryType"] = boost::any(*entryType);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (networkAclEntryId) {
      res["NetworkAclEntryId"] = boost::any(*networkAclEntryId);
    }
    if (networkAclEntryName) {
      res["NetworkAclEntryName"] = boost::any(*networkAclEntryName);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationCidrIp") != m.end() && !m["DestinationCidrIp"].empty()) {
      destinationCidrIp = make_shared<string>(boost::any_cast<string>(m["DestinationCidrIp"]));
    }
    if (m.find("EntryType") != m.end() && !m["EntryType"].empty()) {
      entryType = make_shared<string>(boost::any_cast<string>(m["EntryType"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("NetworkAclEntryId") != m.end() && !m["NetworkAclEntryId"].empty()) {
      networkAclEntryId = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryId"]));
    }
    if (m.find("NetworkAclEntryName") != m.end() && !m["NetworkAclEntryName"].empty()) {
      networkAclEntryName = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryName"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~UpdateNetworkAclEntriesRequestEgressAclEntries() = default;
};
class UpdateNetworkAclEntriesRequestIngressAclEntries : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> entryType{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> networkAclEntryId{};
  shared_ptr<string> networkAclEntryName{};
  shared_ptr<string> policy{};
  shared_ptr<string> port{};
  shared_ptr<string> protocol{};
  shared_ptr<string> sourceCidrIp{};

  UpdateNetworkAclEntriesRequestIngressAclEntries() {}

  explicit UpdateNetworkAclEntriesRequestIngressAclEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (entryType) {
      res["EntryType"] = boost::any(*entryType);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (networkAclEntryId) {
      res["NetworkAclEntryId"] = boost::any(*networkAclEntryId);
    }
    if (networkAclEntryName) {
      res["NetworkAclEntryName"] = boost::any(*networkAclEntryName);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (sourceCidrIp) {
      res["SourceCidrIp"] = boost::any(*sourceCidrIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EntryType") != m.end() && !m["EntryType"].empty()) {
      entryType = make_shared<string>(boost::any_cast<string>(m["EntryType"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("NetworkAclEntryId") != m.end() && !m["NetworkAclEntryId"].empty()) {
      networkAclEntryId = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryId"]));
    }
    if (m.find("NetworkAclEntryName") != m.end() && !m["NetworkAclEntryName"].empty()) {
      networkAclEntryName = make_shared<string>(boost::any_cast<string>(m["NetworkAclEntryName"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SourceCidrIp") != m.end() && !m["SourceCidrIp"].empty()) {
      sourceCidrIp = make_shared<string>(boost::any_cast<string>(m["SourceCidrIp"]));
    }
  }


  virtual ~UpdateNetworkAclEntriesRequestIngressAclEntries() = default;
};
class UpdateNetworkAclEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<UpdateNetworkAclEntriesRequestEgressAclEntries>> egressAclEntries{};
  shared_ptr<vector<UpdateNetworkAclEntriesRequestIngressAclEntries>> ingressAclEntries{};
  shared_ptr<string> networkAclId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<bool> updateEgressAclEntries{};
  shared_ptr<bool> updateIngressAclEntries{};

  UpdateNetworkAclEntriesRequest() {}

  explicit UpdateNetworkAclEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (egressAclEntries) {
      vector<boost::any> temp1;
      for(auto item1:*egressAclEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EgressAclEntries"] = boost::any(temp1);
    }
    if (ingressAclEntries) {
      vector<boost::any> temp1;
      for(auto item1:*ingressAclEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IngressAclEntries"] = boost::any(temp1);
    }
    if (networkAclId) {
      res["NetworkAclId"] = boost::any(*networkAclId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (updateEgressAclEntries) {
      res["UpdateEgressAclEntries"] = boost::any(*updateEgressAclEntries);
    }
    if (updateIngressAclEntries) {
      res["UpdateIngressAclEntries"] = boost::any(*updateIngressAclEntries);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EgressAclEntries") != m.end() && !m["EgressAclEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["EgressAclEntries"].type()) {
        vector<UpdateNetworkAclEntriesRequestEgressAclEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EgressAclEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateNetworkAclEntriesRequestEgressAclEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        egressAclEntries = make_shared<vector<UpdateNetworkAclEntriesRequestEgressAclEntries>>(expect1);
      }
    }
    if (m.find("IngressAclEntries") != m.end() && !m["IngressAclEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["IngressAclEntries"].type()) {
        vector<UpdateNetworkAclEntriesRequestIngressAclEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IngressAclEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateNetworkAclEntriesRequestIngressAclEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ingressAclEntries = make_shared<vector<UpdateNetworkAclEntriesRequestIngressAclEntries>>(expect1);
      }
    }
    if (m.find("NetworkAclId") != m.end() && !m["NetworkAclId"].empty()) {
      networkAclId = make_shared<string>(boost::any_cast<string>(m["NetworkAclId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("UpdateEgressAclEntries") != m.end() && !m["UpdateEgressAclEntries"].empty()) {
      updateEgressAclEntries = make_shared<bool>(boost::any_cast<bool>(m["UpdateEgressAclEntries"]));
    }
    if (m.find("UpdateIngressAclEntries") != m.end() && !m["UpdateIngressAclEntries"].empty()) {
      updateIngressAclEntries = make_shared<bool>(boost::any_cast<bool>(m["UpdateIngressAclEntries"]));
    }
  }


  virtual ~UpdateNetworkAclEntriesRequest() = default;
};
class UpdateNetworkAclEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateNetworkAclEntriesResponseBody() {}

  explicit UpdateNetworkAclEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateNetworkAclEntriesResponseBody() = default;
};
class UpdateNetworkAclEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateNetworkAclEntriesResponseBody> body{};

  UpdateNetworkAclEntriesResponse() {}

  explicit UpdateNetworkAclEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateNetworkAclEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateNetworkAclEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateNetworkAclEntriesResponse() = default;
};
class UpdatePublicIpAddressPoolAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> publicIpAddressPoolId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UpdatePublicIpAddressPoolAttributeRequest() {}

  explicit UpdatePublicIpAddressPoolAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (publicIpAddressPoolId) {
      res["PublicIpAddressPoolId"] = boost::any(*publicIpAddressPoolId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PublicIpAddressPoolId") != m.end() && !m["PublicIpAddressPoolId"].empty()) {
      publicIpAddressPoolId = make_shared<string>(boost::any_cast<string>(m["PublicIpAddressPoolId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UpdatePublicIpAddressPoolAttributeRequest() = default;
};
class UpdatePublicIpAddressPoolAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdatePublicIpAddressPoolAttributeResponseBody() {}

  explicit UpdatePublicIpAddressPoolAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdatePublicIpAddressPoolAttributeResponseBody() = default;
};
class UpdatePublicIpAddressPoolAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePublicIpAddressPoolAttributeResponseBody> body{};

  UpdatePublicIpAddressPoolAttributeResponse() {}

  explicit UpdatePublicIpAddressPoolAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePublicIpAddressPoolAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePublicIpAddressPoolAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePublicIpAddressPoolAttributeResponse() = default;
};
class UpdateTrafficMirrorFilterAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> trafficMirrorFilterDescription{};
  shared_ptr<string> trafficMirrorFilterId{};
  shared_ptr<string> trafficMirrorFilterName{};

  UpdateTrafficMirrorFilterAttributeRequest() {}

  explicit UpdateTrafficMirrorFilterAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (trafficMirrorFilterDescription) {
      res["TrafficMirrorFilterDescription"] = boost::any(*trafficMirrorFilterDescription);
    }
    if (trafficMirrorFilterId) {
      res["TrafficMirrorFilterId"] = boost::any(*trafficMirrorFilterId);
    }
    if (trafficMirrorFilterName) {
      res["TrafficMirrorFilterName"] = boost::any(*trafficMirrorFilterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TrafficMirrorFilterDescription") != m.end() && !m["TrafficMirrorFilterDescription"].empty()) {
      trafficMirrorFilterDescription = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterDescription"]));
    }
    if (m.find("TrafficMirrorFilterId") != m.end() && !m["TrafficMirrorFilterId"].empty()) {
      trafficMirrorFilterId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterId"]));
    }
    if (m.find("TrafficMirrorFilterName") != m.end() && !m["TrafficMirrorFilterName"].empty()) {
      trafficMirrorFilterName = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterName"]));
    }
  }


  virtual ~UpdateTrafficMirrorFilterAttributeRequest() = default;
};
class UpdateTrafficMirrorFilterAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateTrafficMirrorFilterAttributeResponseBody() {}

  explicit UpdateTrafficMirrorFilterAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateTrafficMirrorFilterAttributeResponseBody() = default;
};
class UpdateTrafficMirrorFilterAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTrafficMirrorFilterAttributeResponseBody> body{};

  UpdateTrafficMirrorFilterAttributeResponse() {}

  explicit UpdateTrafficMirrorFilterAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTrafficMirrorFilterAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTrafficMirrorFilterAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTrafficMirrorFilterAttributeResponse() = default;
};
class UpdateTrafficMirrorFilterRuleAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> destinationCidrBlock{};
  shared_ptr<string> destinationPortRange{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> priority{};
  shared_ptr<string> protocol{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ruleAction{};
  shared_ptr<string> sourceCidrBlock{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> trafficMirrorFilterRuleId{};

  UpdateTrafficMirrorFilterRuleAttributeRequest() {}

  explicit UpdateTrafficMirrorFilterRuleAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (destinationCidrBlock) {
      res["DestinationCidrBlock"] = boost::any(*destinationCidrBlock);
    }
    if (destinationPortRange) {
      res["DestinationPortRange"] = boost::any(*destinationPortRange);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ruleAction) {
      res["RuleAction"] = boost::any(*ruleAction);
    }
    if (sourceCidrBlock) {
      res["SourceCidrBlock"] = boost::any(*sourceCidrBlock);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (trafficMirrorFilterRuleId) {
      res["TrafficMirrorFilterRuleId"] = boost::any(*trafficMirrorFilterRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DestinationCidrBlock") != m.end() && !m["DestinationCidrBlock"].empty()) {
      destinationCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestinationCidrBlock"]));
    }
    if (m.find("DestinationPortRange") != m.end() && !m["DestinationPortRange"].empty()) {
      destinationPortRange = make_shared<string>(boost::any_cast<string>(m["DestinationPortRange"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RuleAction") != m.end() && !m["RuleAction"].empty()) {
      ruleAction = make_shared<string>(boost::any_cast<string>(m["RuleAction"]));
    }
    if (m.find("SourceCidrBlock") != m.end() && !m["SourceCidrBlock"].empty()) {
      sourceCidrBlock = make_shared<string>(boost::any_cast<string>(m["SourceCidrBlock"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("TrafficMirrorFilterRuleId") != m.end() && !m["TrafficMirrorFilterRuleId"].empty()) {
      trafficMirrorFilterRuleId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterRuleId"]));
    }
  }


  virtual ~UpdateTrafficMirrorFilterRuleAttributeRequest() = default;
};
class UpdateTrafficMirrorFilterRuleAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateTrafficMirrorFilterRuleAttributeResponseBody() {}

  explicit UpdateTrafficMirrorFilterRuleAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateTrafficMirrorFilterRuleAttributeResponseBody() = default;
};
class UpdateTrafficMirrorFilterRuleAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTrafficMirrorFilterRuleAttributeResponseBody> body{};

  UpdateTrafficMirrorFilterRuleAttributeResponse() {}

  explicit UpdateTrafficMirrorFilterRuleAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTrafficMirrorFilterRuleAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTrafficMirrorFilterRuleAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTrafficMirrorFilterRuleAttributeResponse() = default;
};
class UpdateTrafficMirrorSessionAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> packetLength{};
  shared_ptr<long> priority{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> trafficMirrorFilterId{};
  shared_ptr<string> trafficMirrorSessionDescription{};
  shared_ptr<string> trafficMirrorSessionId{};
  shared_ptr<string> trafficMirrorSessionName{};
  shared_ptr<string> trafficMirrorTargetId{};
  shared_ptr<string> trafficMirrorTargetType{};
  shared_ptr<long> virtualNetworkId{};

  UpdateTrafficMirrorSessionAttributeRequest() {}

  explicit UpdateTrafficMirrorSessionAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (packetLength) {
      res["PacketLength"] = boost::any(*packetLength);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (trafficMirrorFilterId) {
      res["TrafficMirrorFilterId"] = boost::any(*trafficMirrorFilterId);
    }
    if (trafficMirrorSessionDescription) {
      res["TrafficMirrorSessionDescription"] = boost::any(*trafficMirrorSessionDescription);
    }
    if (trafficMirrorSessionId) {
      res["TrafficMirrorSessionId"] = boost::any(*trafficMirrorSessionId);
    }
    if (trafficMirrorSessionName) {
      res["TrafficMirrorSessionName"] = boost::any(*trafficMirrorSessionName);
    }
    if (trafficMirrorTargetId) {
      res["TrafficMirrorTargetId"] = boost::any(*trafficMirrorTargetId);
    }
    if (trafficMirrorTargetType) {
      res["TrafficMirrorTargetType"] = boost::any(*trafficMirrorTargetType);
    }
    if (virtualNetworkId) {
      res["VirtualNetworkId"] = boost::any(*virtualNetworkId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PacketLength") != m.end() && !m["PacketLength"].empty()) {
      packetLength = make_shared<long>(boost::any_cast<long>(m["PacketLength"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TrafficMirrorFilterId") != m.end() && !m["TrafficMirrorFilterId"].empty()) {
      trafficMirrorFilterId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorFilterId"]));
    }
    if (m.find("TrafficMirrorSessionDescription") != m.end() && !m["TrafficMirrorSessionDescription"].empty()) {
      trafficMirrorSessionDescription = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorSessionDescription"]));
    }
    if (m.find("TrafficMirrorSessionId") != m.end() && !m["TrafficMirrorSessionId"].empty()) {
      trafficMirrorSessionId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorSessionId"]));
    }
    if (m.find("TrafficMirrorSessionName") != m.end() && !m["TrafficMirrorSessionName"].empty()) {
      trafficMirrorSessionName = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorSessionName"]));
    }
    if (m.find("TrafficMirrorTargetId") != m.end() && !m["TrafficMirrorTargetId"].empty()) {
      trafficMirrorTargetId = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorTargetId"]));
    }
    if (m.find("TrafficMirrorTargetType") != m.end() && !m["TrafficMirrorTargetType"].empty()) {
      trafficMirrorTargetType = make_shared<string>(boost::any_cast<string>(m["TrafficMirrorTargetType"]));
    }
    if (m.find("VirtualNetworkId") != m.end() && !m["VirtualNetworkId"].empty()) {
      virtualNetworkId = make_shared<long>(boost::any_cast<long>(m["VirtualNetworkId"]));
    }
  }


  virtual ~UpdateTrafficMirrorSessionAttributeRequest() = default;
};
class UpdateTrafficMirrorSessionAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateTrafficMirrorSessionAttributeResponseBody() {}

  explicit UpdateTrafficMirrorSessionAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateTrafficMirrorSessionAttributeResponseBody() = default;
};
class UpdateTrafficMirrorSessionAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTrafficMirrorSessionAttributeResponseBody> body{};

  UpdateTrafficMirrorSessionAttributeResponse() {}

  explicit UpdateTrafficMirrorSessionAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTrafficMirrorSessionAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTrafficMirrorSessionAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTrafficMirrorSessionAttributeResponse() = default;
};
class UpdateVirtualBorderBandwidthRequest : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> virtualBorderRouterId{};

  UpdateVirtualBorderBandwidthRequest() {}

  explicit UpdateVirtualBorderBandwidthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (virtualBorderRouterId) {
      res["VirtualBorderRouterId"] = boost::any(*virtualBorderRouterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VirtualBorderRouterId") != m.end() && !m["VirtualBorderRouterId"].empty()) {
      virtualBorderRouterId = make_shared<string>(boost::any_cast<string>(m["VirtualBorderRouterId"]));
    }
  }


  virtual ~UpdateVirtualBorderBandwidthRequest() = default;
};
class UpdateVirtualBorderBandwidthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateVirtualBorderBandwidthResponseBody() {}

  explicit UpdateVirtualBorderBandwidthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateVirtualBorderBandwidthResponseBody() = default;
};
class UpdateVirtualBorderBandwidthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateVirtualBorderBandwidthResponseBody> body{};

  UpdateVirtualBorderBandwidthResponse() {}

  explicit UpdateVirtualBorderBandwidthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateVirtualBorderBandwidthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateVirtualBorderBandwidthResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateVirtualBorderBandwidthResponse() = default;
};
class UpdateVirtualPhysicalConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<string> expectSpec{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> token{};
  shared_ptr<long> vlanId{};

  UpdateVirtualPhysicalConnectionRequest() {}

  explicit UpdateVirtualPhysicalConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (expectSpec) {
      res["ExpectSpec"] = boost::any(*expectSpec);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (vlanId) {
      res["VlanId"] = boost::any(*vlanId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("ExpectSpec") != m.end() && !m["ExpectSpec"].empty()) {
      expectSpec = make_shared<string>(boost::any_cast<string>(m["ExpectSpec"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("VlanId") != m.end() && !m["VlanId"].empty()) {
      vlanId = make_shared<long>(boost::any_cast<long>(m["VlanId"]));
    }
  }


  virtual ~UpdateVirtualPhysicalConnectionRequest() = default;
};
class UpdateVirtualPhysicalConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  UpdateVirtualPhysicalConnectionResponseBody() {}

  explicit UpdateVirtualPhysicalConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~UpdateVirtualPhysicalConnectionResponseBody() = default;
};
class UpdateVirtualPhysicalConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateVirtualPhysicalConnectionResponseBody> body{};

  UpdateVirtualPhysicalConnectionResponse() {}

  explicit UpdateVirtualPhysicalConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateVirtualPhysicalConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateVirtualPhysicalConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateVirtualPhysicalConnectionResponse() = default;
};
class UpdateVpcGatewayEndpointAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> endpointDescription{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> policyDocument{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UpdateVpcGatewayEndpointAttributeRequest() {}

  explicit UpdateVpcGatewayEndpointAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (endpointDescription) {
      res["EndpointDescription"] = boost::any(*endpointDescription);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (policyDocument) {
      res["PolicyDocument"] = boost::any(*policyDocument);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EndpointDescription") != m.end() && !m["EndpointDescription"].empty()) {
      endpointDescription = make_shared<string>(boost::any_cast<string>(m["EndpointDescription"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PolicyDocument") != m.end() && !m["PolicyDocument"].empty()) {
      policyDocument = make_shared<string>(boost::any_cast<string>(m["PolicyDocument"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UpdateVpcGatewayEndpointAttributeRequest() = default;
};
class UpdateVpcGatewayEndpointAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateVpcGatewayEndpointAttributeResponseBody() {}

  explicit UpdateVpcGatewayEndpointAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateVpcGatewayEndpointAttributeResponseBody() = default;
};
class UpdateVpcGatewayEndpointAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateVpcGatewayEndpointAttributeResponseBody> body{};

  UpdateVpcGatewayEndpointAttributeResponse() {}

  explicit UpdateVpcGatewayEndpointAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateVpcGatewayEndpointAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateVpcGatewayEndpointAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateVpcGatewayEndpointAttributeResponse() = default;
};
class VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> natGatewayId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> resourceUid{};

  VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest() {}

  explicit VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (natGatewayId) {
      res["NatGatewayId"] = boost::any(*natGatewayId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceUid) {
      res["ResourceUid"] = boost::any(*resourceUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("NatGatewayId") != m.end() && !m["NatGatewayId"].empty()) {
      natGatewayId = make_shared<string>(boost::any_cast<string>(m["NatGatewayId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceUid") != m.end() && !m["ResourceUid"].empty()) {
      resourceUid = make_shared<long>(boost::any_cast<long>(m["ResourceUid"]));
    }
  }


  virtual ~VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest() = default;
};
class VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> quota{};
  shared_ptr<string> requestId{};

  VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody() {}

  explicit VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quota) {
      res["Quota"] = boost::any(*quota);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Quota") != m.end() && !m["Quota"].empty()) {
      quota = make_shared<long>(boost::any_cast<long>(m["Quota"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody() = default;
};
class VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody> body{};

  VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse() {}

  explicit VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  ActivateRouterInterfaceResponse activateRouterInterfaceWithOptions(shared_ptr<ActivateRouterInterfaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ActivateRouterInterfaceResponse activateRouterInterface(shared_ptr<ActivateRouterInterfaceRequest> request);
  ActiveFlowLogResponse activeFlowLogWithOptions(shared_ptr<ActiveFlowLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ActiveFlowLogResponse activeFlowLog(shared_ptr<ActiveFlowLogRequest> request);
  AddBgpNetworkResponse addBgpNetworkWithOptions(shared_ptr<AddBgpNetworkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddBgpNetworkResponse addBgpNetwork(shared_ptr<AddBgpNetworkRequest> request);
  AddCommonBandwidthPackageIpResponse addCommonBandwidthPackageIpWithOptions(shared_ptr<AddCommonBandwidthPackageIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCommonBandwidthPackageIpResponse addCommonBandwidthPackageIp(shared_ptr<AddCommonBandwidthPackageIpRequest> request);
  AddCommonBandwidthPackageIpsResponse addCommonBandwidthPackageIpsWithOptions(shared_ptr<AddCommonBandwidthPackageIpsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCommonBandwidthPackageIpsResponse addCommonBandwidthPackageIps(shared_ptr<AddCommonBandwidthPackageIpsRequest> request);
  AddGlobalAccelerationInstanceIpResponse addGlobalAccelerationInstanceIpWithOptions(shared_ptr<AddGlobalAccelerationInstanceIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddGlobalAccelerationInstanceIpResponse addGlobalAccelerationInstanceIp(shared_ptr<AddGlobalAccelerationInstanceIpRequest> request);
  AddIPv6TranslatorAclListEntryResponse addIPv6TranslatorAclListEntryWithOptions(shared_ptr<AddIPv6TranslatorAclListEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddIPv6TranslatorAclListEntryResponse addIPv6TranslatorAclListEntry(shared_ptr<AddIPv6TranslatorAclListEntryRequest> request);
  AddPublicIpAddressPoolCidrBlockResponse addPublicIpAddressPoolCidrBlockWithOptions(shared_ptr<AddPublicIpAddressPoolCidrBlockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPublicIpAddressPoolCidrBlockResponse addPublicIpAddressPoolCidrBlock(shared_ptr<AddPublicIpAddressPoolCidrBlockRequest> request);
  AddSourcesToTrafficMirrorSessionResponse addSourcesToTrafficMirrorSessionWithOptions(shared_ptr<AddSourcesToTrafficMirrorSessionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddSourcesToTrafficMirrorSessionResponse addSourcesToTrafficMirrorSession(shared_ptr<AddSourcesToTrafficMirrorSessionRequest> request);
  AllocateEipAddressResponse allocateEipAddressWithOptions(shared_ptr<AllocateEipAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AllocateEipAddressResponse allocateEipAddress(shared_ptr<AllocateEipAddressRequest> request);
  AllocateEipAddressProResponse allocateEipAddressProWithOptions(shared_ptr<AllocateEipAddressProRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AllocateEipAddressProResponse allocateEipAddressPro(shared_ptr<AllocateEipAddressProRequest> request);
  AllocateEipSegmentAddressResponse allocateEipSegmentAddressWithOptions(shared_ptr<AllocateEipSegmentAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AllocateEipSegmentAddressResponse allocateEipSegmentAddress(shared_ptr<AllocateEipSegmentAddressRequest> request);
  AllocateIpv6AddressResponse allocateIpv6AddressWithOptions(shared_ptr<AllocateIpv6AddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AllocateIpv6AddressResponse allocateIpv6Address(shared_ptr<AllocateIpv6AddressRequest> request);
  AllocateIpv6InternetBandwidthResponse allocateIpv6InternetBandwidthWithOptions(shared_ptr<AllocateIpv6InternetBandwidthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AllocateIpv6InternetBandwidthResponse allocateIpv6InternetBandwidth(shared_ptr<AllocateIpv6InternetBandwidthRequest> request);
  AllocateVpcIpv6CidrResponse allocateVpcIpv6CidrWithOptions(shared_ptr<AllocateVpcIpv6CidrRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AllocateVpcIpv6CidrResponse allocateVpcIpv6Cidr(shared_ptr<AllocateVpcIpv6CidrRequest> request);
  ApplyPhysicalConnectionLOAResponse applyPhysicalConnectionLOAWithOptions(shared_ptr<ApplyPhysicalConnectionLOARequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyPhysicalConnectionLOAResponse applyPhysicalConnectionLOA(shared_ptr<ApplyPhysicalConnectionLOARequest> request);
  AssociateEipAddressResponse associateEipAddressWithOptions(shared_ptr<AssociateEipAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateEipAddressResponse associateEipAddress(shared_ptr<AssociateEipAddressRequest> request);
  AssociateEipAddressBatchResponse associateEipAddressBatchWithOptions(shared_ptr<AssociateEipAddressBatchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateEipAddressBatchResponse associateEipAddressBatch(shared_ptr<AssociateEipAddressBatchRequest> request);
  AssociateHaVipResponse associateHaVipWithOptions(shared_ptr<AssociateHaVipRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateHaVipResponse associateHaVip(shared_ptr<AssociateHaVipRequest> request);
  AssociateNetworkAclResponse associateNetworkAclWithOptions(shared_ptr<AssociateNetworkAclRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateNetworkAclResponse associateNetworkAcl(shared_ptr<AssociateNetworkAclRequest> request);
  AssociatePhysicalConnectionToVirtualBorderRouterResponse associatePhysicalConnectionToVirtualBorderRouterWithOptions(shared_ptr<AssociatePhysicalConnectionToVirtualBorderRouterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociatePhysicalConnectionToVirtualBorderRouterResponse associatePhysicalConnectionToVirtualBorderRouter(shared_ptr<AssociatePhysicalConnectionToVirtualBorderRouterRequest> request);
  AssociateRouteTableResponse associateRouteTableWithOptions(shared_ptr<AssociateRouteTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateRouteTableResponse associateRouteTable(shared_ptr<AssociateRouteTableRequest> request);
  AssociateRouteTableWithGatewayResponse associateRouteTableWithGatewayWithOptions(shared_ptr<AssociateRouteTableWithGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateRouteTableWithGatewayResponse associateRouteTableWithGateway(shared_ptr<AssociateRouteTableWithGatewayRequest> request);
  AssociateRouteTablesWithVpcGatewayEndpointResponse associateRouteTablesWithVpcGatewayEndpointWithOptions(shared_ptr<AssociateRouteTablesWithVpcGatewayEndpointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateRouteTablesWithVpcGatewayEndpointResponse associateRouteTablesWithVpcGatewayEndpoint(shared_ptr<AssociateRouteTablesWithVpcGatewayEndpointRequest> request);
  AssociateVpcCidrBlockResponse associateVpcCidrBlockWithOptions(shared_ptr<AssociateVpcCidrBlockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateVpcCidrBlockResponse associateVpcCidrBlock(shared_ptr<AssociateVpcCidrBlockRequest> request);
  AssociateVpnGatewayWithCertificateResponse associateVpnGatewayWithCertificateWithOptions(shared_ptr<AssociateVpnGatewayWithCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateVpnGatewayWithCertificateResponse associateVpnGatewayWithCertificate(shared_ptr<AssociateVpnGatewayWithCertificateRequest> request);
  AttachDhcpOptionsSetToVpcResponse attachDhcpOptionsSetToVpcWithOptions(shared_ptr<AttachDhcpOptionsSetToVpcRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachDhcpOptionsSetToVpcResponse attachDhcpOptionsSetToVpc(shared_ptr<AttachDhcpOptionsSetToVpcRequest> request);
  AttachVbrToVpconnResponse attachVbrToVpconnWithOptions(shared_ptr<AttachVbrToVpconnRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachVbrToVpconnResponse attachVbrToVpconn(shared_ptr<AttachVbrToVpconnRequest> request);
  CancelCommonBandwidthPackageIpBandwidthResponse cancelCommonBandwidthPackageIpBandwidthWithOptions(shared_ptr<CancelCommonBandwidthPackageIpBandwidthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelCommonBandwidthPackageIpBandwidthResponse cancelCommonBandwidthPackageIpBandwidth(shared_ptr<CancelCommonBandwidthPackageIpBandwidthRequest> request);
  CancelPhysicalConnectionResponse cancelPhysicalConnectionWithOptions(shared_ptr<CancelPhysicalConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelPhysicalConnectionResponse cancelPhysicalConnection(shared_ptr<CancelPhysicalConnectionRequest> request);
  ChangeResourceGroupResponse changeResourceGroupWithOptions(shared_ptr<ChangeResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeResourceGroupResponse changeResourceGroup(shared_ptr<ChangeResourceGroupRequest> request);
  CheckCanAllocateVpcPrivateIpAddressResponse checkCanAllocateVpcPrivateIpAddressWithOptions(shared_ptr<CheckCanAllocateVpcPrivateIpAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckCanAllocateVpcPrivateIpAddressResponse checkCanAllocateVpcPrivateIpAddress(shared_ptr<CheckCanAllocateVpcPrivateIpAddressRequest> request);
  CheckVpnBgpEnabledResponse checkVpnBgpEnabledWithOptions(shared_ptr<CheckVpnBgpEnabledRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckVpnBgpEnabledResponse checkVpnBgpEnabled(shared_ptr<CheckVpnBgpEnabledRequest> request);
  CompletePhysicalConnectionLOAResponse completePhysicalConnectionLOAWithOptions(shared_ptr<CompletePhysicalConnectionLOARequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CompletePhysicalConnectionLOAResponse completePhysicalConnectionLOA(shared_ptr<CompletePhysicalConnectionLOARequest> request);
  ConfirmPhysicalConnectionResponse confirmPhysicalConnectionWithOptions(shared_ptr<ConfirmPhysicalConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfirmPhysicalConnectionResponse confirmPhysicalConnection(shared_ptr<ConfirmPhysicalConnectionRequest> request);
  ConnectRouterInterfaceResponse connectRouterInterfaceWithOptions(shared_ptr<ConnectRouterInterfaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConnectRouterInterfaceResponse connectRouterInterface(shared_ptr<ConnectRouterInterfaceRequest> request);
  ConvertBandwidthPackageResponse convertBandwidthPackageWithOptions(shared_ptr<ConvertBandwidthPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConvertBandwidthPackageResponse convertBandwidthPackage(shared_ptr<ConvertBandwidthPackageRequest> request);
  CopyNetworkAclEntriesResponse copyNetworkAclEntriesWithOptions(shared_ptr<CopyNetworkAclEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyNetworkAclEntriesResponse copyNetworkAclEntries(shared_ptr<CopyNetworkAclEntriesRequest> request);
  CreateBgpGroupResponse createBgpGroupWithOptions(shared_ptr<CreateBgpGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBgpGroupResponse createBgpGroup(shared_ptr<CreateBgpGroupRequest> request);
  CreateBgpPeerResponse createBgpPeerWithOptions(shared_ptr<CreateBgpPeerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBgpPeerResponse createBgpPeer(shared_ptr<CreateBgpPeerRequest> request);
  CreateCommonBandwidthPackageResponse createCommonBandwidthPackageWithOptions(shared_ptr<CreateCommonBandwidthPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCommonBandwidthPackageResponse createCommonBandwidthPackage(shared_ptr<CreateCommonBandwidthPackageRequest> request);
  CreateCustomerGatewayResponse createCustomerGatewayWithOptions(shared_ptr<CreateCustomerGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomerGatewayResponse createCustomerGateway(shared_ptr<CreateCustomerGatewayRequest> request);
  CreateDefaultVSwitchResponse createDefaultVSwitchWithOptions(shared_ptr<CreateDefaultVSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDefaultVSwitchResponse createDefaultVSwitch(shared_ptr<CreateDefaultVSwitchRequest> request);
  CreateDefaultVpcResponse createDefaultVpcWithOptions(shared_ptr<CreateDefaultVpcRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDefaultVpcResponse createDefaultVpc(shared_ptr<CreateDefaultVpcRequest> request);
  CreateDhcpOptionsSetResponse createDhcpOptionsSetWithOptions(shared_ptr<CreateDhcpOptionsSetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDhcpOptionsSetResponse createDhcpOptionsSet(shared_ptr<CreateDhcpOptionsSetRequest> request);
  CreateExpressCloudConnectionResponse createExpressCloudConnectionWithOptions(shared_ptr<CreateExpressCloudConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateExpressCloudConnectionResponse createExpressCloudConnection(shared_ptr<CreateExpressCloudConnectionRequest> request);
  CreateExpressConnectTrafficQosResponse createExpressConnectTrafficQosWithOptions(shared_ptr<CreateExpressConnectTrafficQosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateExpressConnectTrafficQosResponse createExpressConnectTrafficQos(shared_ptr<CreateExpressConnectTrafficQosRequest> request);
  CreateExpressConnectTrafficQosQueueResponse createExpressConnectTrafficQosQueueWithOptions(shared_ptr<CreateExpressConnectTrafficQosQueueRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateExpressConnectTrafficQosQueueResponse createExpressConnectTrafficQosQueue(shared_ptr<CreateExpressConnectTrafficQosQueueRequest> request);
  CreateExpressConnectTrafficQosRuleResponse createExpressConnectTrafficQosRuleWithOptions(shared_ptr<CreateExpressConnectTrafficQosRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateExpressConnectTrafficQosRuleResponse createExpressConnectTrafficQosRule(shared_ptr<CreateExpressConnectTrafficQosRuleRequest> request);
  CreateFailoverTestJobResponse createFailoverTestJobWithOptions(shared_ptr<CreateFailoverTestJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFailoverTestJobResponse createFailoverTestJob(shared_ptr<CreateFailoverTestJobRequest> request);
  CreateFlowLogResponse createFlowLogWithOptions(shared_ptr<CreateFlowLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowLogResponse createFlowLog(shared_ptr<CreateFlowLogRequest> request);
  CreateForwardEntryResponse createForwardEntryWithOptions(shared_ptr<CreateForwardEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateForwardEntryResponse createForwardEntry(shared_ptr<CreateForwardEntryRequest> request);
  CreateFullNatEntryResponse createFullNatEntryWithOptions(shared_ptr<CreateFullNatEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFullNatEntryResponse createFullNatEntry(shared_ptr<CreateFullNatEntryRequest> request);
  CreateGlobalAccelerationInstanceResponse createGlobalAccelerationInstanceWithOptions(shared_ptr<CreateGlobalAccelerationInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateGlobalAccelerationInstanceResponse createGlobalAccelerationInstance(shared_ptr<CreateGlobalAccelerationInstanceRequest> request);
  CreateHaVipResponse createHaVipWithOptions(shared_ptr<CreateHaVipRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHaVipResponse createHaVip(shared_ptr<CreateHaVipRequest> request);
  CreateHighReliablePhysicalConnectionResponse createHighReliablePhysicalConnectionWithOptions(shared_ptr<CreateHighReliablePhysicalConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHighReliablePhysicalConnectionResponse createHighReliablePhysicalConnection(shared_ptr<CreateHighReliablePhysicalConnectionRequest> request);
  CreateIPv6TranslatorResponse createIPv6TranslatorWithOptions(shared_ptr<CreateIPv6TranslatorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIPv6TranslatorResponse createIPv6Translator(shared_ptr<CreateIPv6TranslatorRequest> request);
  CreateIPv6TranslatorAclListResponse createIPv6TranslatorAclListWithOptions(shared_ptr<CreateIPv6TranslatorAclListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIPv6TranslatorAclListResponse createIPv6TranslatorAclList(shared_ptr<CreateIPv6TranslatorAclListRequest> request);
  CreateIPv6TranslatorEntryResponse createIPv6TranslatorEntryWithOptions(shared_ptr<CreateIPv6TranslatorEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIPv6TranslatorEntryResponse createIPv6TranslatorEntry(shared_ptr<CreateIPv6TranslatorEntryRequest> request);
  CreateIpsecServerResponse createIpsecServerWithOptions(shared_ptr<CreateIpsecServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIpsecServerResponse createIpsecServer(shared_ptr<CreateIpsecServerRequest> request);
  CreateIpv4GatewayResponse createIpv4GatewayWithOptions(shared_ptr<CreateIpv4GatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIpv4GatewayResponse createIpv4Gateway(shared_ptr<CreateIpv4GatewayRequest> request);
  CreateIpv6EgressOnlyRuleResponse createIpv6EgressOnlyRuleWithOptions(shared_ptr<CreateIpv6EgressOnlyRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIpv6EgressOnlyRuleResponse createIpv6EgressOnlyRule(shared_ptr<CreateIpv6EgressOnlyRuleRequest> request);
  CreateIpv6GatewayResponse createIpv6GatewayWithOptions(shared_ptr<CreateIpv6GatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIpv6GatewayResponse createIpv6Gateway(shared_ptr<CreateIpv6GatewayRequest> request);
  CreateNatGatewayResponse createNatGatewayWithOptions(shared_ptr<CreateNatGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNatGatewayResponse createNatGateway(shared_ptr<CreateNatGatewayRequest> request);
  CreateNatIpResponse createNatIpWithOptions(shared_ptr<CreateNatIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNatIpResponse createNatIp(shared_ptr<CreateNatIpRequest> request);
  CreateNatIpCidrResponse createNatIpCidrWithOptions(shared_ptr<CreateNatIpCidrRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNatIpCidrResponse createNatIpCidr(shared_ptr<CreateNatIpCidrRequest> request);
  CreateNetworkAclResponse createNetworkAclWithOptions(shared_ptr<CreateNetworkAclRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNetworkAclResponse createNetworkAcl(shared_ptr<CreateNetworkAclRequest> request);
  CreatePhysicalConnectionResponse createPhysicalConnectionWithOptions(shared_ptr<CreatePhysicalConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePhysicalConnectionResponse createPhysicalConnection(shared_ptr<CreatePhysicalConnectionRequest> request);
  CreatePhysicalConnectionOccupancyOrderResponse createPhysicalConnectionOccupancyOrderWithOptions(shared_ptr<CreatePhysicalConnectionOccupancyOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePhysicalConnectionOccupancyOrderResponse createPhysicalConnectionOccupancyOrder(shared_ptr<CreatePhysicalConnectionOccupancyOrderRequest> request);
  CreatePhysicalConnectionSetupOrderResponse createPhysicalConnectionSetupOrderWithOptions(shared_ptr<CreatePhysicalConnectionSetupOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePhysicalConnectionSetupOrderResponse createPhysicalConnectionSetupOrder(shared_ptr<CreatePhysicalConnectionSetupOrderRequest> request);
  CreatePublicIpAddressPoolResponse createPublicIpAddressPoolWithOptions(shared_ptr<CreatePublicIpAddressPoolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePublicIpAddressPoolResponse createPublicIpAddressPool(shared_ptr<CreatePublicIpAddressPoolRequest> request);
  CreateRouteEntriesResponse createRouteEntriesWithOptions(shared_ptr<CreateRouteEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRouteEntriesResponse createRouteEntries(shared_ptr<CreateRouteEntriesRequest> request);
  CreateRouteEntryResponse createRouteEntryWithOptions(shared_ptr<CreateRouteEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRouteEntryResponse createRouteEntry(shared_ptr<CreateRouteEntryRequest> request);
  CreateRouteTableResponse createRouteTableWithOptions(shared_ptr<CreateRouteTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRouteTableResponse createRouteTable(shared_ptr<CreateRouteTableRequest> request);
  CreateRouterInterfaceResponse createRouterInterfaceWithOptions(shared_ptr<CreateRouterInterfaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRouterInterfaceResponse createRouterInterface(shared_ptr<CreateRouterInterfaceRequest> request);
  CreateSnatEntryResponse createSnatEntryWithOptions(shared_ptr<CreateSnatEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSnatEntryResponse createSnatEntry(shared_ptr<CreateSnatEntryRequest> request);
  CreateSslVpnClientCertResponse createSslVpnClientCertWithOptions(shared_ptr<CreateSslVpnClientCertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSslVpnClientCertResponse createSslVpnClientCert(shared_ptr<CreateSslVpnClientCertRequest> request);
  CreateSslVpnServerResponse createSslVpnServerWithOptions(shared_ptr<CreateSslVpnServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSslVpnServerResponse createSslVpnServer(shared_ptr<CreateSslVpnServerRequest> request);
  CreateTrafficMirrorFilterResponse createTrafficMirrorFilterWithOptions(shared_ptr<CreateTrafficMirrorFilterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTrafficMirrorFilterResponse createTrafficMirrorFilter(shared_ptr<CreateTrafficMirrorFilterRequest> request);
  CreateTrafficMirrorFilterRulesResponse createTrafficMirrorFilterRulesWithOptions(shared_ptr<CreateTrafficMirrorFilterRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTrafficMirrorFilterRulesResponse createTrafficMirrorFilterRules(shared_ptr<CreateTrafficMirrorFilterRulesRequest> request);
  CreateTrafficMirrorSessionResponse createTrafficMirrorSessionWithOptions(shared_ptr<CreateTrafficMirrorSessionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTrafficMirrorSessionResponse createTrafficMirrorSession(shared_ptr<CreateTrafficMirrorSessionRequest> request);
  CreateVSwitchResponse createVSwitchWithOptions(shared_ptr<CreateVSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVSwitchResponse createVSwitch(shared_ptr<CreateVSwitchRequest> request);
  CreateVSwitchCidrReservationResponse createVSwitchCidrReservationWithOptions(shared_ptr<CreateVSwitchCidrReservationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVSwitchCidrReservationResponse createVSwitchCidrReservation(shared_ptr<CreateVSwitchCidrReservationRequest> request);
  CreateVbrHaResponse createVbrHaWithOptions(shared_ptr<CreateVbrHaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVbrHaResponse createVbrHa(shared_ptr<CreateVbrHaRequest> request);
  CreateVcoRouteEntryResponse createVcoRouteEntryWithOptions(shared_ptr<CreateVcoRouteEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVcoRouteEntryResponse createVcoRouteEntry(shared_ptr<CreateVcoRouteEntryRequest> request);
  CreateVirtualBorderRouterResponse createVirtualBorderRouterWithOptions(shared_ptr<CreateVirtualBorderRouterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVirtualBorderRouterResponse createVirtualBorderRouter(shared_ptr<CreateVirtualBorderRouterRequest> request);
  CreateVirtualPhysicalConnectionResponse createVirtualPhysicalConnectionWithOptions(shared_ptr<CreateVirtualPhysicalConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVirtualPhysicalConnectionResponse createVirtualPhysicalConnection(shared_ptr<CreateVirtualPhysicalConnectionRequest> request);
  CreateVpcResponse createVpcWithOptions(shared_ptr<CreateVpcRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVpcResponse createVpc(shared_ptr<CreateVpcRequest> request);
  CreateVpcGatewayEndpointResponse createVpcGatewayEndpointWithOptions(shared_ptr<CreateVpcGatewayEndpointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVpcGatewayEndpointResponse createVpcGatewayEndpoint(shared_ptr<CreateVpcGatewayEndpointRequest> request);
  CreateVpcPrefixListResponse createVpcPrefixListWithOptions(shared_ptr<CreateVpcPrefixListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVpcPrefixListResponse createVpcPrefixList(shared_ptr<CreateVpcPrefixListRequest> request);
  CreateVpconnFromVbrResponse createVpconnFromVbrWithOptions(shared_ptr<CreateVpconnFromVbrRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVpconnFromVbrResponse createVpconnFromVbr(shared_ptr<CreateVpconnFromVbrRequest> request);
  CreateVpnAttachmentResponse createVpnAttachmentWithOptions(shared_ptr<CreateVpnAttachmentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVpnAttachmentResponse createVpnAttachment(shared_ptr<CreateVpnAttachmentRequest> request);
  CreateVpnConnectionResponse createVpnConnectionWithOptions(shared_ptr<CreateVpnConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVpnConnectionResponse createVpnConnection(shared_ptr<CreateVpnConnectionRequest> request);
  CreateVpnGatewayResponse createVpnGatewayWithOptions(shared_ptr<CreateVpnGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVpnGatewayResponse createVpnGateway(shared_ptr<CreateVpnGatewayRequest> request);
  CreateVpnPbrRouteEntryResponse createVpnPbrRouteEntryWithOptions(shared_ptr<CreateVpnPbrRouteEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVpnPbrRouteEntryResponse createVpnPbrRouteEntry(shared_ptr<CreateVpnPbrRouteEntryRequest> request);
  CreateVpnRouteEntryResponse createVpnRouteEntryWithOptions(shared_ptr<CreateVpnRouteEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVpnRouteEntryResponse createVpnRouteEntry(shared_ptr<CreateVpnRouteEntryRequest> request);
  DeactivateRouterInterfaceResponse deactivateRouterInterfaceWithOptions(shared_ptr<DeactivateRouterInterfaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeactivateRouterInterfaceResponse deactivateRouterInterface(shared_ptr<DeactivateRouterInterfaceRequest> request);
  DeactiveFlowLogResponse deactiveFlowLogWithOptions(shared_ptr<DeactiveFlowLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeactiveFlowLogResponse deactiveFlowLog(shared_ptr<DeactiveFlowLogRequest> request);
  DeleteBgpGroupResponse deleteBgpGroupWithOptions(shared_ptr<DeleteBgpGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBgpGroupResponse deleteBgpGroup(shared_ptr<DeleteBgpGroupRequest> request);
  DeleteBgpNetworkResponse deleteBgpNetworkWithOptions(shared_ptr<DeleteBgpNetworkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBgpNetworkResponse deleteBgpNetwork(shared_ptr<DeleteBgpNetworkRequest> request);
  DeleteBgpPeerResponse deleteBgpPeerWithOptions(shared_ptr<DeleteBgpPeerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBgpPeerResponse deleteBgpPeer(shared_ptr<DeleteBgpPeerRequest> request);
  DeleteCommonBandwidthPackageResponse deleteCommonBandwidthPackageWithOptions(shared_ptr<DeleteCommonBandwidthPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCommonBandwidthPackageResponse deleteCommonBandwidthPackage(shared_ptr<DeleteCommonBandwidthPackageRequest> request);
  DeleteCustomerGatewayResponse deleteCustomerGatewayWithOptions(shared_ptr<DeleteCustomerGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomerGatewayResponse deleteCustomerGateway(shared_ptr<DeleteCustomerGatewayRequest> request);
  DeleteDhcpOptionsSetResponse deleteDhcpOptionsSetWithOptions(shared_ptr<DeleteDhcpOptionsSetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDhcpOptionsSetResponse deleteDhcpOptionsSet(shared_ptr<DeleteDhcpOptionsSetRequest> request);
  DeleteExpressConnectTrafficQosResponse deleteExpressConnectTrafficQosWithOptions(shared_ptr<DeleteExpressConnectTrafficQosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteExpressConnectTrafficQosResponse deleteExpressConnectTrafficQos(shared_ptr<DeleteExpressConnectTrafficQosRequest> request);
  DeleteExpressConnectTrafficQosQueueResponse deleteExpressConnectTrafficQosQueueWithOptions(shared_ptr<DeleteExpressConnectTrafficQosQueueRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteExpressConnectTrafficQosQueueResponse deleteExpressConnectTrafficQosQueue(shared_ptr<DeleteExpressConnectTrafficQosQueueRequest> request);
  DeleteExpressConnectTrafficQosRuleResponse deleteExpressConnectTrafficQosRuleWithOptions(shared_ptr<DeleteExpressConnectTrafficQosRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteExpressConnectTrafficQosRuleResponse deleteExpressConnectTrafficQosRule(shared_ptr<DeleteExpressConnectTrafficQosRuleRequest> request);
  DeleteFailoverTestJobResponse deleteFailoverTestJobWithOptions(shared_ptr<DeleteFailoverTestJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFailoverTestJobResponse deleteFailoverTestJob(shared_ptr<DeleteFailoverTestJobRequest> request);
  DeleteFlowLogResponse deleteFlowLogWithOptions(shared_ptr<DeleteFlowLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFlowLogResponse deleteFlowLog(shared_ptr<DeleteFlowLogRequest> request);
  DeleteForwardEntryResponse deleteForwardEntryWithOptions(shared_ptr<DeleteForwardEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteForwardEntryResponse deleteForwardEntry(shared_ptr<DeleteForwardEntryRequest> request);
  DeleteFullNatEntryResponse deleteFullNatEntryWithOptions(shared_ptr<DeleteFullNatEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFullNatEntryResponse deleteFullNatEntry(shared_ptr<DeleteFullNatEntryRequest> request);
  DeleteGlobalAccelerationInstanceResponse deleteGlobalAccelerationInstanceWithOptions(shared_ptr<DeleteGlobalAccelerationInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGlobalAccelerationInstanceResponse deleteGlobalAccelerationInstance(shared_ptr<DeleteGlobalAccelerationInstanceRequest> request);
  DeleteHaVipResponse deleteHaVipWithOptions(shared_ptr<DeleteHaVipRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHaVipResponse deleteHaVip(shared_ptr<DeleteHaVipRequest> request);
  DeleteIPv6TranslatorResponse deleteIPv6TranslatorWithOptions(shared_ptr<DeleteIPv6TranslatorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIPv6TranslatorResponse deleteIPv6Translator(shared_ptr<DeleteIPv6TranslatorRequest> request);
  DeleteIPv6TranslatorAclListResponse deleteIPv6TranslatorAclListWithOptions(shared_ptr<DeleteIPv6TranslatorAclListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIPv6TranslatorAclListResponse deleteIPv6TranslatorAclList(shared_ptr<DeleteIPv6TranslatorAclListRequest> request);
  DeleteIPv6TranslatorEntryResponse deleteIPv6TranslatorEntryWithOptions(shared_ptr<DeleteIPv6TranslatorEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIPv6TranslatorEntryResponse deleteIPv6TranslatorEntry(shared_ptr<DeleteIPv6TranslatorEntryRequest> request);
  DeleteIpsecServerResponse deleteIpsecServerWithOptions(shared_ptr<DeleteIpsecServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIpsecServerResponse deleteIpsecServer(shared_ptr<DeleteIpsecServerRequest> request);
  DeleteIpv4GatewayResponse deleteIpv4GatewayWithOptions(shared_ptr<DeleteIpv4GatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIpv4GatewayResponse deleteIpv4Gateway(shared_ptr<DeleteIpv4GatewayRequest> request);
  DeleteIpv6EgressOnlyRuleResponse deleteIpv6EgressOnlyRuleWithOptions(shared_ptr<DeleteIpv6EgressOnlyRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIpv6EgressOnlyRuleResponse deleteIpv6EgressOnlyRule(shared_ptr<DeleteIpv6EgressOnlyRuleRequest> request);
  DeleteIpv6GatewayResponse deleteIpv6GatewayWithOptions(shared_ptr<DeleteIpv6GatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIpv6GatewayResponse deleteIpv6Gateway(shared_ptr<DeleteIpv6GatewayRequest> request);
  DeleteIpv6InternetBandwidthResponse deleteIpv6InternetBandwidthWithOptions(shared_ptr<DeleteIpv6InternetBandwidthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIpv6InternetBandwidthResponse deleteIpv6InternetBandwidth(shared_ptr<DeleteIpv6InternetBandwidthRequest> request);
  DeleteNatGatewayResponse deleteNatGatewayWithOptions(shared_ptr<DeleteNatGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNatGatewayResponse deleteNatGateway(shared_ptr<DeleteNatGatewayRequest> request);
  DeleteNatIpResponse deleteNatIpWithOptions(shared_ptr<DeleteNatIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNatIpResponse deleteNatIp(shared_ptr<DeleteNatIpRequest> request);
  DeleteNatIpCidrResponse deleteNatIpCidrWithOptions(shared_ptr<DeleteNatIpCidrRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNatIpCidrResponse deleteNatIpCidr(shared_ptr<DeleteNatIpCidrRequest> request);
  DeleteNetworkAclResponse deleteNetworkAclWithOptions(shared_ptr<DeleteNetworkAclRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNetworkAclResponse deleteNetworkAcl(shared_ptr<DeleteNetworkAclRequest> request);
  DeletePhysicalConnectionResponse deletePhysicalConnectionWithOptions(shared_ptr<DeletePhysicalConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePhysicalConnectionResponse deletePhysicalConnection(shared_ptr<DeletePhysicalConnectionRequest> request);
  DeletePublicIpAddressPoolResponse deletePublicIpAddressPoolWithOptions(shared_ptr<DeletePublicIpAddressPoolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePublicIpAddressPoolResponse deletePublicIpAddressPool(shared_ptr<DeletePublicIpAddressPoolRequest> request);
  DeletePublicIpAddressPoolCidrBlockResponse deletePublicIpAddressPoolCidrBlockWithOptions(shared_ptr<DeletePublicIpAddressPoolCidrBlockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePublicIpAddressPoolCidrBlockResponse deletePublicIpAddressPoolCidrBlock(shared_ptr<DeletePublicIpAddressPoolCidrBlockRequest> request);
  DeleteRouteEntriesResponse deleteRouteEntriesWithOptions(shared_ptr<DeleteRouteEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRouteEntriesResponse deleteRouteEntries(shared_ptr<DeleteRouteEntriesRequest> request);
  DeleteRouteEntryResponse deleteRouteEntryWithOptions(shared_ptr<DeleteRouteEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRouteEntryResponse deleteRouteEntry(shared_ptr<DeleteRouteEntryRequest> request);
  DeleteRouteTableResponse deleteRouteTableWithOptions(shared_ptr<DeleteRouteTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRouteTableResponse deleteRouteTable(shared_ptr<DeleteRouteTableRequest> request);
  DeleteRouterInterfaceResponse deleteRouterInterfaceWithOptions(shared_ptr<DeleteRouterInterfaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRouterInterfaceResponse deleteRouterInterface(shared_ptr<DeleteRouterInterfaceRequest> request);
  DeleteSnatEntryResponse deleteSnatEntryWithOptions(shared_ptr<DeleteSnatEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSnatEntryResponse deleteSnatEntry(shared_ptr<DeleteSnatEntryRequest> request);
  DeleteSslVpnClientCertResponse deleteSslVpnClientCertWithOptions(shared_ptr<DeleteSslVpnClientCertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSslVpnClientCertResponse deleteSslVpnClientCert(shared_ptr<DeleteSslVpnClientCertRequest> request);
  DeleteSslVpnServerResponse deleteSslVpnServerWithOptions(shared_ptr<DeleteSslVpnServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSslVpnServerResponse deleteSslVpnServer(shared_ptr<DeleteSslVpnServerRequest> request);
  DeleteTrafficMirrorFilterResponse deleteTrafficMirrorFilterWithOptions(shared_ptr<DeleteTrafficMirrorFilterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTrafficMirrorFilterResponse deleteTrafficMirrorFilter(shared_ptr<DeleteTrafficMirrorFilterRequest> request);
  DeleteTrafficMirrorFilterRulesResponse deleteTrafficMirrorFilterRulesWithOptions(shared_ptr<DeleteTrafficMirrorFilterRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTrafficMirrorFilterRulesResponse deleteTrafficMirrorFilterRules(shared_ptr<DeleteTrafficMirrorFilterRulesRequest> request);
  DeleteTrafficMirrorSessionResponse deleteTrafficMirrorSessionWithOptions(shared_ptr<DeleteTrafficMirrorSessionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTrafficMirrorSessionResponse deleteTrafficMirrorSession(shared_ptr<DeleteTrafficMirrorSessionRequest> request);
  DeleteVSwitchResponse deleteVSwitchWithOptions(shared_ptr<DeleteVSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVSwitchResponse deleteVSwitch(shared_ptr<DeleteVSwitchRequest> request);
  DeleteVSwitchCidrReservationResponse deleteVSwitchCidrReservationWithOptions(shared_ptr<DeleteVSwitchCidrReservationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVSwitchCidrReservationResponse deleteVSwitchCidrReservation(shared_ptr<DeleteVSwitchCidrReservationRequest> request);
  DeleteVbrHaResponse deleteVbrHaWithOptions(shared_ptr<DeleteVbrHaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVbrHaResponse deleteVbrHa(shared_ptr<DeleteVbrHaRequest> request);
  DeleteVcoRouteEntryResponse deleteVcoRouteEntryWithOptions(shared_ptr<DeleteVcoRouteEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVcoRouteEntryResponse deleteVcoRouteEntry(shared_ptr<DeleteVcoRouteEntryRequest> request);
  DeleteVirtualBorderRouterResponse deleteVirtualBorderRouterWithOptions(shared_ptr<DeleteVirtualBorderRouterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVirtualBorderRouterResponse deleteVirtualBorderRouter(shared_ptr<DeleteVirtualBorderRouterRequest> request);
  DeleteVpcResponse deleteVpcWithOptions(shared_ptr<DeleteVpcRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVpcResponse deleteVpc(shared_ptr<DeleteVpcRequest> request);
  DeleteVpcGatewayEndpointResponse deleteVpcGatewayEndpointWithOptions(shared_ptr<DeleteVpcGatewayEndpointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVpcGatewayEndpointResponse deleteVpcGatewayEndpoint(shared_ptr<DeleteVpcGatewayEndpointRequest> request);
  DeleteVpcPrefixListResponse deleteVpcPrefixListWithOptions(shared_ptr<DeleteVpcPrefixListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVpcPrefixListResponse deleteVpcPrefixList(shared_ptr<DeleteVpcPrefixListRequest> request);
  DeleteVpnAttachmentResponse deleteVpnAttachmentWithOptions(shared_ptr<DeleteVpnAttachmentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVpnAttachmentResponse deleteVpnAttachment(shared_ptr<DeleteVpnAttachmentRequest> request);
  DeleteVpnConnectionResponse deleteVpnConnectionWithOptions(shared_ptr<DeleteVpnConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVpnConnectionResponse deleteVpnConnection(shared_ptr<DeleteVpnConnectionRequest> request);
  DeleteVpnGatewayResponse deleteVpnGatewayWithOptions(shared_ptr<DeleteVpnGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVpnGatewayResponse deleteVpnGateway(shared_ptr<DeleteVpnGatewayRequest> request);
  DeleteVpnPbrRouteEntryResponse deleteVpnPbrRouteEntryWithOptions(shared_ptr<DeleteVpnPbrRouteEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVpnPbrRouteEntryResponse deleteVpnPbrRouteEntry(shared_ptr<DeleteVpnPbrRouteEntryRequest> request);
  DeleteVpnRouteEntryResponse deleteVpnRouteEntryWithOptions(shared_ptr<DeleteVpnRouteEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVpnRouteEntryResponse deleteVpnRouteEntry(shared_ptr<DeleteVpnRouteEntryRequest> request);
  DeletionProtectionResponse deletionProtectionWithOptions(shared_ptr<DeletionProtectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletionProtectionResponse deletionProtection(shared_ptr<DeletionProtectionRequest> request);
  Describe95TrafficResponse describe95TrafficWithOptions(shared_ptr<Describe95TrafficRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  Describe95TrafficResponse describe95Traffic(shared_ptr<Describe95TrafficRequest> request);
  DescribeAccessPointsResponse describeAccessPointsWithOptions(shared_ptr<DescribeAccessPointsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAccessPointsResponse describeAccessPoints(shared_ptr<DescribeAccessPointsRequest> request);
  DescribeBgpGroupsResponse describeBgpGroupsWithOptions(shared_ptr<DescribeBgpGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBgpGroupsResponse describeBgpGroups(shared_ptr<DescribeBgpGroupsRequest> request);
  DescribeBgpNetworksResponse describeBgpNetworksWithOptions(shared_ptr<DescribeBgpNetworksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBgpNetworksResponse describeBgpNetworks(shared_ptr<DescribeBgpNetworksRequest> request);
  DescribeBgpPeersResponse describeBgpPeersWithOptions(shared_ptr<DescribeBgpPeersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBgpPeersResponse describeBgpPeers(shared_ptr<DescribeBgpPeersRequest> request);
  DescribeCommonBandwidthPackagesResponse describeCommonBandwidthPackagesWithOptions(shared_ptr<DescribeCommonBandwidthPackagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCommonBandwidthPackagesResponse describeCommonBandwidthPackages(shared_ptr<DescribeCommonBandwidthPackagesRequest> request);
  DescribeCustomerGatewayResponse describeCustomerGatewayWithOptions(shared_ptr<DescribeCustomerGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustomerGatewayResponse describeCustomerGateway(shared_ptr<DescribeCustomerGatewayRequest> request);
  DescribeCustomerGatewaysResponse describeCustomerGatewaysWithOptions(shared_ptr<DescribeCustomerGatewaysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustomerGatewaysResponse describeCustomerGateways(shared_ptr<DescribeCustomerGatewaysRequest> request);
  DescribeEcGrantRelationResponse describeEcGrantRelationWithOptions(shared_ptr<DescribeEcGrantRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEcGrantRelationResponse describeEcGrantRelation(shared_ptr<DescribeEcGrantRelationRequest> request);
  DescribeEipAddressesResponse describeEipAddressesWithOptions(shared_ptr<DescribeEipAddressesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEipAddressesResponse describeEipAddresses(shared_ptr<DescribeEipAddressesRequest> request);
  DescribeEipGatewayInfoResponse describeEipGatewayInfoWithOptions(shared_ptr<DescribeEipGatewayInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEipGatewayInfoResponse describeEipGatewayInfo(shared_ptr<DescribeEipGatewayInfoRequest> request);
  DescribeEipMonitorDataResponse describeEipMonitorDataWithOptions(shared_ptr<DescribeEipMonitorDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEipMonitorDataResponse describeEipMonitorData(shared_ptr<DescribeEipMonitorDataRequest> request);
  DescribeEipSegmentResponse describeEipSegmentWithOptions(shared_ptr<DescribeEipSegmentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEipSegmentResponse describeEipSegment(shared_ptr<DescribeEipSegmentRequest> request);
  DescribeExpressConnectTrafficQosResponse describeExpressConnectTrafficQosWithOptions(shared_ptr<DescribeExpressConnectTrafficQosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExpressConnectTrafficQosResponse describeExpressConnectTrafficQos(shared_ptr<DescribeExpressConnectTrafficQosRequest> request);
  DescribeExpressConnectTrafficQosQueueResponse describeExpressConnectTrafficQosQueueWithOptions(shared_ptr<DescribeExpressConnectTrafficQosQueueRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExpressConnectTrafficQosQueueResponse describeExpressConnectTrafficQosQueue(shared_ptr<DescribeExpressConnectTrafficQosQueueRequest> request);
  DescribeExpressConnectTrafficQosRuleResponse describeExpressConnectTrafficQosRuleWithOptions(shared_ptr<DescribeExpressConnectTrafficQosRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExpressConnectTrafficQosRuleResponse describeExpressConnectTrafficQosRule(shared_ptr<DescribeExpressConnectTrafficQosRuleRequest> request);
  DescribeFailoverTestJobResponse describeFailoverTestJobWithOptions(shared_ptr<DescribeFailoverTestJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFailoverTestJobResponse describeFailoverTestJob(shared_ptr<DescribeFailoverTestJobRequest> request);
  DescribeFailoverTestJobsResponse describeFailoverTestJobsWithOptions(shared_ptr<DescribeFailoverTestJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFailoverTestJobsResponse describeFailoverTestJobs(shared_ptr<DescribeFailoverTestJobsRequest> request);
  DescribeFlowLogsResponse describeFlowLogsWithOptions(shared_ptr<DescribeFlowLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowLogsResponse describeFlowLogs(shared_ptr<DescribeFlowLogsRequest> request);
  DescribeForwardTableEntriesResponse describeForwardTableEntriesWithOptions(shared_ptr<DescribeForwardTableEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeForwardTableEntriesResponse describeForwardTableEntries(shared_ptr<DescribeForwardTableEntriesRequest> request);
  DescribeGlobalAccelerationInstancesResponse describeGlobalAccelerationInstancesWithOptions(shared_ptr<DescribeGlobalAccelerationInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGlobalAccelerationInstancesResponse describeGlobalAccelerationInstances(shared_ptr<DescribeGlobalAccelerationInstancesRequest> request);
  DescribeGrantRulesToCenResponse describeGrantRulesToCenWithOptions(shared_ptr<DescribeGrantRulesToCenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGrantRulesToCenResponse describeGrantRulesToCen(shared_ptr<DescribeGrantRulesToCenRequest> request);
  DescribeHaVipsResponse describeHaVipsWithOptions(shared_ptr<DescribeHaVipsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHaVipsResponse describeHaVips(shared_ptr<DescribeHaVipsRequest> request);
  DescribeHighDefinitionMonitorLogAttributeResponse describeHighDefinitionMonitorLogAttributeWithOptions(shared_ptr<DescribeHighDefinitionMonitorLogAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHighDefinitionMonitorLogAttributeResponse describeHighDefinitionMonitorLogAttribute(shared_ptr<DescribeHighDefinitionMonitorLogAttributeRequest> request);
  DescribeIPv6TranslatorAclListAttributesResponse describeIPv6TranslatorAclListAttributesWithOptions(shared_ptr<DescribeIPv6TranslatorAclListAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIPv6TranslatorAclListAttributesResponse describeIPv6TranslatorAclListAttributes(shared_ptr<DescribeIPv6TranslatorAclListAttributesRequest> request);
  DescribeIPv6TranslatorAclListsResponse describeIPv6TranslatorAclListsWithOptions(shared_ptr<DescribeIPv6TranslatorAclListsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIPv6TranslatorAclListsResponse describeIPv6TranslatorAclLists(shared_ptr<DescribeIPv6TranslatorAclListsRequest> request);
  DescribeIPv6TranslatorEntriesResponse describeIPv6TranslatorEntriesWithOptions(shared_ptr<DescribeIPv6TranslatorEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIPv6TranslatorEntriesResponse describeIPv6TranslatorEntries(shared_ptr<DescribeIPv6TranslatorEntriesRequest> request);
  DescribeIPv6TranslatorsResponse describeIPv6TranslatorsWithOptions(shared_ptr<DescribeIPv6TranslatorsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIPv6TranslatorsResponse describeIPv6Translators(shared_ptr<DescribeIPv6TranslatorsRequest> request);
  DescribeIpv6AddressesResponse describeIpv6AddressesWithOptions(shared_ptr<DescribeIpv6AddressesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIpv6AddressesResponse describeIpv6Addresses(shared_ptr<DescribeIpv6AddressesRequest> request);
  DescribeIpv6EgressOnlyRulesResponse describeIpv6EgressOnlyRulesWithOptions(shared_ptr<DescribeIpv6EgressOnlyRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIpv6EgressOnlyRulesResponse describeIpv6EgressOnlyRules(shared_ptr<DescribeIpv6EgressOnlyRulesRequest> request);
  DescribeIpv6GatewayAttributeResponse describeIpv6GatewayAttributeWithOptions(shared_ptr<DescribeIpv6GatewayAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIpv6GatewayAttributeResponse describeIpv6GatewayAttribute(shared_ptr<DescribeIpv6GatewayAttributeRequest> request);
  DescribeIpv6GatewaysResponse describeIpv6GatewaysWithOptions(shared_ptr<DescribeIpv6GatewaysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIpv6GatewaysResponse describeIpv6Gateways(shared_ptr<DescribeIpv6GatewaysRequest> request);
  DescribeNatGatewaysResponse describeNatGatewaysWithOptions(shared_ptr<DescribeNatGatewaysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNatGatewaysResponse describeNatGateways(shared_ptr<DescribeNatGatewaysRequest> request);
  DescribeNetworkAclAttributesResponse describeNetworkAclAttributesWithOptions(shared_ptr<DescribeNetworkAclAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworkAclAttributesResponse describeNetworkAclAttributes(shared_ptr<DescribeNetworkAclAttributesRequest> request);
  DescribeNetworkAclsResponse describeNetworkAclsWithOptions(shared_ptr<DescribeNetworkAclsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworkAclsResponse describeNetworkAcls(shared_ptr<DescribeNetworkAclsRequest> request);
  DescribePhysicalConnectionLOAResponse describePhysicalConnectionLOAWithOptions(shared_ptr<DescribePhysicalConnectionLOARequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePhysicalConnectionLOAResponse describePhysicalConnectionLOA(shared_ptr<DescribePhysicalConnectionLOARequest> request);
  DescribePhysicalConnectionsResponse describePhysicalConnectionsWithOptions(shared_ptr<DescribePhysicalConnectionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePhysicalConnectionsResponse describePhysicalConnections(shared_ptr<DescribePhysicalConnectionsRequest> request);
  DescribePublicIpAddressResponse describePublicIpAddressWithOptions(shared_ptr<DescribePublicIpAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePublicIpAddressResponse describePublicIpAddress(shared_ptr<DescribePublicIpAddressRequest> request);
  DescribeRegionsResponse describeRegionsWithOptions(shared_ptr<DescribeRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionsResponse describeRegions(shared_ptr<DescribeRegionsRequest> request);
  DescribeRouteEntryListResponse describeRouteEntryListWithOptions(shared_ptr<DescribeRouteEntryListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRouteEntryListResponse describeRouteEntryList(shared_ptr<DescribeRouteEntryListRequest> request);
  DescribeRouteTableListResponse describeRouteTableListWithOptions(shared_ptr<DescribeRouteTableListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRouteTableListResponse describeRouteTableList(shared_ptr<DescribeRouteTableListRequest> request);
  DescribeRouteTablesResponse describeRouteTablesWithOptions(shared_ptr<DescribeRouteTablesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRouteTablesResponse describeRouteTables(shared_ptr<DescribeRouteTablesRequest> request);
  DescribeRouterInterfaceAttributeResponse describeRouterInterfaceAttributeWithOptions(shared_ptr<DescribeRouterInterfaceAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRouterInterfaceAttributeResponse describeRouterInterfaceAttribute(shared_ptr<DescribeRouterInterfaceAttributeRequest> request);
  DescribeRouterInterfacesResponse describeRouterInterfacesWithOptions(shared_ptr<DescribeRouterInterfacesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRouterInterfacesResponse describeRouterInterfaces(shared_ptr<DescribeRouterInterfacesRequest> request);
  DescribeServerRelatedGlobalAccelerationInstancesResponse describeServerRelatedGlobalAccelerationInstancesWithOptions(shared_ptr<DescribeServerRelatedGlobalAccelerationInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeServerRelatedGlobalAccelerationInstancesResponse describeServerRelatedGlobalAccelerationInstances(shared_ptr<DescribeServerRelatedGlobalAccelerationInstancesRequest> request);
  DescribeSnatTableEntriesResponse describeSnatTableEntriesWithOptions(shared_ptr<DescribeSnatTableEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSnatTableEntriesResponse describeSnatTableEntries(shared_ptr<DescribeSnatTableEntriesRequest> request);
  DescribeSslVpnClientCertResponse describeSslVpnClientCertWithOptions(shared_ptr<DescribeSslVpnClientCertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSslVpnClientCertResponse describeSslVpnClientCert(shared_ptr<DescribeSslVpnClientCertRequest> request);
  DescribeSslVpnClientCertsResponse describeSslVpnClientCertsWithOptions(shared_ptr<DescribeSslVpnClientCertsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSslVpnClientCertsResponse describeSslVpnClientCerts(shared_ptr<DescribeSslVpnClientCertsRequest> request);
  DescribeSslVpnClientsResponse describeSslVpnClientsWithOptions(shared_ptr<DescribeSslVpnClientsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSslVpnClientsResponse describeSslVpnClients(shared_ptr<DescribeSslVpnClientsRequest> request);
  DescribeSslVpnServersResponse describeSslVpnServersWithOptions(shared_ptr<DescribeSslVpnServersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSslVpnServersResponse describeSslVpnServers(shared_ptr<DescribeSslVpnServersRequest> request);
  DescribeTagKeysResponse describeTagKeysWithOptions(shared_ptr<DescribeTagKeysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagKeysResponse describeTagKeys(shared_ptr<DescribeTagKeysRequest> request);
  DescribeTagKeysForExpressConnectResponse describeTagKeysForExpressConnectWithOptions(shared_ptr<DescribeTagKeysForExpressConnectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagKeysForExpressConnectResponse describeTagKeysForExpressConnect(shared_ptr<DescribeTagKeysForExpressConnectRequest> request);
  DescribeTagsResponse describeTagsWithOptions(shared_ptr<DescribeTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagsResponse describeTags(shared_ptr<DescribeTagsRequest> request);
  DescribeVRoutersResponse describeVRoutersWithOptions(shared_ptr<DescribeVRoutersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVRoutersResponse describeVRouters(shared_ptr<DescribeVRoutersRequest> request);
  DescribeVSwitchAttributesResponse describeVSwitchAttributesWithOptions(shared_ptr<DescribeVSwitchAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVSwitchAttributesResponse describeVSwitchAttributes(shared_ptr<DescribeVSwitchAttributesRequest> request);
  DescribeVSwitchesResponse describeVSwitchesWithOptions(shared_ptr<DescribeVSwitchesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVSwitchesResponse describeVSwitches(shared_ptr<DescribeVSwitchesRequest> request);
  DescribeVbrHaResponse describeVbrHaWithOptions(shared_ptr<DescribeVbrHaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVbrHaResponse describeVbrHa(shared_ptr<DescribeVbrHaRequest> request);
  DescribeVcoRouteEntriesResponse describeVcoRouteEntriesWithOptions(shared_ptr<DescribeVcoRouteEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVcoRouteEntriesResponse describeVcoRouteEntries(shared_ptr<DescribeVcoRouteEntriesRequest> request);
  DescribeVirtualBorderRoutersResponse describeVirtualBorderRoutersWithOptions(shared_ptr<DescribeVirtualBorderRoutersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVirtualBorderRoutersResponse describeVirtualBorderRouters(shared_ptr<DescribeVirtualBorderRoutersRequest> request);
  DescribeVirtualBorderRoutersForPhysicalConnectionResponse describeVirtualBorderRoutersForPhysicalConnectionWithOptions(shared_ptr<DescribeVirtualBorderRoutersForPhysicalConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVirtualBorderRoutersForPhysicalConnectionResponse describeVirtualBorderRoutersForPhysicalConnection(shared_ptr<DescribeVirtualBorderRoutersForPhysicalConnectionRequest> request);
  DescribeVpcAttributeResponse describeVpcAttributeWithOptions(shared_ptr<DescribeVpcAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpcAttributeResponse describeVpcAttribute(shared_ptr<DescribeVpcAttributeRequest> request);
  DescribeVpcsResponse describeVpcsWithOptions(shared_ptr<DescribeVpcsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpcsResponse describeVpcs(shared_ptr<DescribeVpcsRequest> request);
  DescribeVpnAttachmentsResponse describeVpnAttachmentsWithOptions(shared_ptr<DescribeVpnAttachmentsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpnAttachmentsResponse describeVpnAttachments(shared_ptr<DescribeVpnAttachmentsRequest> request);
  DescribeVpnConnectionResponse describeVpnConnectionWithOptions(shared_ptr<DescribeVpnConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpnConnectionResponse describeVpnConnection(shared_ptr<DescribeVpnConnectionRequest> request);
  DescribeVpnConnectionLogsResponse describeVpnConnectionLogsWithOptions(shared_ptr<DescribeVpnConnectionLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpnConnectionLogsResponse describeVpnConnectionLogs(shared_ptr<DescribeVpnConnectionLogsRequest> request);
  DescribeVpnConnectionsResponse describeVpnConnectionsWithOptions(shared_ptr<DescribeVpnConnectionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpnConnectionsResponse describeVpnConnections(shared_ptr<DescribeVpnConnectionsRequest> request);
  DescribeVpnCrossAccountAuthorizationsResponse describeVpnCrossAccountAuthorizationsWithOptions(shared_ptr<DescribeVpnCrossAccountAuthorizationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpnCrossAccountAuthorizationsResponse describeVpnCrossAccountAuthorizations(shared_ptr<DescribeVpnCrossAccountAuthorizationsRequest> request);
  DescribeVpnGatewayResponse describeVpnGatewayWithOptions(shared_ptr<DescribeVpnGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpnGatewayResponse describeVpnGateway(shared_ptr<DescribeVpnGatewayRequest> request);
  DescribeVpnGatewayAvailableZonesResponse describeVpnGatewayAvailableZonesWithOptions(shared_ptr<DescribeVpnGatewayAvailableZonesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpnGatewayAvailableZonesResponse describeVpnGatewayAvailableZones(shared_ptr<DescribeVpnGatewayAvailableZonesRequest> request);
  DescribeVpnGatewaysResponse describeVpnGatewaysWithOptions(shared_ptr<DescribeVpnGatewaysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpnGatewaysResponse describeVpnGateways(shared_ptr<DescribeVpnGatewaysRequest> request);
  DescribeVpnPbrRouteEntriesResponse describeVpnPbrRouteEntriesWithOptions(shared_ptr<DescribeVpnPbrRouteEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpnPbrRouteEntriesResponse describeVpnPbrRouteEntries(shared_ptr<DescribeVpnPbrRouteEntriesRequest> request);
  DescribeVpnRouteEntriesResponse describeVpnRouteEntriesWithOptions(shared_ptr<DescribeVpnRouteEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpnRouteEntriesResponse describeVpnRouteEntries(shared_ptr<DescribeVpnRouteEntriesRequest> request);
  DescribeVpnSslServerLogsResponse describeVpnSslServerLogsWithOptions(shared_ptr<DescribeVpnSslServerLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpnSslServerLogsResponse describeVpnSslServerLogs(shared_ptr<DescribeVpnSslServerLogsRequest> request);
  DescribeZonesResponse describeZonesWithOptions(shared_ptr<DescribeZonesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeZonesResponse describeZones(shared_ptr<DescribeZonesRequest> request);
  DetachDhcpOptionsSetFromVpcResponse detachDhcpOptionsSetFromVpcWithOptions(shared_ptr<DetachDhcpOptionsSetFromVpcRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachDhcpOptionsSetFromVpcResponse detachDhcpOptionsSetFromVpc(shared_ptr<DetachDhcpOptionsSetFromVpcRequest> request);
  DiagnoseVpnConnectionsResponse diagnoseVpnConnectionsWithOptions(shared_ptr<DiagnoseVpnConnectionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DiagnoseVpnConnectionsResponse diagnoseVpnConnections(shared_ptr<DiagnoseVpnConnectionsRequest> request);
  DiagnoseVpnGatewayResponse diagnoseVpnGatewayWithOptions(shared_ptr<DiagnoseVpnGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DiagnoseVpnGatewayResponse diagnoseVpnGateway(shared_ptr<DiagnoseVpnGatewayRequest> request);
  DisableNatGatewayEcsMetricResponse disableNatGatewayEcsMetricWithOptions(shared_ptr<DisableNatGatewayEcsMetricRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableNatGatewayEcsMetricResponse disableNatGatewayEcsMetric(shared_ptr<DisableNatGatewayEcsMetricRequest> request);
  DisableVpcClassicLinkResponse disableVpcClassicLinkWithOptions(shared_ptr<DisableVpcClassicLinkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableVpcClassicLinkResponse disableVpcClassicLink(shared_ptr<DisableVpcClassicLinkRequest> request);
  DissociateRouteTableFromGatewayResponse dissociateRouteTableFromGatewayWithOptions(shared_ptr<DissociateRouteTableFromGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DissociateRouteTableFromGatewayResponse dissociateRouteTableFromGateway(shared_ptr<DissociateRouteTableFromGatewayRequest> request);
  DissociateRouteTablesFromVpcGatewayEndpointResponse dissociateRouteTablesFromVpcGatewayEndpointWithOptions(shared_ptr<DissociateRouteTablesFromVpcGatewayEndpointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DissociateRouteTablesFromVpcGatewayEndpointResponse dissociateRouteTablesFromVpcGatewayEndpoint(shared_ptr<DissociateRouteTablesFromVpcGatewayEndpointRequest> request);
  DissociateVpnGatewayWithCertificateResponse dissociateVpnGatewayWithCertificateWithOptions(shared_ptr<DissociateVpnGatewayWithCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DissociateVpnGatewayWithCertificateResponse dissociateVpnGatewayWithCertificate(shared_ptr<DissociateVpnGatewayWithCertificateRequest> request);
  DownloadVpnConnectionConfigResponse downloadVpnConnectionConfigWithOptions(shared_ptr<DownloadVpnConnectionConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadVpnConnectionConfigResponse downloadVpnConnectionConfig(shared_ptr<DownloadVpnConnectionConfigRequest> request);
  EnableNatGatewayEcsMetricResponse enableNatGatewayEcsMetricWithOptions(shared_ptr<EnableNatGatewayEcsMetricRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableNatGatewayEcsMetricResponse enableNatGatewayEcsMetric(shared_ptr<EnableNatGatewayEcsMetricRequest> request);
  EnablePhysicalConnectionResponse enablePhysicalConnectionWithOptions(shared_ptr<EnablePhysicalConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnablePhysicalConnectionResponse enablePhysicalConnection(shared_ptr<EnablePhysicalConnectionRequest> request);
  EnableVpcClassicLinkResponse enableVpcClassicLinkWithOptions(shared_ptr<EnableVpcClassicLinkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableVpcClassicLinkResponse enableVpcClassicLink(shared_ptr<EnableVpcClassicLinkRequest> request);
  EnableVpcIpv4GatewayResponse enableVpcIpv4GatewayWithOptions(shared_ptr<EnableVpcIpv4GatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableVpcIpv4GatewayResponse enableVpcIpv4Gateway(shared_ptr<EnableVpcIpv4GatewayRequest> request);
  GetDhcpOptionsSetResponse getDhcpOptionsSetWithOptions(shared_ptr<GetDhcpOptionsSetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDhcpOptionsSetResponse getDhcpOptionsSet(shared_ptr<GetDhcpOptionsSetRequest> request);
  GetFlowLogServiceStatusResponse getFlowLogServiceStatusWithOptions(shared_ptr<GetFlowLogServiceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFlowLogServiceStatusResponse getFlowLogServiceStatus(shared_ptr<GetFlowLogServiceStatusRequest> request);
  GetIpv4GatewayAttributeResponse getIpv4GatewayAttributeWithOptions(shared_ptr<GetIpv4GatewayAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetIpv4GatewayAttributeResponse getIpv4GatewayAttribute(shared_ptr<GetIpv4GatewayAttributeRequest> request);
  GetNatGatewayAttributeResponse getNatGatewayAttributeWithOptions(shared_ptr<GetNatGatewayAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNatGatewayAttributeResponse getNatGatewayAttribute(shared_ptr<GetNatGatewayAttributeRequest> request);
  GetPhysicalConnectionServiceStatusResponse getPhysicalConnectionServiceStatusWithOptions(shared_ptr<GetPhysicalConnectionServiceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPhysicalConnectionServiceStatusResponse getPhysicalConnectionServiceStatus(shared_ptr<GetPhysicalConnectionServiceStatusRequest> request);
  GetTrafficMirrorServiceStatusResponse getTrafficMirrorServiceStatusWithOptions(shared_ptr<GetTrafficMirrorServiceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTrafficMirrorServiceStatusResponse getTrafficMirrorServiceStatus(shared_ptr<GetTrafficMirrorServiceStatusRequest> request);
  GetVSwitchCidrReservationUsageResponse getVSwitchCidrReservationUsageWithOptions(shared_ptr<GetVSwitchCidrReservationUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVSwitchCidrReservationUsageResponse getVSwitchCidrReservationUsage(shared_ptr<GetVSwitchCidrReservationUsageRequest> request);
  GetVpcGatewayEndpointAttributeResponse getVpcGatewayEndpointAttributeWithOptions(shared_ptr<GetVpcGatewayEndpointAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVpcGatewayEndpointAttributeResponse getVpcGatewayEndpointAttribute(shared_ptr<GetVpcGatewayEndpointAttributeRequest> request);
  GetVpcPrefixListAssociationsResponse getVpcPrefixListAssociationsWithOptions(shared_ptr<GetVpcPrefixListAssociationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVpcPrefixListAssociationsResponse getVpcPrefixListAssociations(shared_ptr<GetVpcPrefixListAssociationsRequest> request);
  GetVpcPrefixListEntriesResponse getVpcPrefixListEntriesWithOptions(shared_ptr<GetVpcPrefixListEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVpcPrefixListEntriesResponse getVpcPrefixListEntries(shared_ptr<GetVpcPrefixListEntriesRequest> request);
  GetVpcRouteEntrySummaryResponse getVpcRouteEntrySummaryWithOptions(shared_ptr<GetVpcRouteEntrySummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVpcRouteEntrySummaryResponse getVpcRouteEntrySummary(shared_ptr<GetVpcRouteEntrySummaryRequest> request);
  GetVpnGatewayDiagnoseResultResponse getVpnGatewayDiagnoseResultWithOptions(shared_ptr<GetVpnGatewayDiagnoseResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVpnGatewayDiagnoseResultResponse getVpnGatewayDiagnoseResult(shared_ptr<GetVpnGatewayDiagnoseResultRequest> request);
  GrantInstanceToCenResponse grantInstanceToCenWithOptions(shared_ptr<GrantInstanceToCenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GrantInstanceToCenResponse grantInstanceToCen(shared_ptr<GrantInstanceToCenRequest> request);
  GrantInstanceToVbrResponse grantInstanceToVbrWithOptions(shared_ptr<GrantInstanceToVbrRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GrantInstanceToVbrResponse grantInstanceToVbr(shared_ptr<GrantInstanceToVbrRequest> request);
  ListBusinessAccessPointsResponse listBusinessAccessPointsWithOptions(shared_ptr<ListBusinessAccessPointsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBusinessAccessPointsResponse listBusinessAccessPoints(shared_ptr<ListBusinessAccessPointsRequest> request);
  ListDhcpOptionsSetsResponse listDhcpOptionsSetsWithOptions(shared_ptr<ListDhcpOptionsSetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDhcpOptionsSetsResponse listDhcpOptionsSets(shared_ptr<ListDhcpOptionsSetsRequest> request);
  ListEnhanhcedNatGatewayAvailableZonesResponse listEnhanhcedNatGatewayAvailableZonesWithOptions(shared_ptr<ListEnhanhcedNatGatewayAvailableZonesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEnhanhcedNatGatewayAvailableZonesResponse listEnhanhcedNatGatewayAvailableZones(shared_ptr<ListEnhanhcedNatGatewayAvailableZonesRequest> request);
  ListFullNatEntriesResponse listFullNatEntriesWithOptions(shared_ptr<ListFullNatEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFullNatEntriesResponse listFullNatEntries(shared_ptr<ListFullNatEntriesRequest> request);
  ListGatewayRouteTableEntriesResponse listGatewayRouteTableEntriesWithOptions(shared_ptr<ListGatewayRouteTableEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGatewayRouteTableEntriesResponse listGatewayRouteTableEntries(shared_ptr<ListGatewayRouteTableEntriesRequest> request);
  ListGeographicSubRegionsResponse listGeographicSubRegionsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGeographicSubRegionsResponse listGeographicSubRegions();
  ListIpsecServerLogsResponse listIpsecServerLogsWithOptions(shared_ptr<ListIpsecServerLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIpsecServerLogsResponse listIpsecServerLogs(shared_ptr<ListIpsecServerLogsRequest> request);
  ListIpsecServersResponse listIpsecServersWithOptions(shared_ptr<ListIpsecServersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIpsecServersResponse listIpsecServers(shared_ptr<ListIpsecServersRequest> request);
  ListIpv4GatewaysResponse listIpv4GatewaysWithOptions(shared_ptr<ListIpv4GatewaysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIpv4GatewaysResponse listIpv4Gateways(shared_ptr<ListIpv4GatewaysRequest> request);
  ListNatIpCidrsResponse listNatIpCidrsWithOptions(shared_ptr<ListNatIpCidrsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNatIpCidrsResponse listNatIpCidrs(shared_ptr<ListNatIpCidrsRequest> request);
  ListNatIpsResponse listNatIpsWithOptions(shared_ptr<ListNatIpsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNatIpsResponse listNatIps(shared_ptr<ListNatIpsRequest> request);
  ListPrefixListsResponse listPrefixListsWithOptions(shared_ptr<ListPrefixListsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrefixListsResponse listPrefixLists(shared_ptr<ListPrefixListsRequest> request);
  ListPublicIpAddressPoolCidrBlocksResponse listPublicIpAddressPoolCidrBlocksWithOptions(shared_ptr<ListPublicIpAddressPoolCidrBlocksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPublicIpAddressPoolCidrBlocksResponse listPublicIpAddressPoolCidrBlocks(shared_ptr<ListPublicIpAddressPoolCidrBlocksRequest> request);
  ListPublicIpAddressPoolsResponse listPublicIpAddressPoolsWithOptions(shared_ptr<ListPublicIpAddressPoolsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPublicIpAddressPoolsResponse listPublicIpAddressPools(shared_ptr<ListPublicIpAddressPoolsRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ListTagResourcesForExpressConnectResponse listTagResourcesForExpressConnectWithOptions(shared_ptr<ListTagResourcesForExpressConnectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesForExpressConnectResponse listTagResourcesForExpressConnect(shared_ptr<ListTagResourcesForExpressConnectRequest> request);
  ListTrafficMirrorFiltersResponse listTrafficMirrorFiltersWithOptions(shared_ptr<ListTrafficMirrorFiltersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTrafficMirrorFiltersResponse listTrafficMirrorFilters(shared_ptr<ListTrafficMirrorFiltersRequest> request);
  ListTrafficMirrorSessionsResponse listTrafficMirrorSessionsWithOptions(shared_ptr<ListTrafficMirrorSessionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTrafficMirrorSessionsResponse listTrafficMirrorSessions(shared_ptr<ListTrafficMirrorSessionsRequest> request);
  ListVSwitchCidrReservationsResponse listVSwitchCidrReservationsWithOptions(shared_ptr<ListVSwitchCidrReservationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVSwitchCidrReservationsResponse listVSwitchCidrReservations(shared_ptr<ListVSwitchCidrReservationsRequest> request);
  ListVirtualPhysicalConnectionsResponse listVirtualPhysicalConnectionsWithOptions(shared_ptr<ListVirtualPhysicalConnectionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVirtualPhysicalConnectionsResponse listVirtualPhysicalConnections(shared_ptr<ListVirtualPhysicalConnectionsRequest> request);
  ListVpcEndpointServicesByEndUserResponse listVpcEndpointServicesByEndUserWithOptions(shared_ptr<ListVpcEndpointServicesByEndUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVpcEndpointServicesByEndUserResponse listVpcEndpointServicesByEndUser(shared_ptr<ListVpcEndpointServicesByEndUserRequest> request);
  ListVpcGatewayEndpointsResponse listVpcGatewayEndpointsWithOptions(shared_ptr<ListVpcGatewayEndpointsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVpcGatewayEndpointsResponse listVpcGatewayEndpoints(shared_ptr<ListVpcGatewayEndpointsRequest> request);
  ListVpnCertificateAssociationsResponse listVpnCertificateAssociationsWithOptions(shared_ptr<ListVpnCertificateAssociationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVpnCertificateAssociationsResponse listVpnCertificateAssociations(shared_ptr<ListVpnCertificateAssociationsRequest> request);
  ModifyBgpGroupAttributeResponse modifyBgpGroupAttributeWithOptions(shared_ptr<ModifyBgpGroupAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBgpGroupAttributeResponse modifyBgpGroupAttribute(shared_ptr<ModifyBgpGroupAttributeRequest> request);
  ModifyBgpPeerAttributeResponse modifyBgpPeerAttributeWithOptions(shared_ptr<ModifyBgpPeerAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBgpPeerAttributeResponse modifyBgpPeerAttribute(shared_ptr<ModifyBgpPeerAttributeRequest> request);
  ModifyCommonBandwidthPackageAttributeResponse modifyCommonBandwidthPackageAttributeWithOptions(shared_ptr<ModifyCommonBandwidthPackageAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCommonBandwidthPackageAttributeResponse modifyCommonBandwidthPackageAttribute(shared_ptr<ModifyCommonBandwidthPackageAttributeRequest> request);
  ModifyCommonBandwidthPackageIpBandwidthResponse modifyCommonBandwidthPackageIpBandwidthWithOptions(shared_ptr<ModifyCommonBandwidthPackageIpBandwidthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCommonBandwidthPackageIpBandwidthResponse modifyCommonBandwidthPackageIpBandwidth(shared_ptr<ModifyCommonBandwidthPackageIpBandwidthRequest> request);
  ModifyCommonBandwidthPackageSpecResponse modifyCommonBandwidthPackageSpecWithOptions(shared_ptr<ModifyCommonBandwidthPackageSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCommonBandwidthPackageSpecResponse modifyCommonBandwidthPackageSpec(shared_ptr<ModifyCommonBandwidthPackageSpecRequest> request);
  ModifyCustomerGatewayAttributeResponse modifyCustomerGatewayAttributeWithOptions(shared_ptr<ModifyCustomerGatewayAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCustomerGatewayAttributeResponse modifyCustomerGatewayAttribute(shared_ptr<ModifyCustomerGatewayAttributeRequest> request);
  ModifyEipAddressAttributeResponse modifyEipAddressAttributeWithOptions(shared_ptr<ModifyEipAddressAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyEipAddressAttributeResponse modifyEipAddressAttribute(shared_ptr<ModifyEipAddressAttributeRequest> request);
  ModifyExpressCloudConnectionAttributeResponse modifyExpressCloudConnectionAttributeWithOptions(shared_ptr<ModifyExpressCloudConnectionAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyExpressCloudConnectionAttributeResponse modifyExpressCloudConnectionAttribute(shared_ptr<ModifyExpressCloudConnectionAttributeRequest> request);
  ModifyExpressCloudConnectionBandwidthResponse modifyExpressCloudConnectionBandwidthWithOptions(shared_ptr<ModifyExpressCloudConnectionBandwidthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyExpressCloudConnectionBandwidthResponse modifyExpressCloudConnectionBandwidth(shared_ptr<ModifyExpressCloudConnectionBandwidthRequest> request);
  ModifyExpressConnectTrafficQosResponse modifyExpressConnectTrafficQosWithOptions(shared_ptr<ModifyExpressConnectTrafficQosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyExpressConnectTrafficQosResponse modifyExpressConnectTrafficQos(shared_ptr<ModifyExpressConnectTrafficQosRequest> request);
  ModifyExpressConnectTrafficQosQueueResponse modifyExpressConnectTrafficQosQueueWithOptions(shared_ptr<ModifyExpressConnectTrafficQosQueueRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyExpressConnectTrafficQosQueueResponse modifyExpressConnectTrafficQosQueue(shared_ptr<ModifyExpressConnectTrafficQosQueueRequest> request);
  ModifyExpressConnectTrafficQosRuleResponse modifyExpressConnectTrafficQosRuleWithOptions(shared_ptr<ModifyExpressConnectTrafficQosRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyExpressConnectTrafficQosRuleResponse modifyExpressConnectTrafficQosRule(shared_ptr<ModifyExpressConnectTrafficQosRuleRequest> request);
  ModifyFlowLogAttributeResponse modifyFlowLogAttributeWithOptions(shared_ptr<ModifyFlowLogAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyFlowLogAttributeResponse modifyFlowLogAttribute(shared_ptr<ModifyFlowLogAttributeRequest> request);
  ModifyForwardEntryResponse modifyForwardEntryWithOptions(shared_ptr<ModifyForwardEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyForwardEntryResponse modifyForwardEntry(shared_ptr<ModifyForwardEntryRequest> request);
  ModifyFullNatEntryAttributeResponse modifyFullNatEntryAttributeWithOptions(shared_ptr<ModifyFullNatEntryAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyFullNatEntryAttributeResponse modifyFullNatEntryAttribute(shared_ptr<ModifyFullNatEntryAttributeRequest> request);
  ModifyGlobalAccelerationInstanceAttributesResponse modifyGlobalAccelerationInstanceAttributesWithOptions(shared_ptr<ModifyGlobalAccelerationInstanceAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyGlobalAccelerationInstanceAttributesResponse modifyGlobalAccelerationInstanceAttributes(shared_ptr<ModifyGlobalAccelerationInstanceAttributesRequest> request);
  ModifyGlobalAccelerationInstanceSpecResponse modifyGlobalAccelerationInstanceSpecWithOptions(shared_ptr<ModifyGlobalAccelerationInstanceSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyGlobalAccelerationInstanceSpecResponse modifyGlobalAccelerationInstanceSpec(shared_ptr<ModifyGlobalAccelerationInstanceSpecRequest> request);
  ModifyHaVipAttributeResponse modifyHaVipAttributeWithOptions(shared_ptr<ModifyHaVipAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHaVipAttributeResponse modifyHaVipAttribute(shared_ptr<ModifyHaVipAttributeRequest> request);
  ModifyIPv6TranslatorAclAttributeResponse modifyIPv6TranslatorAclAttributeWithOptions(shared_ptr<ModifyIPv6TranslatorAclAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyIPv6TranslatorAclAttributeResponse modifyIPv6TranslatorAclAttribute(shared_ptr<ModifyIPv6TranslatorAclAttributeRequest> request);
  ModifyIPv6TranslatorAclListEntryResponse modifyIPv6TranslatorAclListEntryWithOptions(shared_ptr<ModifyIPv6TranslatorAclListEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyIPv6TranslatorAclListEntryResponse modifyIPv6TranslatorAclListEntry(shared_ptr<ModifyIPv6TranslatorAclListEntryRequest> request);
  ModifyIPv6TranslatorAttributeResponse modifyIPv6TranslatorAttributeWithOptions(shared_ptr<ModifyIPv6TranslatorAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyIPv6TranslatorAttributeResponse modifyIPv6TranslatorAttribute(shared_ptr<ModifyIPv6TranslatorAttributeRequest> request);
  ModifyIPv6TranslatorBandwidthResponse modifyIPv6TranslatorBandwidthWithOptions(shared_ptr<ModifyIPv6TranslatorBandwidthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyIPv6TranslatorBandwidthResponse modifyIPv6TranslatorBandwidth(shared_ptr<ModifyIPv6TranslatorBandwidthRequest> request);
  ModifyIPv6TranslatorEntryResponse modifyIPv6TranslatorEntryWithOptions(shared_ptr<ModifyIPv6TranslatorEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyIPv6TranslatorEntryResponse modifyIPv6TranslatorEntry(shared_ptr<ModifyIPv6TranslatorEntryRequest> request);
  ModifyIpv6AddressAttributeResponse modifyIpv6AddressAttributeWithOptions(shared_ptr<ModifyIpv6AddressAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyIpv6AddressAttributeResponse modifyIpv6AddressAttribute(shared_ptr<ModifyIpv6AddressAttributeRequest> request);
  ModifyIpv6GatewayAttributeResponse modifyIpv6GatewayAttributeWithOptions(shared_ptr<ModifyIpv6GatewayAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyIpv6GatewayAttributeResponse modifyIpv6GatewayAttribute(shared_ptr<ModifyIpv6GatewayAttributeRequest> request);
  ModifyIpv6InternetBandwidthResponse modifyIpv6InternetBandwidthWithOptions(shared_ptr<ModifyIpv6InternetBandwidthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyIpv6InternetBandwidthResponse modifyIpv6InternetBandwidth(shared_ptr<ModifyIpv6InternetBandwidthRequest> request);
  ModifyNatGatewayAttributeResponse modifyNatGatewayAttributeWithOptions(shared_ptr<ModifyNatGatewayAttributeRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyNatGatewayAttributeResponse modifyNatGatewayAttribute(shared_ptr<ModifyNatGatewayAttributeRequest> request);
  ModifyNatGatewaySpecResponse modifyNatGatewaySpecWithOptions(shared_ptr<ModifyNatGatewaySpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyNatGatewaySpecResponse modifyNatGatewaySpec(shared_ptr<ModifyNatGatewaySpecRequest> request);
  ModifyNatIpAttributeResponse modifyNatIpAttributeWithOptions(shared_ptr<ModifyNatIpAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyNatIpAttributeResponse modifyNatIpAttribute(shared_ptr<ModifyNatIpAttributeRequest> request);
  ModifyNatIpCidrAttributeResponse modifyNatIpCidrAttributeWithOptions(shared_ptr<ModifyNatIpCidrAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyNatIpCidrAttributeResponse modifyNatIpCidrAttribute(shared_ptr<ModifyNatIpCidrAttributeRequest> request);
  ModifyNetworkAclAttributesResponse modifyNetworkAclAttributesWithOptions(shared_ptr<ModifyNetworkAclAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyNetworkAclAttributesResponse modifyNetworkAclAttributes(shared_ptr<ModifyNetworkAclAttributesRequest> request);
  ModifyPhysicalConnectionAttributeResponse modifyPhysicalConnectionAttributeWithOptions(shared_ptr<ModifyPhysicalConnectionAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPhysicalConnectionAttributeResponse modifyPhysicalConnectionAttribute(shared_ptr<ModifyPhysicalConnectionAttributeRequest> request);
  ModifyRouteEntryResponse modifyRouteEntryWithOptions(shared_ptr<ModifyRouteEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyRouteEntryResponse modifyRouteEntry(shared_ptr<ModifyRouteEntryRequest> request);
  ModifyRouteTableAttributesResponse modifyRouteTableAttributesWithOptions(shared_ptr<ModifyRouteTableAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyRouteTableAttributesResponse modifyRouteTableAttributes(shared_ptr<ModifyRouteTableAttributesRequest> request);
  ModifyRouterInterfaceAttributeResponse modifyRouterInterfaceAttributeWithOptions(shared_ptr<ModifyRouterInterfaceAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyRouterInterfaceAttributeResponse modifyRouterInterfaceAttribute(shared_ptr<ModifyRouterInterfaceAttributeRequest> request);
  ModifyRouterInterfaceSpecResponse modifyRouterInterfaceSpecWithOptions(shared_ptr<ModifyRouterInterfaceSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyRouterInterfaceSpecResponse modifyRouterInterfaceSpec(shared_ptr<ModifyRouterInterfaceSpecRequest> request);
  ModifySnatEntryResponse modifySnatEntryWithOptions(shared_ptr<ModifySnatEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySnatEntryResponse modifySnatEntry(shared_ptr<ModifySnatEntryRequest> request);
  ModifySslVpnClientCertResponse modifySslVpnClientCertWithOptions(shared_ptr<ModifySslVpnClientCertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySslVpnClientCertResponse modifySslVpnClientCert(shared_ptr<ModifySslVpnClientCertRequest> request);
  ModifySslVpnServerResponse modifySslVpnServerWithOptions(shared_ptr<ModifySslVpnServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySslVpnServerResponse modifySslVpnServer(shared_ptr<ModifySslVpnServerRequest> request);
  ModifyTunnelAttributeResponse modifyTunnelAttributeWithOptions(shared_ptr<ModifyTunnelAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTunnelAttributeResponse modifyTunnelAttribute(shared_ptr<ModifyTunnelAttributeRequest> request);
  ModifyVRouterAttributeResponse modifyVRouterAttributeWithOptions(shared_ptr<ModifyVRouterAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVRouterAttributeResponse modifyVRouterAttribute(shared_ptr<ModifyVRouterAttributeRequest> request);
  ModifyVSwitchAttributeResponse modifyVSwitchAttributeWithOptions(shared_ptr<ModifyVSwitchAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVSwitchAttributeResponse modifyVSwitchAttribute(shared_ptr<ModifyVSwitchAttributeRequest> request);
  ModifyVSwitchCidrReservationAttributeResponse modifyVSwitchCidrReservationAttributeWithOptions(shared_ptr<ModifyVSwitchCidrReservationAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVSwitchCidrReservationAttributeResponse modifyVSwitchCidrReservationAttribute(shared_ptr<ModifyVSwitchCidrReservationAttributeRequest> request);
  ModifyVcoRouteEntryWeightResponse modifyVcoRouteEntryWeightWithOptions(shared_ptr<ModifyVcoRouteEntryWeightRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVcoRouteEntryWeightResponse modifyVcoRouteEntryWeight(shared_ptr<ModifyVcoRouteEntryWeightRequest> request);
  ModifyVirtualBorderRouterAttributeResponse modifyVirtualBorderRouterAttributeWithOptions(shared_ptr<ModifyVirtualBorderRouterAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVirtualBorderRouterAttributeResponse modifyVirtualBorderRouterAttribute(shared_ptr<ModifyVirtualBorderRouterAttributeRequest> request);
  ModifyVpcAttributeResponse modifyVpcAttributeWithOptions(shared_ptr<ModifyVpcAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVpcAttributeResponse modifyVpcAttribute(shared_ptr<ModifyVpcAttributeRequest> request);
  ModifyVpcPrefixListResponse modifyVpcPrefixListWithOptions(shared_ptr<ModifyVpcPrefixListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVpcPrefixListResponse modifyVpcPrefixList(shared_ptr<ModifyVpcPrefixListRequest> request);
  ModifyVpnAttachmentAttributeResponse modifyVpnAttachmentAttributeWithOptions(shared_ptr<ModifyVpnAttachmentAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVpnAttachmentAttributeResponse modifyVpnAttachmentAttribute(shared_ptr<ModifyVpnAttachmentAttributeRequest> request);
  ModifyVpnConnectionAttributeResponse modifyVpnConnectionAttributeWithOptions(shared_ptr<ModifyVpnConnectionAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVpnConnectionAttributeResponse modifyVpnConnectionAttribute(shared_ptr<ModifyVpnConnectionAttributeRequest> request);
  ModifyVpnGatewayAttributeResponse modifyVpnGatewayAttributeWithOptions(shared_ptr<ModifyVpnGatewayAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVpnGatewayAttributeResponse modifyVpnGatewayAttribute(shared_ptr<ModifyVpnGatewayAttributeRequest> request);
  ModifyVpnPbrRouteEntryAttributeResponse modifyVpnPbrRouteEntryAttributeWithOptions(shared_ptr<ModifyVpnPbrRouteEntryAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVpnPbrRouteEntryAttributeResponse modifyVpnPbrRouteEntryAttribute(shared_ptr<ModifyVpnPbrRouteEntryAttributeRequest> request);
  ModifyVpnPbrRouteEntryPriorityResponse modifyVpnPbrRouteEntryPriorityWithOptions(shared_ptr<ModifyVpnPbrRouteEntryPriorityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVpnPbrRouteEntryPriorityResponse modifyVpnPbrRouteEntryPriority(shared_ptr<ModifyVpnPbrRouteEntryPriorityRequest> request);
  ModifyVpnPbrRouteEntryWeightResponse modifyVpnPbrRouteEntryWeightWithOptions(shared_ptr<ModifyVpnPbrRouteEntryWeightRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVpnPbrRouteEntryWeightResponse modifyVpnPbrRouteEntryWeight(shared_ptr<ModifyVpnPbrRouteEntryWeightRequest> request);
  ModifyVpnRouteEntryWeightResponse modifyVpnRouteEntryWeightWithOptions(shared_ptr<ModifyVpnRouteEntryWeightRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVpnRouteEntryWeightResponse modifyVpnRouteEntryWeight(shared_ptr<ModifyVpnRouteEntryWeightRequest> request);
  MoveResourceGroupResponse moveResourceGroupWithOptions(shared_ptr<MoveResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveResourceGroupResponse moveResourceGroup(shared_ptr<MoveResourceGroupRequest> request);
  MoveVpnResourceGroupResponse moveVpnResourceGroupWithOptions(shared_ptr<MoveVpnResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveVpnResourceGroupResponse moveVpnResourceGroup(shared_ptr<MoveVpnResourceGroupRequest> request);
  OpenFlowLogServiceResponse openFlowLogServiceWithOptions(shared_ptr<OpenFlowLogServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenFlowLogServiceResponse openFlowLogService(shared_ptr<OpenFlowLogServiceRequest> request);
  OpenPhysicalConnectionServiceResponse openPhysicalConnectionServiceWithOptions(shared_ptr<OpenPhysicalConnectionServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenPhysicalConnectionServiceResponse openPhysicalConnectionService(shared_ptr<OpenPhysicalConnectionServiceRequest> request);
  OpenTrafficMirrorServiceResponse openTrafficMirrorServiceWithOptions(shared_ptr<OpenTrafficMirrorServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenTrafficMirrorServiceResponse openTrafficMirrorService(shared_ptr<OpenTrafficMirrorServiceRequest> request);
  PublishVpnRouteEntryResponse publishVpnRouteEntryWithOptions(shared_ptr<PublishVpnRouteEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishVpnRouteEntryResponse publishVpnRouteEntry(shared_ptr<PublishVpnRouteEntryRequest> request);
  RecoverPhysicalConnectionResponse recoverPhysicalConnectionWithOptions(shared_ptr<RecoverPhysicalConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RecoverPhysicalConnectionResponse recoverPhysicalConnection(shared_ptr<RecoverPhysicalConnectionRequest> request);
  RecoverVirtualBorderRouterResponse recoverVirtualBorderRouterWithOptions(shared_ptr<RecoverVirtualBorderRouterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RecoverVirtualBorderRouterResponse recoverVirtualBorderRouter(shared_ptr<RecoverVirtualBorderRouterRequest> request);
  ReleaseEipAddressResponse releaseEipAddressWithOptions(shared_ptr<ReleaseEipAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseEipAddressResponse releaseEipAddress(shared_ptr<ReleaseEipAddressRequest> request);
  ReleaseEipSegmentAddressResponse releaseEipSegmentAddressWithOptions(shared_ptr<ReleaseEipSegmentAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseEipSegmentAddressResponse releaseEipSegmentAddress(shared_ptr<ReleaseEipSegmentAddressRequest> request);
  ReleaseIpv6AddressResponse releaseIpv6AddressWithOptions(shared_ptr<ReleaseIpv6AddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseIpv6AddressResponse releaseIpv6Address(shared_ptr<ReleaseIpv6AddressRequest> request);
  RemoveCommonBandwidthPackageIpResponse removeCommonBandwidthPackageIpWithOptions(shared_ptr<RemoveCommonBandwidthPackageIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveCommonBandwidthPackageIpResponse removeCommonBandwidthPackageIp(shared_ptr<RemoveCommonBandwidthPackageIpRequest> request);
  RemoveGlobalAccelerationInstanceIpResponse removeGlobalAccelerationInstanceIpWithOptions(shared_ptr<RemoveGlobalAccelerationInstanceIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveGlobalAccelerationInstanceIpResponse removeGlobalAccelerationInstanceIp(shared_ptr<RemoveGlobalAccelerationInstanceIpRequest> request);
  RemoveIPv6TranslatorAclListEntryResponse removeIPv6TranslatorAclListEntryWithOptions(shared_ptr<RemoveIPv6TranslatorAclListEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveIPv6TranslatorAclListEntryResponse removeIPv6TranslatorAclListEntry(shared_ptr<RemoveIPv6TranslatorAclListEntryRequest> request);
  RemoveSourcesFromTrafficMirrorSessionResponse removeSourcesFromTrafficMirrorSessionWithOptions(shared_ptr<RemoveSourcesFromTrafficMirrorSessionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveSourcesFromTrafficMirrorSessionResponse removeSourcesFromTrafficMirrorSession(shared_ptr<RemoveSourcesFromTrafficMirrorSessionRequest> request);
  ReplaceVpcDhcpOptionsSetResponse replaceVpcDhcpOptionsSetWithOptions(shared_ptr<ReplaceVpcDhcpOptionsSetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReplaceVpcDhcpOptionsSetResponse replaceVpcDhcpOptionsSet(shared_ptr<ReplaceVpcDhcpOptionsSetRequest> request);
  RetryVpcPrefixListAssociationResponse retryVpcPrefixListAssociationWithOptions(shared_ptr<RetryVpcPrefixListAssociationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RetryVpcPrefixListAssociationResponse retryVpcPrefixListAssociation(shared_ptr<RetryVpcPrefixListAssociationRequest> request);
  RevokeInstanceFromCenResponse revokeInstanceFromCenWithOptions(shared_ptr<RevokeInstanceFromCenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeInstanceFromCenResponse revokeInstanceFromCen(shared_ptr<RevokeInstanceFromCenRequest> request);
  RevokeInstanceFromVbrResponse revokeInstanceFromVbrWithOptions(shared_ptr<RevokeInstanceFromVbrRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeInstanceFromVbrResponse revokeInstanceFromVbr(shared_ptr<RevokeInstanceFromVbrRequest> request);
  SecondApplyPhysicalConnectionLOAResponse secondApplyPhysicalConnectionLOAWithOptions(shared_ptr<SecondApplyPhysicalConnectionLOARequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SecondApplyPhysicalConnectionLOAResponse secondApplyPhysicalConnectionLOA(shared_ptr<SecondApplyPhysicalConnectionLOARequest> request);
  SetHighDefinitionMonitorLogStatusResponse setHighDefinitionMonitorLogStatusWithOptions(shared_ptr<SetHighDefinitionMonitorLogStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetHighDefinitionMonitorLogStatusResponse setHighDefinitionMonitorLogStatus(shared_ptr<SetHighDefinitionMonitorLogStatusRequest> request);
  StartFailoverTestJobResponse startFailoverTestJobWithOptions(shared_ptr<StartFailoverTestJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartFailoverTestJobResponse startFailoverTestJob(shared_ptr<StartFailoverTestJobRequest> request);
  StopFailoverTestJobResponse stopFailoverTestJobWithOptions(shared_ptr<StopFailoverTestJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopFailoverTestJobResponse stopFailoverTestJob(shared_ptr<StopFailoverTestJobRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  TagResourcesForExpressConnectResponse tagResourcesForExpressConnectWithOptions(shared_ptr<TagResourcesForExpressConnectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesForExpressConnectResponse tagResourcesForExpressConnect(shared_ptr<TagResourcesForExpressConnectRequest> request);
  TerminatePhysicalConnectionResponse terminatePhysicalConnectionWithOptions(shared_ptr<TerminatePhysicalConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TerminatePhysicalConnectionResponse terminatePhysicalConnection(shared_ptr<TerminatePhysicalConnectionRequest> request);
  TerminateVirtualBorderRouterResponse terminateVirtualBorderRouterWithOptions(shared_ptr<TerminateVirtualBorderRouterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TerminateVirtualBorderRouterResponse terminateVirtualBorderRouter(shared_ptr<TerminateVirtualBorderRouterRequest> request);
  UnTagResourcesResponse unTagResourcesWithOptions(shared_ptr<UnTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnTagResourcesResponse unTagResources(shared_ptr<UnTagResourcesRequest> request);
  UnassociateEipAddressResponse unassociateEipAddressWithOptions(shared_ptr<UnassociateEipAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnassociateEipAddressResponse unassociateEipAddress(shared_ptr<UnassociateEipAddressRequest> request);
  UnassociateGlobalAccelerationInstanceResponse unassociateGlobalAccelerationInstanceWithOptions(shared_ptr<UnassociateGlobalAccelerationInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnassociateGlobalAccelerationInstanceResponse unassociateGlobalAccelerationInstance(shared_ptr<UnassociateGlobalAccelerationInstanceRequest> request);
  UnassociateHaVipResponse unassociateHaVipWithOptions(shared_ptr<UnassociateHaVipRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnassociateHaVipResponse unassociateHaVip(shared_ptr<UnassociateHaVipRequest> request);
  UnassociateNetworkAclResponse unassociateNetworkAclWithOptions(shared_ptr<UnassociateNetworkAclRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnassociateNetworkAclResponse unassociateNetworkAcl(shared_ptr<UnassociateNetworkAclRequest> request);
  UnassociatePhysicalConnectionFromVirtualBorderRouterResponse unassociatePhysicalConnectionFromVirtualBorderRouterWithOptions(shared_ptr<UnassociatePhysicalConnectionFromVirtualBorderRouterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnassociatePhysicalConnectionFromVirtualBorderRouterResponse unassociatePhysicalConnectionFromVirtualBorderRouter(shared_ptr<UnassociatePhysicalConnectionFromVirtualBorderRouterRequest> request);
  UnassociateRouteTableResponse unassociateRouteTableWithOptions(shared_ptr<UnassociateRouteTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnassociateRouteTableResponse unassociateRouteTable(shared_ptr<UnassociateRouteTableRequest> request);
  UnassociateVpcCidrBlockResponse unassociateVpcCidrBlockWithOptions(shared_ptr<UnassociateVpcCidrBlockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnassociateVpcCidrBlockResponse unassociateVpcCidrBlock(shared_ptr<UnassociateVpcCidrBlockRequest> request);
  UntagResourcesForExpressConnectResponse untagResourcesForExpressConnectWithOptions(shared_ptr<UntagResourcesForExpressConnectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesForExpressConnectResponse untagResourcesForExpressConnect(shared_ptr<UntagResourcesForExpressConnectRequest> request);
  UpdateDhcpOptionsSetAttributeResponse updateDhcpOptionsSetAttributeWithOptions(shared_ptr<UpdateDhcpOptionsSetAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDhcpOptionsSetAttributeResponse updateDhcpOptionsSetAttribute(shared_ptr<UpdateDhcpOptionsSetAttributeRequest> request);
  UpdateFailoverTestJobResponse updateFailoverTestJobWithOptions(shared_ptr<UpdateFailoverTestJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFailoverTestJobResponse updateFailoverTestJob(shared_ptr<UpdateFailoverTestJobRequest> request);
  UpdateGatewayRouteTableEntryAttributeResponse updateGatewayRouteTableEntryAttributeWithOptions(shared_ptr<UpdateGatewayRouteTableEntryAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewayRouteTableEntryAttributeResponse updateGatewayRouteTableEntryAttribute(shared_ptr<UpdateGatewayRouteTableEntryAttributeRequest> request);
  UpdateIpsecServerResponse updateIpsecServerWithOptions(shared_ptr<UpdateIpsecServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateIpsecServerResponse updateIpsecServer(shared_ptr<UpdateIpsecServerRequest> request);
  UpdateIpv4GatewayAttributeResponse updateIpv4GatewayAttributeWithOptions(shared_ptr<UpdateIpv4GatewayAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateIpv4GatewayAttributeResponse updateIpv4GatewayAttribute(shared_ptr<UpdateIpv4GatewayAttributeRequest> request);
  UpdateNatGatewayNatTypeResponse updateNatGatewayNatTypeWithOptions(shared_ptr<UpdateNatGatewayNatTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateNatGatewayNatTypeResponse updateNatGatewayNatType(shared_ptr<UpdateNatGatewayNatTypeRequest> request);
  UpdateNetworkAclEntriesResponse updateNetworkAclEntriesWithOptions(shared_ptr<UpdateNetworkAclEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateNetworkAclEntriesResponse updateNetworkAclEntries(shared_ptr<UpdateNetworkAclEntriesRequest> request);
  UpdatePublicIpAddressPoolAttributeResponse updatePublicIpAddressPoolAttributeWithOptions(shared_ptr<UpdatePublicIpAddressPoolAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePublicIpAddressPoolAttributeResponse updatePublicIpAddressPoolAttribute(shared_ptr<UpdatePublicIpAddressPoolAttributeRequest> request);
  UpdateTrafficMirrorFilterAttributeResponse updateTrafficMirrorFilterAttributeWithOptions(shared_ptr<UpdateTrafficMirrorFilterAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTrafficMirrorFilterAttributeResponse updateTrafficMirrorFilterAttribute(shared_ptr<UpdateTrafficMirrorFilterAttributeRequest> request);
  UpdateTrafficMirrorFilterRuleAttributeResponse updateTrafficMirrorFilterRuleAttributeWithOptions(shared_ptr<UpdateTrafficMirrorFilterRuleAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTrafficMirrorFilterRuleAttributeResponse updateTrafficMirrorFilterRuleAttribute(shared_ptr<UpdateTrafficMirrorFilterRuleAttributeRequest> request);
  UpdateTrafficMirrorSessionAttributeResponse updateTrafficMirrorSessionAttributeWithOptions(shared_ptr<UpdateTrafficMirrorSessionAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTrafficMirrorSessionAttributeResponse updateTrafficMirrorSessionAttribute(shared_ptr<UpdateTrafficMirrorSessionAttributeRequest> request);
  UpdateVirtualBorderBandwidthResponse updateVirtualBorderBandwidthWithOptions(shared_ptr<UpdateVirtualBorderBandwidthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateVirtualBorderBandwidthResponse updateVirtualBorderBandwidth(shared_ptr<UpdateVirtualBorderBandwidthRequest> request);
  UpdateVirtualPhysicalConnectionResponse updateVirtualPhysicalConnectionWithOptions(shared_ptr<UpdateVirtualPhysicalConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateVirtualPhysicalConnectionResponse updateVirtualPhysicalConnection(shared_ptr<UpdateVirtualPhysicalConnectionRequest> request);
  UpdateVpcGatewayEndpointAttributeResponse updateVpcGatewayEndpointAttributeWithOptions(shared_ptr<UpdateVpcGatewayEndpointAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateVpcGatewayEndpointAttributeResponse updateVpcGatewayEndpointAttribute(shared_ptr<UpdateVpcGatewayEndpointAttributeRequest> request);
  VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse vpcDescribeVpcNatGatewayNetworkInterfaceQuotaWithOptions(shared_ptr<VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse vpcDescribeVpcNatGatewayNetworkInterfaceQuota(shared_ptr<VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Vpc20160428

#endif
